<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc tocompact="yes"?>
<?rfc toc="yes" ?>
<?rfc tocdepth="2"?>
<?rfc sortrefs="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc comments="yes" ?>
<!--<?rfc editing="yes" ?>-->
<rfc category="exp" ipr="pre5378Trust200902" docName="draft-ietf-hip-native-api-10">
<front> 
<title abbrev="Basic API Extensions for HIP">Basic Socket Interface Extensions for Host Identity Protocol (HIP)</title>
<author fullname="Miika Komu" initials="M.K.T." surname="Komu">
  <organization>Helsinki Institute for Information Technology</organization>
  <address>
  <postal>
    <street>Metsanneidonkuja 4</street>
    <city>Helsinki</city>
    <country>Finland</country>
  </postal>
  <phone>+358503841531</phone>
  <facsimile>+35896949768</facsimile>
  <email>miika@iki.fi</email>
  <uri>http://www.iki.fi/miika/</uri>
  </address>
</author>
<author fullname="Thomas Henderson" initials="T." surname="Henderson">
  <organization>The Boeing Company</organization>
  <address>
  <postal>
    <street>P.O. Box 3707</street>
    <city>Seattle, WA</city>
    <country>USA</country>
  </postal>
  <email>thomas.r.henderson@boeing.com</email>
  </address>
</author>
<date year="2009"/>
<area>Internet Area</area>
<workgroup>Host Identity Protocol</workgroup>

  <abstract>

  <t>This document defines extensions to the current sockets API for
     the Host Identity Protocol (HIP). The extensions focus on the use of
     public-key based identifiers discovered via DNS resolution, but
     define also interfaces for manual bindings between HITs and
     locators.  With the extensions, the application can also support
     more relaxed security models where the communication can be
     non-HIP based, according to local policies. The extensions in
     this document are experimental and provide basic tools for
     further experimentation with policies.</t>

</abstract>

<!--
<note title="Requirements Language">
<t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
&quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in  <xref target="RFC2119">RFC 2119</xref>.
</t>
</note>
-->

<!--
XX FIXME: reverse queries. Should we do something with them?
-->

</front>
<middle>

<section anchor="sec:intro" title="Introduction">

<t>
This document defines the C-based sockets Application Programming
Interface (API) extensions for handling Host Identity Protocol (HIP)-based 
identifiers
explicitly in HIP-aware applications. It is up to the applications, or
high-level programming languages or libraries, to manage the
identifiers. The extensions in this document are mainly related to the
use case in which a DNS resolution step has occurred prior to the
creation of a new socket, and assumes that the system has cached
or is otherwise able to resolve identifiers to locators (IP addresses).
The DNS extensions for HIP are described in <xref
target="RFC5205" />.
The extensions also cover the case in which an application may want
to explicitly provide suggested locators with the identifiers, including
supporting the opportunistic case in which the system does not know
the peer host identity.
</t>

<t>The Host Identity Protocol (HIP) <xref target="RFC4423" /> proposes
a new cryptographic namespace by separating the roles of end-point
identifiers and locators by introducing a new namespace to the
TCP/IP stack. SHIM6 <xref target="RFC5533" /> is another
protocol based on an identity-locator split.
The APIs specified in this document are specific to HIP, but
have been designed as much as possible so
as not to preclude its use with other protocols. The use of these APIs with
other protocols is, nevertheless, for further study.
</t>

<t>
The APIs in this document are based on HITs that are defined as IPv6 
addresses with the Overlay 
Routable Cryptographic Host Identifiers (ORCHID) prefix
<xref target="RFC4843" />. ORCHIDs are derived from Host Identifiers
using a hash and fitting the result into an IPv6 address. Such addresses are
called Host Identity Tags (HITs) and they can be distinguished from other
IPv6 addresses via the ORCHID prefix.  Note that ORCHIDs are presently
an experimental allocation by IANA.  If the ORCHID allocation were to
expire and HIT generation were to use a different prefix in the future,
most users of the API would not be impacted, unless they explicitly
checked the ORCHID prefix on returned HITs.  Users who check (for 
consistency) that HITs have a valid ORCHID prefix must monitor the
IANA allocation for ORCHIDs and adapt their software in case the ORCHID
allocation were to be removed at a future date.
</t>

<t>
Applications can observe the HIP layer and its identifiers in the
networking stacks with varying degrees of visibility. <xref
target="RFC5338" /> discusses the lowest levels
of visibility in which applications are completely unaware of
the underlying HIP layer. Such HIP-unaware applications in some circumstances use HIP-based
identifiers, such as Local Scope Identifiers (LSIs) or HITs, instead of IPv4 or IPv6 addresses
and cannot observe the identifier-locator bindings.
</t>

<t>
This document specifies extensions to <xref target="RFC3493" /> to
define a new socket address family, AF_HIP. Similarly to other address
families, AF_HIP can be used as an alias for PF_HIP. The extensions also
describe a new socket address structure for sockets using
HITs explicitly and describe how the socket calls
in <xref target="RFC3493" /> are adapted or extended as a result.
</t>

<t>Some applications may accept incoming communications from any
identifier. Other applications may initiate outgoing communications
without the knowledge of the peer identifier in Opportunistic Mode (section 4.1.6 in <xref
target="RFC5201" />) by just relying on a peer locator.  This
document describes how to address both situations using "wildcards"
as described in <xref target="sec:wildcards" />.
</t>

<t>This document references one additional API document that handles
multihoming and explicit-locator handling, defined in <xref
   target="I-D.ietf-shim6-multihome-shim-api" />. 
   Most of the extensions defined in this
   document can be used independently of the above document.
</t>

<t>
The identity-locator split introduced by HIP introduces some policy
related challenges with datagram oriented sockets, opportunistic mode,
and manual bindings between HITs and locators.  The extensions in this
document are of an experimental nature and provide basic tools for
experimenting with policies. Policy related issues are left for
further experimentation.
</t>

<t>
To recap, the extensions in this document have three goals. The first goal
is to allow HIP-aware applications to open sockets to other hosts based on
the HITs alone, presuming that the underlying system can resolve the HITs
to addresses used for initial contact.  The second
goal is that applications can explicitly initiate communications
with unknown peer identifiers.  The third goal is to illustrate how
HIP-aware applications can use the SHIM API
<xref target="I-D.ietf-shim6-multihome-shim-api" /> to manually
map locators to HITs.
</t>

<t>
This document was published as experimental because a number of its
normative references had experimental status. The success of this
experiment can be evaluated by a thorough implementation of the APIs
defined.
</t>

</section> <!-- intro -->

<section anchor="sec:terminology" title="Terminology">

<t>The terms used in this document are summarized in <xref
target="tbl:terms" />.</t>

<texttable anchor="tbl:terms">
<ttcol align="left">Term</ttcol><ttcol align="left">Explanation</ttcol>
<!--
<c>ULID</c>
<c>Upper Layer IDentifier equals to the identity part of the
   identity-locator split. It is the identifier used by the
   application to name a peer for the transport layer.</c>
-->
<c>FQDN</c>
<c>Fully Qualified Domain Name</c>
<c>HIP</c><c>Host Identity Protocol</c>
<c>HI</c><c>Host Identity</c>
<c>HIT</c>
<c>Host Identity Tag, a 100-bit hash of a public key with a 28 bit prefix</c>
<c>LSI</c><c>Local Scope Identifier, a local, 32-bit descriptor for a given 
          public key.</c>
<c>Locator</c>
<c>Routable IPv4 or IPv6 address used at the lower layers</c>
<c>RR</c><c>Return Routability</c>
</texttable>

</section> <!-- terminology -->

<!--

<section anchor="sec:architecture" title="Design Model">

<t>In this section, the native HIP APIs is described from a
   design point of view. We first describe the namespace
   model and conclude the discussion with a description of the
   resolver model.</t>

-->

<!--
  <section anchor="sec:layering" title="Layering Model">

  <t>The application layer accesses the transport layer via the socket
     interface. The application layer uses the traditional TCP/IP IPv4 or
     IPv6 interface, or the new native HIP APIs interface provided by the
     socket layer. The layering model is illustrated in <xref
     target="fig:layering" />. For simplicity, the IPsec layer has been
     excluded from the figure.</t>

   <figure anchor="fig:layering">
   <artwork>
                      +--------------------------------+
   Application Layer  |           Application          |
                      +----------+----------+----------+
        Socket Layer  | IPv4 API | IPv6 API |  HIP API |
                      +----------+----+-----+----------+
     Transport Layer  |      TCP      |      UDP       |
                      +---------------+----------------+
            HIP Layer |              HIP               |
                      +---------------+----------------+
       Network Layer  |     IPv4      |     IPv6       |
                      +---------------+----------------+
          Link Layer  |   Ethernet    |     Etc        |
                      +---------------+----------------+
   </artwork>
   </figure>

  <t>The HIP layer is as a shim/wedge layer between the transport and
     network layers. The datagrams delivered between the transport and
     network layers are intercepted by the system for
     transformation from from identifiers to locators or vice
     versa.</t>

  </section>

    <section anchor="sec:namespace" title="Namespace Model">

    <t>The namespace model is shown in <xref target="tbl:identifiers" /> from
       HIP point of view. The namespace identifiers are described in this
       section.</t>

      <texttable anchor="tbl:identifiers">
        <ttcol align="left">Layer</ttcol><ttcol align="left">Identifier</ttcol>
        <c>User Interface</c>    <c>Relative hostname or FQDN</c>
        <c>Application Layer</c> <c>HIT, port and protocol</c>
        <c>Transport Layer</c>   <c>HIT, port</c>
        <c>HIP Layer</c>         <c>HIT or HI</c>
        <c>Network Layer</c>     <c>Locator</c>
      </texttable>

    <t>User interfaces input human-readable names and translate them
    to machine-readable names. In native APIs for HIP, the machine
    readable names are HITs. The HITs are present at the application
    layer, and transport-layer pseudo checksums are based on HITs.
    The HIP layer transforms the HITs to locators for the network layer
    and vice versa.
    </t>

    </section>
-->

    <section anchor="sec:name_res" title="Name Resolution Process">


    <t>This section provides an overview of how the API can be used.  First,
       the case in which a resolver is involved in name resolution is
       described, and then the case in which no resolver is involved
       is described.
    </t>

      <section anchor="sec:resolver" title="Interaction with the Resolver">

    <t>Before an application can establish network communications with
       the entity named by a given FQDN or relative host name, the
       application must translate the name into the corresponding
       identifier(s). DNS-based hostname-to-identifier translation is
       illustrated in <xref target="fig:resolver_path" />. The
       application calls the resolver in step (a) to resolve an FQDN
       to one or more socket addresses within the PF_HIP family.
       The resolver, in turn, queries the DNS in step (b) to
       map the FQDN to
       one or more HIP RRs with the HIT and HI and possibly rendezvous
       server of the Responder, and also (in parallel or sequentially) to
       resolve the FQDN into possibly one or more A and AAAA records.
       It should be noted that the FQDN may map to
       multiple host identifiers and
       locators, and this step may involve multiple DNS transactions,
       including queries for A, AAAA, HI and possibly other resource records.
       The DNS server responds with a list of HIP resource records
       in step (c). Optionally in step (d), the
       resolver caches the HIT-to-locator mapping with the HIP
       module. The resolver converts the HIP records to HITs and
       returns the HITs to the application contained in
       HIP socket address structures
       in step (e). Depending on the parameters for the resolver call,
       the resolver may return also other socket address structures
       to the application.
       Finally, the application receives the socket address structure(s)
       from the resolver and uses them in socket calls such as connect()
       in step (f).
    </t>

    <figure anchor="fig:resolver_path">

    <artwork><![CDATA[
                                           +----------+
                                           |          |
                                           |   DNS    |
                                           |          |
                                           +----------+
                                               ^  |
                                b. QNAME=FQDN  |  | c. HIP and
                                               |  |    A/AAAA
                                               |  v    RR(s)
    +-------------+ a. getaddrinfo(<FQDN>)  +----------+
    |             |------------------------>|          |
    | Application |                         | Resolver |
    |             |<------------------------|          |
    +-------------+        e. <HITs>        +----------+
            |                                    |
            |                                    | d. HIP and
            | f. connect(<HIT>)                  |    A/AAAA
            |    or any other socket call        |    RR(s)
            v                                    v
     +----------+                           +----------+
     |          |                           |          |
     |  TCP/IP  |                           |   HIP    |
     |  Stack   |                           |          |
     +----------+                           +----------+
]]></artwork>
</figure>

<t>
In practice, the resolver functionality can be implemented in different
ways. For example, it may be implemented in existing resolver
libraries or as a HIP-aware interposing agent.
</t>

<!--    </section>  -->

    </section> <!-- design model  -->

    <section anchor="sec:no-resolver" title="Interaction without a Resolver">
<t>
The extensions in this document focus on the use of the resolver to
map host names to HITs and locators in HIP-aware applications.
The resolver may implicitly associate a HIT with the corresponding
locator(s) by communicating the HIT-to-IP mapping to the
HIP daemon. However, it is possible that an application operates
directly on a peer HIT without interacting with the resolver. In
such a case, the application may resort to the system to map the peer
HIT to an IP address. Alternatively, the application can explicitly
map the HIT to an IP address using socket options as specified in <xref
target="sec:explicit" />. Full support for all of
the extensions defined in this draft requires a number of shim socket options
<xref target="I-D.ietf-shim6-multihome-shim-api" /> to be implemented by
the system.
</t>

    </section>

  </section> <!-- Overview -->

    <section anchor="sec:syntax" title="API Syntax and Semantics">

    <t>In this section, we describe the native HIP APIs using the
       syntax of the C programming language. We limit the description
       to the interfaces and data structures that are either modified
       or completely new because the native HIP APIs are otherwise
       identical to the sockets API <xref target="POSIX" />.
       </t>

      <section anchor="sec:sock" title="Socket Family and Address Structure Extensions">

     <t>The sockets API extensions define a new protocol family, PF_HIP, and
        a new address family, AF_HIP.   The AF_HIP and PF_HIP constants are aliases to
        each other.  These definitions shall be defined as a result of including
        &lt;sys/socket.h&gt;.</t>

     <t>When the socket() function is called with PF_HIP as the first argument (domain), it attempts to create a socket for HIP communication.
     If HIP is not supported, socket() follows its default behaviour and returns -1 and sets errno to EAFNOSUPPORT.</t>

     <t><xref target="fig:sockaddr_hip"/> shows the recommended implementation of the socket address
        structure for HIP in POSIX.1.g format.</t>

       <figure anchor="fig:sockaddr_hip">
      <artwork>
        #include &lt;netinet/hip.h&gt;

        typedef struct in6_addr hip_hit_t;

        struct sockaddr_hip {
                  uint8_t        ship_len;
                  sa_family_t    ship_family;
                  in_port_t      ship_port;
                  uint32_t       ship_flags;
                  hip_hit_t      ship_hit;
        };
      </artwork>
     </figure>

    <t>uint8_t ship_len:
       This field is optional in POSIX.1.g (and 4.3BSD-RENO).
       The field defines the length of the structure. Implementations that
       do not define this field typically embed the information in the
       following ship_family field.
    </t>

    <t>sa_family_t ship_family:
      This mandatory field identifies this as a sockaddr_hip structure.
      It overlays the sa_family field of the sockaddr structure.
      Its value must be AF_HIP.</t>

    <t>in_port_t ship_port:
      This mandatory field contains the transport protocol port number.
      It is handled in the same way as the sin_port field of the sockaddr_in structure.
      The port number is stored in network byte order.</t>

    <!--
    <t>uint32_t ship_pad:
      This optional field introduces zero-filled padding to align the ship_flags field to a 64-bit boundary (relative to the ship_family field).
      </t>
     -->

    <t>uint32_t ship_flags:
      This mandatory bit field contains auxiliary flags.
      This document does not define any flags.
      This field is included for future extensions.</t>

    <t>hip_hit_t ship_hit:
      This mandatory field contains the end-point identifier.
      When the system passes a sockaddr_hip structure to the application, the value of this field is set to a valid HIT, IPv4, or IPv6 address, as discussed in <xref target="sec:types" />.
      When the application passes a sockaddr_hip structure to the system, this field must be set to a HIT or a wildcard address as discussed in <xref target="sec:wildcards" />.</t>

    <!--
    <t>uint8_t ship_reserved[] array in the ship_id union:
      This mandatory field is reserved for future extensions as described in <xref target="sec:security" />.
      This field must be initialized with zeroes except the intersection with ship_hit field.
      It's implementation size (_HIP_SA_EXT_MAXSIZE) should be adjusted so that sizeof(struct sockaddr_hip) equals to sizeof(struct sockaddr_storage).
    </t>
    -->

     <t>Some applications rely on system level access control, either
        implicit or explicit (such as the accept_filter() function found on
        BSD-based systems), but such discussion is out of scope.
        Other applications implement access control
        themselves by using the HITs.

        Applications operating on sockaddr_hip structures can use memcmp()
        or similar function to compare the ship_hit fields.

<!--
In such a case, the application
        can compare the ship_id unions of sockaddr_hip structures using
        memcmp() or a similar function. It is recommended that the application
        compares the whole ship_id union instead of just the ship_hit field
        for future proofing as described in section <xref target="sec:security" />. -->

        It should be also noted that different connection attempts between
        the same two hosts can result in different HITs because a host
        is allowed to have multiple HITs.
     </t>

    <section anchor="sec:wildcards" title="HIP Wildcard Addresses">

    <t>HIP wildcard addresses are similar to IPv4 and IPv6 wildcard addresses.
    They can be used instead of specific HITs in the ship_hit field for local and remote end-points in socket API calls such
    as bind(), connect(), sendto(), sendmsg().</t>

    <t>In order to bind to all local IPv4 and IPv6 addresses and HIP HITs, the ship_hit field must be set to HIP_ENDPOINT_ANY.
    In order to bind to all local HITs, ship_hit must contain HIP_HIT_ANY.
    To only bind to all local public HITs, the ship_hit field must be HIP_HIT_ANY_PUB.
    The value HIP_HIT_ANY_TMP binds a socket to all local anonymous identifiers only as specified in <xref target="RFC4423" />.
<!-- stg: I copied the following sentence from the old text without understand it so it may need review in this context. Is this a hint on how a system may implement anonymous identifiers? -->
    The system may label anonymous identifiers as such depending on whether they have been published or not.
    After binding a socket via one of the HIP_HIT_ANY_* wildcard addresses, the application is guaranteed to receive only HIP-based data flows.
    With the HIP_ENDPOINT_ANY wildcard address, the socket accepts HIP, IPv6, and IPv4-based data flows.</t>

    <t>When a socket is bound or connected via a sockaddr_hip structure, i.e. the PF_HIP protocol family, the system returns only addresses of the AF_HIP family, i.e. sockaddr_hip structures, for this socket.
    This applies to all functions which provide addresses to the application, such as accept() or recvfrom().
    If the data flow is based on HIP, the ship_hit field contains the peer's HIT.
    For a non-HIP IPv6 data flow, the field contains the peer's IPv6 address.
    For a non-HIP IPv4 data flow, the field contains the peer's IPv4 address in IPv4-mapped IPv6 address format as described in section 3.7 of <xref target="RFC3493" />.
    <xref target="sec:types" /> describes how the application can verify the type of the address returned by the socket API calls.</t>

    <t>An application uses the socket API as follows to set up a connection or to send messages in HIP Opportunistic Mode (cf. <xref target="RFC5201" />).
    First, the application associates a socket with at least one IP address of the destination peer via setting the SHIM_LOCLIST_PEER_PREF socket option.
    It then uses outgoing socket functions such as connect(), sendto(), or sendmsg() with the HIP_ENDPOINT_ANY or HIP_HIT_ANY wildcard address in the ship_hit field of the sockaddr_hip structure.
    With the HIP_HIT_ANY address,
    the underlying system allows only HIP-based data flows with the
    corresponding socket.  For incoming packets, the system
    discards all non-HIP-related traffic arriving at the socket.
    For outgoing packets, the system returns -1 in the socket call and
    sets errno to an appropriate error type when the system failed to
    deliver the packet over
    a HIP-based data channel.
    The semantics of using the HIP_ENDPOINT_ANY are the subject of further experimentation in the context of opportunistic mode.
    Such use may result in a data flow either with or without HIP.</t>
    </section><!-- HIP Wildcard Addresses -->

      </section> <!-- socket -->

      <section anchor="sec:getaddrinfo" title="Extensions to Resolver Data Structures">


      <t>The HIP APIs introduce a new address family, AF_HIP, that
         HIP-aware applications can use to control the address type returned
         from the getaddrinfo() function <xref target="RFC3493" />.
         The getaddrinfo() function uses a data structure called addrinfo
         in its "hints" and "res" argument which is described in more
         detail in the next section. The addrinfo data structure is
         illustrated in <xref target="fig:addrinfo" />.
      </t>

      <figure anchor="fig:addrinfo">
      <artwork>
       #include &lt;netdb.h&gt;

       struct addrinfo {
           int       ai_flags;          /* e.g. AI_CANONNAME */
           int       ai_family;         /* e.g. AF_HIP */
           int       ai_socktype;       /* e.g. SOCK_STREAM */
           int       ai_protocol;       /* 0 or IPPROTO_HIP */
           socklen_t ai_addrlen;        /* size of *ai_addr  */
           struct    sockaddr *ai_addr; /* sockaddr_hip */
           char     *ai_canonname;     /* canon. name of the host */
           struct    addrinfo *ai_next; /* next endpoint */
           int       ai_eflags;         /* RFC5014 extension */
       };
     </artwork>
     </figure>


     <!-- XX FIXME: what about IPPROTO_HIP -->

     <t>
        An application resolving with the ai_family field set to
        AF_UNSPEC in the hints argument may receive any kind of socket
        address structures, including sockaddr_hip.  When the
        application wants to receive only HITs contained in
        sockaddr_hip structures, it should set the ai_family field to
        AF_HIP.
        Otherwise, the resolver does not return any sockaddr_hip structures.
        The resolver returns EAI_FAMILY when AF_HIP is requested but not supported.
     </t>

     <t>The resolver ignores the AI_PASSIVE flag when the application sets the family
        in hints to AF_HIP.
     </t>

      <t>
         The system may have a HIP-aware interposing DNS agent as
         described in section 3.2 in <xref target="RFC5338" />. In
         such a case, the DNS agent may, according to local policy, return
         transparently LSIs or HITs
         in sockaddr_in and sockaddr_in6 structures when available.
         A HIP-aware application can override this local policy in two ways.
         First, the application can set the family to AF_HIP in the hints
         argument of getaddrinfo() when it requests only sockaddr_hip
         structures. Second, the application can set
         AI_NO_HIT flag to prevent the resolver from returning HITs in
         any kind of data structures.
      </t>

      <t>
	 When getaddrinfo() returns resolved outputs in the output "res" argument,
         it sets the family to AF_HIP when the related structure is
         sockaddr_hip.
      </t>

<section anchor="sec:resolver_usage" title="Resolver Usage">

      <t>A HIP-aware application creates the sockaddr_hip structures
	 manually or obtains them from the resolver. The explicit
	 configuration of locators is described in <xref
	 target="I-D.ietf-shim6-multihome-shim-api" />. This document
	 defines "automated" resolver extensions for getaddrinfo()
	 resolver <xref target="RFC3493" />. Other resolver calls, such
	 as gethostbyname() and getservbyname() are not defined in this
	 document. The getaddrinfo resolver interface is shown in
	 <xref target="fig:getaddrinfo" />.</t>

        <figure anchor="fig:getaddrinfo">
        <artwork>
        #include &lt;netdb.h&gt;

        int getaddrinfo(const char *nodename,
                        const char *servname,
                        const struct addrinfo *hints,
                        struct addrinfo **res)
        void free_addrinfo(struct addrinfo *res)
        </artwork>
        </figure>

        <t>As described in <xref target="RFC3493" />, the getaddrinfo()
           function takes the nodename, servname, and hints as its
           input arguments. It places the result of the query into the
           res output argument. The return value is zero on success, or a
           non-zero error value on error. The nodename argument
           specifies the host name to be resolved; a NULL argument
           denotes the HITs of the local host. The servname parameter
           declares the
           port number to be set in the socket addresses in the res
           output argument. Both the nodename and servname cannot be
           NULL at the same time.</t>

        <t>The input argument "hints" acts like a filter that defines
           the attributes required from the resolved endpoints. A NULL
           hints argument indicates that any kind of endpoints are
           acceptable.</t>

        <t>The output argument "res" is dynamically allocated by the
           resolver.  The application frees the res argument with the
           free_addrinfo function. The res argument contains a linked
           list of the resolved endpoints. The linked list contains
           only sockaddr_hip structures when the input argument has
           the family set to AF_HIP. When the family is zero,
           the list contains
           sockaddr_hip structures before sockaddr_in and sockaddr_in6
           structures.
        </t>

        <t>The resolver can return a HIT which maps to multiple
           locators. The resolver may cache the locator mappings with
           the HIP module. The HIP module manages the multiple
           locators according to system policies of the host.  The
           multihoming document <xref
           target="I-D.ietf-shim6-multihome-shim-api" /> describes how
           an application can override system default policies.
        </t>

       <t>
           It should be noted that the application can
           configure the HIT explicitly without setting the locator or
           the resolver can fail to resolve any locator. In this
           scenario, the application relies on the system to map the
           HIT to an IP address. When the system fails to provide the
           mapping, it returns -1 in the called sockets API
           function to the application and sets errno to EADDRNOTAVAIL.
       </t>

    </section> <!-- resolver usage -->
    </section> <!-- resolver -->

    <section anchor="sec:getsock" title="The Use of getsockname and getpeername Functions">

    <t>The sockaddr_hip structure does not contain a HIT when the
       application uses the HIP_HIT_ANY_* or HIP_ENDPOINT_ANY
       constants. In such a case, the application can discover the
       local and peer HITs using the getsockname() and getpeername()
       functions after the socket is connected.  The functions
       getsockname() and getpeername() always output a sockaddr_hip
       structure when the family of the socket is AF_HIP. The
       application should be prepared to handle also IPv4 and IPv6
       addresses in the ship_hit field as described in
       <xref target="sec:sock" /> in the context of the
       HIP_ENDPOINT_ANY constant.</t>
 
    </section> <!-- getsockname section  -->

    <section anchor="sec:sockopt" title="Selection of Source HIT Type">

    <t>A client-side application can choose its source HIT by
       e.g. querying all of the local HITs with getaddrinfo() and
       associating one of them with the socket using bind(). This
       section describes another method for a client-side application
       to affect the selection of the source HIT type where the
       application does not call bind() explicitly. Instead, the
       application just specifies the preferred requirements for the source HIT
       type.
    </t>

    <t>
      The Socket API for Source Address Selection <xref target="RFC5014" />
      defines socket options to allow applications to influence source address
      selection mechanisms.  In some cases, HIP-aware applications may
      want to influence source HIT selection; in particular, whether
      an outbound connection should use a published or anonymous HIT.
      Similar to IPV6_ADDR_PREFERENCES defined in <xref target="RFC5014" />, the
      socket option HIT_PREFERENCES is defined for
      HIP-based sockets.  This socket option can be used with
      setsockopt() and getsockopt() calls to set and get the HIT
      selection preferences affecting a HIP-enabled socket.  The
      socket option value (optval) is a 32-bit unsigned integer
      argument.  The argument consists of a number of flags where each
      flag indicates an address selection preference that modifies one
      of the rules in the default HIT selection; these flags are shown in
      <xref target="tbl:src_hit" />.
    </t>

    <texttable anchor="tbl:src_hit">
      <ttcol align="left">Socket Option</ttcol>
      <ttcol align="left">Purpose</ttcol>
      <c>HIP_PREFER_SRC_HIT_TMP</c><c>Prefer an anonymous HIT</c>
      <c>HIP_PREFER_SRC_HIT_PUBLIC</c><c>Prefer a public HIT</c>
    </texttable>

   <t>
     If the system is unable to assign the type of HIT that is
     requested, at HIT selection time, the socket call (connect(),
     sendto(), or sendmsg()) will fail and errno will be set to
     EINVAL.  If the application tries to set both of the above flags
     for the same socket, this also results in the error EINVAL.
   </t>

  </section> <!-- Selection of Source HIT Type -->

    <section anchor="sec:types" title="Verification of HIT Type">

     <t>An application that uses the HIP_ENDPOINT_ANY constant may want to
        check whether the actual communications was based on HIP or not.
        Also, the application may want
        to verify whether a HIT belonging to the local host is public or anonymous. The
        application accomplishes this using a new function called
        sockaddr_is_srcaddr() which is illustrated in <xref
        target="fig:sockaddr_is_srcaddr"/>.
     </t>

     <figure anchor="fig:sockaddr_is_srcaddr">
      <artwork>
      #include &lt;netinet/hip.h&gt;

      short sockaddr_is_srcaddr(struct sockaddr *srcaddr,
                                uint64_t flags);
      </artwork>
     </figure>

     <t>The sockaddr_is_srcaddr() function operates in the same way as the
        inet6_is_srcaddr() function <xref target="RFC5014" /> which
        can be used to verify the type of an address belonging to the
        local host. The difference is that the sockaddr_is_srcaddr()
        function handles sockaddr_hip structures in addition to
        sockaddr_in6, and possibly other socket structures in
        further extensions. Also, the length of the flags argument is 64-bits instead
        of 32 bits because the new function handles the same flags as
        defined in <xref target="RFC5014" /> in addition to
        two HIP-specific flags,
        HIP_PREFER_SRC_HIT_TMP and HIP_PREFER_SRC_HIT_PUBLIC. With these
        two flags, the application can distinguish
        anonymous HITs from public HITs.
     </t>

     <t>When given an AF_INET6 socket, sockaddr_is_srcaddr() behaves as
        inet6_is_srcaddr() function as described in <xref target="RFC5014" />.
        With an AF_HIP socket, the function returns 1 when the HIT contained in the socket
        address structure corresponds to a valid HIT of the local host and
        the HIT satisfies the given flags.
        The function returns -1 when
        the HIT does not belong to the local host or the flags are not valid.
        The function returns 0 when the preference flags are valid but the
        HIT does not match the given flags.
        The function also returns
        0 on a sockaddr_hip structure containing a HIP_ENDPOINT_ANY or HIP_HIT_ANY_* wildcard.
     </t>

     <t>The sockaddr_is_srcaddr() interface applies only to local HITs.
        Applications can
        call the function hip_is_hit() to verify that the given
        hit_hit_t pointer has the HIT prefix. The
        function is illustrated in <xref target="fig:sockaddr_is_hit" />.
     </t>

     <figure anchor="fig:sockaddr_is_hit">
      <artwork>
      #include &lt;netinet/hip.h&gt;

      short hip_is_hit(hip_hit_t *hit);
      </artwork>
     </figure>

     <t>The hip_is_hit() function returns 1 when the given argument
        contains the HIT prefix. The function returns -1 on error and
        sets errno appropriately.
        The function returns 0 when the argument does not have the HIT prefix.
        The function also returns
        0 when the argument is a HIP_ENDPOINT_ANY or HIP_HIT_ANY_* wildcard.
     </t>

    </section> <!-- "Validating HIT Type  -->

    <section anchor="sec:explicit" title="Explicit Handling of Locators">

         <t>
         The system resolver, or the HIP module, maps HITs to locators
         implicitly. However, some applications may want to specify
         initial locator mappings explicitly. In such a case, the
         application first creates a socket with AF_HIP as the domain
         argument. Second, the application may get or set locator information
         with one of the following shim socket options
         as defined in the multihoming extensions in <xref
         target="I-D.ietf-shim6-multihome-shim-api" />. The related socket
         options are summarized briefly in <xref target="tbl:shim" />.
         </t>

<texttable anchor="tbl:shim">
  <ttcol align="left">optname</ttcol>
  <ttcol align="left">description</ttcol>

  <c>SHIM_LOC_LOCAL_PREF</c>
  <c>Get or set the preferred locator on the local side for the context
     associated with the socket.</c>

  <c>SHIM_LOC_PEER_PREF</c>
  <c>Get or set the preferred locator on the remote side for the context
     associated with the socket.</c>

  <c>SHIM_LOCLIST_LOCAL</c>
  <c>Get or set a list of locators associated with the local EID.</c>

  <c>SHIM_LOCLIST_PEER</c>
  <c>Get or set a list of locators associated with the peer's EID.</c>

  <c>SHIM_LOC_LOCAL_SEND</c>
  <c>Set or get the default source locator of outgoing IP packets.</c>

  <c>SHIM_LOC_PEER_SEND</c>
  <c>Set or get the default destination locator of  outgoing IP packets.</c>

</texttable>

<t>As an example of locator mappings, a connection-oriented
   application creates a HIP-based socket and sets the
   SHIM_LOCLIST_PEER socket option on the socket.  The HIP module uses
   the first address contained in the option if multiple are provided.
   If the application provides one or more addresses in the
   SHIM_LOCLIST_PEER setsockopt call, the system should not connect to
   the host via another destination address, in case the application
   intends to restrict the range of addresses permissible as a policy
   choice.  The application can override the default peer locator by
   setting the SHIM_LOC_PEER_PREF socket option if necessary. Finally,
   the application provides a specific HIT in the ship_hit field of
   the sockaddr_hip in the connect() system call.  If the system
   cannot reach the HIT at one of the addresses provided, the outbound
   socket API functions (connect, sendmsg, etc.)  return -1 and set
   errno to EINVALIDLOCATOR.
</t>

<t>
  Applications may also choose to associate local addresses with
  sockets.  The procedures specified in <xref
  target="I-D.ietf-shim6-multihome-shim-api" /> are followed in this
  case.
</t>

<t>
  Another use case is to use the opportunistic mode
  when the destination HIT is specified as a wildcard. The application
  sets one or more destination addresses using the
  SHIM_LOCLIST_PEER socket option as described earlier in this section and then calls
  connect() with the wildcard HIT. The connect() call returns -1 and
  sets errno to EADDRNOTAVAIL when the application connects to a
  wildcard without specifying any destination address.
</t>

<t>
  Applications using datagram-oriented sockets can use ancillary data
  to control the locators, as described in detail in <xref
  target="I-D.ietf-shim6-multihome-shim-api" />.
</t>

   </section> <!-- locators -->

    </section> <!-- syntax -->

    <section title="Summary of New Definitions">

<t>
<xref target="tbl:defs" /> summarizes the new constants and
structures defined in this document.
</t>

<texttable anchor="tbl:defs">
<ttcol align="left">Header</ttcol><ttcol align="left">Definition</ttcol>
<c>&lt;sys/socket.h&gt;</c><c>AF_HIP</c>
<c>&lt;sys/socket.h&gt;</c><c>PF_HIP</c>
<c>&lt;netinet/in.h&gt;</c><c>IPPROTO_HIP</c>
<c>&lt;netinet/hip.h&gt;</c><c>HIP_HIT_ANY</c>
<c>&lt;netinet/hip.h&gt;</c><c>HIP_HIT_ANY_PUB</c>
<c>&lt;netinet/hip.h&gt;</c><c>HIP_HIT_ANY_TMP</c>
<c>&lt;netinet/hip.h&gt;</c><c>HIP_ENDPOINT_ANY</c>
<c>&lt;netinet/hip.h&gt;</c><c>HIP_HIT_PREFERENCES</c>
<c>&lt;netinet/hip.h&gt;</c><c>hip_hit_t</c>
<c>&lt;netdb.h&gt;</c><c>AI_NO_HIT</c>
<!--
<c>&lt;netdb.h&gt;</c><c>HIP_PREFER_SRC_HIT_TMP</c>
<c>&lt;netdb.h&gt;</c><c>HIP_PREFER_SRC_HIT_PUBLIC</c>
<c>&lt;netdb.h&gt;</c><c>HIP_PREFER_PASSIVE_HIT_TMP</c>
<c>&lt;netdb.h&gt;</c><c>HIP_PREFER_PASSIVE_HIT_PUB</c>
<c>&lt;netdb.h&gt;</c><c>HIP_PREFER_PASSIVE_HIT_ANY</c>
<c>&lt;netdb.h&gt;</c><c>HIP_PREFER_PASSIVE_ADDR_ANY</c>
-->
<c>&lt;netinet/hip.h&gt;</c><c>sockaddr_hip</c>
<c>&lt;netinet/hip.h&gt;</c><c>sockaddr_is_srcaddr()</c>
<c>&lt;netinet/hip.h&gt;</c><c>hip_is_hit()</c>
</texttable>

    </section> <!-- new defs -->

    <section anchor="sec:iana" title="IANA Considerations">

    <t>No IANA considerations.</t>

    </section> <!-- iana -->

    <section anchor="sec:security" title="Security Considerations">

    <!-- Poisoning of mappings, app. spec. id access priviledges -->
    <t>This document describes an API for HIP and therefore depends on
    the mechanisms defined in the HIP protocol suite.  Security concerns
    associated with HIP itself are specified in <xref target="RFC4423" />,
    <xref target="RFC4843" />, <xref target="RFC5201" />, 
    <xref target="RFC5205" />,  and <xref target="RFC5338" />. </t>

    <t>The HIP_ENDPOINT_ANY constant can be used to accept incoming or
    create outgoing data flows without HIP. The application should use
    the sockaddr_is_srcaddr() function to validate the type of the
    connection in order to e.g. inform the user of the lack of
    HIP-based security. The use of the HIP_HIT_ANY_* constants is
    recommended in security-critical applications and systems.</t>

    <t>It should be noted that the wildcards described in this document
       are not suitable for identifying end-hosts. Instead, applications
       should use getsockname() and getpeername() as described in
       <xref target="sec:getsock" /> to identify an end-host.</t>

    <t>Future proofing of HITs was discussed during the design of this API.
       If HITs longer than 128-bits are required at the application layer,
       this will require explicit support from the applications because
       they can store or cache HITs with their explicit sizes.
       To support longer HITs, further extensions of this API may define
       an additional flag for getaddrinfo()
       to generate different kind of socket address structures for HIP.</t>

    <!--
    <t>The sockaddr_hip structure contains the ship_id union for storing a HIT.
    In addition to the actual HIT, the union contains a reserved field for
    future proofing of HITs longer than 128 bits. Introducing longer HITs
    may also require setting a new flag in the ship_flags field to indicate
    the length of the HIT or, alternatively, a new prefix for longer HITs.
    Also, the ai_flags field in the hints argument for
    getaddrinfo() function may require an additional flag in order for the
    application to indicate that it can support longer HITs. It is recommended that
    applications compare different sockaddr_hip structures using the ship_id union
    instead of directly using the ship_hit field to maximize future compatibility.
    </t> 
    -->

    </section>

    <section title="Contributors">
    <t>Thanks for Jukka Ylitalo and Pekka Nikander for their original
    contribution, time and effort to the native HIP APIs. Thanks for
    Yoshifuji Hideaki and Stefan G&ouml;tz for their contributions to this document.
    </t>
    </section> <!-- Contributors -->

    <section anchor="sec:acknowledgements" title="Acknowledgements">
    <t>
    Kristian Slavov, Julien Laganier, Jaakko Kangasharju, Mika Kousa,
    Jan Melen, Andrew McGregor, Sasu Tarkoma, Lars Eggert, Joe Touch,
    Antti Jarvinen, Anthony Joseph, Teemu Koponen, Jari Arkko, Ari
    Keranen, Juha-Matti Tapio, Shinta Sugimoto, Philip Matthews,
    Joakim Koskela, Jeff Ahrenholz, Tobias Heer, Stefan Gotz and Gonzalo Camarillo have provided
    valuable ideas and
    feedback. Thanks also for the APPS area folks, including Stephane
    Bortzmeyer, Chris Newman, Tony Finch, "der Mouse" and Keith Moore.
    </t>
  </section> <!-- acknowledgements -->

  </middle>

  <back>

    <references title="Normative References">
      <reference anchor="POSIX">
        <front>
        <title>IEEE Std. 1003.1-2001 Standard for Information Technology -
               Portable Operating System Interface (POSIX)</title>
        <author>
        <organization>Institute of Electrical and Electronics Engineers
        </organization>
        </author>
        <date month="Dec" year="2001" />
        </front>
      </reference>
      <!-- <?rfc include="reference.RFC.3484" ?> -->
      <?rfc include="reference.RFC.5014" ?>
      <?rfc include="reference.RFC.3493" ?>
      <?rfc include="reference.RFC.4843" ?>
      <!-- <?rfc include="reference.RFC.3041" ?> -->
      <?rfc include="reference.RFC.4423" ?>

      <?rfc include="reference.RFC.5201" ?>
      <?rfc include="reference.RFC.5205" ?>

      <?rfc include="reference.RFC.5338" ?>

      <!-- <?rfc include="reference.I-D.ietf-hip-applications" ?> -->
      <?rfc include="reference.I-D.ietf-shim6-multihome-shim-api" ?>
      <!-- <?rfc include="reference.RFC.2553" ?> -->


    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.5533" ?>
    </references>

  </back>
</rfc>
