<?xml version='1.0' encoding="UTF-8" ?>
<?rfc notedraftinprogress='yes'?>
<?rfc rfcprocack="yes"?>
<?rfc toc="yes"?>
<rfc ipr='trust200902' docName='draft-abarth-websocket-handshake-00' category='std'>
  <front>
    <title>The WebSocket protocol</title>
    <author initials='A.' surname='Barth' fullname='Adam Barth'>
      <organization>Google, Inc.</organization>
      <address>
        <email>ietf@adambarth.com</email>
        <uri>http://www.adambarth.com/</uri>
      </address>
    </author>
    <date day="18" month="October" year="2010"/>
    <area>Applications</area>
    <workgroup>HyBi Working Group</workgroup>
    <abstract>
      <t>The WebSocket protocol enables two-way communication between a user agent running untrusted code running in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the Origin-based security model commonly used by Web browsers. The protocol consists of an initial handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g. using XMLHttpRequest or &lt;iframe&gt;s and long polling).</t>
      <t>Please send feedback to the hybi@ietf.org mailing list.</t>
    </abstract>
  </front>
  <middle>
    <section title='Opening Handshake' anchor='handshake'>
      <section title='Client Requirements'>
        <t>
          User agents running in controlled environments, e.g. browsers on
          mobile handsets tied to specific carriers, may offload the
          management of the connection to another agent on the network. In
          such a situation, the user agent for the purposes of conformance
          is considered to include both the handset software and any such
          agents.
        </t>
        <t>
          When the user agent is to <spanx style='strong'>establish a WebSocket connection</spanx> to a host /host/, on a port /port/, from an origin whose ASCII serialization is /origin/, with a flag /secure/, with a string giving a /resource name/, with a (possibly empty) list of strings giving the /protocols/, and optionally with a /defer cookies/ flag, it must run the following steps. <xref target='ORIGIN'/>
        </t>
        <t>
          <list style='numbers'>
            <t>
              Verify that the WebSocket URL and its components are valid according to ???. If any of the requirements are not met, the client MUST fail the WebSocket connection and abort these steps.
            </t>
            <t>
              If the user agent already has a WebSocket connection to the remote host (IP address) identified by /host/, even if known by another name, wait until that connection has been established or for that connection to have failed. If multiple connections to the same IP address are attempted simultaneously, the user agent must serialize them so that there is no more than one connection at a time running through the following steps.
              <vspace blankLines='1'/>
              If the user agent cannot determine the IP address of the remote
              host (for example because all communication is being done through
              a proxy server that performs DNS queries itself), then the user
              agent must assume for the purposes of this step that each host
              name refers to a distinct remote host, but should instead limit
              the total number of simultaneous connections that are not
              established to a reasonably low number (e.g., in a Web browser, to
              the number of tabs the user has open).
              <vspace blankLines='1'/>
              NOTE: This makes it harder for a script to perform a denial of
              service attack by just opening a large number of WebSocket
              connections to a remote host. A server can further
              reduce the load on itself when attacked by making use of this by
              pausing before closing the connection, as that will reduce the
              rate at which the client reconnects.
              <vspace blankLines='1'/>
              NOTE: There is no limit to the number of established WebSocket connections a user agent can have with a single remote host. Servers can refuse to connect users with an excessive number of connections, or disconnect resource-hogging users when suffering high load.
            </t>
            <t>
              <spanx style='emph'>Connect</spanx>: If the user agent is configured to use a proxy when using the WebSocket protocol to connect to host /host/ and/or port /port/, then connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.<list style='empty'>
                <t>
                  EXAMPLE: For example, if the user agent uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server:<vspace blankLines='1'/>
                  <figure>
                    <artwork>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
                    </artwork>
                  </figure>
                </t>
                <t>
                  If there was a password, the connection might look like:<vspace blankLines='1'/>
                  <figure>
                    <artwork>
           CONNECT example.com:80 HTTP/1.1
           Host: example.com
           Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
                    </artwork>
                  </figure>
                </t>
              </list>
              Otherwise, if the user agent is not configured to use a proxy, then open a TCP connection to the host given by /host/ and the port given by /port/.
              <vspace blankLines='1'/>
              NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.
              <vspace blankLines='1'/>
              For the purpose of proxy autoconfiguration scripts, the URL to pass the function must be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the steps to construct a WebSocket URL.
              <vspace blankLines='1'/>
              NOTE: The WebSocket protocol can be identified in proxy autoconfiguration scripts from the scheme (&quot;ws:&quot; for unencrypted connections and &quot;wss:&quot; for encrypted connections).
            </t>
            <t>If the connection could not be opened, then fail the WebSocket connection and abort these steps.</t>
            <t>
              If /secure/ is true, perform a TLS handshake over the connection. If this fails (e.g. the server&apos;s certificate could not be verified), then fail the WebSocket connection and abort these steps. Otherwise, all further communication on this channel must run through the encrypted tunnel. <xref target='RFC2246'/>
              <vspace blankLines='1'/>
              User agents must use the Server Name Indication extension in the TLS handshake. <xref target='RFC4366'/>
            </t>
            <t>
              Let the client-nonce be a 16 byte sequence chosen uniformly at random.
            </t>
            <t>
              Send the following strings (in order):
              <list type="numbers">
                <t>Send the UTF-8 string &quot;CONNECT 1C1BCE63-1DF8-455C-8235-08C2646A4F21.invalid:443 HTTP/1.1&quot;.</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
                <t>Send the UTF-8 string &quot;Host: 1C1BCE63-1DF8-455C-8235-08C2646A4F21.invalid:443&quot;.</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
                <t>Send the UTF-8 string &quot;Sec-WebSocket-Key: &quot;.</t>
                <t>Send the client-nonce encoded in base64.</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
              </list>
            </t>
            <t>Let /hostport/ be an empty string.</t>
            <t>Append the /host/ value, converted to ASCII lowercase, to /hostport/.</t>
            <t>If /secure/ is false, and /port/ is not 80, or if /secure/ is
            true, and /port/ is not 443, then append a U+003A COLON character
            (:) followed by the value of /port/, expressed as a base-ten
            integer, to /hostport/.</t>
            <t>
              Let the handshake-key be the first 16 bytes of the HMAC-SHA1 of the UTF-8 string
              &quot;C1BA787A-0556-49F3-B6AE-32E5376F992B&quot; keyed with the
              client-nonce.
            </t>
            <t>
              Send the following strings (in order) encrypted with AES-128-CTR keyed with the handshake-key:
              <list type="numbers">
                <t>Send the UTF-8 string &quot;GET&quot; followed by a UTF-8-encoded U+0020 SPACE character.</t>
                <t>Send the /resource name/ value, encoded as UTF-8.</t>
                <t>Send another UTF-8-encoded U+0020 SPACE character, followed
                by the UTF-8 string &quot;HTTP/1.1&quot;, followed by a
                UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED
                character pair (CRLF).</t>
                <t>Send the string consisting of the concatenation of the
                string &quot;Host:&quot;, a U+0020 SPACE character, and
                /hostport/.</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
                <t>Send the string consisting of the concatenation of the
                string &quot;Origin:&quot;, a U+0020 SPACE character, and the
                /origin/ value.</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
                <t>If there is a /protocols/, then generate the acceptable
                protocol string by joining each protocol in /protocols/ using
                a U+0020 SPACE character. Send the string consisting of the
                concatenation of the string
                &quot;Sec-WebSocket-Protocol:&quot;, a U+0020 SPACE character,
                and the acceptable protocol string generated above followed by
                a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED
                character pair (CRLF).</t>
                <t>If the client has any  cookies that would be relevant to a
                resource accessed over HTTP, if /secure/ is false, or HTTPS,
                if it is true, on host /host/, port /port/, with /resource
                name/ as the path (and possibly query parameters), then send
                any HTTP headers that would be appropriate for that
                information, followed by a UTF-8-encoded U+000D CARRIAGE
                RETURN U+000A LINE FEED character pair (CRLF). <xref
                target='RFC2616'/> <xref target='RFC2109'/>
                <xref target='RFC2965'/>
                <vspace blankLines='1'/>
                This includes &quot;HttpOnly&quot; cookies (cookies with the
                http-only-flag set to true); the WebSocket protocol is not
                considered a non-HTTP API for the purpose of cookie
                processing.</t>
                <t>Send a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE
                FEED character pair (CRLF). (Notice that the sent data
                termiantes with a sequence of two CRLF pairs.)</t>
              </list>
            </t>
            <t>
              TODO: Handle proxy authentication.
            </t>
            <t>
              Read bytes from the server until either the connection closes or
              until 17 bytes are read.  If the read bytes are not exactly the
              UTF-8 string &quot;HTTP/1.1 200 OK&quot; followed by a
              UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character
              pair (CRLF), then <spanx style='emph'>fail the WebSocket
              connection</spanx> and abort these steps.
              <vspace blankLines='1'/>
              User agents may apply a timeout to this step, failing the
              WebSocket connection if the server does not send back data in a
              suitable time period.
            </t>
            <t>Let /fields/ be a list of name-value pairs, initially empty.</t>
            <t>
              <spanx style='emph'>Field</spanx>: Let /name/ and /value/ be empty byte arrays.
            </t>
            <t>
              Read a byte from the server.
              <vspace blankLines='1'/>
              If the connection closes before this byte is received, then fail the WebSocket connection and abort these steps.
              <vspace blankLines='1'/>
              Otherwise, handle the byte as described in the appropriate entry below:<list style='hanging'>
                <t hangText='-> If the byte is 0x0D (UTF-8 CR)'>
                  <vspace blankLines='0'/>If the /name/ byte array is empty, then jump to the fields processing step. Otherwise, fail the WebSocket connection and abort these steps.
                </t>
                <t hangText='-> If the byte is 0x0A (UTF-8 LF)'>
                  <vspace blankLines='0'/>Fail the WebSocket connection and abort these steps.
                </t>
                <t hangText='-> If the byte is 0x3A (UTF-8 :)'>
                  <vspace blankLines='0'/>Move on to the next step.
                </t>
                <t hangText='-> If the byte is in the range 0x41 to 0x5A (UTF-8 A-Z)'>
                  <vspace blankLines='0'/>Append a byte whose value is the byte&apos;s value plus 0x20 to the /name/ byte array and redo this step for the next byte.
                </t>
                <t hangText='-> Otherwise'>
                  <vspace blankLines='0'/>Append the byte to the /name/ byte array and redo this step for the next byte.
                </t>
              </list>
              NOTE: This reads a field name, terminated by a colon, converting upper-case  letters in the range A-Z to lowercase, and aborting if a stray CR or LF is found.
            </t>
            <t>
              Let /count/ equal 0.
              <vspace blankLines='1'/>
              NOTE: This is used in the next step to skip past a space character after the colon, if necessary.
            </t>
            <t>
              Read a byte from the server and increment /count/ by 1.
              <vspace blankLines='1'/>
              If the connection closes before this byte is received, then fail the WebSocket connection and abort these steps.
              <vspace blankLines='1'/>
              Otherwise, handle the byte as described in the appropriate entry below:<list style='hanging'>
                <t hangText='-> If the byte is 0x20 (UTF-8 space) and /count/ equals 1'>
                  <vspace blankLines='0'/>Ignore the byte and redo this step for the next byte.
                </t>
                <t hangText='-> If the byte is 0x0D (UTF-8 CR)'>
                  <vspace blankLines='0'/>Move on to the next step.
                </t>
                <t hangText='-> If the byte is 0x0A (UTF-8 LF)'>
                  <vspace blankLines='0'/>Fail the WebSocket connection and abort these steps.
                </t>
                <t hangText='-> Otherwise'>
                  <vspace blankLines='0'/>Append the byte to the /value/ byte array and redo this step for the next byte.
                </t>
              </list>
              NOTE: This reads a field value, terminated by a CRLF, skipping past a single space after the colon if there is one.
            </t>
            <t>
              Read a byte from the server.
              <vspace blankLines='1'/>
              If the connection closes before this byte is received, or if the byte is not a 0x0A byte (UTF-8 LF), then fail the WebSocket connection and abort these steps.
              <vspace blankLines='1'/>
              NOTE: This skips past the LF byte of the CRLF after the field.
            </t>
            <t>Append an entry to the /fields/ list that has the name given by the string obtained by interpreting the /name/ byte array as a UTF-8 byte stream and the value given by the string obtained by interpreting the /value/ byte array as a UTF-8 byte stream.</t>
            <t>Return to the &quot;Field&quot; step above.</t>
            <t>
              <spanx style='emph'>Fields processing</spanx>: Read a byte from the server.
              <vspace blankLines='1'/>
              If the connection closes before this byte is received, or if the byte is not a 0x0A byte (UTF-8 LF), then fail the WebSocket connection and abort these steps.
              <vspace blankLines='1'/>
              NOTE: This skips past the LF byte of the CRLF after the blank line after the fields.
            </t>
            <t>
              Let the /list of cookies/ be empty.
            </t>
            <t>
              If there is not exactly one entry in the /fields/ list whose
              name is &quot;sec-websocket-accept&quot;, or if there is not exactly one
              entry in the /fields/ list whose name is &quot;sec-websocket-key&quot;,
              or if there is not exactly one entry in the /fields/ list whose
              name is &quot;sec-websocket-origin&quot;, or if there is not
              exactly one entry in the /fields/ list whose name is
              &quot;sec-websocket-location&quot;, or if the /protocol/ was
              specified but there is not exactly one entry in the /fields/
              list whose name is &quot;sec-websocket-protocol&quot;, or if
              there are any entries in the /fields/ list whose names are the
              empty string, then fail the WebSocket connection and abort these
              steps. Otherwise, handle each entry in the /fields/ list as
              follows:<list style='hanging'>
                <t hangText='-> If the entry&apos;s name is &quot;sec-websocket-accept&quot;'>
                  <vspace blankLines='0'/>If the value is not exactly equal to
                  the base64 encoding of the HMAC-SHA1 of the UTF-8 string
                  &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; keyed with
                  the client-nonce, then <spanx style='emph'>fail the
                  WebSocket connection</spanx> and abort these steps.
                </t>
                <t hangText='-> If the entry&apos;s name is &quot;sec-websocket-key&quot;'>
                  <vspace blankLines='0'/>
                  If the read bytes are not the base64 encoding of a 16 byte
                  sequence, then <spanx style='emph'>fail the WebSocket
                  connection</spanx> and abort these steps.  Otherwise, let
                  the server-nonce be that 16 byte sequence.  If the
                  server-nonce is identical to the client-nonce, then <spanx
                  style='emph'>fail the WebSocket connection</spanx> and abort
                  these steps.
                </t>
                <t hangText='-> If the entry&apos;s name is &quot;sec-websocket-origin&quot;'>
                  <vspace blankLines='0'/>If the value is not exactly equal to /origin/, then fail the WebSocket connection and abort these steps. <xref target='ORIGIN'/>
                </t>
                <t hangText='-> If the entry&apos;s name is &quot;sec-websocket-location&quot;'>
                  <vspace blankLines='0'/>If the value is not exactly equal to a string obtained from the steps to construct a WebSocket URL from /host/, /port/, /resource name/, and the /secure/ flag, then fail the WebSocket connection and abort these steps.
                </t>
                <t hangText='-> If the entry&apos;s name is &quot;sec-websocket-protocol&quot;'>
                  <vspace blankLines='0'/>If there was a /protocols/ string specified, and the value is not exactly equal to one of the items in /protocols/, then fail the WebSocket connection and abort these steps. (If no /protocols/ was specified, the field is ignored.)
                </t>
                <t hangText='-> If the entry&apos;s name is &quot;set-cookie&quot; or &quot;set-cookie2&quot; or another cookie-related field name'>
                  <vspace blankLines='0'/>If the relevant specification is supported by the user agent, add the cookie, interpreted as defined by the appropriate specification, to the /list of cookies/, with the resource being the one with the host /host/, the port /port/, the path (and possibly query parameters) /resource name/, and the scheme |http| if /secure/ is false and |https| if /secure/ is true. <xref target='RFC2109'/> <xref target='RFC2965'/>
                  <vspace blankLines='1'/>
                  If the relevant specification is not supported by the user agent, then the field must be ignored.
                  <vspace blankLines='1'/>
                  The cookies added to the /list of cookies/ are discarded if the connection fails to be established. Only if and when the connection is established do the cookies actually get applied.
                </t>
                <t hangText='-> Any other name'>
                  <vspace blankLines='0'/>Ignore it.
                </t>
              </list>
              <vspace blankLines='1'/>
            </t>
            <t>
              If the /defer cookies/ flag is not set, apply the cookies in the /list of cookies/.
            </t>
            <t>
              The <spanx style='strong'>WebSocket connection is
              established</spanx>. Now the user agent must send and receive to
              and from the connection as described in the next section.  The
              handshake has established two keys:
              <list style="symbols">
                <t>The client-to-server key is the intial 16 bytes of the
                HMAC-SHA1 of the UTF-8 string
                &quot;363A6078-74D2-4C0B-8CBC-1E6A36E83442&quot; keyed with
                the concatenation of the client-nonce and the
                server-nonce.</t>
                <t>The server-to-client key is the initial 16 bytes of the
                HMAC-SHA1 of the UTF-8 string
                &quot;2306C3BE-0ACF-42C0-B69E-DFFE02CFA346&quot; keyed with
                the concatentation of the client-nonce and the
                server-nonce.</t>
              </list>
              All subsequent bytes sent from the user agent to the server are
              encrypted using AES-128-CTR keyed with the client-to-server
              key.  All subsequence bytes read by the user agent from the
              server are decrypted using AES-128-CTR keyed with the
              server-to-client key.
            </t>
            <t>
              If the /defer cookies/ flag is set, store the /list of cookies/ for use by the component that invoked this algorithm.
            </t>
          </list>
        </t>

        <t>
          Where the algorithm above requires that a user agent
          fail the WebSocket connection,
          the user agent may first read an
          arbitrary number of further bytes from the connection (and then
          discard them) before actually <spanx style='strong'>failing the WebSocket connection</spanx>.
          Similarly, if a
          user agent can show that the bytes read from the connection so far
          are such that there is no subsequent sequence of bytes that the
          server can send that would not result in the user agent being
          required to <spanx style='strong'>fail the WebSocket connection</spanx>, the user
          agent may immediately <spanx style='strong'>fail the WebSocket connection</spanx>
          without waiting for those bytes.
        </t>

        <t>
          NOTE: The previous paragraph is intended to make it
          conforming for user agents to implement the algorithm in subtlely
          different ways that are equivalent in all ways except that they
          terminate the connection at earlier or later points. For example, it
          enables an implementation to buffer the entire handshake response
          before checking it, or to verify each field as it is received rather
          than collecting all the fields and then checking them as a
          block.
        </t>

        <t>
          When the user agent is to &quot;apply the cookies&quot; in a
          /list of cookies/, it must handle each cookie in the
          /list of cookies/ as defined by the appropriate
          specification. <xref target='RFC2109'/> <xref target='RFC2965'/>
        </t>

        
      </section>
      <section title='Server-side requirements'>
        <t>
          <spanx style='emph'>This section only applies to servers.</spanx>
        </t>

        <t>
          Servers may offload the management of the connection to other
          agents on the network, for example load balancers and reverse
          proxies. In such a situation, the server for the purposes of
          conformance is considered to include all parts of the server-side
          infrastructure from the first device to terminate the TCP connection
          all the way to the server that processes requests and sends
          responses.
        </t>

        <t>
          EXAMPLE: For example, a data center might have a server that responds to
          Web Socket requests with an appropriate handshake, and then passes
          the connection to another server to actually process the data
          frames. For the purposes of this specification, the "server" is the
          combination of both computers.
        </t>

        <section title='Reading the client&apos;s opening handshake'>
          <t>When a client starts a WebSocket connection, it sends its part of
          the opening handshake. The server must parse at least part of this
          handshake in order to obtain the necessary information to generate
          the server part of the handshake.</t>
          <t>
            The client handshake consists of the following parts. If the
            server, while reading the handshake, finds that the client did not
            send a handshake that matches the description below, the server
            should abort the WebSocket connection.
            <list style='numbers'>
              <t>The UTF-8 string &quot;CONNECT 1C1BCE63-1DF8-455C-8235-08C2646A4F21.invalid:443 HTTP/1.1&quot;.</t>
              <t>A UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
              <t>The UTF-8 string &quot;Host: 1C1BCE63-1DF8-455C-8235-08C2646A4F21.invalid:443&quot;.</t>
              <t>A UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).</t>
              <t>The UTF-8 string &quot;Sec-WebSocket-Key: &quot;.</t>
              <t>A string of base64 encoded bytes terminated by a
              UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character
              pair (CRLF). The decoded bytes are the client-nonce.</t>
            </list>
          </t>
          <t>
            Let the handshake-key be the first 16 bytes of the HMAC-SHA1 of the UTF-8 string
            &quot;C1BA787A-0556-49F3-B6AE-32E5376F992B&quot; keyed with the
            client-nonce.
          </t>
          <t>
            The next portion of the client handshake is encrypted using
            AES-128-CTR keyed with the handshake-key.  If the server, while
            reading the handshake, finds that the client did not send a
            handshake that matches the description below, the server should
            abort the WebSocket connection.
            <list style='numbers'>
              <t>The three-character UTF-8 string &quot;GET&quot;.</t>
              <t>A UTF-8-encoded U+0020 SPACE character (0x20 byte).</t>
              <t>A string consisting of all the bytes up to the next UTF-8-encoded U+0020 SPACE character (0x20 byte). The result of decoding this string as a UTF-8 string is the name of the resource requested by the server. If the server only supports one resource, then this can safely be ignored; the client verifies that the right resource is supported based on the information included in the server&apos;s own handshake. The resource name will begin with U+002F SOLIDUS character (/) and will only include characters in the range U+0021 to U+007E.</t>
              <t>A string of bytes terminated by a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF). All the characters from the second 0x20 byte up to the first 0x0D 0x0A byte pair in the data from the client can be safely ignored. (It will probably be the string &quot;HTTP/1.1&quot;.)</t>
              <t>
                A series of fields.
                <vspace blankLines='1'/>
                Each field is terminated by a UTF-8-encoded U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF). The end of the fields is denoted by the terminating CRLF pair being followed immediately by another CRLF pair.
                <vspace blankLines='1'/>
                NOTE: In other words, the fields start with the first 0x0D 0x0A byte pair, end with the first 0x0D 0x0A 0x0D 0x0A byte sequence, and are separate from each other by 0x0D 0x0A byte pairs.
                <vspace blankLines='1'/>
                The fields are encoded as UTF-8.
                <vspace blankLines='1'/>
                Each field consists of a name, consisting of one or more characters in the ranges U+0021 to U+0039 and U+003B to U+007E, followed by a U+003A COLON character (:) and a U+0020 SPACE character, followed by zero or more characters forming the value.
                <vspace blankLines='1'/>
                The expected field names, the meaning of their corresponding values, and the processing servers are required to apply to those fields, are described below, after the description of the client handshake.
              </t>
            </list>
          </t>
          <t>
            The expected field names, and the meaning of their corresponding values, are as follows. Field names must be compared in an ASCII case-insensitive manner.
            <list style='hanging'>
              <t hangText='|Host|'>
                <vspace blankLines='0'/>The value gives the hostname that the client intended to use when opening the WebSocket. It would be of interest in particular to virtual hosting environments, where one server might serve multiple hosts, and might therefore want to return different data.
                <vspace blankLines='1'/>
                Can be safely ignored, though the server should abort the WebSocket connection if this field is absent or has a value that does not match the server&apos;s host name, to avoid vulnerability to cross-protocol attacks and DNS rebinding attacks.
              </t>
              <t hangText='|Origin|'>
                <vspace blankLines='0'/>The value gives the scheme, hostname, and port (if it&apos;s not the default port for the given scheme) of the page that asked the client to open the WebSocket. It would be interesting if the server&apos;s operator had deals with operators of other sites, since the server could then decide how to respond (or indeed, <spanx style='emph'>whether</spanx> to respond) based on which site was requesting a connection. <xref target='ORIGIN'/>
                <vspace blankLines='1'/>
                Can be safely ignored, though the server should abort the WebSocket connection if this field is absent or has a value that does not match one of the origins the server is expecting to communicate with, to avoid vulnerability to cross-protocol attacks and cross-site scripting attacks.
              </t>
              <t hangText='|Sec-WebSocket-Protocol|'>
                <vspace blankLines='0'/>The value gives the name of a subprotocol that the client is intending to select. It would be interesting if the server supports multiple protocols or protocol versions.
                <vspace blankLines='1'/>
                Can be safely ignored, though the server may abort the WebSocket connection if the field is absent but the conventions for communicating with the server are such that the field is expected; and the server should abort the WebSocket connection if the field has a value that does not match one of the subprotocols that the server supports, to avoid integrity errors once the connection is established.
              </t>
              <t hangText='Other fields'>
                <vspace blankLines='0'/>Other fields can be used, such as &quot;Cookie&quot;, for authentication purposes. Their semantics are equivalent to the semantics of the HTTP headers with the same names.
              </t>
            </list>
          </t>
          <t>Unrecognized fields can be safely ignored, and are probably either the result of intermediaries injecting fields unrelated to the operation of the WebSocket protocol, or clients that support future versions of the protocol offering options that the server doesn&apos;t support.</t>
        </section>
        <section title='Sending the server&apos;s opening handshake'>
          <t>
            When a client establishes a WebSocket connection to a server, the server must run the following steps.
            <list style='numbers'>
              <t>
                If the server supports encryption, perform a TLS handshake over the connection. If this fails (e.g. the client indicated a host name in the extended client hello &quot;server_name&quot; extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server handshake) must run through the encrypted tunnel. <xref target='RFC2246'/>
              </t>
              <t>
                Establish the following information:<list style='hanging'>
                  <t hangText='/host/'>
                    <vspace blankLines='0'/>The host name or IP address of the WebSocket server, as it is to be addressed by clients. The host name must be punycode-encoded if necessary. If the server can respond to requests to multiple hosts (e.g. in a virtual hosting environment), then the value should be derived from the client&apos;s handshake, specifically from the &quot;Host&quot; field. The /host/ value must be lowercase (not containing characters in the range U+0041 LATIN CAPITAL LETTER A to U+005A LATIN CAPITAL LETTER Z).
                  </t>
                  <t hangText='/port/'>
                    <vspace blankLines='0'/>The port number on which the server expected and/or received the connection.
                  </t>
                  <t hangText='/resource name/'>
                    <vspace blankLines='0'/>An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client&apos;s handshake.
                  </t>
                  <t hangText='/secure flag/'>
                    <vspace blankLines='0'/>
                  </t>
                  <t hangText=''>
                    <vspace blankLines='0'/>True if the connection is encrypted or if the server expected it to be encrypted; false otherwise.
                  </t>
                  <t hangText='/origin/'>
                    <vspace blankLines='0'/>The ASCII serialization of the origin that the server is willing to communicate with, converted to ASCII lowercase. If the server can respond to requests from multiple origins (or indeed, all origins), then the value should be derived from the client&apos;s handshake, specifically from the &quot;Origin&quot; field. <xref target='ORIGIN'/>
                  </t>
                  <t hangText='/subprotocol/'>
                    <vspace blankLines='0'/>Either null, or a string representing the subprotocol the server is ready to use. If the server supports multiple subprotocols, then the value should be derived from the client&apos;s handshake, specifically by selecting one of the values from the &quot;Sec-WebSocket-Protocol&quot; field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes.
                  </t>
                </list>
              </t>
              <t>Let /location/ be the string that results from constructing a WebSocket URL from /host/, /port/, /resource name/, and /secure flag/.</t>
              <t>
                Let acceptance-proof be the base64 encoding of the HMAC-SHA1 of the UTF-8 string
                &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; keyed with the client-nonce.
              </t>
              <t>
                Let server-nonce be a sequence of 16 bytes chosen uniformly at random.
              </t>
              <t>
                Send the following line, terminated by the two characters U+000D CARRIAGE RETURN and U+000A LINE FEED (CRLF) and encoded as UTF-8, to the client:<vspace blankLines='1'/>
                <figure>
                  <artwork>        HTTP/1.1 200 OK</artwork>
                </figure>
              </t>
              <t>
                Send the following fields to the client. Each field must be sent as a line consisting of the field name, which must be an ASCII case-insensitive match for the field name in the list below, followed by a U+003A COLON character (:) and a U+0020 SPACE character, followed by the field value as specified in the list below, followed by the two characters U+000D CARRIAGE RETURN and U+000A LINE FEED (CRLF). The lines must be encoded as UTF-8. The lines may be sent in any order.<list style='hanging'>
                  <t hangText='|Sec-WebSocket-Accept|'>
                    <vspace blankLines='0'/>The value must be the acceptance-proof.
                  </t>
                  <t hangText='|Sec-WebSocket-Key|'>
                    <vspace blankLines='0'/>The value must be the server-nonce encoded in base64.
                  </t>
                  <t hangText='|Sec-WebSocket-Location|'>
                    <vspace blankLines='0'/>The value must be /location/
                  </t>
                  <t hangText='|Sec-WebSocket-Origin|'>
                    <vspace blankLines='0'/>The value must be /origin/
                  </t>
                  <t hangText='|Sec-WebSocket-Protocol|'>
                    <vspace blankLines='0'/>This field must be included if /subprotocol/ is not null, and must not be included if /subprotocol/ is null.
                    <vspace blankLines='1'/>
                    If included, the value must be /subprotocol/
                  </t>
                </list>
                Optionally, include &quot;Set-Cookie&quot;, &quot;Set-Cookie2&quot;, or other cookie-related fields, with values equal to the values that would be used for the identically named HTTP headers. <xref target='RFC2109'/> <xref target='RFC2965'/>
              </t>
              <t>Send two bytes 0x0D 0x0A (UTF-8 CRLF).</t>
              <t>Send /response/.</t>
            </list>
          </t>
          <t>This completes the server&apos;s handshake. If the server
          finishes these steps without aborting the WebSocket connection, and
          if the client does not then fail the WebSocket connection, then the
          connection is established and the server may begin sending and
          receiving data, as described in the next section.  The handshake has
          established two keys:
          <list style="symbols">
            <t>The client-to-server key is the intial 16 bytes of the
            HMAC-SHA1 of the UTF-8 string
            &quot;363A6078-74D2-4C0B-8CBC-1E6A36E83442&quot; keyed with
            the concatenation of the client-nonce and the
            server-nonce.</t>
            <t>The server-to-client key is the initial 16 bytes of the
            HMAC-SHA1 of the UTF-8 string
            &quot;2306C3BE-0ACF-42C0-B69E-DFFE02CFA346&quot; keyed with
            the concatentation of the client-nonce and the
            server-nonce.</t>
          </list>
          All subsequent bytes read by the server from the user agent are
          decrypted using AES-128-CTR keyed with the client-to-server key.
          All subsequence bytes sent from the server to the user agent are
          encrypted using AES-128-CTR keyed with the server-to-client key.
          </t>
        </section>
      </section>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <reference anchor='HTML' target='http://whatwg.org/html5'>
        <front>
          <title>HTML</title>
          <author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
            <organization>Google, Inc.</organization>
          </author>
          <date day="18" month="August" year="2010"/>
        </front>
      </reference>
      <reference anchor='ORIGIN' target='http://tools.ietf.org/html/draft-abarth-origin'>
        <front>
          <title>The HTTP Origin Header</title>
          <author initials='A.' surname='Barth' fullname='Adam Barth'>
            <organization>U.C. Berkeley</organization>
          </author>
          <author initials='C.' surname='Jackson' fullname='Collin Jackson'>
            <organization>Stanford University</organization>
          </author>
          <author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
            <organization>Google, Inc.</organization>
          </author>
          <date day="24" month="September" year="2009"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-abarth-origin"/>
      </reference>
      <?rfc include='reference.ANSI.X3-4.1986.xml'?>
      <?rfc include='reference.RFC.1321.xml'?>
      <?rfc include='reference.RFC.1951.xml'?>
      <?rfc include='reference.RFC.2109.xml'?>
      <?rfc include='reference.RFC.2119.xml'?>
      <?rfc include='reference.RFC.2246.xml'?>
      <?rfc include='reference.RFC.2616.xml'?>
      <?rfc include='reference.RFC.2965.xml'?>
      <?rfc include='reference.RFC.3490.xml'?>
      <?rfc include='reference.RFC.3629.xml'?>
      <?rfc include='reference.RFC.3864.xml'?>
      <?rfc include='reference.RFC.3986.xml'?>
      <?rfc include='reference.RFC.3987.xml'?>
      <?rfc include='reference.RFC.4366.xml'?>
      <?rfc include='reference.RFC.5234.xml'?>
<!--
      <reference anchor='WEBADDRESSES' target='http://www.w3.org/html/wg/href/draft'>
        <front>
          <title>Web addresses in HTML 5</title>
          <author initials='D.' surname='Connolly' fullname='Dan Connolly'>
            <organization>Midwest Web Sense LLC and W3C</organization>
          </author>
          <author initials='C. M.' surname='Sperberg-McQueen' fullname='C. M. Sperberg-McQueen'>
            <organization>Black Mesa Technologies LLC</organization>
          </author>
          <date day="21" month="May" year="2009"/>
        </front>
      </reference>
-->
      <reference anchor='WSAPI' target='http://dev.w3.org/html5/websockets/'>
        <front>
          <title>The Web Sockets API</title>
          <author initials='I.E.' surname='Hickson' fullname='Ian Hickson'>
            <organization>Google, Inc.</organization>
          </author>
          <date day="18" month="August" year="2010"/>
        </front>
      </reference>
    </references>
  </back>
</rfc>
