<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an
Internet Draft using xml2rfc, which is available here: http://xml.resource.org.
-->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from
the online citation libraries. There has to be one entity for each item to be
referenced. An alternate method (rfc include) is described in the references.
-->
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY rfc3550 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY rfc3552 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY rfc3611 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3611.xml">
<!ENTITY rfc4585 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4585.xml">
<!ENTITY rfc3629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY rfc5245 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5245.xml">
<!ENTITY rfc5285 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5285.xml">
<!ENTITY rfc5760 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5760.xml">
<!ENTITY rfc4960 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY rfc5533 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5533.xml">
<!ENTITY rfc3261 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY rfc3264 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY rfc5117 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5117.xml">
<!ENTITY rfc4566 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY I-D.ietf-mptcp-architecture PUBLIC "" "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-mptcp-architecture.xml">
<!ENTITY I-D.ietf-mmusic-rfc2326bis PUBLIC "" "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-mmusic-rfc2326bis.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="no"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="exp" docName="draft-singh-avt-mprtp-01" ipr='trust200902'>
  <!-- category values: std, bcp, info, exp, and historic ipr
values: full3667, noModification3667, noDerivatives3667 you can add the
attributes updates="NNNN" and obsoletes="NNNN" they will automatically be output
with "(if approved)" -->

  <front>
    <title abbrev="Multipath RTP">Multipath RTP (MPRTP)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <author fullname="Varun Singh" initials="V" surname="Singh">
      <organization>Aalto University</organization>

      <address>
        <postal>
          <street>School of Science and Technology</street>

          <street>Otakaari 5 A</street>

          <city>Espoo</city>

          <region>FIN</region>

          <code>02150</code>

          <country>Finland</country>
        </postal>

        <email>varun@comnet.tkk.fi</email>
      </address>
    </author>

    <author fullname="Teemu Karkkainen" initials="T" surname="Karkkainen">
      <organization>Aalto University</organization>

      <address>
        <postal>
          <street>School of Science and Technology</street>

          <street>Otakaari 5 A</street>

          <city>Espoo</city>

          <region>FIN</region>

          <code>02150</code>

          <country>Finland</country>
        </postal>

        <email>teemuk@comnet.tkk.fi</email>
      </address>
    </author>

    <author fullname="Joerg Ott" initials="J" surname="Ott">
      <organization>Aalto University</organization>

      <address>
        <postal>
          <street>School of Science and Technology</street>

          <street>Otakaari 5 A</street>

          <city>Espoo</city>

          <region>FIN</region>

          <code>02150</code>

          <country>Finland</country>
        </postal>

        <email>jo@comnet.tkk.fi</email>
      </address>
    </author>
    
    <author fullname="Saba Ahsan" initials="S" surname="Ahsan">
      <organization>Aalto University</organization>

      <address>
        <postal>
          <street>School of Science and Technology</street>

          <street>Otakaari 5 A</street>

          <city>Espoo</city>

          <region>FIN</region>

          <code>02150</code>

          <country>Finland</country>
        </postal>

        <email>sahsan@cc.hut.fi</email>
      </address>
    </author>
 	<author initials="L." surname="Eggert" fullname="Lars Eggert">
		<organization abbrev="Nokia">
			Nokia Research Center
		</organization>
		<address>
			<postal>
				<street>P.O. Box 407</street>
				<code>00045</code> <city>Nokia Group</city>
				<country>Finland</country>
			</postal>
			<phone>+358 50 48 24461</phone>
			<email>lars.eggert@nokia.com</email>
			<uri>
				http://research.nokia.com/people/lars_eggert
			</uri>
		</address>
	</author>

 
    <date year="2010" />

    <!-- <area>RAI</area> <workgroup>AVT Working
Group</workgroup> -->

    <area>Internet Engineering Task Force</area>

    <workgroup>AVT Working Group</workgroup>

    <keyword>RTP</keyword>

    <keyword>RTCP</keyword>

    <keyword>multipath</keyword>

    <keyword>streaming</keyword>

    <abstract>
      <t>The Real-time Transport Protocol (RTP) is used to deliver real-time
      content and, along with the RTP Control Protocol (RTCP), forms the control channel between the sender and receiver. However, RTP and RTCP assume a single delivery path between the sender and receiver and make decisions based on the measured characteristics of this single path. Increasingly, endpoints are becoming multi-homed, which means that they are connected via multiple Internet paths. Network utilization can be improved when endpoints use multiple parallel paths for communication. The resulting increase in reliability and throughput can also enhance the user experience. This document extends the Real-time Transport Protocol (RTP) so that a single session can take advantage of the availability of multiple paths between two endpoints.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
	<t>Multi-homed endpoints are becoming common in today's Internet, e.g., devices that support multiple wireless access technologies such as 3G and Wireless LAN. This means that often there is more than one network path available between two endpoints. Transport protocols, such as RTP, have not been designed to take advantage of the availability of multiple concurrent paths and therefore cannot benefit from the increased capacity and reliability that can be achieved by pooling their respective capacities.</t>
	
	<t>Multipath RTP (MPRTP) is an OPTIONAL extension to RTP <xref target="RFC3550" /> that allows splitting a single RTP stream into multiple subflows that transmit over different paths. In effect, this pools the resource capacity of multiple paths.</t>
	
	<t>Other IETF transport protocols that are capable of using multiple paths include SCTP <xref target="RFC4960" />, MPTCP <xref target="I-D.ietf-mptcp-architecture">MPTCP</xref> and SHIM6 <xref target="RFC5533" />. However, these protocols are not suitable for realtime communications.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119" />.</t>
      </section>

      <section title="Terminology">
        <!--    <t> .</t> -->

        <t><list style="symbols">
            <t>Endpoint: host either initiating or terminating an RTP
            connection.</t>

            <t>Interface: A logical or physical component that is capable of
            acquiring a unique IP address.</t>

            <t>Path: sequence of links between a sender and a receiver.
            Typically, defined by a set of source and destination
            addresses.</t>

            <t>Subflow: A flow of RTP packets along a specific path, i.e., a subset of the packets belonging to an RTP stream. The combination of all RTP subflows forms the complete RTP stream.</t>

            <!--       <t>
             Connection: is s
           </t>-->
          </list></t>
      </section>

      <section title="Use cases">
	  
	  <t>
	  The primary use case for MPRTP is transporting high bit-rate streaming multimedia content between endpoints, where at least one is multi-homed. Such endpoints could be residential IPTV devices that connect to the Internet through two different Internet service providers (ISPs), or mobile devices that connect to the Internet through 3G and WLAN interfaces. By allowing RTP to use multiple paths for transmission, the following gains can be achieved:
	  <list style="symbols">
		<t>
			Higher quality: Pooling the resource capacity of multiple Internet paths allows higher bit-rate and higher quality codecs to be used. From the application perspective, the available bandwidth between the two endpoints increases.
		</t>
		<t>
			Load balancing: Transmitting one RTP stream over multiple paths can reduce the bandwidth usage, compared to transmitting the same stream along a single path. This reduces the impact on other traffic.
		</t>
		<t>
			Fault tolerance: When multiple paths are used in conjunction with redundancy mechanisms (FEC, re-transmissions, etc.), outages on one path have less impact on the overall perceived quality of the stream.
		</t>
	  </list>
	  </t>
	  
	  <t>
	  A secondary use case for MPRTP is transporting Voice over IP (VoIP) calls to a device with multiple interfaces. Again, such an endpoint could be a mobile device with multiple wireless interfaces. In this case, little is to be gained  from resource pooling, i.e., higher capacity or load balancing, because a single path should be easily capable of handling the required load. However, using multiple concurrent subflows can improve fault tolerance, because traffic can shift between the subflows when path outages occur. This results in very fast transport-layer handovers that do not require support from signaling.
	  </t>
	  
	  <!--<t>JO: There maybe other scenarios such as, High Quality Audio </t>-->
	  
<!--
        <t>A typical use-case for MPRTP is to maximize throughput, i.e., all available paths are used to stream data simultaneously. <xref target="fig-mp-use-case1"></xref> shows this basic use-case where-in Host A establishes a connection with Host B using RTSP, SIP or some other similar protocol, during the handshake, the two end-points exchange their multiple addresses. Depending on the bandwidth delay product and loss characteristics of each path the host MAY send data concurrently along the two paths or send redundant data (FEC, re-transmissions etc) along one path and normal streaming data along the other.
        </t>

        <figure anchor="fig-mp-use-case1"
            title="Example MPRTP Scenario">
            <artwork><![CDATA[
        Host A                               Host B
-----------------------              -----------------------
Address A1   Address A2              Address B1   Address
-----------------------              -----------------------
    |            |                       |            |
    |    (initial connection setup)      |            |
    |  (A advertises interfaces A1, A2)  |            |
    |-----------------------------------\>|            |
    |  (B advertises interfaces B1, B2)  |            |
    |<-----------------------------------|            |
    |            |                       |            |
    |     (RTP data B1->A1, B2->A2)      |            |
    |<===================================|            |
    |            |<===================================|
    |            |                       |            |
    ]]></artwork>
          </figure>

        <t><xref target="fig-mp-use-case2"></xref> describes a
        simpler scenario where-in only one host has multiple interfaces.</t>
        <figure anchor="fig-mp-use-case2" title="Simplified MPRTP Scenario">
            <artwork><![CDATA[
        Host A                           Host B
-----------------------                ----------
Address A1   Address A2                Address B1 
-----------------------                ----------
    |            |                         |
    |      (initial connection setup)      |
    |   (A advertises interfaces A1, A2)   |
    |-------------------------------------\>|
    |   (B only advertises interfaces B1)  |
    |<-------------------------------------|
    |            |                         |
    |       (RTP data B1->A1, B2->A2)      |
    |<=====================================|
    |            |<========================|
    |            |                         |
    ]]></artwork>
          </figure> 
        <t>Furthermore, the above figures for simplicity only show simplex data flow but the protocol MAY also be used for duplex communication. There maybe more complex scenarios involving middle-boxes, NATs and firewalls. We discuss them in more detail in later sections.</t>
-->
      </section>
    </section>

    <section title="Goals">
      <t>This section outlines the basic goals that multipath RTP aims to meet. These are broadly classified as Functional goals and Compatibility goals.</t>

      <section title="Functional goals">
        <t>Allow unicast RTP session to be split into multiple subflows in order to be carried over multiple paths. This may prove beneficial in case of video streaming. 
        <list style="symbols">
            <t>Increased Throughput: Cumulative capacity of the two paths may meet the requirements of the multimedia session. Therefore, MPRTP MUST support concurrent use of the multiple paths. <!-- (Note: should this be a function of bandwidth-delay product)
            possibility of streaming future data, i.e. send current data along a low delay path while future data along a high delay, such that data along the two paths arrive relatively at the time of playback. -->
            </t>

            <t>Improved Reliability: MPRTP SHOULD be able to send redundant or re-transmit packets along any available path to increase reliability.</t>
          </list>
		  The protocol SHOULD be able to open new subflows for an existing session when new paths appear and MUST be able to close subflows when paths disappear.</t>
      </section>

      <section title="Compatibility goals">
        <t>MPRTP MUST be backwards compatible; an MPRTP stream needs to fall back to be compatible with legacy RTP stacks if MPRTP support is not successfully negotiated.<list style="symbols">
            <t>Application Compatibility: MPRTP service model MUST be backwards compatible with existing RTP applications, i.e., an MPRTP stack MUST be able to work with legacy RTP applications and not require changes to them. Therefore, the basic RTP APIs MUST remain unchanged, but an MPRTP stack MAY provide extended APIs so that the application can configure any additional features provided by the MPRTP stack.</t>

            <t>Network Compatibility: individual RTP subflows MUST themselves be well-formed RTP flows, so that they are able to traverse NATs and firewalls. This MUST be the case even when interfaces appear after session initiation. <xref target="RFC5245">Interactive Connectivity Establishment (ICE)</xref> MAY be used for discovering new interfaces or performing connectivity checks.</t>
          </list>
        </t>
      </section>
    </section>
<!-- 
    <section title="Comparison to TCP, SCTP, and MPTCP">
Teemu: Can we get rid of this? Especially the TCP stuff seems irrelevant.
      <t>TCP is a transport protocol and runs over IP, TCP has a strong feedback loop provides services such as reliability and congestion control. RTP is an application layer protocols and runs on top of UDP. RTP is capable of running over multicast network and has a loose feedback loop using RTCP. Due to this loose binding RTP/RTCP provides limited services for Congestion Control, Reliability etc <xref target="RFC4585"></xref> <xref target="RFC3611"></xref>.</t>

      <t>While SCTP supports multihoming and multipath functions, it is typically used as a failover mechanism and cannot be used to make concurrent data transfer over multiple interfaces. However, <xref target="I-D.ietf-mptcp-architecture">MPTCP</xref> describes an extension to TCP for multipath concurrent data transfer.</t>
      
      <t>(...)</t>

      <t>However, MPRTP provides aggregate path information for each subflow that maybe used to adapt to the link characteristics.</t>
    </section>
-->  
   
    <section title="RTP Topologies">
    <t><xref target="RFC5117">RFC 5117</xref> describes a number of scenarios using mixers and translators in single-party (point-to-point), and multi-party (point-to-multipoint) scenarios.
    <xref target="RFC3550">RFC 3550</xref> (Section 2.3 and 7.x) discuss in detail the impact of mixers and translators on RTP and RTCP packets. MPRTP assumes that if a mixer or translator exists in the network, then either all of the multiple paths or none of the multiple paths go via this component.
    </t>
    </section>
    
    <section title="MPRTP Architecture">
      <t>In a typical scenario, an RTP session uses a single path. In an MPRTP scenario, an RTP session uses multiple subflows that each use a different path. <xref target="fig-mp-rtp-streaming" /> shows the difference. </t>
    
<!--      <section title="Operation overview"> -->
<figure anchor="fig-mp-rtp-streaming" title="Comparison between traditional RTP streaming and MPRTP">
<artwork><![CDATA[
+--------------+                Signaling            +--------------+
|              |------------------------------------>|              |
|    Client    |<------------------------------------|    Server    |
|              |             Single RTP flow         |              |
+--------------+                                     +--------------+

+--------------+              Signaling              +--------------+
|              |------------------------------------>|              |
|    Client    |<------------------------------------|    Server    |
|              |<------------------------------------|              |
+--------------+           MPRTP sub-flows           +--------------+
]]></artwork>
</figure>
<!--    </section> -->

    <figure anchor="fig-mp-rtp-archit" title="MPRTP Architecture">
<artwork><![CDATA[
+-----------------------+         +-------------------------------+
|      Application      |         |          Application          |
+-----------------------+         +-------------------------------+
|                       |         |             MPRTP             |
+          RTP          +         +- - - - - - - -+- - - - - - - -+
|                       |         |  RTP subflow  |  RTP subflow  |
+-----------------------+         +---------------+---------------+
|          UDP          |         |      UDP      |      UDP      |
+-----------------------+         +---------------+---------------+
|           IP          |         |       IP      |       IP      |
+-----------------------+         +---------------+---------------+
]]></artwork>
</figure>
    <t><xref target="fig-mp-rtp-archit" /> illustrates the differences between the standard RTP stack and the MPRTP stack. MPRTP receives a normal RTP session from the application and splits it into multiple RTP subflows. Each subflow is then sent along a different path to the receiver. To the network, each subflow appears as an independent, well-formed RTP flow. At the receiver, the subflows are combined to recreate the original RTP session. The MPRTP layer performs the following functions:
    
    <list style="symbols">
        <t>Path Management: The layer is aware of alternate paths to the peer, which may, for example, be the peer's multiple interfaces to send differently marked packets along separate paths.
        <!-- detects the host's multiple interfaces and advertises them as they appear and disappear.--> MPRTP also selects interfaces to send and receive data. Furthermore, it manages the port and IP address pair bindings for each interface.
        </t>
        <t>Packet Scheduling: the layer splits a single RTP flow into multiple subflows and sends them across multiple interfaces (paths). The splitting MAY BE done using different path characteristics.</t>
        <t>Subflow recombination: the layer creates the original stream by recombining the independent subflows. Therefore, the multipath subflows appear as a single RTP stream to applications.</t>
    </list>
    </t>


        <section title="Relationship of MPRTP and Session Signaling">
        <t>
        Session signaling (e.g., SIP<xref target="RFC3261" />, <xref target="I-D.ietf-mmusic-rfc2326bis">RTSP</xref>) SHOULD be done over failover-capable or multipath-capable transport for e.g., <xref target="RFC4960">SCTP</xref> or <xref target="I-D.ietf-mptcp-architecture">MPTCP</xref> instead of TCP or UDP.
        </t>    
        </section>
    </section>
    <!-- NOTE: find the drawback/pain of using ICE!! -->

<section title="Example Media Flow Diagrams">
    <t>There may be many complex technical scenarios for MPRTP, however, this memo only considers the following two scenarios: 1) an unidirectional media flow that represents the streaming use case, and 2) a bidirectional media flow that represents a conversational use case.</t>

    <section title="Streaming Use Case">
    <t>In the unidirectional scenario, the receiver (client) initiates a multimedia session with the sender (server). The receiver or the sender may have multiple interfaces and both the endpoints are  MPRTP-capable. <xref target="fig-mp-rtp-unidir" /> shows this scenario. In this case, host A has multiple interfaces. Host B performs connectivity checks on host A's multiple interfaces. If the interfaces are reachable, then host B streams multimedia data along multiple paths to host A. Furthermore, host B splits the multimedia stream into two subflows based on the individually measured path characteristics.</t>
    
    <t>Alternatively, to reduce media startup time, host B may start streaming multimedia data to host A's initiating interface and then perform connectivity checks for the other interfaces. This method of updating a single path session to a multipath session is called "multipath session upgrade".
    </t>
    
    <figure anchor="fig-mp-rtp-unidir" title="Unidirectional media flow">
<artwork><![CDATA[
        Host A                           Host B
-----------------------                ----------
Address A1   Address A2                Address B1 
-----------------------                ----------
    |            Session Setup             |
    |------------------------------------->|  connection for the
    |<-------------------------------------|  peers may be "preloaded"
    |            |                         |  (e.g., with ICE)
    |            |                         |
    |       (RTP data B1->A1, B1->A2)      |
    |<=====================================|
    |            |<========================|
    |            |                         |    
    Note: there maybe more scenarios.
    ]]></artwork>
    </figure> 
    </section>

<!--    or
    
  Host A                                      Host B
----------                           -----------------------
Address A1                           Address B1   Address B2
----------                           -----------------------
    |                                    |            |
    |    (initial connection setup)      |            |
    |  (A only advertises interfaces A1) |            |
    |-----------------------------------&gt;|            |
    |  (B advertises interfaces B1, B2)  |            |
    |<-----------------------------------|            |
    |                                    |            |
    |     (RTP data B1->A1, B2->A1)      |            |
    |<===================================|            |
    |<================================================|
    
    
    or 
    
    Host A                               Host B
-----------------------              -----------------------
Address A1   Address A2              Address B1   Address B2
-----------------------              -----------------------
    |            |                       |            |
    |    (initial connection setup)      |            |
    |  (A advertises interfaces A1, A2)  |            |
    |-----------------------------------&gt;|            |
    |  (B advertises interfaces B1, B2)  |            |
    |<-----------------------------------|            |
    |            |                       |            |
    |     (RTP data B1->A1, B2->A2)      |            |
    |<===================================|            |
    |            |<===================================|
-->
    <section title="Conversational Use Case">
    <t>In the bidirectional scenario, multimedia data flows in both directions. The two hosts exchange their lists of interfaces with each other and perform connectivity checks. Communication begins after each host finds suitable address, port pairs. All interfaces that receive data send back RTCP receiver statistics for each path. The peers balance their own multimedia stream over multiple links based on the reception statistics from its peer and its own volume of traffic. <xref target="fig-mp-rtp-bidir" /> describes an example of a bidirectional flow.</t>
    
     <figure anchor="fig-mp-rtp-bidir" title="Bidirectional flow">
<artwork><![CDATA[
        Host A                               Host B
-----------------------              -----------------------
Address A1   Address A2              Address B1   Address B2
-----------------------              -----------------------
    |            |                       |            | 
    |            Session Setup           |            | connection for
    |----------------------------------->|            | the peers may
    |<-----------------------------------|            | be "preloaded"
    |            |                       |            | (e.g., with ICE)
    |            |                       |            |    
    |    (RTP data B1<->A1, B2<->A2)     |            |
    |<===================================|            |
    |            |<===================================|
    |===================================>|            |
    |            |===================================>|
    |            |                       |            |  
    Note: the address pairs may have other permutations,
    and they maybe symmetric or asymmetric combinations.
    ]]></artwork>
    </figure> 
    </section>
    
    <section title="Challenges with Multipath Interface Discovery">
    <t>For some applications, where the user expects immediate playback, e.g., High Definition Media Streaming or IPTV, it may not be possible to perform connectivity checks within the given time bound. In these cases, connectivity checks MAY need to be done ahead of time.</t>
    <t>[Editor: ICE or any other system would need to aware of the peer's interfaces ahead of time].</t>
    </section>

</section>


<section title="MPRTP Functional Blocks">
 <t>This section describes some of the functional blocks needed for MPRTP. We then investigate each block and consider available mechanisms in the next section.
    <list style="numbers">
        <t>Session Setup: Multipath session setup is an upgrade or add-on to a typical RTP session. Interfaces may appear or disappear at anytime during the session. To preserve backward compatibility with legacy applications, a multipath session MUST look like a bundle of individual RTP sessions.</t>
        
        <t>Expanding RTP: For a multipath session, each subflow MUST look like an independent RTP flow, so that individual RTCPs can be generated per subflow. Furthermore, MPRTP  splits the single multimedia stream into multiple subflows based on path characteristics and dynamically adjusts the load on each link.</t>
        
        <t>Adding Interfaces: Interfaces on the host need to be regularly discovered and signaled. This can be done at the session setup and/or during the session. When discovering and receiving new interfaces, the MPRTP layer needs to select address and port pairs.</t>
        
        <t>Expanding RTCP: MPRTP MUST recombine RTCP reports from each path to re-create a single RTCP message to maintain backward compatibility with legacy applications.</t>
        
        <t>Maintenance and Failure Handling: In a multi-homed endpoint interfaces may appear and disappear. If this happens at the sender, it has to re-adjust the load on the available links. On the other hand, if this occurs on the receiver, then the multimedia data transmitted by the sender to those interfaces is lost. This data may be re-transmitted along a different path i.e., to a different interface on the receiver. Furthermore, the receiver has to explicitly signal the disappearance of an interface, or the sender has to detect it.
        
        What happens if the interface that setup the session disappears? does the control channel also failover? re-start the session?</t>
        
        <t>Teardown: The MPRTP layer releases the occupied ports on the interfaces.</t>
    </list>
 </t>   
</section>


<section title="Available Mechanisms Within the Functional Blocks">
<t>This section discusses some of the possible alternatives for each functional block mentioned in the previous section.</t>
    <section title="Session Setup">
        <t>MPRTP session can be set up in many possible ways e.g., during handshake, or upgraded mid-session. The capability exchange may be done using out-of-band signaling (e.g., SDP<xref target="RFC3264" /> in SIP<xref target="RFC3261" />, <xref target="I-D.ietf-mmusic-rfc2326bis">RTSP</xref>) or in-band signaling (e.g., RTP/RTCP header extension).

        Furthermore, ICE <xref target="RFC5245" /> may be used for discovering and performing connectivity checks during session setup.</t>
    </section>

    <section title="Expanding RTP">
        <t>RTCP <xref target="RFC3550" /> is generated per media session. However, with MPRTP, the media sender spreads the RTP load across several interfaces. The media sender SHOULD make the path selection, load balancing and fault tolerance decisions based on the characteristics of each path. Therefore, apart from normal RTP sequence numbers defined in <xref target="RFC3550" / >, the MPRTP sender SHOULD add subflow-specific sequence numbers and RTP timestamps to help calculate fractional losses, jitter, RTT, playout time, etc., for each path. An example RTP header extension for MPRTP is shown in <xref target="sec-mp-rtp-pkt-format" />). </t>
        
    </section>

    <section title="Adding New Interfaces">
        <t> When interfaces appear and disappear mid-session, ICE <xref target="RFC5245" /> may be used for discovering interfaces and performing connectivity checks. However, MPRTP may require a capability re-negotiation (using SDP) to include all these new interfaces. This method is referred to as out-of-band multipath advertisement.</t>
        
        <t>Alternatively, when new interfaces appear the interface advertisements may be done in-band using RTP/RTCP extensions. The peers perform connectivity checks (see <xref target="fig-mp-rtp-new-subflow" /> for more details). If the connectivity packets are received by the peers, then multimedia data can flow between the new address, port pairs.</t>
        
    </section>

    <section title="Expanding RTCP">
        <t> Multiple subflows in MPRTP affect RTCP bandwidth and RTCP reporting interval calculations. RTCP report scheduling for each subflow may cause a problem for RTCP recombined and reconstruction in cases when 1) RTCP for a subflow is lost, and 2) RTCP for a subflow arrives slower than other subflows. (There maybe other cases as well.)</t>
        <t>The subflow RTCP RR reports at the sender help balance the load along each path. However, this document doesn't cover algorithms for congestion control or load balancing.</t>
    </section>

    <section title="Checking and Failure Handling">
        <t>[Editor:If the original interface that setup the session disappears then does the session signaling failover to another interface? Can we recommend that SIP/RTSP be run over MPTCP, SCTP].</t>
    </section>

<!--    <section title="Teardown">
        <t></t>
    </section> -->
</section>
    
    <section title="MPRTP Protocol" anchor="sec-mp-rtp-proto">
      <t>To provide a more concrete basis for discussion, in this section we illustrate a solution. To enable a quick start to a multimedia session, we presume that a multipath session SHOULD be upgraded from a single path session. Therefore, no explicit changes are needed in multimedia session setup and the session can be setup as before.</t>

<!--      <section title="Connection Initiation"> 
        <t>The multipath discovery and transmission begins after establishing a single path RTP session.</t>
      </section> -->

      <section title="MPRTP Session Establishment" anchor="sec-mp-rtp-proto-new-subflow">
      <!--due to changes in connections. new interfaces can appear, old ones can disappear.-->
        <t>
        Initially, the session is set up as a standard single path multimedia session. The bullet points below explain the different steps shown in <xref target="fig-mp-rtp-new-subflow" />.
        <list style="empty">
            <t>(1) The first two interactions between the hosts describes the standard session setup. This may be SIP or RTSP.</t>
            
            <t>(2) Following the setup, like in a conventional RTP scenario, host B using interface B1 starts to stream data to host A at interface A1.</t>
            
            <t>(3) Host B is an MPRTP-capable media sender and becomes aware of another interface B2.</t>
            
            <t>(4) Host B advertises the multiple interface addresses using an RTP header extensions.</t>        
            
            <t>(5) Host A is an MPRTP-capable media receiver and becomes aware of another interface A2. It advertises the multiple interface addresses using an RTCP RR extension. </t>
            
            <t>Side note, if the MPRTP-capable hosts have no additional interfaces, then the hosts SHOULD still advertise a single interface.</t>
            
            <t>(6) Each hosts receives information about the additional interfaces and perform connectivity tests (not shown in figure) and if the paths are reachable then the hosts start to stream the multimedia content using the additional paths.</t>
        </list>
        </t>
        <figure anchor="fig-mp-rtp-new-subflow" title="MPRTP New Interface">
<artwork><![CDATA[
        Host A                                   Host B
-----------------------                  -----------------------
Address A1   Address A2                  Address B1   Address B2
-----------------------                  -----------------------
    |            |                           |             |
    |            |      (1)                  |             |
    |--------------------------------------->|             |
    |<---------------------------------------|             |
    |            |      (2)                  |             |
    |<=======================================|             |
    |<=======================================|     (3)     |
    |            |      (4)                  |             |
    |<=======================================|             |
    |<=======================================|             |
    |<=======================================|             |
    |            |      (5)                  |             |
    |- - - - - - - - - - - - - - - - - - - ->|             |
    |<=======================================|     (6)     |
    |<=======================================|             |
    |            |<========================================|
    |<=======================================|             |
    |            |<========================================|

Key:
|  Interface
---> Signaling Protocol
<=== RTP Packets
- -> RTCP Packet
]]></artwork>
</figure>
        <section title="Subflow or Interface Advertisement" anchor="sec-mp-rtp-proto-subflow-advert">
          <t>MPRTP-capable media senders SHOULD use the RTP header extension defined in <xref target="fig-mp-rtp-header-ia" />  to advertise their interfaces. Each unique address is encapsulated in a Interface Advertisement block and contains the IP address, RTP port, and RTCP port addresses. The Interface Advertisement blocks are ordered based on decreasing priority level. 
          </t>
    
        <t>
        On receiving the MPRTP Interface Advertisement, the receiver will either ignore the RTP header extension if it is not MPRTP capable or MUST respond with its own set of interfaces in decreasing order of priority. If the sender and receiver are MPRTP-capable but have only one interface, then they MUST respond with the default interface address, RTP and RTCP port addresses. If the sender receives an RTCP report without the MPRTP RTCP block after advertising its interfaces, then the sender MUST presume that the receiver is not MPRTP capable. <xref target="fig-mp-rtcp-header-ia" /> illustrates an RTCP format for MPRTP Interface Advertisement.
        </t>

        </section>

        <section title="Path selection" anchor="sec-mp-rtp-proto-addr-select" >
            <t>After MPRTP support has been discovered and interface advertisements have been exchanged, the sender MUST initiate connectivity checks to determine which interface pairs offer valid paths between the sender and the receiver. To initiate a connectivity check, the sender sends an RTP packet with MPRTP extension header with MPR_Type = 0x02 and no RTP payload. The receiver replies with an MPRTP RTCP packet with type MPRR_Type = 0x02. After the sender receives the reply, the path is considered a valid candidate for subflow establishment.
            </t>
			
			<t>The sender MAY choose to do any number of connectivity checks for any interface pairs at any point in a session.</t>			
        </section>

        <section title="Opening subflows" anchor="sec-mp-rtp-proto-subflow-desc" >
	<!-- Editor: Each combination of sender/receiver port pair is a unique subflow  -->
		<t>The sender may open any number of subflows after performing connectivity checks. MPRTP MUST associate a Flow ID to each subflow. To open a new subflow, the sender simply starts sending the RTP packets with an MPRTP extension shown in <xref target="fig-mp-rtp-header-subflow" />. The MPRTP extension carries a mapping of a subflow packet to the aggregate flow. Namely, sequence numbers and timestamps associated to the subflow.</t>
        </section>
      </section>

      <section title="Packet Transmission" anchor="sec-mp-rtp-pkt-trans">
        <t> The MPRTP layer SHOULD associate an RTP packet to a subflow based on a scheduling strategy. The scheduling strategy may either choose to augment the paths to create higher throughput or use the alternate paths for enhancing resilience or error-repair. Due to the changing path characteristics, an MPRTP sender might change its scheduling strategy during an ongoing session. The MPRTP sender MUST also populate the flow specific fields described in the MPRTP extension header (see <xref target="sec-mp-rtp-pkt-format-rtp" />).
		</t>
      </section>

      <section title="Playout Considerations at the Receiver" anchor="sec-mp-rtp-playout">
        <t>A media receiver, irrespective of MPRTP support or not, should be able to playback the media stream because the received RTP packets are compliant to <xref target="RFC3550" />, i.e., a non-MPRTP receiver will ignore the MPRTP header and still be able to playback the RTP packets. However, the variation of jitter and loss per path may affect proper playout. The receiver can compensate for the jitter by modifying the playout delay (adaptive playout) of the received RTP packets.</t>
      </section>

      <section title="Flow specific RTCP Statistics and RTCP Aggregation" anchor="sec-mp-rtp-rtcp-agg">
		<t>The aggregate RTCP report may not provide sufficient per path information to an MPRTP scheduler. Specifically, the scheduler should be aware of each path's RTT, which an aggregate RTCP cannot provide.</t>
		<!-- 			A simple MPRTP scheduler makes its decisions based on the per path jitter, loss and RTT and the aggregate RTCP Receiver Report. -->
        <t>[Editor: 1) Should the RTCP RRs sent per path carry a) the aggregate and the path's RR or b) the aggregate and RR of each path. </t>
	    <t>2) Should the per path RTCP Interval be dependent on the overall session bitrate or per path interval receiver rate?]</t>
      </section>
      
      <section title="Packet Format" anchor="sec-mp-rtp-pkt-format">
      <t>In this sub-section we define the protocol structures described in the previous sections.</t>
        <section title="MPRTP RTP Header Extension" anchor="sec-mp-rtp-pkt-format-rtp">
        <t>The MPRTP header extension is used 1) to pack single stream RTP data into multiple subflows, 2) to advertise the multiple interface addresses for a media sender, and 3) perform connectivity check on the new interfaces.</t>

<t>MPRTP RTP header extension for a subflow:</t>
		
<figure anchor="fig-mp-rtp-header-subflow" title="MPRTP header for subflow">
<artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  RTP H-Ext ID |     length    |         MPR_Type=0x00         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            flow ID            | flow specific sequence number |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                         RTP payload                           |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure>
        <t>
        <list style="empty">
         <t>RTP H-Ext ID and length: 8-bits each
            <list style="empty">
            <t>It conforms to the 2-byte RTP header extension defined in <xref target="RFC5285" />.</t> 
            <t>RTP H-Ext=TBD</t>
            <t>The 8-bit length field is the length of extension data in bytes not including the RTP H-Ext ID and length fields. The value zero indicates there is no data following.</t></list>
        </t>
        <t>MPR_Type: 16-bits
            <list style="empty">
            <t>The MPR_Type field corresponds to the type of RTP packet. Namely:
                <list style="empty">
                <t>0x00: Subflow RTP Header</t>
                <t>0x01: Interface Advertisement</t>
                <t>0x02: Connectivity Check</t>
                </list>
            </t>
            </list>
        </t>
		<t>Flow ID: Identifier of the subflow. Every RTP packet belonging to the same subflow carries the same unique flow identifier.</t>
		
		<t>Flow specific Sequence No.: Sequence of the packet in the subflow. Each subflow has its own strictly monotonically increasing sequence number space.</t>
		<!--This corresponds to the sequence number of the packet in the associated subflow. -->
		</list>
		</t>
      
<t>MPRTP RTP header extension for Interface Advertisements:</t>

<figure anchor="fig-mp-rtp-header-ia" title="Media Sender's Interface Advertisement (RTP header extension)">
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  RTP H-Ext ID |     length    |         MPR_Type=0x01         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Interface #1 Advertisement block               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Interface #2 Advertisement block               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Interface #... Advertisement block              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Interface #n Advertisement block               |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                         RTP Payload                           |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure> 
        <t>
            <list style="empty">
             <!--   <t>RTP H-Ext ID and length: 8-bits each
                    <list style="empty">
                    <t>It conforms to the 2-byte RTP header extension defined in <xref target="RFC5285" />.</t> 
                    <t>RTP H-Ext=TBD</t>
                    <t>The 8-bit length field is the length of extension data in bytes not including the RTP H-Ext ID and length fields. The value zero indicates there is no data following.</t></list>
                </t>
                <t>MPR_Type: 16-bits
                    <list style="empty">
                    <t>The MPR_Type field corresponds to the type of RTP packet. Namely:
                        <list style="empty">
                        <t>0x00: Subflow RTP Header</t>
                        <t>0x01: Interface Advertisement</t>
                        <t>0x02: Connectivity Check</t>
                        </list>
                    </t>
                    </list>
                </t> -->
                <t>Interface Advertisement block: variable size
                    <list style="empty">
                    <t>Defined later in the section.</t></list>
                </t>                
            </list>            
        </t>
        </section>
    <section title="Interface Address Advertisement block" anchor="sec-mp-rtp-pkt-format-ia">
    <t>This block describes a method to represent IPv4, IPv6 and generic DNS-type addresses in a block format. It is based on the sub-reporting block in RFC 5760 <xref target="RFC5760" />.</t>

<figure anchor="fig-mp-rtp-address-header" title="Interface Address Advertisement block during path discovery">
<artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type={0,1,2}  |     Length    |           RTP Port            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           RTCP Port           |            Address            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
:                                                               :
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
</figure> 
<t><list style="empty">
    <t>Type: 8 bits
      <list style="empty"><t>The Type corresponds to the type of address. Namely:
       <list>
          <t>0: IPv4 address</t>
          <t>1: IPv6 address</t>
          <t>2: DNS name</t>
          </list>
      </t></list>
   </t>
   <t>Length: 8 bits
      <list style="empty"><t>The length of the Interface Advertisement block in bytes.  
       <list>
          <t>For an IPv4 address, this should be 9 (i.e., 5 octets for the header and 4 octets for IPv4 address).</t>
          <t>For an IPv6 address, this should be 21.</t>
          <t>For a DNS name, the length field indicates the number of octets making up the string plus the 5 byte header.</t>
       </list>
      </t></list>
   </t>

   <t>RTP Port: 2 octets
      <list style="empty"><t>The port number to which the sender sends RTP data.  A port number of 0 is invalid and MUST NOT be used.</t></list>
   </t>
   <t>RTCP Port: 2 octets
      <list style="empty"><t>The port number to which receivers send feedback reports.  A port number of 0 is invalid and MUST NOT be used. </t></list>
   </t>
   
   <t>Address: 4 octets (IPv4), 16 octets (IPv6), or n octets (DNS name)
      <list style="empty"><t>The address to which receivers send feedback reports.  For IPv4 and IPv6, fixed-length address fields are used.  A DNS name is an arbitrary-length string.  The string MAY contain Internationalizing Domain Names in Applications (IDNA) domain names and MUST be UTF-8 encoded <xref target="RFC3629"></xref>.</t></list>
   </t>
</list></t>
</section>
<section title="MPRTP RTCP Header Extension" anchor="sec-mp-rtp-pkt-format-rtcp">
        <t> The MPRTP RTCP header extension is used 1) to provide RTCP feedback per subflow to gauge the characteristics of each path, 2) to advertise the multiple interface addresses for a media receiver, and 3) perform connectivity check on the new interfaces.</t>

<t>MPRTP RTCP header extension for flow specific SR/RR:   TBD</t>   
<t>MPRTP RTCP header extension for Interface advertisement:</t>                

<figure anchor="fig-mp-rtcp-header-ia" title="Media Receiver's Interface Advertisement. (RTCP header Extension)"> <artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
|V=2|P|    RC   | PT=MP_RR=2xx  |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     SSRC of packet sender                     |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 SSRC_1 (SSRC of first source)                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           MPRR_Type           |     length    |      RESV     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Interface #1 Advertisement block               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Interface #2 Advertisement block               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Interface #... Advertisement block              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Interface #m Advertisement block               |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
]]></artwork>
</figure> 
<t>
            <list style="empty">
                <t>MP_RR: 8 bits
                    <list style="empty">
                    <t>Indicates that it is a RTCP Receiver Report extension for MPRTP.</t></list>
                </t>
                <t>MPRR_Type: 16-bits
                    <list style="empty">
                    <t>The MPRR_Type field corresponds to the type of MPRTP RTCP packet. Namely:
                        <list style="empty">
                        <t>0x00: Subflow RTCP Statistics Aggregation</t>
                        <t>0x01: Interface Advertisement</t>
                        <t>0x02: Connectivity Check</t>
                        </list>
                    </t>
                    </list>
                </t>
                <t>length: 8-bits
                    <list style="empty">
                    <t>The 8-bit length field is the length of extension data in bytes not including the MPRR_Type and length fields.  The value zero indicates there is no data following.
                    </t>
                    </list>
                </t>
                <t>Interface Advertisement block: variable size
                    <list style="empty">
                    <t>Already defined in <xref target="sec-mp-rtp-pkt-format-ia" />.</t></list>
                </t>                
            </list>            
        </t>
        
        </section>
      
      </section>

    </section>
    
	<section anchor="sec-mp-rtp-sdp" title="SDP Considerations">
      <t>
		The packet formats specified in this document define extensions for RTP and RTCP. The use of MPRTP is left to the discretion of the sender and receiver.  <!--However, its presence may enable better operation or increased throughput.--></t>

<!-- The MPRTP MAY be used without prior signaling.  This is consistent with the rules governing other RTCP packet types, as described in  <xref target="RFC3550" />. -->
	   	<t>A participant of a media session MAY use SDP to signal that it supports MPRTP. Not providing this information may/will make the sender or receiver ignore the header extensions. However, MPRTP MAY be used by either sender or receiver without prior signaling.</t>
		<figure>
		 <artwork><![CDATA[

    mprtp-attrib = "a=" "mprtp" [":" 
            mprtp-optional-parameter] 
            CRLF   ; flag to enable MPRTP 
		]]></artwork>
		</figure>

		<t>The literal 'mprtp' MUST be used to indicate support for MPRTP. Generally, senders and receivers SHOULD indicate this capability if they support MPRTP and would like to use it in the specific media session being signaled. However, it is possible for an MPRTP sender to stream data using multiple paths to a non-MPRTP client.</t>
		<t>Currently, there are no extensions defined for the literal 'mprtp' but we provide the opportunity to extend it using the mprtp-optional-parameter.</t>
		
    <section anchor="sdp-inc-througput" title="Increased Throughput">
	<t>The MPRTP layer MAY choose to augment paths to increase throughput. If the desired media rate exceeds the current media rate, the peers MUST renegotiate the application specific ("b=AS:") <xref target="RFC4566" /> bandwidth.</t>
	</section>
    </section>
    
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
    Varun Singh, Saba Ahsan, and Teemu Karkkainen are supported by Trilogy
    (http://www.trilogy-project.org), a research project (ICT-216372)
    partially funded by the European Community under its Seventh
    Framework Program.  The views expressed here are those of the
    author(s) only.  The European Commission is not liable for any use
    that may be made of the information in this document.
      </t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <!--<section anchor="Contributors" title="Contributors"> <t>...</t> </section>
-->

    <section anchor="IANA" title="IANA Considerations">
<!--      <t>This document defines a new SDP attribute, "mprtp", within the existing IANA registry of SDP Parameters.</t> -->
 	  <t>TBD.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>All drafts are required to have a security considerations section. See <xref target="RFC3552">RFC 3552</xref> for a guide.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &rfc2119;
      &rfc3629;
      &rfc5760;
      &rfc5245;
      &rfc5285;
      &rfc3550;

    </references>

    <references title="Informative References">
      &rfc3552;
<!--      &rfc3611;
      &rfc4585;-->
	  &rfc4566;
      &rfc4960;
		&rfc5533;
      &rfc5117;
      
      &rfc3261;      
      &rfc3264;
      &I-D.ietf-mptcp-architecture;
      &I-D.ietf-mmusic-rfc2326bis;
      
      
    </references>

<!--    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>
-->

    <!-- Change Log
v00 2010-02-18  Varun   Initial version, 9 sections -->
  </back>
</rfc>
