<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict='yes'?>
<?rfc iprnotified='no'?>
<rfc category="std" docName="draft-templin-intarea-seal-38.txt"
     ipr="trust200902">
  <front>
    <title abbrev="SEAL">The Subnetwork Encapsulation and Adaptation Layer
    (SEAL)</title>

    <author fullname="Fred L. Templin" initials="F. L." role="editor"
            surname="Templin">
      <organization>Boeing Research &amp; Technology</organization>

      <address>
        <postal>
          <street>P.O. Box 3707</street>

          <city>Seattle</city>

          <region>WA</region>

          <code>98124</code>

          <country>USA</country>
        </postal>

        <email>fltemplin@acm.org</email>
      </address>
    </author>

    <date day="17" month="November" year="2011" />

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>For the purpose of this document, a subnetwork is defined as a
      virtual topology configured over a connected IP network routing region
      and bounded by encapsulating border nodes. These virtual topologies are
      manifested by tunnels that may span multiple IP and/or sub-IP layer
      forwarding hops, and can introduce failure modes due to packet
      duplication and/or links with diverse Maximum Transmission Units (MTUs).
      This document specifies a Subnetwork Encapsulation and Adaptation Layer
      (SEAL) that accommodates such virtual topologies over diverse underlying
      link technologies.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>As Internet technology and communication has grown and matured, many
      techniques have developed that use virtual topologies (including tunnels
      of one form or another) over an actual network that supports the
      Internet Protocol (IP) <xref target="RFC0791"></xref><xref
      target="RFC2460"></xref>. Those virtual topologies have elements that
      appear as one hop in the virtual topology, but are actually multiple IP
      or sub-IP layer hops. These multiple hops often have quite diverse
      properties that are often not even visible to the endpoints of the
      virtual hop. This introduces failure modes that are not dealt with well
      in current approaches.</t>

      <t>The use of IP encapsulation (also known as "tunneling") has long been
      considered as the means for creating such virtual topologies. However,
      the insertion of an outer IP header reduces the effective path MTU
      visible to the inner network layer. When IPv4 is used, this reduced MTU
      can be accommodated through the use of IPv4 fragmentation, but</t>

      <t>unmitigated in-the-network fragmentation has been found to be harmful
      through operational experience and studies conducted over the course of
      many years <xref target="FRAG"></xref><xref target="FOLK"></xref><xref
      target="RFC4963"></xref>. Additionally, classical path MTU discovery
      <xref target="RFC1191"></xref> has known operational issues that are
      exacerbated by in-the-network tunnels <xref
      target="RFC2923"></xref><xref target="RFC4459"></xref>. The following
      subsections present further details on the motivation and approach for
      addressing these issues.</t>

      <section title="Motivation">
        <t>Before discussing the approach, it is necessary to first understand
        the problems. In both the Internet and private-use networks today,
        IPv4 is ubiquitously deployed as the Layer 3 protocol. The primary
        functions of IPv4 are to provide for routing, addressing, and a
        fragmentation and reassembly capability used to accommodate links with
        diverse MTUs. While it is well known that the IPv4 address space is
        rapidly becoming depleted, there is a lesser-known but growing
        consensus that other IPv4 protocol limitations have already or may
        soon become problematic.</t>

        <t>First, the IPv4 header Identification field is only 16 bits in
        length, meaning that at most 2^16 unique packets with the same
        (source, destination, protocol)-tuple may be active in the Internet at
        a given time <xref target="I-D.ietf-intarea-ipv4-id-update"></xref>.
        Due to the escalating deployment of high-speed links, however, this
        number has become too small by several orders of magnitude for high
        data rate packet sources such as tunnel endpoints <xref
        target="RFC4963"></xref>. Furthermore, there are many well-known
        limitations pertaining to IPv4 fragmentation and reassembly &ndash;
        even to the point that it has been deemed &ldquo;harmful&rdquo; in
        both classic and modern-day studies (see above). In particular, IPv4
        fragmentation raises issues ranging from minor annoyances (e.g.,
        in-the-network router fragmentation <xref target="RFC1981"></xref>) to
        the potential for major integrity issues (e.g., mis-association of the
        fragments of multiple IP packets during reassembly <xref
        target="RFC4963"></xref>).</t>

        <t>As a result of these perceived limitations, a
        fragmentation-avoiding technique for discovering the MTU of the
        forward path from a source to a destination node was devised through
        the deliberations of the Path MTU Discovery Working Group (PMTUDWG)
        during the late 1980&rsquo;s through early 1990&rsquo;s (see Appendix
        D). In this method, the source node provides explicit instructions to
        routers in the path to discard the packet and return an ICMP error
        message if an MTU restriction is encountered. However, this approach
        has several serious shortcomings that lead to an overall
        &ldquo;brittleness&rdquo; <xref target="RFC2923"></xref>.</t>

        <t>In particular, site border routers in the Internet have been known
        to discard ICMP error messages coming from the outside world. This is
        due in large part to the fact that malicious spoofing of error
        messages in the Internet is trivial since there is no way to
        authenticate the source of the messages <xref
        target="RFC5927"></xref>. Furthermore, when a source node that
        requires ICMP error message feedback when a packet is dropped due to
        an MTU restriction does not receive the messages, a path MTU-related
        black hole occurs. This means that the source will continue to send
        packets that are too large and never receive an indication from the
        network that they are being discarded. This behavior has been
        confirmed through documented studies showing clear evidence of path
        MTU discovery failures in the Internet today <xref
        target="TBIT"></xref><xref target="WAND"></xref><xref
        target="SIGCOMM"></xref>.</t>

        <t>The issues with both IPv4 fragmentation and this
        &ldquo;classical&rdquo; method of path MTU discovery are exacerbated
        further when IP tunneling is used <xref target="RFC4459"></xref>. For
        example, an ingress tunnel endpoint (ITE) may be required to forward
        encapsulated packets into the subnetwork on behalf of hundreds,
        thousands, or even more original sources within the end site that it
        serves. If the ITE allows IPv4 fragmentation on the encapsulated
        packets, persistent fragmentation could lead to undetected data
        corruption due to Identification field wrapping. If the ITE instead
        uses classical IPv4 path MTU discovery, it must rely on ICMP error
        messages coming from the subnetwork that may be suspect, subject to
        loss due to filtering middleboxes, or insufficiently provisioned for
        translation into error messages to be returned to the original
        sources.</t>

        <t>Although recent works have led to the development of a robust
        end-to-end MTU determination scheme <xref target="RFC4821"></xref>,
        they do not excuse tunnels from delivering path MTU discovery feedback
        when packets are lost due to size restrictions. Moreover, in current
        practice existing tunneling protocols mask the MTU issues by selecting
        a "lowest common denominator" MTU that may be much smaller than
        necessary for most paths and difficult to change at a later date.
        Therefore, a new approach to accommodate tunnels over links with
        diverse MTUs is necessary.</t>
      </section>

      <section title="Approach">
        <t>For the purpose of this document, a subnetwork is defined as a
        virtual topology configured over a connected network routing region
        and bounded by encapsulating border nodes. Example connected network
        routing regions include Mobile Ad hoc Networks (MANETs), enterprise
        networks and the global public Internet itself. Subnetwork border
        nodes forward unicast and multicast packets over the virtual topology
        across multiple IP and/or sub-IP layer forwarding hops that may
        introduce packet duplication and/or traverse links with diverse
        Maximum Transmission Units (MTUs).</t>

        <t>This document introduces a Subnetwork Encapsulation and Adaptation
        Layer (SEAL) for tunneling network layer protocols (e.g., IPv4, IPv6,
        OSI, etc.) over IP subnetworks that connect Ingress and Egress Tunnel
        Endpoints (ITEs/ETEs) of border nodes. It provides a modular
        specification designed to be tailored to specific associated tunneling
        protocols. A transport-mode of operation is also possible, and
        described in Appendix C.</t>

        <t>SEAL provides a mid-layer encapsulation that accommodates links
        with diverse MTUs and allows routers in the subnetwork to perform
        efficient duplicate packet detection. The encapsulation further
        ensures data origin authentication, packet header integrity and
        anti-replay.</t>

        <t>SEAL treats tunnels that traverse the subnetwork as ordinary links
        that must support network layer services. Moreover, SEAL provides
        dynamic mechanisms to ensure a maximal path MTU over the tunnel. This
        is in contrast to static approaches which avoid MTU issues by
        selecting a lowest common denominator MTU value that may be overly
        conservative for the vast majority of tunnel paths and difficult to
        change even when larger MTUs become available.</t>

        <t>The following sections provide the SEAL normative specifications,
        while the appendices present non-normative additional
        considerations.</t>
      </section>
    </section>

    <section title="Terminology and Requirements">
      <t>The following terms are defined within the scope of this
      document:</t>

      <t><list style="hanging">
          <t hangText="subnetwork"><vspace />a virtual topology configured
          over a connected network routing region and bounded by encapsulating
          border nodes.</t>

          <t hangText="Ingress Tunnel Endpoint (ITE)"><vspace />a virtual
          interface over which an encapsulating border node (host or router)
          sends encapsulated packets into the subnetwork.</t>

          <t hangText="Egress Tunnel Endpoint (ETE)"><vspace />a virtual
          interface over which an encapsulating border node (host or router)
          receives encapsulated packets from the subnetwork.</t>

          <t hangText="ETE Link Path"><vspace />a subnetwork path from an ITE
          to an ETE beginning with an underlying link of the ITE as the first
          hop.</t>

          <t hangText="inner packet"><vspace />an unencapsulated network layer
          protocol packet (e.g., IPv6 <xref target="RFC2460"></xref>, IPv4
          <xref target="RFC0791"></xref>, OSI/CLNP <xref
          target="RFC1070"></xref>, etc.) before any outer encapsulations are
          added. Internet protocol numbers that identify inner packets are
          found in the IANA Internet Protocol registry <xref
          target="RFC3232"></xref>. SEAL protocol packets that incur an
          additional layer of SEAL encapsulation are also considered inner
          packets.</t>

          <t hangText="outer IP packet"><vspace />a packet resulting from
          adding an outer IP header (and possibly other outer headers) to a
          SEAL-encapsulated inner packet.</t>

          <t hangText="packet-in-error"><vspace />the leading portion of an
          invoking data packet encapsulated in the body of an error control
          message (e.g., an ICMPv4 <xref target="RFC0792"></xref> error
          message, an ICMPv6 <xref target="RFC4443"></xref> error message,
          etc.).</t>

          <t hangText="Packet Too Big (PTB)"><vspace />a control plane message
          indicating an MTU restriction (e.g., an ICMPv6 "Packet Too Big"
          message <xref target="RFC4443"></xref>, an ICMPv4 "Fragmentation
          Needed" message <xref target="RFC0792"></xref>, etc.).</t>

          <t hangText="IP"><vspace />used to generically refer to either
          Internet Protocol (IP) version, i.e., IPv4 or IPv6.</t>
        </list></t>

      <t>The following abbreviations correspond to terms used within this
      document and/or elsewhere in common Internetworking nomenclature:</t>

      <t><list>
          <t>DF - the IPv4 header "Don't Fragment" flag <xref
          target="RFC0791"></xref><vspace /></t>

          <t>ETE - Egress Tunnel Endpoint<vspace /></t>

          <t>HLEN - the length of the SEAL header plus outer
          headers<vspace /></t>

          <t>ICV - Integrity Check Vector<vspace /></t>

          <t>ITE - Ingress Tunnel Endpoint<vspace /></t>

          <t>MTU - Maximum Transmission Unit<vspace /></t>

          <t>SCMP - the SEAL Control Message Protocol<vspace /></t>

          <t>SDU - SCMP Destination Unreachable message<vspace /></t>

          <t>SNA - SCMP Neighbor Advertisement message<vspace /></t>

          <t>SNS - SCMP Neighbor Solicitation message<vspace /></t>

          <t>SPP - SCMP Parameter Problem message<vspace /></t>

          <t>SPTB - SCMP Packet Too Big message<vspace /></t>

          <t>SEAL - Subnetwork Encapsulation and Adaptation
          Layer<vspace /></t>

          <t>SEAL_PORT - a transport-layer service port number used for
          SEAL<vspace /></t>

          <t>SEAL_PROTO - an IP protocol number used for SEAL<vspace /></t>

          <t>TE - Tunnel Endpoint (i.e., either ingress or egress)
          <vspace /></t>

          <t>VET - Virtual Enterprise Traversal<vspace /></t>
        </list></t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>. When used in lower case (e.g., must, must not,
      etc.), these words MUST NOT be interpreted as described in <xref
      target="RFC2119"></xref>, but are rather interpreted as they would be in
      common English.</t>
    </section>

    <section title="Applicability Statement">
      <t>SEAL was originally motivated by the specific case of subnetwork
      abstraction for Mobile Ad hoc Networks (MANETs), however the domain of
      applicability also extends to subnetwork abstractions over enterprise
      networks, ISP networks, SOHO networks, the global public Internet
      itself, and any other connected network routing region. SEAL, along with
      the Virtual Enterprise Traversal (VET) <xref
      target="I-D.templin-intarea-vet"></xref> tunnel virtual interface
      abstraction, are the functional building blocks for the Internet Routing
      Overlay Network (IRON) <xref target="I-D.templin-ironbis"></xref> and
      Routing and Addressing in Networks with Global Enterprise Recursion
      (RANGER) <xref target="RFC5720"></xref><xref target="RFC6139"></xref>
      architectures.</t>

      <t>SEAL provides a network sublayer for encapsulation of an inner
      network layer packet within outer encapsulating headers. SEAL can also
      be used as a sublayer within a transport layer protocol data payload,
      where transport layer encapsulation is typically used for Network
      Address Translator (NAT) traversal as well as operation over subnetworks
      that give preferential treatment to certain "core" Internet protocols
      (e.g., TCP, UDP, etc.). The SEAL header is processed the same as for
      IPv6 extension headers, i.e., it is not part of the outer IP header but
      rather allows for the creation of an arbitrarily extensible chain of
      headers in the same way that IPv6 does.</t>

      <t>To accommodate MTU diversity, the Egress Tunnel Endpoint (ETE) acts
      as a passive observer that simply informs the Ingress Tunnel Endpoint
      (ITE) of any packet size limitations. This allows the ITE to return
      appropriate path MTU discovery feedback even if the network path between
      the ITE and ETE filters ICMP messages.</t>

      <t>SEAL further ensures data origin authentication, packet header
      integrity, and anti-replay. The SEAL framework is therefore similar to
      the IP Security (IPsec) Authentication Header (AH) <xref
      target="RFC4301"></xref><xref target="RFC4302"></xref>, however it
      provides only minimal hop-by-hop authenticating services along a path
      while leaving full data integrity, authentication and confidentiality
      services as an end-to-end consideration. While SEAL performs data origin
      authentication, the origin site must also perform the necessary ingress
      filtering in order to provide full source address verification <xref
      target="I-D.ietf-savi-framework"></xref>.</t>
    </section>

    <section title="SEAL Specification">
      <t>The following sections specify the operation of SEAL:</t>

      <section title="VET Interface Model">
        <t>SEAL is an encapsulation sublayer used within VET non-broadcast,
        multiple access (NBMA) tunnel virtual interfaces. Each VET interface
        is configured over one or more underlying interfaces attached to
        subnetwork links. The VET interface connects an ITE to one or more ETE
        "neighbors" via tunneling across an underlying subnetwork, where
        tunnel neighbor relationship may be either unidirectional or
        bidirectional.</t>

        <t>A unidirectional tunnel neighbor relationship allows the near end
        ITE to send data packets forward to the far end ETE, while the ETE
        only returns control messages when necessary. A bidirectional tunnel
        neighbor relationship is one over which both TEs can exchange both
        data and control messages.</t>

        <t>Implications of the VET unidirectional and bidirectional models are
        discussed in <xref target="I-D.templin-intarea-vet"></xref>.</t>
      </section>

      <section title="SEAL Model of Operation">
        <t>SEAL-enabled ITEs encapsulate each inner packet in a SEAL header,
        any outer header encapsulations, and in some instances a SEAL trailer
        as shown in <xref target="encaps1"></xref>:</t>

        <t><figure anchor="encaps1" title="SEAL Encapsulation">
            <artwork><![CDATA[                             +--------------------+
                             ~   outer IP header  ~
                             +--------------------+
                             ~  other outer hdrs  ~
                             +--------------------+
                             ~    SEAL Header     ~
+--------------------+       +--------------------+
|                    |  -->  |                    |
~        Inner       ~  -->  ~        Inner       ~
~       Packet       ~  -->  ~       Packet       ~
|                    |  -->  |                    |
+--------------------+       +--------------------+
                             |    SEAL Trailer    |
                             +--------------------+
]]></artwork>
          </figure></t>

        <t>The ITE inserts the SEAL header according to the specific tunneling
        protocol. For simple encapsulation of an inner network layer packet
        within an outer IP header (e.g., <xref target="RFC1070"></xref><xref
        target="RFC2003"></xref><xref target="RFC2473"></xref><xref
        target="RFC4213"></xref>, etc.), the ITE inserts the SEAL header
        between the inner packet and outer IP headers as: IP/SEAL/{inner
        packet}.</t>

        <t>For encapsulations over transports such as UDP, the ITE inserts the
        SEAL header between the outer transport layer header and the inner
        packet, e.g., as IP/UDP/SEAL/{inner packet} (similar to <xref
        target="RFC4380"></xref>). In that case, the UDP header is seen as an
        "other outer header" as depicted in <xref
        target="encaps1"></xref>.</t>

        <t>When necessary, the ITE also appends a SEAL trailer at the end of
        the SEAL packet. In that case, the trailer is added after the final
        byte of the encapsulated packet.</t>

        <t>SEAL supports both "nested" tunneling and "re-encapsulating"
        tunneling. Nested tunneling occurs when a first tunnel is encapsulated
        within a second tunnel, which may then further be encapsulated within
        additional tunnels. Nested tunneling can be useful, and stands in
        contrast to "recursive" tunneling which is an anomalous condition
        incurred due to misconfiguration or a routing loop. Considerations for
        nested tunneling are discussed in Section 4 of <xref
        target="RFC2473"></xref>.</t>

        <t>Re-encapsulating tunneling occurs when a packet arrives at a first
        ETE, which then acts as an ITE to re-encapsulate and forward the
        packet to a second ETE connected to the same subnetwork. In that case
        each ITE/ETE transition represents a segment of a bridged path between
        the ITE nearest the source and the ETE nearest the destination.
        Combinations of nested and re-encapsulating tunneling are also
        naturally supported by SEAL.</t>

        <t>The SEAL ITE considers each {underlying interface, IP address} pair
        as the ingress attachment point to a subnetwork link path to the ETE.
        The ITE therefore maintains path MTU state on a per ETE link path
        basis, although it may instead maintain only the
        lowest-common-denominator values for all of the ETE's link paths in
        order to reduce state.</t>

        <t>Finally, the SEAL ITE ensures that the inner network layer protocol
        will see a minimum MTU of 1280 bytes over each ETE link path
        regardless of the outer network layer protocol version, i.e., even if
        a small amount of fragmentation and reassembly are necessary.</t>
      </section>

      <section title="SEAL Header and Trailer Format">
        <t>The SEAL header is formatted as follows:</t>

        <t><figure anchor="minimal" title="SEAL Header Format ">
            <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |VER|C|P|R|T|U|Z|     NEXTHDR   |    PREFLEN    | LINK_ID |LEVEL|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             PKT_ID                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              ICV1                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                      PREFIX (when present)                    ~
   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
]]></artwork>
          </figure></t>

        <t><list style="hanging">
            <t hangText="VER (2)"><vspace />a 2-bit version field. This
            document specifies Version 0 of the SEAL protocol, i.e., the VER
            field encodes the value 0.</t>

            <t hangText="C (1)"><vspace />the "Control/Data" bit. Set to 1 by
            the ITE in SEAL Control Message Protocol (SCMP) control messages,
            and set to 0 in ordinary data packets.</t>

            <t hangText="P (1)"><vspace />the "Prefix Included" bit. Set to 1
            if the header includes a Prefix Field. Used for SCMP messages that
            do not include a packet-in-error (see: <xref
            target="I-D.templin-intarea-vet"></xref>), and for NULL SEAL data
            packets used as probes (see: Section 4.4.6).</t>

            <t hangText="R (1)"><vspace />the "Redirects Permitted" bit. For
            data packets, set to 1 by the ITE to inform the ETE that the
            source is accepting Redirects (see:<xref
            target="I-D.templin-intarea-vet"> </xref>).</t>

            <t hangText="T (1)"><vspace />the "Trailer Included" bit. Set to 1
            if the ITE was obliged to include a trailer.</t>

            <t hangText="U (1)"><vspace />the "Unfragmented Packet" bit. Set
            to 1 by the ITE in SEAL data packets for which it wishes to
            receive an explicit acknowledgement from the ETE if the packet
            arrives unfragmented.</t>

            <t hangText="Z (1)"><vspace />the "Reserved" bit. Must be set to 0
            for this version of the SEAL specification.</t>

            <t hangText="NEXTHDR (8)">an 8-bit field that encodes the next
            header Internet Protocol number the same as for the IPv4 protocol
            and IPv6 next header fields.</t>

            <t hangText="PREFLEN (8)">an 8-bit field that encodes the length
            of the prefix to be applied to the source address of the inner
            packets (when P==0) or the prefix included in the PREFIX field
            (when P==1).</t>

            <t hangText="LINK_ID (5)"><vspace />a 5-bit link identification
            value, set to a unique value by the ITE for each underlying link
            as the first hop of a path over which it will send encapsulated
            packets to ETEs. Up to 32 ETE link paths are therefore supported
            for each ETE.</t>

            <t hangText="LEVEL (3)"><vspace />a 3-bit nesting level; use to
            limit the number of tunnel nesting levels. Set to an integer value
            up to 7 in the innermost SEAL encapsulation, and decremented by 1
            for each successive additional SEAL encapsulation nesting level.
            Up to 8 levels of nesting are therefore supported.</t>

            <t hangText="PKT_ID (32)"><vspace />a 32-bit per-packet
            identification field. Set to a monotonically-incrementing 32-bit
            value for each SEAL packet transmitted to this ETE, beginning with
            0.</t>

            <t hangText="ICV1 (32)"><vspace />a 32-bit header integrity check
            value that covers the leading 128 bytes of the packet beginning
            with the SEAL header. The value 128 is chosen so that at least the
            SEAL header as well as the inner packet network and transport
            layer headers are covered by the integrity check.</t>

            <t hangText="PREFIX (variable)"><vspace />a variable-length string
            of bytes; present only when P==1. The field length is determined
            by calculating Len=(Ceiling(PREFLEN / 32) * 4). For example, if
            PREFLEN==63, the field is 8 bytes in length and encodes the
            leading 63 bits of the inner network layer prefix beginning with
            the most significant bit.</t>
          </list>When T==1, SEAL encapsulation also includes a trailer
        formatted as follows:</t>

        <t><figure anchor="min2" title="SEAL Trailer Format ">
            <artwork><![CDATA[     0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              ICV2                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure></t>

        <t><list style="hanging">
            <t hangText="ICV2 (32)"><vspace />a 32-bit packet integrity check
            value. Present only when T==1, and covers the remaining length of
            the encapsulated packet beyond the leading 128 bytes (i.e., the
            remaining portion that was not covered by ICV1). Added as a
            trailing 32 bit field following the final byte of the encapsulated
            SEAL packet and used to detect reassembly misassociations. Need
            not be aligned on an even byte boundary.</t>
          </list></t>
      </section>

      <section title="ITE Specification">
        <section title="Tunnel Interface MTU">
          <t>The tunnel interface must present a constant MTU value to the
          inner network layer as the size for admission of inner packets into
          the interface. Since VET NBMA tunnel virtual interfaces may support
          a large set of ETE link paths that accept widely varying maximum
          packet sizes, however, a number of factors should be taken into
          consideration when selecting a tunnel interface MTU.</t>

          <t>Due to the ubiquitous deployment of standard Ethernet and similar
          networking gear, the nominal Internet cell size has become 1500
          bytes; this is the de facto size that end systems have come to
          expect will either be delivered by the network without loss due to
          an MTU restriction on the path or a suitable ICMP Packet Too Big
          (PTB) message returned. When large packets sent by end systems incur
          additional encapsulation at an ITE, however, they may be dropped
          silently within the tunnel since the network may not always deliver
          the necessary PTBs <xref target="RFC2923"></xref>.</t>

          <t>The ITE should therefore set a tunnel interface MTU of at least
          1500 bytes plus extra room to accommodate any additional
          encapsulations that may occur on the path from the original source.
          The ITE can also set smaller MTU values; however, care must be taken
          not to set so small a value that original sources would experience
          an MTU underflow. In particular, IPv6 sources must see a minimum
          path MTU of 1280 bytes, and IPv4 sources should see a minimum path
          MTU of 576 bytes.</t>

          <t>The inner network layer protocol consults the tunnel interface
          MTU when admitting a packet into the interface. For non-SEAL inner
          IPv4 packets with the IPv4 Don't Fragment (DF) bit set to 0, if the
          packet is larger than the tunnel interface MTU the inner IPv4 layer
          uses IPv4 fragmentation to break the packet into fragments no larger
          than the tunnel interface MTU. The ITE then admits each fragment
          into the interface as an independent packet.</t>

          <t>For all other inner packets, the inner network layer admits the
          packet if it is no larger than the tunnel interface MTU; otherwise,
          it drops the packet and sends a PTB error message to the source with
          the MTU value set to the tunnel interface MTU. The message contains
          as much of the invoking packet as possible without the entire
          message exceeding the network layer minimum MTU (e.g., 1280 bytes
          for IPv6, 576 bytes for IPv4, etc.).</t>

          <t>The ITE can alternatively set an indefinite MTU on the tunnel
          interface such that all inner packets are admitted into the
          interface regardless of their size. For ITEs that host applications
          that use the tunnel interface directly, this option must be
          carefully coordinated with protocol stack upper layers since some
          upper layer protocols (e.g., TCP) derive their packet sizing
          parameters from the MTU of the outgoing interface and as such may
          select too large an initial size. This is not a problem for upper
          layers that use conservative initial maximum segment size estimates
          and/or when the tunnel interface can reduce the upper layer's
          maximum segment size, e.g., by reducing the size advertised in the
          MSS option of outgoing TCP messages (sometimes known as "MSS
          clamping").</t>

          <t>In light of the above considerations, the ITE SHOULD configure an
          indefinite MTU on tunnel *router* interfaces so that subnetwork
          adaptation is handled from within the interface. The ITE MAY instead
          set a finite MTU on tunnel *host* interfaces.</t>
        </section>

        <section title="Tunnel Neighbor Soft State">
          <t>Within the tunnel virtual interface, the ITE maintains a per
          tunnel neighbor (i.e., a per-ETE) integrity check vector (ICV)
          calculation algorithm and (when data origin authentication is
          required) a symmetric secret key to calculate the ICV(s) in packets
          it will send to this ETE. The ITE also maintains a window of PKT_ID
          values for the packets it has recently sent to this ETE.</t>

          <t>For each ETE link path, the ITE must account for the lengths of
          the headers to be used for encapsulation. The ITE therefore
          maintains the per ETE link path constant values "SHLEN" set to
          length of the SEAL header, "UHLEN" set to the length of the UDP
          encapsulating header (or 0 if UDP encapsulation is not used),
          "IHLEN" set to the length of the outer IP layer header, and "HLEN"
          set to (SHLEN+UHLEN+IHLEN). (The ITE must include the length of the
          uncompressed headers even if header compression is enabled when
          calculating these lengths.) In addition, the ETE maintains a
          constant value "MIN_MTU" set to 1280+HLEN as well as a variable
          "PATH_MTU" initialized to the MTU of the underlying link.</t>

          <t>For IPv4, the ITE also maintains the per ETE link path boolean
          variables "USE_DF" (initialized to "FALSE") and "USE_TRAILER"
          (initialized to "TRUE" if PATH_MTU is less than MIN_MTU; otherwise
          initialized to "FALSE") .</t>

          <t>The ITE may instead maintain *HLEN, MIN_MTU, PATH_MTU, USE_DF,
          and USE_TRAILER as per ETE (rather than per ETE link path) values.
          In that case, the values reflect the lowest-common-denominator MTU
          across all of the ETE's link paths.</t>
        </section>

        <section title="Pre-Encapsulation">
          <t>For each inner packet admitted into the tunnel interface, if the
          packet is itself a SEAL packet (i.e., one with either SEAL_PROTO in
          the IP protocol/next-header field, or with SEAL_PORT in the
          transport layer destination port field) and the LEVEL field of the
          SEAL header contains the value 0, the ITE silently discards the
          packet.</t>

          <t>Otherwise, for IPv4 inner packets with DF==0 in the IPv4 header,
          if the packet is larger than 512 bytes and is not the first fragment
          of a SEAL packet (i.e., not a packet that includes a SEAL header)
          the ITE fragments the packet into inner fragments no larger than 512
          bytes. The ITE then submits each inner fragment for SEAL
          encapsulation as specified in Section 4.4.4.</t>

          <t>For all other packets, if the packet is no larger than
          (MAX(PATH_MTU, MIN_MTU)-HLEN) for the corresponding ETE link path,
          the ITE submits it for SEAL encapsulation as specified in Section
          4.4.4. Otherwise, the ITE sends a PTB error message toward the
          source address of the inner packet.</t>

          <t>To send the PTB message, the ITE first checks its forwarding
          tables to discover the previous hop toward the source address of the
          inner packet. If the previous hop is reached via the same tunnel
          interface, the ITE sends an SCMP PTB (SPTB) message to the previous
          hop (see: Section 4.6.1.1) with the MTU field set to (MAX(PATH_MTU,
          MIN_MTU)-HLEN). Otherwise, the ITE sends an ordinary PTB message
          appropriate to the inner protocol version with the MTU field set to
          (MAX(PATH_MTU, MIN_MTU)-HLEN).</t>

          <t>After sending the (S)PTB message, the ITE discards the inner
          packet.</t>
        </section>

        <section title="SEAL Encapsulation">
          <t>The ITE next encapsulates the inner packet in a SEAL header
          formatted as specified in Section 4.3. The ITE sets NEXTHDR to the
          protocol number corresponding to the address family of the
          encapsulated inner packet. For example, the ITE sets NEXTHDR to the
          value '4' for encapsulated IPv4 packets <xref
          target="RFC2003"></xref>, '41' for encapsulated IPv6 packets <xref
          target="RFC2473"></xref><xref target="RFC4213"></xref>, '80' for
          encapsulated OSI/CLNP packets <xref target="RFC1070"></xref>,
          etc.</t>

          <t>The ITE then sets R=1 if redirects are permitted (see: <xref
          target="I-D.templin-intarea-vet"></xref>) and sets PREFLEN to the
          length of the prefix to be applied to the inner source address. The
          ITE's claimed PREFLEN is subject to verification by the ETE; hence,
          the ITE MUST set PREFLEN to the exact prefix length that it is
          authorized to use. (Note that if this process is entered via
          re-encapsulation (see: Section 4.5.4), PREFLEN and R are instead
          copied from the SEAL header of the re-encapsulated packet. This
          implies that the PREFLEN and R values are propagated across a
          re-encapsulating chain of ITE/ETEs that must all be authorized to
          represent the prefix.)</t>

          <t>Next, the ITE sets (C=0; P=0; Z=0), then sets LINK_ID to the
          value assigned to the underlying ETE link path and sets PKT_ID to a
          monotonically-increasing integer value for this ETE, beginning with
          0 in the first packet transmitted. The ITE also sets U=1 if it needs
          to determine whether the ETE will receive the packet without
          fragmentation, e.g., for ETE reachability determination (see:
          Section 4.4.6), to test whether a middlebox on the path is
          reassembling fragmented packets before they arrive at the ETE (see:
          Section 4.4.8), for stateful MTU determination (see Section 4.4.9),
          etc. Otherwise, the ITE sets U=0.</t>

          <t>Next, if the inner packet is not itself a SEAL packet the ITE
          sets LEVEL to an integer value between 0 and 7 as a specification of
          the number of additional layers of nested SEAL encapsulations
          permitted. If the inner packet is a SEAL packet that is undergoing
          nested encapsulation, the ITE instead sets LEVEL to the value that
          appears in the inner packet's SEAL header minus 1. If the inner
          packet is undergoing SEAL re-encapsulation, the ITE instead copies
          the LEVEL value from the SEAL header of the packet to be
          re-encapsulated.</t>

          <t>Next, if this is an IPv4 ETE link path with USE_TRAILER==TRUE,
          and the inner packet is larger than (128-SHLEN-UHLEN) bytes but no
          larger than 1280 bytes, the ITE sets T=1. Otherwise, the ITE sets
          T=0. The ITE then adds the outer encapsulating headers, calculates
          the ICV(s) and performs any necessary outer fragmentation as
          specified in Section 4.4.5.</t>
        </section>

        <section title="Outer Encapsulation">
          <t>Following SEAL encapsulation, the ITE next encapsulates the
          packet in the requisite outer headers according to the specific
          encapsulation format (e.g., <xref target="RFC1070"></xref>, <xref
          target="RFC2003"></xref>, <xref target="RFC2473"></xref>, <xref
          target="RFC4213"></xref>, etc.), except that it writes 'SEAL_PROTO'
          in the protocol field of the outer IP header (when simple IP
          encapsulation is used) or writes 'SEAL_PORT' in the outer
          destination transport service port field (e.g., when IP/UDP
          encapsulation is used).</t>

          <t>When UDP encapsulation is used, the ITE sets the UDP header
          fields as specified in Section 5.5.4 of <xref
          target="I-D.templin-intarea-vet"></xref> (where the UDP header
          length field includes the length of the SEAL trailer, if present).
          The ITE then performs outer IP header encapsulation as specified in
          Section 5.5.5 of <xref target="I-D.templin-intarea-vet"></xref>. If
          this process is entered via re-encapsulation (see: Section 4.5.4),
          the ITE instead follows the outer IP/UDP re-encapsulation procedures
          specified in Section 5.5.6 of <xref
          target="I-D.templin-intarea-vet"></xref>.</t>

          <t>When IPv4 is used as the outer encapsulation layer, if
          USE_DF==FALSE the ITE sets DF=0 in the IPv4 header to allow the
          packet to be fragmented within the subnetwork if it encounters a
          restricting link. Otherwise, the ITE sets DF=1.</t>

          <t>When IPv6 is used as the outer encapsulation layer, the "DF" flag
          is absent but implicitly set to 1. The packet therefore will not be
          fragmented within the subnetwork, since IPv6 deprecates
          in-the-network fragmentation.</t>

          <t>The ITE next sets ICV1=0 in the SEAL header and calculates the
          packet ICVs. The ICVs are calculated using an algorithm agreed on by
          the ITE and ETE. When data origin authentication is required, the
          algorithm uses a symmetric secret key so that the ETE can verify
          that the ICVs were generated by the ITE.</t>

          <t>The ITE first calculates the ICV over the leading 128 bytes of
          the packet (or up to the end of the packet if there are fewer than
          128 bytes) beginning with the UDP header (if present) then places
          result in the ICV1 field in the header. If T==1, the ITE next
          calculates the ICV over the remainder of the packet and places the
          result in the ICV2 field in the SEAL trailer. The ITE then submits
          the packet for outer encapsulation.</t>

          <t>Next, the ITE uses IP fragmentation if necessary to fragment the
          encapsulated packet into outer IP fragments that are no larger than
          PATH_MTU. By virtue of the pre-encapsulation packet size
          calculations specified in Section 4.4.3, fragmentation will
          therefore only occur for outer packets that are larger than PATH_MTU
          but no larger than MIN_MTU. (Note that, for IPv6, fragmentation must
          be performed by the ITE itself, while for IPv4 the fragmentation
          could instead be performed by a router in the ETE link path.)</t>

          <t>The ITE then sends each outer packet/fragment via the underlying
          link corresponding to LINK_ID.</t>
        </section>

        <section title="Path Probing and ETE Reachability Verification">
          <t>All SEAL data packets sent by the ITE are considered implicit
          probes. SEAL data packets will elicit an SCMP message from the ETE
          if it needs to acknowledge a probe and/or report an error condition.
          SEAL data packets may also be dropped by either the ETE or a router
          on the path, which will return an ICMP message.</t>

          <t>The ITE can also send an SCMP Router/Neighbor Solicitation
          message to elicit an SCMP Router/Neighbor Advertisement response
          (see: <xref target="I-D.templin-intarea-vet"></xref>) as
          verification that the ETE is still reachable via a specific link
          path.</t>

          <t>The ITE processes ICMP messages as specified in Section
          4.4.7.</t>

          <t>The ITE processes SCMP messages as specified in Section
          4.6.2.</t>
        </section>

        <section title="Processing ICMP Messages">
          <t>When the ITE sends SEAL packets, it may receive ICMP error
          messages<xref target="RFC0792"></xref><xref target="RFC4443"></xref>
          from another ITE on the path to the ETE (i.e., in case of nested
          encapsulations) or from an ordinary router within the subnetwork.
          Each ICMP message includes an outer IP header, followed by an ICMP
          header, followed by a portion of the SEAL data packet that generated
          the error (also known as the "packet-in-error") beginning with the
          outer IP header.</t>

          <t>The ITE should process ICMPv4 Protocol Unreachable messages and
          ICMPv6 Parameter Problem messages with Code "Unrecognized Next
          Header type encountered" as a hint that the ETE does not implement
          the SEAL protocol. The ITE can also process other ICMP messages that
          do not include sufficient information in the packet-in-error as a
          hint that the ETE link path may be failing. Specific actions that
          the ITE may take in these cases are out of scope.</t>

          <t>For other ICMP messages, the should use any outer header
          information available as a first-pass authentication filter (e.g.,
          to determine if the source of the message is within the same
          administrative domain as the ITE) and discards the message if first
          pass filtering fails.</t>

          <t>Next, the ITE examines the packet-in-error beginning with the
          SEAL header. If the value in the PKT_ID field is not within the
          window of packets the ITE has recently sent to this ETE, or if the
          value in the SEAL header ICV1 field is incorrect, the ITE discards
          the message.</t>

          <t>Next, if the received ICMP message is a PTB the ITE sets the
          temporary variable "PMTU" for this ETE link path to the MTU value in
          the PTB message. If PMTU==0, the ITE consults a plateau table (e.g.,
          as described in <xref target="RFC1191"></xref>) to determine PMTU
          based on the length field in the outer IP header of the
          packet-in-error. (For example, if the ITE receives a PTB message
          with MTU==0 and length 1500, it can set PMTU=1450. If the ITE
          subsequently receives a PTB message with MTU==0 and length 1450, it
          can set PMTU=1400, etc.) If the ITE is performing stateful MTU
          determination for this ETE link path (see Section 4.4.9), the ITE
          next sets PATH_MTU=PMTU. If PMTU is less than MIN_MTU, the ITE sets
          PATH_MTU=PMTU (and for IPv4 also sets USE_TRAILER=TRUE), then
          discards the message.</t>

          <t>If the ICMP message was not discarded, the ITE then transcribes
          it into a message to return to the previous hop. If the previous hop
          toward the inner source address within the packet-in-error is
          reached via the same tunnel interface the SEAL data packet was sent
          on, the ITE transcribes the ICMP message into an SCMP message.
          Otherwise, the ITE transcribes the ICMP message into a message
          appropriate for the inner protocol version.</t>

          <t>To transcribe the message, the ITE extracts the inner packet from
          within the ICMP message packet-in-error field and uses it to
          generate a new message corresponding to the type of the received
          ICMP message. For SCMP messages, the ITE generates the message the
          same as described for ETE generation of SCMP messages in Section
          4.6.1. For (S)PTB messages, the ITE writes (PMTU-HLEN) in the MTU
          field.</t>

          <t>The ITE finally forwards the transcribed message to the previous
          hop toward the inner source address.</t>
        </section>

        <section title="IPv4 Middlebox Reassembly Testing">
          <t>For IPv4, the ITE can perform a qualification exchange over an
          ETE link path to ensure that the subnetwork correctly delivers
          fragments to the ETE. This procedure can be used, e.g., to determine
          whether there are middleboxes on the path that violate the <xref
          target="RFC1812"></xref>, Section 5.2.6 requirement that: "A router
          MUST NOT reassemble any datagram before forwarding it".</t>

          <t>When possible, the ITE should use knowledge of its topological
          arrangement as an aid in determining when middlebox reassembly
          testing is necessary. For example, if the ITE is aware that the ETE
          is located somewhere in the public Internet, middlebox reassembly
          testing is unnecessary. If the ITE is aware that the ETE is located
          behind a NAT or a firewall, however, then middlebox reassembly
          testing is recommended.</t>

          <t>The ITE can perform a middlebox reassembly test by setting U=1 in
          the header of a SEAL data packet to be used as a probe. Next, the
          ITE encapsulates the packet in the appropriate outer headers, splits
          it into two outer IPv4 fragments, then sends both fragments over the
          same ETE link path.</t>

          <t>While performing the test, the ITE should select only inner
          packets that are no larger than 1280 bytes for testing purposes in
          order to avoid reassembly buffer overruns. The ITE can also
          construct a NULL test packet instead of using ordinary SEAL data
          packets for testing.</t>

          <t>To create the NULL packet, the ITE prepares a data packet with
          (C=0; P=1; R=0; T=0; U=1; Z=0) in the SEAL header, writes the length
          of the ITE's claimed prefix in the PREFLEN field, and writes the
          ITE's claimed prefix in the PREFIX field. The ITE then sets NEXTHDR
          according to the address family of the PREFIX, i.e., it sets NEXTHDR
          to the value '4' for an IPv4 prefix, '41' for an IPv6 prefix , '80'
          for an OSI/CLNP prefix, etc.</t>

          <t>The ITE can further add padding following the PREFIX field to a
          length that would not cause the size of the NULL packet to exceed
          1280 bytes before encapsulation. The ITE then sets LINK_ID, LEVEL
          and PKT_ID to the appropriate values for this ETE link path and
          calculates ICV1 the same as for an ordinary SEAL data packet.</t>

          <t>The ITE should send a series of test packets (e.g., 3-5 tests
          with 1sec intervals between tests) instead of a single isolated test
          in case of packet loss, and will eventually receive an SPTB message
          from the ITE (see: Section 4.6.2.1). If the ETE returns an SCMP PTB
          message with MTU != 0, then the ETE link path correctly supports
          fragmentation.</t>

          <t>If the ETE returns an SCMP PTB message with MTU==0, however, then
          a middlebox in the subnetwork is reassembling the fragments before
          forwarding them to the ETE. In that case, the ITE sets
          PATH_MTU=MIN_MTU and sets (USE_TRAILER=TRUE; USE_DF=FALSE). The ITE
          may instead enable stateful MTU determination for this ETE link path
          as specified in Section 4.4.9 to attempt to discover larger
          MTUs.</t>

          <t>NB: Examples of middleboxes that may perform reassembly include
          stateful NATs and firewalls. Such devices could still allow for
          stateless MTU determination if they gather the fragments of a
          fragmented IPv4 SEAL data packet for packet analysis purposes but
          then forward the fragments on to the final destination rather than
          forwarding the reassembled packet.</t>
        </section>

        <section title="Stateful MTU Determination">
          <t>SEAL supports a stateless MTU determination capability, however
          the ITE may in some instances wish to impose a stateful MTU limit on
          a particular ETE link path. For example, when the ETE is situated
          behind a middlebox that performs IPv4 reassembly (see: Section
          4.4.8) it is imperative that fragmentation of large packets be
          avoided on the path to the middlebox. In other instances (e.g., when
          the ETE link path includes performance-constrained links), the ITE
          may deem it necessary to cache a conservative static MTU in order to
          avoid sending large packets that would only be dropped due to an MTU
          restriction somewhere on the path.</t>

          <t>To determine a static MTU value, the ITE can send a series of
          probe packets of various sizes to the ETE with U=1 in the SEAL
          header and DF=1 in the outer IP header. The ITE can then cache the
          size of the largest packet for which it receives a probe reply from
          the ETE as the PATH_MTU value this ETE link path.</t>

          <t>For example, the ITE could send NULL probe packets of 1500 bytes,
          followed by 1450 bytes, followed by 1400 bytes, etc. then set
          PATH_MTU for this ETE link path to the size of the largest probe
          packet for which it receives an SPTB reply message. While probing
          with NULL probe packets, the ITE processes any ICMP PTB message it
          receives as a potential indication of probe failure then discards
          the message.</t>

          <t>For IPv4, if the largest successful probe is larger than MIN_MTU
          the ITE then sets (USE_TRAILER=FALSE; USE_DF=TRUE) for this ETE link
          path; otherwise, the ITE sets (USE_TRAILER=TRUE; USE_DF=FALSE).</t>
        </section>

        <section title="Detecting Path MTU Changes">
          <t>For IPv6, the ITE can periodically reset PATH_MTU to the MTU of
          the underlying link to determine whether the ETE link path now
          supports larger packet sizes. If the path still has a too-small MTU,
          the ITE will receive a PTB message that reports a smaller size.</t>

          <t>For IPv4, when USE_TRAILER==TRUE and PATH_MTU is larger than
          MIN_MTU the ITE can periodically reset USE_TRAILER=FALSE to
          determine whether the ETE link path still requires trailers. If the
          ITE receives an SPTB message for an inner packet that is no larger
          than 1280 bytes (see: Section 4.6.1.1), the ITE should again set
          USE_TRAILER=TRUE.</t>

          <t>When stateful MTU determination is used, the ITE should
          periodically re-probe the path as described in Section 4.4.9 to
          determine whether routing changes have resulted in a reduced or
          increased PATH_MTU.</t>
        </section>
      </section>

      <section title="ETE Specification">
        <section title="Tunnel Neighbor Soft State">
          <t>The ETE maintains a per-ITE ICV calculation algorithm and (when
          data origin authentication is required) a symmetric secret key to
          verify the ICV(s) in the SEAL header and trailer. The ETE also
          maintains a window of PKT_ID values for the packets it has recently
          received from this ITE.</t>
        </section>

        <section title="IP-Layer Reassembly">
          <t>The ETE must maintain a minimum IP-layer reassembly buffer size
          of 1500 bytes for both IPv4 <xref target="RFC0791"></xref> and IPv6
          <xref target="RFC2460"></xref>.</t>

          <t>The ETE should maintain conservative reassembly cache high- and
          low-water marks. When the size of the reassembly cache exceeds this
          high-water mark, the ETE should actively discard stale incomplete
          reassemblies (e.g., using an Active Queue Management (AQM) strategy)
          until the size falls below the low-water mark. The ETE should also
          actively discard any pending reassemblies that clearly have no
          opportunity for completion, e.g., when a considerable number of new
          fragments have arrived before a fragment that completes a pending
          reassembly arrives.</t>

          <t>The ETE processes non-SEAL IP packets as specified in the
          normative references, i.e., it performs any necessary IP reassembly
          then discards the packet if it is larger than the reassembly buffer
          size or delivers the (fully-reassembled) packet to the appropriate
          upper layer protocol module.</t>

          <t>For SEAL packets, the ITE performs any necessary IP reassembly
          until it has received at least the first 1280 bytes beyond the SEAL
          header or up to the end of the packet. For IPv4, the ETE then
          submits the (fully- or partially-reassembled) packet for
          decapsulation as specified in Section 4.5.3. For IPv6, the ETE only
          submits the packet if it was fully-reassembled and no larger than
          the reassembly buffer size.</t>
        </section>

        <section title="Decapsulation and Re-Encapsulation">
          <t>For each SEAL packet submitted for decapsulation, the ETE first
          examines the PKT_ID and ICV1 fields. If the PKT_ID is not within the
          window of acceptable values for this ITE, or if the ICV1 field
          includes an incorrect value, the ETE silently discards the
          packet.</t>

          <t>Next, if the SEAL header has T==1 and the inner packet is larger
          than 1280 bytes the ETE silently discards the packet. If the SEAL
          header has T==1 and the inner packet is no larger than 1280 bytes,
          the ETE instead verifies the ICV2 value and silently discards the
          packet if the value is incorrect.</t>

          <t>Next, if the SEAL header has C==0 and there is an incorrect value
          in a SEAL header field (e.g., an incorrect "VER" field value), the
          ETE returns an SCMP "Parameter Problem" (SPP) message (see Section
          4.6.1.2) and discards the packet.</t>

          <t>Next, if the packet arrived as multiple IPv4 fragments and the
          inner packet is larger than 1280 bytes, the ETE sends an SPTB
          message back to the ITE with MTU set to the size of the largest
          fragment received minus HLEN (see: Section 4.6.1.1) then discards
          the packet. If the packet arrived as multiple IPv6 fragments and the
          inner packet is larger than 1280 bytes, the ETE instead silently
          discards the packet.</t>

          <t>Next, if the packet arrived as multiple IPv4 fragments, the SEAL
          header has (C==0; T==0), and the inner packet is larger than
          (128-SHLEN-UHLEN) bytes, the ETE sends an SPTB message back to the
          ITE with MTU set to the size of the largest fragment received minus
          HLEN (see: Section 4.6.1.1) then continues to process the
          packet.</t>

          <t>Next, if the SEAL header has C==1, the ETE processes the packet
          as an SCMP packet as specified in Section 4.6.2. Otherwise, the ETE
          continues to process the packet as a SEAL data packet.</t>

          <t>Next, if the packet arrived unfragmented and the SEAL header has
          U==1, the ETE sends an SPTB message back to the ITE with MTU=0 (see:
          Section 4.6.1.1).</t>

          <t>Next, if the SEAL header has P==1 the ETE discards the (NULL)
          packet.</t>

          <t>Finally, the ETE discards the outer headers and processes the
          inner packet according to the header type indicated in the SEAL
          NEXTHDR field. If the next hop toward the inner destination address
          is via a different interface than the SEAL packet arrived on, the
          ETE discards the SEAL header and delivers the inner packet either to
          the local host or to the next hop interface if the packet is not
          destined to the local host.</t>

          <t>If the next hop is on the same interface the SEAL packet arrived
          on, however, the ETE submits the packet for SEAL re-encapsulation
          beginning with the specification in Section 4.4.3 above. In this
          process, the packet remains within the tunnel interface (i.e., it
          does not exit and then re-enter the interface); hence, the packet is
          not discarded if the LEVEL field in the SEAL header contains the
          value 0.</t>
        </section>
      </section>

      <section title="The SEAL Control Message Protocol (SCMP)">
        <t>SEAL provides a companion SEAL Control Message Protocol (SCMP) that
        uses the same message types and formats as for the Internet Control
        Message Protocol for IPv6 (ICMPv6) <xref target="RFC4443"></xref>. As
        for ICMPv6, each SCMP message includes a 4-byte header and a
        variable-length body. The TE encapsulates the SCMP message in a SEAL
        header and outer headers as shown in <xref
        target="scmpencaps"></xref>:</t>

        <t><figure anchor="scmpencaps" title="SCMP Message Encapsulation">
            <artwork><![CDATA[                                    +--------------------+
                                    ~   outer IP header  ~
                                    +--------------------+
                                    ~  other outer hdrs  ~
                                    +--------------------+
                                    ~    SEAL Header     ~
       +--------------------+       +--------------------+
       | SCMP message header|  -->  | SCMP message header|
       +--------------------+       +--------------------+
       |                    |  -->  |                    |
       ~  SCMP message body ~  -->  ~  SCMP message body ~
       |                    |  -->  |                    |
       +--------------------+       +--------------------+
 
            SCMP Message                  SCMP Packet
        before encapsulation          after encapsulation]]></artwork>
          </figure></t>

        <t>The following sections specify the generation, processing and
        relaying of SCMP messages.</t>

        <section title="Generating SCMP Error Messages">
          <t>ETEs generate SCMP error messages in response to receiving
          certain SEAL data packets using the format shown in <xref
          target="control2"></xref>:</t>

          <t><figure anchor="control2" title="SCMP Error Message Format">
              <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Type-Specific Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      As much of the inner packet within the invoking          |
   ~       SEAL data packet as possible without the SCMP           ~
   |              packet exceeding 576 bytes (*)                   |

   (*) also known as the "packet-in-error"]]></artwork>
            </figure>The error message includes the 4 byte SCMP message
          header, followed by a 4 byte Type-Specific Data field, followed by
          the leading portion of the inner packet within the invoking SEAL
          data packet (i.e., beginning immediately after the SEAL header) as
          the "packet-in-error". The packet-in-error includes as much of the
          inner packet as possible extending to a length that would not cause
          the entire SCMP packet following outer encapsulation to exceed 576
          bytes.</t>

          <t>When the ETE processes a SEAL data packet for which the ICVs are
          correct but an error must be returned, it prepares an SCMP error
          message as shown in <xref target="control2"></xref>. The ETE sets
          the Type and Code fields to the same values that would appear in the
          corresponding ICMPv6 message and calculates the Checksum beginning
          with the SCMP message header and continuing to the end of the
          message. (When calculating the Checksum, the TE sets the Checksum
          field itself to 0.)</t>

          <t>The ETE next encapsulates the SCMP message in the requisite SEAL
          header, outer headers and SEAL trailer as shown in <xref
          target="scmpencaps"></xref>. During encapsulation, the ETE sets the
          outer destination address/port numbers of the SCMP packet to the
          outer source address/port numbers of the original SEAL data packet
          and sets the outer source address/port numbers to its own outer
          address/port numbers.</t>

          <t>The ETE then sets (C=1; R=0; T=0; U=0; Z=0) in the SEAL header,
          then sets NEXTHDR, PREFLEN, LINK_ID, LEVEL, and PKT_ID to the same
          values that appeared in the SEAL header of the data packet. If the
          SEAL data packet header had P==1, the ETE also copies the PREFIX
          field from the data packet into the SEAL header and sets P=1;
          otherwise, it sets P=0.</t>

          <t>The ETE then calculates and sets the ICV1 field the same as
          specified for SEAL data packet encapsulation in Section 4.4.4. Next,
          the ETE encapsulates the SCMP message in the requisite outer
          encapsulations and sends the resulting SCMP packet to the ITE the
          same as specified for SEAL data packets in Section 4.4.5.</t>

          <t>The following sections describe additional considerations for
          various SCMP error messages:</t>

          <section title="Generating SCMP Packet Too Big (SPTB) Messages">
            <t>An ETE generates an SCMP "Packet Too Big" (SPTB) message when
            it receives a SEAL data packet that arrived as multiple outer IPv4
            fragments and for which the reassembled inner packet would be
            larger than 1280 bytes. The ETE also generates an SPTB when it
            receives the fragments of a fragmented IPv4-encapsulated SEAL data
            packet with T==0 in the SEAL header but that following reassembly
            would be larger than (128-SHLEN-UHLEN) bytes but no larger than
            1280 bytes. The ETE prepares the SPTB message the same as for the
            corresponding ICMPv6 PTB message, and writes the length of the
            largest outer IP fragment received minus HLEN in the MTU field of
            the message.</t>

            <t>The ETE also generates an SPTB message when it accepts a SEAL
            protocol data packet which did not undergo IP fragmentation and
            with U==1 in the SEAL header. The ETE prepares the SPTB message
            the same as above, except that it writes the value 0 in the MTU
            field.</t>
          </section>

          <section title="Generating Other SCMP Error Messages">
            <t>An ETE generates an SCMP "Destination Unreachable" (SDU)
            message under the same circumstances that an IPv6 system would
            generate an ICMPv6 Destination Unreachable message.</t>

            <t>An ETE generates an SCMP "Parameter Problem" (SPP) message when
            it receives a SEAL packet with an incorrect value in the SEAL
            header. IN THIS CASE ALONE, the ETE prepares the packet-in-error
            beginning with the SEAL header instead of beginning immediately
            after the SEAL header.</t>

            <t>TEs generate other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>

        <section title="Processing SCMP Error Messages">
          <t>An ITE may receive SCMP messages after sending packets to an ETE.
          The ITE first verifies that the outer addresses of the SCMP packet
          are correct, and that the PKT_ID is within its window of values for
          this ETE. The ITE next verifies that the SEAL header fields are set
          correctly as specified in Section 4.6.1. The ITE then verifies the
          ICV1 value. If the outer addresses, SEAL header information and/or
          ICV1 value are incorrect, the ITE silently discards the message;
          otherwise, it processes the message as follows:</t>

          <section title="Processing SCMP PTB Messages">
            <t>After an ITE sends a SEAL data packet to an ETE, it may receive
            an SPTB message with a packet-in-error containing the leading
            portion of the inner packet (see: Section 4.6.1.1). For IP SPTB
            messages with MTU==0, the ITE processes the message as
            confirmation that the ETE received an unfragmented SEAL data
            packet with U==1 in the SEAL header. The ITE then discards the
            message.</t>

            <t>For IPv4 SPTB messages with MTU != 0, the ITE instead processes
            the message as an indication of a packet size limitation as
            follows. The ITE first determines the inner packet length by
            subtracting SHLEN from the length field in the UDP header within
            the packet-in-error (and also subtracting the length of the SEAL
            trailer when T=1). If the inner packet is no larger than 1280
            bytes, the ITE sets USE_TRAILER=TRUE. If the inner packet is
            larger than 1280 bytes, the ITE instead examines the SPTB message
            MTU field. If the MTU value is not substantially less than
            (1500-HLEN), the value is likely to reflect the true MTU of the
            restricting link on the path to the ETE; otherwise, a router on
            the path may be generating runt fragments.</t>

            <t>In that case, the ITE can consult a plateau table (e.g., as
            described in <xref target="RFC1191"></xref>) to rewrite the MTU
            value to a reduced size. For example, if the ITE receives an IPv4
            SPTB message with MTU==256 and inner packet length 1500, it can
            rewrite the MTU to 1450. If the ITE subsequently receives an IPv4
            SPTB message with MTU==256 and inner packet length 1450, it can
            rewrite the MTU to 1400, etc. If the ITE is performing stateful
            MTU determination for this ETE link path, it then writes the new
            MTU value in PATH_MTU.</t>

            <t>The ITE then checks its forwarding tables to discover the
            previous hop toward the source address of the inner packet. If the
            previous hop is reached via the same tunnel interface the SPTB
            message arrived on, the ITE relays the message to the previous
            hop. In order to relay the message, the ITE rewrites the SEAL
            header fields with values corresponding to the previous hop and
            recalculates the ICV1 values using the ICV calculation parameters
            associated with the previous hop. Next, the ITE replaces the
            SPTB's outer headers with headers of the appropriate protocol
            version and fills in the header fields as specified in Sections
            5.5.4-5.5.6 of <xref target="I-D.templin-intarea-vet"></xref>,
            where the destination address/port correspond to the previous hop
            and the source address/port correspond to the ITE. The ITE then
            sends the message to the previous hop the same as if it were
            issuing a new SPTB message.</t>

            <t>If the previous hop is not reached via the same tunnel
            interface, the ITE instead transcribes the message into a format
            appropriate for the inner packet (i.e., the same as described for
            transcribing ICMP messages in Section 4.4.7) and sends the
            resulting transcribed message to the original source. The ITE then
            discards the SPTB message.</t>
          </section>

          <section title="Processing Other SCMP Error Messages">
            <t>An ITE may receive an SDU message with an appropriate code
            under the same circumstances that an IPv6 node would receive an
            ICMPv6 Destination Unreachable message. The ITE either transcribes
            or relays the message toward the source address of the inner
            packet within the packet-in-error the same as specified for SPTB
            messages in Section 4.6.2.1.</t>

            <t>An ITE may receive an SPP message when the ETE receives a SEAL
            packet with an incorrect value in the SEAL header. The ITE should
            examine the SEAL header within the packet-in-error to determine
            whether a different setting should be used in subsequent packets,
            but does not relay the message further.</t>

            <t>TEs process other SCMP message types using methods and
            procedures specified in other documents. For example, SCMP message
            types used for tunnel neighbor coordinations are specified in VET
            <xref target="I-D.templin-intarea-vet"></xref>.</t>
          </section>
        </section>
      </section>
    </section>

    <section title="Link Requirements">
      <t>Subnetwork designers are expected to follow the recommendations in
      Section 2 of <xref target="RFC3819"></xref> when configuring link
      MTUs.</t>
    </section>

    <section title="End System Requirements">
      <t>End systems are encouraged to implement end-to-end MTU assurance
      (e.g., using Packetization Layer Path MTU Discovery per <xref
      target="RFC4821"></xref>) even if the subnetwork is using SEAL.</t>
    </section>

    <section title="Router Requirements">
      <t>Routers within the subnetwork are expected to observe the router
      requirements found in the normative references, including the
      implementation of IP fragmentation and reassembly <xref
      target="RFC1812"></xref><xref target="RFC2460"></xref> as well as the
      generation of ICMP messages <xref target="RFC0792"></xref><xref
      target="RFC4443"></xref>.</t>
    </section>

    <section title="Nested Encapsulation Considerations">
      <t>SEAL supports nested tunneling for up to 8 layers of encapsulation.
      In this model, the SEAL ITE has a tunnel neighbor relationship only with
      ETEs at its own nesting level, i.e., it does not have a tunnel neighbor
      relationship with any ITEs/ETEs at other nesting levels.</t>

      <t>Therefore, when an ITE 'A' within an inner nesting level needs to
      return an error message to an ITE 'B' within an outer nesting level, it
      generates an ordinary ICMP error message the same as if it were an
      ordinary router within the subnetwork. 'B' can then perform message
      validation as specified in Section 4.4.7, but full message origin
      authentication is not possible.</t>

      <t>Since ordinary ICMP messages are used for coordinations between ITEs
      at different nesting levels, nested SEAL encapsulations should only be
      used when the ITEs are within a common administrative domain and/or when
      there is no ICMP filtering middlebox such as a firewall or NAT between
      them. An example would be a recursive nesting of mobile networks, where
      the first network receives service from an ISP, the second network
      receives service from the first network, the third network receives
      service from the second network, etc.</t>
    </section>

    <section title="IANA Considerations">
      <t>The IANA is instructed to allocate an IP protocol number for
      'SEAL_PROTO' in the 'protocol-numbers' registry.</t>

      <t>The IANA is instructed to allocate a Well-Known Port number for
      'SEAL_PORT' in the 'port-numbers' registry.</t>

      <t>The IANA is instructed to establish a "SEAL Protocol" registry to
      record SEAL Version values. This registry should be initialized to
      include the initial SEAL Version number, i.e., Version 0.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>SEAL provides a segment-by-segment data origin authentication and
      anti-replay service across the (potentially) multiple segments of a
      re-encapsulating tunnel. It further provides a segment-by-segment
      integrity check of the headers of encapsulated packets, but does not
      verify the integrity of the rest of the packet beyond the headers unless
      fragmentation is unavoidable. SEAL therefore considers full message
      integrity checking, authentication and confidentiality as end-to-end
      considerations in a manner that is compatible with securing mechanisms
      such as TLS/SSL <xref target="RFC5246"></xref>.</t>

      <t>An amplification/reflection/buffer overflow attack is possible when
      an attacker sends IP fragments with spoofed source addresses to an ETE
      in an attempt to clog the ETE's reassembly buffer and/or cause the ETE
      to generate a stream of SCMP messages returned to a victim ITE. The SCMP
      message ICVs, PKT_ID, as well as the inner headers of the
      packet-in-error, provide mitigation for the ETE to detect and discard
      SEAL segments with spoofed source addresses.</t>

      <t>The SEAL header is sent in-the-clear the same as for the outer IP and
      other outer headers. In this respect, the threat model is no different
      than for IPv6 extension headers. Unlike IPv6 extension headers, however,
      the SEAL header is protected by an integrity check that also covers the
      inner packet headers.</t>

      <t>Security issues that apply to tunneling in general are discussed in
      <xref target="RFC6169"></xref>.</t>
    </section>

    <section title="Related Work">
      <t>Section 3.1.7 of <xref target="RFC2764"></xref> provides a high-level
      sketch for supporting large tunnel MTUs via a tunnel-level segmentation
      and reassembly capability to avoid IP level fragmentation. This
      capability was implemented in the first edition of SEAL, but is now
      deprecated.</t>

      <t>Section 3 of <xref target="RFC4459"> </xref> describes inner and
      outer fragmentation at the tunnel endpoints as alternatives for
      accommodating the tunnel MTU.</t>

      <t>Section 4 of <xref target="RFC2460"></xref> specifies a method for
      inserting and processing extension headers between the base IPv6 header
      and transport layer protocol data. The SEAL header is inserted and
      processed in exactly the same manner.</t>

      <t>IPsec/AH is <xref target="RFC4301"></xref><xref
      target="RFC4301"></xref> is used for full message integrity verification
      between tunnel endpoints, whereas SEAL only ensures integrity for the
      inner packet headers. The AYIYA proposal <xref
      target="I-D.massar-v6ops-ayiya"></xref> uses similar means for providing
      full message authentication and integrity.</t>

      <t>The concepts of path MTU determination through the report of
      fragmentation and extending the IPv4 Identification field were first
      proposed in deliberations of the TCP-IP mailing list and the Path MTU
      Discovery Working Group (MTUDWG) during the late 1980's and early
      1990's. An historical analysis of the evolution of these concepts, as
      well as the development of the eventual path MTU discovery mechanism,
      appears in Appendix D of this document.</t>
    </section>

    <section anchor="acknowledge" title="Acknowledgments">
      <t>The following individuals are acknowledged for helpful comments and
      suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum, Oliver
      Bonaventure, Teco Boot, Bob Braden, Brian Carpenter, Steve Casner, Ian
      Chakeres, Noel Chiappa, Remi Denis-Courmont, Remi Despres, Ralph Droms,
      Aurnaud Ebalard, Gorry Fairhurst, Washam Fan, Dino Farinacci, Joel
      Halpern, Sam Hartman, John Heffner, Thomas Henderson, Bob Hinden,
      Christian Huitema, Eliot Lear, Darrel Lewis, Joe Macker, Matt Mathis,
      Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch, Mark Townsley, Ole
      Troan, Margaret Wasserman, Magnus Westerlund, Robin Whittle, James
      Woodyatt, and members of the Boeing Research &amp; Technology NST
      DC&amp;NT group.</t>

      <t>Discussions with colleagues following the publication of RFC5320 have
      provided useful insights that have resulted in significant improvements
      to this, the Second Edition of SEAL.</t>

      <t>Path MTU determination through the report of fragmentation was first
      proposed by Charles Lynn on the TCP-IP mailing list in 1987. Extending
      the IP identification field was first proposed by Steve Deering on the
      MTUDWG mailing list in 1989.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.0791"?>

      <?rfc include="reference.RFC.0792"?>

      <?rfc include="reference.RFC.4443"?>

      <?rfc include="reference.RFC.3971"?>

      <?rfc include="reference.RFC.4861"?>

      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.2460"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.1063"?>

      <?rfc include="reference.RFC.1191"?>

      <?rfc include="reference.RFC.1981"?>

      <?rfc include="reference.RFC.2003"?>

      <?rfc include="reference.RFC.2473"?>

      <?rfc include="reference.RFC.2923"?>

      <?rfc include="reference.RFC.3366"?>

      <?rfc include="reference.RFC.3819"?>

      <?rfc include="reference.RFC.4213"?>

      <?rfc include="reference.RFC.1812"?>

      <?rfc include="reference.RFC.4380"?>

      <?rfc include="reference.RFC.4301"?>

      <?rfc include="reference.RFC.4302"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.4459"?>

      <?rfc include="reference.RFC.4821"?>

      <?rfc include="reference.RFC.4963"?>

      <?rfc include="reference.RFC.2764"?>

      <?rfc include="reference.RFC.2675"?>

      <?rfc include="reference.RFC.5445"?>

      <?rfc include="reference.RFC.1070"?>

      <?rfc include="reference.RFC.3232"?>

      <?rfc include="reference.RFC.4191"?>

      <?rfc include="reference.RFC.4987"?>

      <?rfc include="reference.RFC.5720"?>

      <?rfc include="reference.I-D.templin-intarea-vet"?>

      <?rfc include="reference.I-D.ietf-savi-framework"?>

      <?rfc include="reference.I-D.templin-ironbis"?>

      <?rfc include="reference.RFC.6139"?>

      <?rfc include="reference.RFC.5927"?>

      <?rfc include="reference.RFC.6169"?>

      <?rfc include="reference.I-D.ietf-intarea-ipv4-id-update"?>

      <?rfc include="reference.I-D.templin-aero"?>

      <?rfc include="reference.I-D.massar-v6ops-ayiya"?>

      <reference anchor="FRAG">
        <front>
          <title>Fragmentation Considered Harmful</title>

          <author fullname="Christopher Kent" initials="C" surname="Kent">
            <organization></organization>
          </author>

          <author fullname="Jeffrey Mogul" initials="J" surname="Mogul">
            <organization></organization>
          </author>

          <date month="October" year="1987" />
        </front>
      </reference>

      <reference anchor="FOLK">
        <front>
          <title>Beyond Folklore: Observations on Fragmented Traffic</title>

          <author fullname="Colleen Shannon" initials="C" surname="Shannon">
            <organization></organization>
          </author>

          <author fullname="David Moore" initials="D" surname="Moore">
            <organization></organization>
          </author>

          <author fullname="k claffy" initials="k" surname="claffy">
            <organization></organization>
          </author>

          <date month="December" year="2002" />
        </front>
      </reference>

      <reference anchor="MTUDWG">
        <front>
          <title>IETF MTU Discovery Working Group mailing list,
          gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log, November 1989 -
          February 1995.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TCP-IP">
        <front>
          <title>Archive/Hypermail of Early TCP-IP Mail List,
          http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/, May 1987 - May
          1990.</title>

          <author fullname="" initials="" surname="">
            <organization></organization>
          </author>

          <date month="" year="" />
        </front>
      </reference>

      <reference anchor="TBIT">
        <front>
          <title>Measuring Interactions Between Transport Protocols and
          Middleboxes</title>

          <author fullname="Alberto Medina" initials="A" surname="Medina">
            <organization></organization>
          </author>

          <author fullname="Mark Allman" initials="M" surname="Allman">
            <organization></organization>
          </author>

          <author fullname="Sally Floyd" initials="S" surname="Floyd">
            <organization></organization>
          </author>

          <date month="October" year="2004" />
        </front>
      </reference>

      <reference anchor="WAND">
        <front>
          <title>Inferring and Debugging Path MTU Discovery Failures</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Kenjiro Cho" initials="K" surname="Cho">
            <organization></organization>
          </author>

          <author fullname="Bill Owens" initials="B" surname="Owens">
            <organization></organization>
          </author>

          <date month="October" year="2005" />
        </front>
      </reference>

      <reference anchor="SIGCOMM">
        <front>
          <title>Measuring Path MTU Discovery Behavior</title>

          <author fullname="Matthew Luckie" initials="M" surname="Luckie">
            <organization></organization>
          </author>

          <author fullname="Ben Stasiewicz" initials="B" surname="Stasiewicz">
            <organization></organization>
          </author>

          <date month="November" year="2010" />
        </front>
      </reference>
    </references>

    <section title="Reliability">
      <t>Although a SEAL tunnel may span an arbitrarily-large subnetwork
      expanse, the IP layer sees the tunnel as a simple link that supports the
      IP service model. Links with high bit error rates (BERs) (e.g., IEEE
      802.11) use Automatic Repeat-ReQuest (ARQ) mechanisms <xref
      target="RFC3366"></xref> to increase packet delivery ratios, while links
      with much lower BERs typically omit such mechanisms. Since SEAL tunnels
      may traverse arbitrarily-long paths over links of various types that are
      already either performing or omitting ARQ as appropriate, it would
      therefore often be inefficient to also require the tunnel endpoints to
      also perform ARQ.</t>
    </section>

    <section title="Integrity">
      <t>The SEAL header includes an ICV field that covers the SEAL header and
      at least the inner packet headers. This provides for header integrity
      verification on a segment-by-segment basis for a segmented
      re-encapsulating tunnel path. When IPv4 fragmentation is needed, the
      SEAL packet also contains a trailer with a secondary ICV that covers the
      remainder of the packet.</t>

      <t>Fragmentation and reassembly schemes must consider packet-splicing
      errors, e.g., when two fragments from the same packet are concatenated
      incorrectly, when a fragment from packet X is reassembled with fragments
      from packet Y, etc. The primary sources of such errors include
      implementation bugs and wrapping IPv4 ID fields.</t>

      <t>In terms of wrapping ID fields, the IPv4 16-bit ID field can wrap
      with only 64K packets with the same (src, dst, protocol)-tuple alive in
      the system at a given time <xref target="RFC4963"></xref> increasing the
      likelihood of reassembly mis-associations</t>

      <t>When reassembly is unavoidable, SEAL provides an extended ICV to
      detect reassembly mis-associations for packets no larger than 1280 bytes
      and also discards any reassembled packets larger than 1280 bytes.</t>
    </section>

    <section title="Transport Mode">
      <t>SEAL can also be used in "transport-mode", e.g., when the inner layer
      comprises upper-layer protocol data rather than an encapsulated IP
      packet. For instance, TCP peers can negotiate the use of SEAL (e.g., by
      inserting a 'SEAL_OPTION' TCP option during connection establishment)
      for the carriage of protocol data encapsulated as IP/SEAL/TCP. In this
      sense, the "subnetwork" becomes the entire end-to-end path between the
      TCP peers and may potentially span the entire Internet.</t>

      <t>If both TCPs agree on the use of SEAL, their protocol messages will
      be carried as IP/SEAL/TCP and the connection will be serviced by the
      SEAL protocol using TCP (instead of an encapsulating tunnel endpoint) as
      the transport layer protocol. The SEAL protocol for transport mode
      otherwise observes the same specifications as for Section 4.</t>
    </section>

    <section title="Historic Evolution of PMTUD">
      <t>The topic of Path MTU discovery (PMTUD) saw a flurry of discussion
      and numerous proposals in the late 1980's through early 1990. The
      initial problem was posed by Art Berggreen on May 22, 1987 in a message
      to the TCP-IP discussion group <xref target="TCP-IP"></xref>. The
      discussion that followed provided significant reference material for
      [FRAG]. An IETF Path MTU Discovery Working Group <xref
      target="MTUDWG"></xref> was formed in late 1989 with charter to produce
      an RFC. Several variations on a very few basic proposals were
      entertained, including:</t>

      <t><list style="numbers">
          <t>Routers record the PMTUD estimate in ICMP-like path probe
          messages (proposed in [FRAG] and later <xref
          target="RFC1063"></xref>)</t>

          <t>The destination reports any fragmentation that occurs for packets
          received with the "RF" (Report Fragmentation) bit set (Steve
          Deering's 1989 adaptation of Charles Lynn's Nov. 1987 proposal)</t>

          <t>A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw
          RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)</t>

          <t>Combination of the Lynn proposal with TCP (Fred Bohle, Jan 30,
          1990)</t>

          <t>Fragmentation avoidance by setting "IP_DF" flag on all packets
          and retransmitting if ICMPv4 "fragmentation needed" messages occur
          (Geof Cooper's 1987 proposal; later adapted into <xref
          target="RFC1191"></xref> by Mogul and Deering).</t>
        </list></t>

      <t>Option 1) seemed attractive to the group at the time, since it was
      believed that routers would migrate more quickly than hosts. Option 2)
      was a strong contender, but repeated attempts to secure an "RF" bit in
      the IPv4 header from the IESG failed and the proponents became
      discouraged. 3) was abandoned because it was perceived as too
      complicated, and 4) never received any apparent serious consideration.
      Proposal 5) was a late entry into the discussion from Steve Deering on
      Feb. 24th, 1990. The discussion group soon thereafter seemingly lost
      track of all other proposals and adopted 5), which eventually evolved
      into <xref target="RFC1191"></xref> and later <xref
      target="RFC1981"></xref>.</t>

      <t>In retrospect, the "RF" bit postulated in 2) is not needed if a
      "contract" is first established between the peers, as in proposal 4) and
      a message to the MTUDWG mailing list from jrd@PTT.LCS.MIT.EDU on Feb 19.
      1990. These proposals saw little discussion or rebuttal, and were
      dismissed based on the following the assertions:</t>

      <t><list style="symbols">
          <t>routers upgrade their software faster than hosts</t>

          <t>PCs could not reassemble fragmented packets</t>

          <t>Proteon and Wellfleet routers did not reproduce the "RF" bit
          properly in fragmented packets</t>

          <t>Ethernet-FDDI bridges would need to perform fragmentation (i.e.,
          "translucent" not "transparent" bridging)</t>

          <t>the 16-bit IP_ID field could wrap around and disrupt reassembly
          at high packet arrival rates</t>
        </list>The first four assertions, although perhaps valid at the time,
      have been overcome by historical events. The final assertion is
      addressed by the mechanisms specified in SEAL.</t>
    </section>
  </back>
</rfc>
