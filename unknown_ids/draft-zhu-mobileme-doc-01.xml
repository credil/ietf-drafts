<?xml version="1.0"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
     'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<!-- zzzz next line -->
<rfc category="info" ipr="trust200811" docName="draft-zhu-mobileme-doc-01.txt">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<!-- do not keep one blank line between list items -->

<front>
   <title abbrev="BTMM">Understanding Apple's Back to My Mac Service</title>
    <author initials="S" surname="Cheshire" fullname="Stuart Cheshire">
    <organization>Apple Inc.</organization>
    <address>
        <postal>
        <street>1 Infinite Loop</street>
        <city>Cupertino</city><region>CA</region><code>95014</code>
        <country>US</country>
        </postal>
        <phone>+1 408 974 3207</phone>
        <email>cheshire@apple.com</email>
    </address>
    </author>

	<author initials="Z" surname="Zhu" fullname="Zhenkai Zhu">
		<organization>UCLA</organization>
		<address>
			<postal>
				<street>4805 Boelter Hall, UCLA</street>
				<city>Los Angeles</city> <region>CA</region> <code>90095</code>
				<country>US</country>
			</postal>
			<phone>+1 310 993 7128</phone>
			<email>zhenkai@cs.ucla.edu</email>
		</address>
	</author>
	<author initials="R" surname="Wakikawa" fullname="Ryuji Wakikawa">
		<organization>Toyota ITC</organization>
		<address>
			<postal>
				<street>465 Bernardo Avenue</street>
				<city>Mountain View</city> <region>CA</region> <code>94043</code>
				<country>US</country>
			</postal>
			<email>ryuji@jp.toyota-itc.com</email>
		</address>
	</author>

	<author initials="L" surname="Zhang" fullname="Lixia Zhang">
	<organization>UCLA</organization>
	<address>
		<postal>
		<street>3713 Boelter Hall, UCLA</street>
		<city>Los Angeles</city> <region>CA</region> <code>90095</code>
		<country>US</country>
		</postal>
		<phone>+1 310 825 2695</phone>
		<email>lixia@cs.ucla.edu</email>
	</address>
	</author>
   <date year="2010" />
   <area>Internet</area>
   <keyword>Mobility Support, BTMM</keyword>

<abstract>
<t>
This draft describes the implementation of Apple Inc.'s Back to My Mac (BTMM) service. BTMM provides network connectivity between devices so that a user can perform file sharing and screen sharing among multiple computers at home, at work, or on the road. The implementation of BTMM addresses the issues of single sign-on authentication, secure data communication, service discovery and end-to-end connectivity in face of Network Address Translators (NAT) and mobility of devices.
</t>
</abstract>

</front>
<middle>
<section title = "Introduction"> 
<t>
<!-- Apple Computer,Inc. announced MobileMe at WWDC <xref target="WWDC"/> 2008 targeting Mac OSX, Windows, iPhone and iPod users. As of today, MobileMe has attracted multiple millions of subscribers. MobileMe is a bundle of services, including mail, contacts and calendar synchronization, online storage, online photo gallery, personal website hosting and 
-->
The Back to My Mac (BTMM) service was shipped with MAC OS X 10.5 in October 2007.
BTMM provides secure connections among a set of devices over dynamic and heterogeneous network environment. Whether the user is traveling around accessing the Internet with airport wifi, or staying at home behind a NAT, BTMM allows the user to connect to any of his Mac computers with just a click, after which the user can share files with remote computers or control the remote Mac through screen sharing.
When a user is on the road and changes locations and hence the IP addresses (e.g. roaming around with laptop, receiving dynamically allocated IP address, etc.), BTMM provides a way for the roaming host to updates its reachability information. BTMM also provides mechanisms to reach devices behind a NAT.  In order to maintain end-to-end connections in face of IP address changes, BTMM lets each end-host use a unique identifier for TCP connections.  Finally, BTMM also provides security for user data communications.
</t>
<!-- ZZ: we should use MobileMe here, because BTMM is only a part of MobileMe. It is not proper to say BTMM has millions of subscribers, and it is also not proper to say millions of users subscribe to MobileMe because of BTMM -->
<!-- of a possible way in the future to support mobility in the Internet. It is a valuable experience for Internet researchers on mobility support, since few mobility support protocols have been launched in the commercial world, despite the fact that numerous protocols were proposed during the last 20 years. It represents a way of using unique local IPv6 address as an endpoint identifier, which is related to the recent discussion within IETF about endpoint identifier, and serves as another reason why we want to produce this document. 
-->

<t>
BTMM achieves the above goals largely by integrating a set of existing protocols and software tools. 
BTMM uses DNS-based Service Discovery <xref target="DNS-SD" /> to announce host reachability information, uses dynamic DNS Update <xref target="DDNS" /> to refresh the DNS resource records when a host changes locations,
and uses DNS Long-lived Queries <xref target ="DNS-LLQ" /> to make sure that all interested hosts get notified when the content of their interested DNS resource records changes.
It uses the NAT Port Mapping Protocol <xref target="NAT-PMP" /> for NAT traversal, and Kerberos for authentication.
BTMM uses IPv6 ULA addresses as host identifiers, and uses IPsec between a pair of host identifiers to secure data communications. 
</t>
</section>

<section title="Overview of Back to My Mac">
<t><xref target="btmm" /> provides a sketch of the basic components in BTMM implementation.
</t>
<figure anchor="btmm">
<artwork><![CDATA[

        DDNS update    +--------+  DDNS update
      +--------------->|        |<-------+
      |                |  DNS   |        |
      |      LLQ       |        | LLQ    |
      |    +---------->|        |<----+  |
      |    |           |        |     |  |
      |    |           +--------+     |  |
      |    |                          |  |            +---------+
      |    V                      +---+--+----+       |         |
     ++-------+                   |           +-------|         |
     |Endhost1|     Tunnel        |    NAT    +------>|Endhost2 |
     |        |<=====================================>|         |
     +--------+                   |           |       |         |
                                  +-----------+       +---------+
]]></artwork>
</figure>

<t>
In BTMM, every user is assigned a DNS domain under members.me.com domain (e.g. bob.members.me.com), and Apple Inc. provides the DNS service.  The reachability information of the user's machines is published in DNS, and only accessible to the user.
<!-- through a clever way of "abusing" existing DNS resource records.-->
When a user logs in from a computer M, the machine starts updating the Dynamic DNS server about M's reachability information. If the user has multiple machines, M will also set up LLQ with the DNS server, so that the DNS server can push any newly changed resource records to it if any other machines change their reachability information. In case a host is behind a NAT, the public IP address of the NAT box and the port opened for the host will be put in the DNS resource records; otherwise, the public IP address of the host and the port opened on the host are published to DNS instead. Other hosts can then use this information to reach computer M.
</t>

<t>
To enable established connections between a pair of machines to survive IP address changes at either end, the connections must be based on unique and stable identifier for each machine.  BTMM chose to use IPv6 ULA as host identifier, so that all the existing IPv6 application and protocol code can be reused.  For security concerns, BTMM leverages IPsec to protect the communications, and Kerberos is used to do the authentication. 
</t>

<t>Thus, each user data packet originated by BTMM is an IPv6 packet, which is inside the IPsec encapsulation. The outer most headers is the UDP head and IPv4 header that are used for NAT traversal. <xref target="Encapsulation" /> illustrates how an encapsulated packet looks like.  Note that even if both ends have routed public IP addresses, the packet encapsulation process is still the same.
<!-- LZ: what if a host is in public Internet? would the packet look the same? please explain -->
<!-- ZZ: it's the same. -->
<figure anchor="Encapsulation">
<artwork><![CDATA[
 
  +-------------+------+------------+------------------------+
  | IPv4 Header | UDP  | IP6sec ESP |      IPv6 Packet       | 
  +-------------+------+------------+------------------------+
]]></artwork>
</figure>
</t>

<t>The following sections describes each of the basic components in BTMM. Since this draft is intended to be an informal description of the BTMM design, we did not include the details (e.g. packet format, error code, etc) of each component.
 </t>
</section>
<!--<section title="Locating Host via DNS">-->

<section title="Representing Host Location in SRV Records">
<t>
For each host, BTMM must encode into DNS both the host identifier and its current location information. Since many hosts are behind a NAT box, NAT traversal requires a transport port number as well.  BTMM stores the host ID in DNS AAAA records, and utilizes DNS SRV RR to represent the host's current location information.
</t>
<t>
The format of SRV RR <xref target="RFC2782" /> is as following:
</t>
<t>
<figure anchor="SRV">
<artwork><![CDATA[
 
+----------------------+---+-----+---+--------+------+----+------+
| _Service._Proto.Name |TTL|Class|SRV|Priority|Weight|Port|Target|
+----------------------+---+-----+---+--------+------+----+------+
]]></artwork>
</figure>
</t>
<t>The following text explains how BTMM utilizes SRV records to represent the locations of machines.
</t>
<t>Service is the symbolic name of the desired service. In BTMM case, the service is named "autotunnel", which means that the information contained in the SRV RR is used by BTMM to automatically set up a tunnel between two end hosts. 
</t>
<t>Proto is the symbolic name of desired protocol. Typically it is either "_tcp" or "_udp". BTMM uses "_udp" to do the tunneling.
</t>
<t>Name is the domain this RR refers to. When the user subscribes to BTMM service, a domain name "username.members.me.com" is assigned to her. For a particular machine, a user-friendly host name would be appended to the assigned domain name. Hence, the first part of SRV record would look like "_autotunnel._udp.hostname.username.members.me.com". 
</t>
<t>TTL and Class have Standard DNS meaning <xref target="RFC1035"/>. Priority and Weight are always zero, since in BTMM for each Name there is only one instance that provides "autotunnel" service.  
</t>
<t>Port is the port on this target host of this service. In our case, most likely it is the external port a NAT opened for the host behind it. Knowing the port number, the NAT traversal can be achieved via UDP encapsulation. More on NAT traversal will be discussed in next section. If the host is not behind a NAT, the port opened on the host for autotunnel service would be placed here.
</t>
<t>Target is the domain name of the target host. Here it refers to a name constructed by appending an autotunnel label to the domain name, not generally user-visible. The form of autotunnel label is concatenating "AutoTunnel" with the IEEE EUI-64 identifier, which is created according to <xref target="EUI64"/> from the machine's 48bit MAC identifier of the primary interface. The IP address corresponding to the target will be used as external tunnel address during NAT traversal.
</t>
<t>The following is an example of SRV records used by BTMM.

<figure anchor="SRVRR">
<artwork><![CDATA[
+----------------------------------------------+-----+--+---+-+-+----+-------
| _autotunnel._udp.myMacpro.bob.members.me.com |86400|IN|SRV|0|0|7809|AutoTun
+----------------------------------------------+-----+--+---+-+-+----+-------
-----------------------------------------------+
nel-00-22-69-FF-FE-8E-34-2A.bob.members.me.com |
-----------------------------------------------+
]]></artwork>
</figure>
</t>
</section>
<!--
<section title="Finding a Particular Host">
<t>
SRV records help us to find the location of a host. However, before that step, the user needs to know which of his/her machines are available online. This is solved by DNS-Based Service Discovery <xref target="DNS-SD"/>. 
</t>
<t>
One of the motivations for DNS-Based Service Discovery is to that when a client arrives at a new network, it can discover what services are available on that network without manual configuration. In our case, we want to find out which machines are offering autotunnel services in the user's own domain.
</t>
<t>Five special RR names are reserved: 
</t>
<list>
<t> "b._dns-sd._udp." : 
</t>  
<t> "db._dns-sd._udp." : default browsing
</t>
<t> "lb._dns-sd._udp." : automatic browsing
</t>
<t> "r._dns-sd._udp." : used for registering services
</t>
<t> "dr._dns-sd._udp." : default registering
</t>
</list> 
<t>When the user turns on Back to My Mac in BTMM preference, the hosts are registered in DNS by MobileMe. When the machine is power off, the de-registration process runs and it is then no longer listed in DNS. 
</t>
<t>
By default, BTMM periodically browses the service instances (i.e. the user's machines that are online with Back to My Mac turned on) in the user's domain by sending queries for PTR records. The result of PTR lookup is a list of zero or more PTR records that enumerate the service instances. Typically, what shown to the user are the first labels (the user-friendly host names) for the user to select one (or more).
</t>
</section>
-->

<section title="NAT Traversal">
<t>BTMM requires the router devices to support NAT-PMP or UPnP IGD. NAT-PMP is the alternative introduced by Apple Inc. to the more common Internet Gateway Device (IGD) Standardized Device Control Protocol <xref target="IGD" /> as published in UPnP forum. Both NAT-PMP and IGD require that the NAT device can open a port for inbound connections for the host behind it and inform the host about its public IP address. The design difference between IGD and NAT-PMP can be found in <xref target="NAT-PMP"/>. This section focuses on NAT-PMP.
</t>
<section title="Introduction to NAT-PMP">
<t>NAT-PMP is a protocol that is designed specifically to handle the NAT traversal without manual configuration. When a host determines that its primary IPv4 address is in one of the private IP address ranges defined in "Address Allocation for Private Internets" <xref target="RFC1918"/>, it will invoke NAT-PMP to communicate with the NAT gateway to request the creation of inbound mappings on demand.  Having created a NAT mapping to allow inbound connections, the client host can then publish its NAT's public IP address and external port number in a public registry (e.g. DNS as we discussed in last section).
</t>

<t>A host sends its Port Mapping Protocol request to the default gateway, which means that by default, this protocol is designed for small home networks where the host's default gateway is the NAT router. If the host finds that NAT-PMP is not available on its network, it would proceed on assumption that the network is a publicly reachable network.
</t>
</section>

<section title="Requesting/Removing a Port Mapping">
<t>
To request a port mapping, the client host sends its request packet to port 5351 of its configured gateway address, and waits 250ms for a response. If no response is received after 250ms, the host repeats the process with exponential back-off retry timer. 
</t>
<t>
While requesting the port mapping, the host can specify the desired external port(e.g. the port that is identical to the internal port), but the NAT device is not obliged to allocate the desired one. If such port is not available, NAT device responds with another port. The primary reason for allowing host to request a specific port is to help recover from the NAT device crash, so that the host is likely to obtain a port which is the same as the original one (i.e. this allows the end hosts to keep the mapping states and does not require the NAT to keep the mapping state after crash, which turns hard state in the network into soft state, and enables automatic recovery when needed). 
</t>
<t>The recommended port mapping lifetime is 3600 seconds. And the host should begin trying to renew the mapping at 1800 seconds.
</t>
<t>The renewal sent by client host, whether for the purpose of extending lease or recreating mappings on NAT device reboot, is the same as requesting a port mapping. 
</t>
<t>
A mapping may be removed in a variety ways. If a client host fails to renew a mapping, then when its lifetime expires the mapping is automatically deleted. Or if the client host's DHCP address lease expires, the NAT device may automatically delete the mapping. A client host may also send an explicit packet to request deletion of a mapping that is no longer needed.
</t>
</section>
<section title="Obtaining NAT box's Public IP Address">
<t>To determine the public IP address of the NAT, the client host also sends the query packet to port 5351 of the configured gateway address. NAT device should response with a packet containing the public IP address of NAT. 
</t>
<t>In case the public IP address of the NAT changes, the NAT gateway sends a gratuitous response to the link-local multicast address 224.0.0.1, port 5350 to notify the clients about the new IP address.
</t>
</section>
<section title="Un-supported Scenarios">
<t>
There are a number of situations where NAT-PMP (and consequently BTMM) may not work.
</t>
<section title="NAT Behind NAT">
<t>
Some people's primary IP address assigned by their ISP may itself be a NAT address. In addition, some people may have an public IP address, but may then double NAT themselves. NAT traversal can not be achieved with NAT-PMP in such situations.
</t>
</section>
<section title="NATs and Routed Private Networks">
<t>
In some cases, a site may install a NAT gateway and subnet the private network. Such subneting breaks the assumption of NAT-PMP protocol because the router address is not necessarily the address of the device performing NAT.
</t>
</section>
</section>
</section>
<section title="Handling IP Address or Port Changes">
<!--
<t>As of today, more people are accessing Internet on mobile devices than those that access Internet through static wired machines. For BTMM, it is also the case. In fact, for most people, the reason they subscribe to MobileMe service is to accessing/synchronizing with their machines at home when they are traveling around and accessing Internet via MacBooks or iPhones/iPods. The mobile nature of such hosts means that their IP addresses may frequently change with locations. 
</t>
<t>Even for the static wired machines, because most likely their IP addresses are dynamically allocated by the ISPs, it is the usual case that they get different IP addresses after they (or the gateway NAT devices) reboot for whatever reasons.
</t> 
-->
<t>This section describes how BTMM provides a way to handle IP address or port changes, so that the hosts belonging to the same user can find each other and keep ongoing connections even after the change happens at one or both ends.
</t>
<section title="Updating Local Interfaces and Tunnels">
<t>After BTMM receives the notification about the network changes, all interfaces are marked as inactive. Then the system updates the interface list, and at the same time it clears all inactive interfaces. Finally it sets up active interfaces.
</t>
<t>Then, BTMM also needs to send requests to the NAT device (if it is behind a NAT) in order to create a port mapping and obtain the new public IP addresses, as discussed in last section.
</t>
<t>Next step, BTMM makes change to the local autotunnel interface, i.e. configures the IPv6 interface for the inner address of tunnel. If there are established tunnels, it scans to find those that local inner/outer addresses have changed since the tunnel was set up, and then put in the current addresses. 
</t>
<t>With all these done, now the BTMM client needs to publish the changes to DNS.
</t>
</section>
<section title="Dynamically Updating Reachability Information">
<t>
The mobile nature of the BTMM clients implies that Dynamic DNS Update <xref target="DDNS"/>  is required if the location information of hosts are going to be published via DNS. 
</t>
<t>
However, the dynamically updated resource records are often not properly removed, leaving stale RRs in DNS server. Hence, Dynamic DNS Update Leases <xref target="DDUL"/> is used by BTMM to reduce the impact of stale RRs. 
Another possible choice is to overload the resource records' TTL as the removal timer. However, there is a concern about unacceptable amount of network traffic due to refreshes if TTL were used to clear stale resource record, because TTL is usually set to be very short in order to minimize stale cached data in intermedia DNS.
</t>

<t>
In the case of network changes, the resource records of a host should be updated immediately after local interfaces are properly configured and port mapping as well as the public IP address of the NAT are obtained. Usually there are 4 types of resource records involved. An AAAA record for updating the new IPv6 address of the host (possibly the same as the old one); an SRV record for updating the autotunnel service information, which includes the new external port and the new target; an A record for updating the new public IP address of the target; and a TXT record for describing the autotunnel device information. The host then constructs and sends an SRV query for the name _dns-update._udp.user-domain. Then the updates are sent to the Dynamic DNS server returned in the target field of SRV query response. 
</t>
<t>
Besides that, periodically refreshment is also required by the Dynamical DNS Update Leases even though the network may not experience any change. The Update Requests contain a signed 32-bit integer indicating the lease life in seconds. To reduce network and server load, a minimum lease of 30 minutes is recommended. On the other hand, to avoid stale information, a lease longer than 2 hours is not allowed in BTMM case. The typical length is 90 minutes. Resource records not to be deleted by the server must be refreshed by the client host before the lease expires.
</t>

</section>
<section title="Getting Up-to-Date DNS Resource Records by DNS-LLQ">
<t>
In dynamic environments, changes to DNS information are very frequent. How to let the hosts that are concerned about particular DNS resource records know the change efficiently is a challenging question. In traditional DNS, queries are "one-shot" -- a name server will answer a query once, returning the results available at that instant in time. Thus, polling is necessary to learn the changes. This solution is not scalable, however, as low polling rate could leave the client with stale information and a high polling rate would have an adverse impact on the network and server.
</t>
<t>
BTMM relies on DNS long-lived queries <xref target="DNS-LLQ"/> to allow the DNS server to notify the client host about the changes to DNS data.
</t>
<t>
The same as in the case of resource records updates, the client issues an SRV query for the name _dns-llq._udp.user-domain and obtains the server providing LLQs. LLQ is initiated by a client and is completed via a four-way handshake: Initial Request, Challenge, Challenge Response, and ACK + Answers. During the Challenge phase,  the DNS server would provides a unique identifier for the request and the client is required to echo this identifier in Challenge Response phase. This handshake provides resilience to packet loss, demonstrates client reachability and reduces denial-of-service attack opportunities. 
</t>
<t>
LLQ lease is negotiated during the handshake. In BTMM case, the minimum lease is 15 minutes and the maximum lease is 2 hours. Lease must be refreshed before expiration. 
</t>
<t>When a change ("event") occurs to a name server's domain, the server checks if the new or deleted resource records answer any LLQs. If so, the resource records would be sent to the LLQ requesters in the form of a gratuitous DNS response, with the question(s) being answered in the Question section, and answer(s) to the question(s) in the Answer section. Client acknowledges the reception of the notifications, otherwise the server would re-send the response. If a total of 3 transmissions fails, the client is considered unreachable and the LLQ is deleted. 
</t>
<t>BTMM host would then update tunnels according to the query answers. The callback function for automatically setting up tunnels goes as <xref target="callback" /> shows.

<figure anchor="callback">
<artwork><![CDATA[


                       1:  Push Updated AAAA RR       +------------+
                <-----------------------------------  |            | 
                    2: Query for autotunnel SRV RR    |            | 
    +--------+  ----------------------------------->  |            | 
    |        |        3: Reply Updated SRV RR         | DNS server |           
    | client |  <-----------------------------------  |            | 
    |        |      4: Query for Target in SRV RR     |            | 
    +--------+  ----------------------------------->  |            | 
                    5: Reply Updated A RR of Target   |            | 
                <-----------------------------------  |            |     
                                                      +------------+ 
                    
                  In Step 
                  1: client learns the inner IP address of the tunnel
                  3: client learns the port opened for UDP NAT traversal
                  5: client learns the public IP address of the remote NAT,
                     i.e. the outer IP address of the tunnel
                    
]]></artwork>
</figure>
</t>
</section>
</section>
<section title="An Engineering Approach to Augmenting Host with An Identifier">
<section title="Why BTMM Needs Host Identifiers">
<t>
There are a number of reasons why BTMM would need a topology-independent identifier for each client host.
<list style="symbols">
<t>
A host may on the move, thus any identifier that is related to the topology would be constantly changing, which causes great troubles for mobility support and other purposes.
</t>
<t>
The two ends may wish to have the established TCP connections survive network changes.
</t>
<!--<t>
A host may have multiple interfaces and a unique identifier would make it possible to reach a host through multiple interfaces (for greater bandwidth or higher reliability).
</t>
-->
<t>
To facilitate the cryptography protection, sometimes a constant identifier would need to be associated with a key so that the security association can survive the location changes.
</t>
</list>
</t>
<t>
<!--
If the user, while moving, is sharing files among different machines via BTMM, she naturally wishes to keep the TCP connection un-disrupted even she may may cross the boundary of a subnet and connect to the Internet via a new Wifi access point. Besides, BTMM uses IPsec to protect the communications, adding another supportive reason for host identifiers. Finally, all most all MobileMe clients have more than one interfaces, which gives one a temptation to fully utilize the capacity, although this function is not implemented yet.
-->
</t>
</section>
<section title="What to Use As Host Identifier">
<t>
There are several candidates for host identifiers, such as DNS name, HIP <xref target="HIP"/>, and of course IPv6 address. To be accurate, the last one should be IPv6 ULA <xref target="RFC4193"/>, because the globally routable IPv6 address dependents on the topology. So why choose IPv6 ULA?
</t>
<t>
A very pragmatic concern about introducing a host identifier is: do we need to re-write all the protocol and application code? It would be a tedious and error-prone work to migrate all the existing implementations. This gives us a hint: the host identifier should be compatible with existing protocol and application implementations, e.g. something in the same form and length as IP address. This rules out DNS name, which has variable length.
</t>
<t>
For HIP, although it has the same length as IPv6 address and host ID can serve as its public key, we still lack a secure way to retrieve the host ID. Under this condition, using HIP would not bring us much benefit.
</t>
<t>
On the other hand, with IPv6 ULA as host identifier, all the existing code can be used directly. And since in BTMM all the IPv6 addresses are not leaked to the public network, it would not cause any problem to the global Internet. 
</t>
</section>
<section title="IPv6 ULA Configuration">
<t>
In BTMM, IPv6 ULA is advertised to be used in the autotunnel service of the host. Thus, the IPv6 address needs to be configured before BTMM can start its service.
</t>
<t>
When the machine boots up, the IPv6 address for autotunnel service is initialized as zeros and the autotunnel interface is marked as inactive. During the process when BTMM updates the interfaces list (which is performed every time the network changes), if the IPv6 address is found uninitialized, BTMM would randomly generate an IPv6 ULA according to <xref target="RFC4193"/>. The first octet of the ULA is set to be "0xFD", and the following 7 octets are randomly selected from 0~255. Finally, the EUI-64 identifier fills up the rest 8 octets. Since there are 56 random bits plus a theoretically unique EUI-64 identifier, it is unlikely to have the IPv6 ULA collision between any two machines of the same subscriber.
</t>
<t>
This locally generated ULA keeps unchanged when the machine is on, despite its location changes. Hence the user can fully enjoy the benefits brought by topology-independent host identifiers. After the machine power off, this particular ULA is no longer kept. 
</t>
</section>
</section>
<section title="Securing Communication">
<t>
BTMM users often have to fetch their personal data via a network they don't trust (or have no idea whether it's trustworthy). Hence, it is important for BTMM to have effective means to secure the communications.
</t>
<section title="Authentication for Connecting to Remote Host">
<t>Kerberos is a "single sign on" technology and is supported in Apple's products since Mac OS X 10.5. Each Mac OS X client maintains a local Key Distribution Center (KDC) for the use of Bonjour and peer-to-peer security, which means that it is also a component of BTMM.
</t>
<t>When the user first signs in to MobileMe on a host, it automatically receives a digital certificate and private key for "Back to My Mac Encryption Certificate". When the user connects to another system using BTMM, authentication is performed using the standard Public Key Cryptography for Initial Authentication in Kerberos (PKINIT) protocol <xref target ="PKINIT" /> with that certificate. After that, the user is granted a "ticket" that permits it to continue to use the services on the remote machine, without re-authenticating, until the ticket expires, which usually has 10 hours lifetime.
</t>
<!-- <t>(ZZ: I don't find any code related to this. The above is learned from apple support and Back to My Mac User's Guide. I think there is a separate server other than DNS server to handle the "sign-in" process of a BTMM user, e.g. providing the certificates) 
</t> -->
</section>
<section title="Authentication for DNS Request/Response">
<t>
BTMM uses Transaction SIGnature (TSIG) to authenticate user when dynamic DNS update is performed, as specified in <xref target="RFC2845" />. Also, to protect the subscriber's privacy, LLQ is required to contain TSIG. This authentication mechanism is based on the shared secret key, which in BTMM's case is the subscriber's MobileMe account password. <!-- (ZZ: this is my guess. I couldn't find the code related to the secret key used, but the only secret share between Apple and its user is the password). -->
</t>
<t>Every time a DNS request/response is going to be issued, a TSIG RR is dynamically computed with HMAC-MD5 message digest algorithm (and the TSIG RR will be discarded once its has been used). Inside the TSIG RR, a name of the shared secret key in domain name syntax is included, so the receiver knows which key to used (especially useful if the receiver is the DNS server). This TSIG RR is appended to the additional data section before the message is send out. The receiver of the message verifies the TSIG RR and proceeds only if the TSIG is valid.
</t>
<t>Besides, the DNS messages are also protected by TLS <xref target="RFC2246" />, so that it prevents eavesdropping.
</t>
</section>
<section title="Using IPsec to Secure End-to-End Data Communication">
<section title="Internet Key Exchange">
<t>
Before the Security Association can be established between two end hosts, Internet Key Exchange (IKE) process needs to be accomplished.
</t>
<t>
BTMM calls another process Racoon <xref target="Racoon"/> to do the key exchange, after which the key will be put into Security Association Database (SAD). The exchange mode is set to be aggressive so that it would not take too long. And it uses pre-shared key to do the user authentication. The subscriber's FQDN is used as both identifier and pre-shared key during IKE process. 
</t>
</section>
<section title="End-to-End Encryption">
<t>
When it comes the time to set up Security Associations between two BTMM clients, we have two choices: either to put the other host's IPv4 address in the destination address field, or otherwise put in the IPv6 address of the remote end. 
</t>
<t>
If the IPv4 address (which is the public address of a NAT) is chosen to associate with a Security Association, that means we set up a Security Association between one end host and the NAT of the other host. The IPv6 packet would then be wrapped by UDP header and then get encrypted by ESP. After the encrypted packet arrives at the NAT, the NAT device decrypts the packet and sends it to the destination according to the port mapping. Although this approach seems viable, there are 3 drawbacks:
<list style="symbols">
<t>
First, the encryption is not end-to-end, i.e. only the path between one end host and the NAT device of the other end is protected. The rest of the path, from the NAT device to the final receiver, is unprotected and vulnerable to attacks. If the NAT device is not trustworthy, the communication is at high risk. Even if the NAT device is trustworthy (e.g. the user owns the NAT), it is not uncommon that the NAT communicates with the host through broadcast channel, which provides opportunities for eavesdropper to sniff the sensitive data (consider the unlocked "free" wifi access near your neighborhood).
</t>
<t>
Second, quite a lot BTMM clients are on move very often. Every time they change their attachment points to the Internet they will get different IPv4 addresses. As a result, the previously established Security Associations become obsoleted and the two end hosts need to re-establish them again. This is a waste of time and resources.
</t>
<t>
Third, this approach assumes that the NAT device is able and willing to do the IPsec ESP for the host behind it, which is not always the case.
</t>
</list>
</t>
<t>
Consequently, BTMM decides to put the IPv6 ULA into the destination field of IPsec Security Associations. This way, the end-to-end path between the hosts are fully protected, and the Security Associations can survive the network changes since the IPv6 ULA remains the same even the BTMM client changes its location. Furthermore, the encryption is transparent to the NAT device, which means we do not need the NAT device to interfere with the IPsec protection.
</t>
</section>
</section>
</section>

<!--
<section title="Work to Be Done">
<t>After studying the implementation of BTMM, one would raise several questions about the future improvements of BTMM.
</t>
<section title="Can BTMM be generalized to the Internet?">
<t>Despite the commercial success of MobileMe, it is not clear whether BTMM can be generalized to the Internet. A big problem is how should the hosts authenticate each other without pre-shared secrets. Another problem is would LLQ be a problem if the number of hosts are large (e.g. a change of RR needs to be pushed to many hosts).
</t>
</section>
<section title="How about double NAT?">
<t>It is sometimes the case that the host is behind double NAT. How to deal with this problem and whether it is worth to do this is still in question.
</t>
</section>
<section title="Integrating with multipath TCP?">
<t>Today the majority of the hosts have multiple interfaces. It would be great if BTMM can utilize all the interfaces at the same time.
</t>
</section>
<section title="Allowing hosts to notify each other?"> 
<t>Currently, all the locations changes are first published to the DNS servers, and then be propagated to the hosts that are concerned about those changes (usually the ones that are communicating with the moving hosts). However, it is much more efficient if hosts communicating with each other can notify the other end about the location changes directly. Besides, this allows us to get rid of LLQ.
</t>
</section>
</section>
-->
</middle>
<back>
	<references>

		<reference anchor="WWDC">
			<front>
				<title>Worldwide Developers Conference</title>
			</front>
			<seriesInfo name="http" value ="developer.apple.com/wwdc/" />
		</reference>
		<reference anchor="RFC4193">
			<front>
				<title>Unique Local IPv6 Unicast Address</title>
				<author name="R. Hinden">
                </author>
				<author name="B. Haberman">
                </author>
			</front>
			<seriesInfo name="RFC" value ="4193" />
		</reference>
		<reference anchor="DDNS">
			<front>
				<title>Dynamic Updates in the Domain Name System (DNS UPDATE)</title>
				<author name="P. Vixie">
                </author>
				<author name="S. Thomson">
                </author>
				<author name="Y. Rekhter">
                </author>
				<author name="J. Bound">
				</author>
			</front>
			<seriesInfo name="draft" value ="draft-cheshire-dnsext-dns-sd-05.txt" />
		</reference>
		<reference anchor="DNS-SD">
			<front>
				<title>DNS-Based Service Discovery</title>
				<author name="Stuart Cheshire">
                </author>
				<author name="Marc Krochmal">
				</author>
			</front>
			<seriesInfo name="draft" value ="draft-cheshire-dnsext-dns-sd-05.txt" />
		</reference>
		<reference anchor="DNS-LLQ">
			<front>
				<title>DNS Long-Lived Queries</title>
				<author name="Stuart Cheshire">
                </author>
				<author name="Marc Krochmal">
                </author>
				<author name="Kiren Sekar">
				</author>
			</front>
			<seriesInfo name="draft" value ="draft-cheshire-dns-llq-01.txt" />
		</reference>
		<reference anchor="NAT-PMP">
			<front>
				<title>NAT Port Mapping Protocol</title>
				<author name="Stuart Cheshire">
                </author>
				<author name="Marc Krochmal">
                </author>
				<author name="Kiren Sekar">
				</author>
			</front>
			<seriesInfo name="draft" value ="draft-cheshire-nat-pmp-03.txt" />
		</reference>
		<reference anchor="RFC2782">
			<front>
				<title>A DNS RR for specifying the location of services (DNS SRV)</title>
				<author name="A. Gulbrandsen">
                </author>
				<author name="P. Vixie">
                </author>
				<author name="L. Esibov">
				</author>
			</front>
			<seriesInfo name="RFC" value ="2782" />
		</reference>
		<reference anchor="RFC1035">
			<front>
				<title>Domain Names - implementation and specification</title>
				<author name="P. Mockapetris">
                </author>
			</front>
			<seriesInfo name="RFC" value ="1035" />
		</reference>
		<reference anchor="RFC1918">
			<front>
				<title>Address Allocation for Private Internets</title>
				<author name="Y. Rekhter">
                </author>
				<author name="B. Moskowitz">
                </author>
                <author name="D. Karrenberg">
                </author>
                <author name="G. J. de Groot">
                </author>
                <author name="E. Lear">
                </author>
			</front>
			<seriesInfo name="RFC" value ="1918" />
		</reference>
		<reference anchor="EUI64">
			<front>
				<title>Guidelines for 64-bit Global Identifier (EUI-64)</title>
			</front>
			<seriesInfo name="http" value ="://standards.ieee.org/regauth/oui/tutorials/EUI64.html" />
		</reference>
		<reference anchor="DDUL">
			<front>
				<title>Dynamic DNS Update Leases</title>
				<author name="Stuart Cheshire">
                </author>
				<author name="Marc Krochmal">
                </author>
                <author name="Kiren Sekar">
                </author>
			</front>
			<seriesInfo name="draft" value ="-sekar-dns-ul-01.txt" />
		</reference>
		<reference anchor="HIP">
			<front>
				<title>Host Identify Protocol (HIP) Architecture</title>
				<author name="R. Moskowitz">
                </author>
				<author name="P. Nikander">
                </author>
			</front>
			<seriesInfo name="RFC" value ="4423" />
		</reference>
		<reference anchor="RFC2845">
			<front>
				<title>Secret Key Transaction Authentication for DNS (TSIG)</title>
				<author name="P. Vixie">
                </author>
				<author name="O. Gudmundsson">
                </author>
				<author name="D. Eastlake 3rd">
                </author>
				<author name="B. Wellington">
                </author>
			</front>
			<seriesInfo name="RFC" value ="2845" />
		</reference>
		<reference anchor="PKINIT">
			<front>
				<title>Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)</title>
				<author name="L. Zhu">
                </author>
				<author name="B. Tung">
                </author>
			</front>
			<seriesInfo name="RFC" value ="4556" />
		</reference>
		<reference anchor="RFC2246">
			<front>
				<title>The TLS Protocol</title>
				<author name="T. Dierks">
                </author>
				<author name="C. Allen">
                </author>
			</front>
			<seriesInfo name="RFC" value ="2246" />
		</reference>
		<reference anchor="IGD">
			<front>
				<title>Internet Gateway Device(IGD) Standard Device Control Protocol</title>
			</front>
			<seriesInfo name="http" value ="://www.upnp.org/standardizeddcps/igd.asp" />
		</reference>
		<reference anchor="Racoon">
			<front>
				<title>Racoon</title>
			</front>
			<seriesInfo name="http" value ="://netbsd.gw.com/cgi-bin/man-cgi?racoon++NetBSD-current" />
		</reference>
	</references>
</back>
</rfc>
