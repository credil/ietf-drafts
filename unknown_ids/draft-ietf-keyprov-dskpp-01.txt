


KEYPROV Working Group                                         A. Doherty
Internet-Draft                         RSA, The Security Division of EMC
Intended status: Standards Track                                  M. Pei
Expires: May 1, 2008                                      Verisign, Inc.
                                                              S. Machani
                                                        Diversinet Corp.
                                                              M. Nystrom
                                       RSA, The Security Division of EMC
                                                        October 29, 2007


          Dynamic Symmetric Key Provisioning Protocol (DSKPP)
                    draft-ietf-keyprov-dskpp-01.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on May 1, 2008.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   DSKPP is a client-server protocol for initialization (and
   configuration) of symmetric keys to locally and remotely accessible
   cryptographic modules.  The protocol can be run with or without



Doherty, et al.            Expires May 1, 2008                  [Page 1]


Internet-Draft                    DSKPP                     October 2007


   private-key capabilities in the cryptographic modules, and with or
   without an established public-key infrastructure.

   Three variations of the protocol support multiple usage scenarios.
   The four-pass (i.e., two round-trip) variant enables key generation
   in near real-time.  With the four-pass variant, keys are mutually
   generated by the provisioning server and cryptographic module;
   provisioned keys are not transferred over-the-wire or over-the-air.
   Two- and one-pass variants enable secure and efficient download and
   installation of symmetric keys to a cryptographic module in
   environments where near real-time communication may not be possible.

   This document builds on information contained in [RFC4758], adding
   specific enhancements in response to implementation experience and
   liaison requests.  It is intended, therefore, that this document or a
   successor version thereto will become the basis for subsequent
   progression of a symmetric key provisioning protocol specification on
   the standards track.

































Doherty, et al.            Expires May 1, 2008                  [Page 2]


Internet-Draft                    DSKPP                     October 2007


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.1.  Scope . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.2.  Background  . . . . . . . . . . . . . . . . . . . . . . .   7
   2.  Requirements Notation and Terminology . . . . . . . . . . . .   8
   3.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .  11
     3.1.  Single Key Request  . . . . . . . . . . . . . . . . . . .  11
     3.2.  Multiple Key Requests . . . . . . . . . . . . . . . . . .  11
     3.3.  Session Time-Out Policy . . . . . . . . . . . . . . . . .  11
     3.4.  Outsourced Provisioning . . . . . . . . . . . . . . . . .  12
     3.5.  Key Renewal . . . . . . . . . . . . . . . . . . . . . . .  12
     3.6.  Pre-Loaded Key Replacement  . . . . . . . . . . . . . . .  12
     3.7.  Pre-Shared Transport Key  . . . . . . . . . . . . . . . .  12
     3.8.  SMS-Based Key Transport . . . . . . . . . . . . . . . . .  13
     3.9.  Non-Protected Transport Layer . . . . . . . . . . . . . .  13
     3.10. Non-Authenticated Transport Layer . . . . . . . . . . . .  13
   4.  DSKPP Overview  . . . . . . . . . . . . . . . . . . . . . . .  13
     4.1.  Entities  . . . . . . . . . . . . . . . . . . . . . . . .  13
     4.2.  Overview of Protocol Usage  . . . . . . . . . . . . . . .  15
     4.3.  Four-Pass Protocol Usage  . . . . . . . . . . . . . . . .  18
       4.3.1.  Message Flow  . . . . . . . . . . . . . . . . . . . .  19
       4.3.2.  Generation of Symmetric Keys for Cryptographic
               Modules . . . . . . . . . . . . . . . . . . . . . . .  20
       4.3.3.  Client Authentication . . . . . . . . . . . . . . . .  23
       4.3.4.  Key Confirmation  . . . . . . . . . . . . . . . . . .  23
       4.3.5.  Server Authentication . . . . . . . . . . . . . . . .  23
     4.4.  Two-Pass Protocol Usage . . . . . . . . . . . . . . . . .  24
       4.4.1.  Message Flow  . . . . . . . . . . . . . . . . . . . .  26
       4.4.2.  Key Confirmation  . . . . . . . . . . . . . . . . . .  27
       4.4.3.  Server Authentication . . . . . . . . . . . . . . . .  27
     4.5.  One-Pass Protocol Usage . . . . . . . . . . . . . . . . .  28
       4.5.1.  Message Flow  . . . . . . . . . . . . . . . . . . . .  29
       4.5.2.  Key Confirmation  . . . . . . . . . . . . . . . . . .  30
       4.5.3.  Server Authentication . . . . . . . . . . . . . . . .  30
   5.  Methods Common to More Than One Protocol Variant  . . . . . .  31
     5.1.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF  . . .  31
       5.1.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  31
       5.1.2.  Declaration . . . . . . . . . . . . . . . . . . . . .  32
     5.2.  Encryption of Pseudorandom Nonces Sent from the DSKPP
           Client (Applicable to Four-Pass and Two-Pass DSKPP) . . .  32
     5.3.  Client Authentication Mechanisms (Applicable to Four-
           and Two-Pass DSKPP) . . . . . . . . . . . . . . . . . . .  32
       5.3.1.  Device Certificate  . . . . . . . . . . . . . . . . .  33
       5.3.2.  Device Identifier . . . . . . . . . . . . . . . . . .  33
       5.3.3.  Authentication Code . . . . . . . . . . . . . . . . .  33
     5.4.  Client Authentication Examples  . . . . . . . . . . . . .  36
       5.4.1.  Example Using a MAC from an Authentication Code . . .  36



Doherty, et al.            Expires May 1, 2008                  [Page 3]


Internet-Draft                    DSKPP                     October 2007


       5.4.2.  Example Using a Device Certificate  . . . . . . . . .  36
   6.  Four-Pass Protocol  . . . . . . . . . . . . . . . . . . . . .  36
     6.1.  XML Basics  . . . . . . . . . . . . . . . . . . . . . . .  36
     6.2.  Round-Trip #1:  <KeyProvClientHello> and
           <KeyProvServerHello>  . . . . . . . . . . . . . . . . . .  37
       6.2.1.  Examples  . . . . . . . . . . . . . . . . . . . . . .  37
       6.2.2.  Components of the <KeyProvClientHello> Request  . . .  41
       6.2.3.  Components of the <KeyProvServerHello> Response . . .  45
     6.3.  Round-Trip #2: <KeyProvClientNonce> and
           <KeyProvServerFinished> . . . . . . . . . . . . . . . . .  46
       6.3.1.  Examples  . . . . . . . . . . . . . . . . . . . . . .  46
       6.3.2.  Components of a <KeyProvClientNonce> Request  . . . .  47
       6.3.3.  Components of a <KeyProvServerFinished> Response  . .  48
     6.4.  DSKPP Server Results:  The StatusCode Type  . . . . . . .  49
   7.  Two-Pass Protocol . . . . . . . . . . . . . . . . . . . . . .  50
     7.1.  XML Basics  . . . . . . . . . . . . . . . . . . . . . . .  50
     7.2.  Round-Trip #1:  <KeyProvClientHello> and
           <KeyProvServerFinished> . . . . . . . . . . . . . . . . .  51
       7.2.1.  Examples  . . . . . . . . . . . . . . . . . . . . . .  51
       7.2.2.  Components of the <KeyProvClientHello> Request  . . .  59
       7.2.3.  Components of a <KeyProvServerFinished> Response  . .  60
     7.3.  DSKPP Server Results:  The StatusCode Type  . . . . . . .  62
   8.  One-Pass Protocol . . . . . . . . . . . . . . . . . . . . . .  63
     8.1.  XML Basics  . . . . . . . . . . . . . . . . . . . . . . .  63
     8.2.  Server to Client Only: <KeyProvServerFinished>  . . . . .  64
       8.2.1.  Example . . . . . . . . . . . . . . . . . . . . . . .  64
       8.2.2.  Components of a <KeyProvServerFinished> Response  . .  65
   9.  Trigger . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
     9.1.  XML Basics  . . . . . . . . . . . . . . . . . . . . . . .  66
     9.2.  Example . . . . . . . . . . . . . . . . . . . . . . . . .  67
     9.3.  Components of the <KeyProvTrigger> Message  . . . . . . .  67
   10. Extensibility . . . . . . . . . . . . . . . . . . . . . . . .  68
     10.1. The ClientInfoType Type . . . . . . . . . . . . . . . . .  68
     10.2. The ServerInfoType Type . . . . . . . . . . . . . . . . .  68
     10.3. The KeyInitializationDataType Type  . . . . . . . . . . .  68
   11. Key Initialization Profiles of Two- and One-Pass DSKPP  . . .  69
     11.1. Introduction  . . . . . . . . . . . . . . . . . . . . . .  69
     11.2. Key Transport Profile . . . . . . . . . . . . . . . . . .  69
       11.2.1. Introduction  . . . . . . . . . . . . . . . . . . . .  69
       11.2.2. Identification  . . . . . . . . . . . . . . . . . . .  69
       11.2.3. Payloads  . . . . . . . . . . . . . . . . . . . . . .  69
     11.3. Key Wrap Profile  . . . . . . . . . . . . . . . . . . . .  70
       11.3.1. Introduction  . . . . . . . . . . . . . . . . . . . .  70
       11.3.2. Identification  . . . . . . . . . . . . . . . . . . .  71
       11.3.3. Payloads  . . . . . . . . . . . . . . . . . . . . . .  71
     11.4. Passphrase-Based Key Wrap Profile . . . . . . . . . . . .  72
       11.4.1. Introduction  . . . . . . . . . . . . . . . . . . . .  72
       11.4.2. Identification  . . . . . . . . . . . . . . . . . . .  72



Doherty, et al.            Expires May 1, 2008                  [Page 4]


Internet-Draft                    DSKPP                     October 2007


       11.4.3. Payloads  . . . . . . . . . . . . . . . . . . . . . .  72
   12. Protocol Bindings . . . . . . . . . . . . . . . . . . . . . .  73
     12.1. General Requirements  . . . . . . . . . . . . . . . . . .  74
     12.2. HTTP/1.1 Binding for DSKPP  . . . . . . . . . . . . . . .  74
       12.2.1. Introduction  . . . . . . . . . . . . . . . . . . . .  74
       12.2.2. Identification of DSKPP Messages  . . . . . . . . . .  74
       12.2.3. HTTP Headers  . . . . . . . . . . . . . . . . . . . .  74
       12.2.4. HTTP Operations . . . . . . . . . . . . . . . . . . .  74
       12.2.5. HTTP Status Codes . . . . . . . . . . . . . . . . . .  75
       12.2.6. HTTP Authentication . . . . . . . . . . . . . . . . .  75
       12.2.7. Initialization of DSKPP . . . . . . . . . . . . . . .  75
       12.2.8. Example Messages  . . . . . . . . . . . . . . . . . .  75
   13. DSKPP Schema  . . . . . . . . . . . . . . . . . . . . . . . .  76
   14. Security Considerations . . . . . . . . . . . . . . . . . . .  85
     14.1. General . . . . . . . . . . . . . . . . . . . . . . . . .  85
     14.2. Active Attacks  . . . . . . . . . . . . . . . . . . . . .  85
       14.2.1. Introduction  . . . . . . . . . . . . . . . . . . . .  85
       14.2.2. Message Modifications . . . . . . . . . . . . . . . .  85
       14.2.3. Message Deletion  . . . . . . . . . . . . . . . . . .  87
       14.2.4. Message Insertion . . . . . . . . . . . . . . . . . .  87
       14.2.5. Message Replay  . . . . . . . . . . . . . . . . . . .  87
       14.2.6. Message Reordering  . . . . . . . . . . . . . . . . .  88
       14.2.7. Man-in-the-Middle . . . . . . . . . . . . . . . . . .  88
     14.3. Passive Attacks . . . . . . . . . . . . . . . . . . . . .  88
     14.4. Cryptographic Attacks . . . . . . . . . . . . . . . . . .  88
     14.5. Attacks on the Interaction between DSKPP and User
           Authentication  . . . . . . . . . . . . . . . . . . . . .  89
     14.6. Additional Considerations Specific to 2- and 1-pass
           DSKPP . . . . . . . . . . . . . . . . . . . . . . . . . .  89
       14.6.1. Client Contributions to K_TOKEN Entropy . . . . . . .  89
       14.6.2. Key Confirmation  . . . . . . . . . . . . . . . . . .  90
       14.6.3. Server Authentication . . . . . . . . . . . . . . . .  90
       14.6.4. Client Authentication . . . . . . . . . . . . . . . .  90
       14.6.5. Key Protection in the Passphrase Profile  . . . . . .  91
   15. Internationalization Considerations . . . . . . . . . . . . .  91
   16. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  92
   17. Intellectual Property Considerations  . . . . . . . . . . . .  92
   18. Contributors  . . . . . . . . . . . . . . . . . . . . . . . .  92
   19. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  92
   20. References  . . . . . . . . . . . . . . . . . . . . . . . . .  93
     20.1. Normative references  . . . . . . . . . . . . . . . . . .  93
     20.2. Informative references  . . . . . . . . . . . . . . . . .  94
   Appendix A.  Integration with PKCS #11  . . . . . . . . . . . . .  95
     A.1.  The 4-pass Variant  . . . . . . . . . . . . . . . . . . .  96
     A.2.  The 2-pass Variant  . . . . . . . . . . . . . . . . . . .  96
     A.3.  The 1-pass Variant  . . . . . . . . . . . . . . . . . . .  98
   Appendix B.  Example of DSKPP-PRF Realizations  . . . . . . . . . 100
     B.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . 101



Doherty, et al.            Expires May 1, 2008                  [Page 5]


Internet-Draft                    DSKPP                     October 2007


     B.2.  DSKPP-PRF-AES . . . . . . . . . . . . . . . . . . . . . . 101
       B.2.1.  Identification  . . . . . . . . . . . . . . . . . . . 101
       B.2.2.  Definition  . . . . . . . . . . . . . . . . . . . . . 101
       B.2.3.  Example . . . . . . . . . . . . . . . . . . . . . . . 102
     B.3.  DSKPP-PRF-SHA256  . . . . . . . . . . . . . . . . . . . . 102
       B.3.1.  Identification  . . . . . . . . . . . . . . . . . . . 102
       B.3.2.  Definition  . . . . . . . . . . . . . . . . . . . . . 103
       B.3.3.  Example . . . . . . . . . . . . . . . . . . . . . . . 104
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 104
   Intellectual Property and Copyright Statements  . . . . . . . . . 106









































Doherty, et al.            Expires May 1, 2008                  [Page 6]


Internet-Draft                    DSKPP                     October 2007


1.  Introduction

1.1.  Scope

   This document describes a client-server protocol for initialization
   (and configuration) of symmetric keys to locally and remotely
   accessible cryptographic modules.  The protocol can be run with or
   without private-key capabilities in the cryptographic modules, and
   with or without an established public-key infrastructure.  The
   objectives of this protocol are to:

   o     Provide a secure method of initializing cryptographic modules
         with symmetric keys without exposing generated, secret material
         to any other entities than the server and the cryptographic
         module itself.
   o     Provide a secure method of generating and transporting
         symmetric keys to a cryptographic module in environments where
         near real-time communication is not possible.
   o     Provide a secure method of transporting pre-generated (i.e.,
         legacy) keys to a cryptographic module.
   o     Provide a solution that is easy to administer and scales well.

   The mechanism is intended for general use within computer and
   communications systems employing symmetric key cryptographic modules
   that are locally (i.e., over-the-wire) or remotely (i.e., over-the-
   air) accessible.

1.2.  Background

   A locally accessible symmetric key cryptographic module may be hosted
   by, for example, a hardware device connected to a personal computer
   through an electronic interface, such as USB, or a software
   application resident on a personal computer.  A remotely accessible
   symmetric key cryptographic module may be hosted by, for example, any
   device that can support over-the-air communication, such as a hand-
   held hardware device (e.g., a mobile phone).  The cryptographic
   module itself offers symmetric key cryptographic functionality that
   may be used to authenticate a user towards some service, perform data
   encryption, etc.  Increasingly, these modules enable their
   programmatic initialization as well as programmatic retrieval of
   their output values.  This document intends to meet the need for an
   open and inter-operable mechanism to programmatically initialize and
   configure symmetric keys to locally and remotely accessible
   cryptographic modules.

   The target mechanism makes use of a symmetric key provisioning
   server.  In an ideal deployment scenario, near real-time
   communication is possible between the provisioning server and the



Doherty, et al.            Expires May 1, 2008                  [Page 7]


Internet-Draft                    DSKPP                     October 2007


   cryptographic module.  In such an environment, it is possible for the
   cryptographic module and provisioning server to mutually generate a
   symmetric key, and to ensure that keys are not transported between
   them.

   There are, however, several deployment scenarios that make mutual key
   generation less suitable.  Specifically, scenarios where near real-
   time communication between the symmetric key provisioning server and
   the cryptographic module is not possible, and scenarios with
   significant design constraints.  Examples include work-flow
   constraints (e.g., policies that require incremental administrative
   approval), network design constraints that create network latency,
   and budget constraints that sustain reliance upon legacy systems that
   already have supplies of pre-generated keys.  In these situations,
   the cryptographic module is required to download and install a
   symmetric key from the provisioning server in a secure and efficient
   manner.

   This document tries to meet the needs of these scenarios by
   describing three variations to DSKPP for the provisioning of
   symmetric keys in two round trips or less.  The four-pass (i.e., two
   round-trip) variant enables key generation in near real-time.  With
   this variant, keys are mutually generated by the provisioning server
   and cryptographic module; provisioned keys are not transferred over-
   the-wire or over-the-air.  In contrast, two- and one-pass variants
   enable secure and efficient download and installation of symmetric
   keys to a cryptographic module in environments where near real-time
   communication is not possible.


2.  Requirements Notation and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].


   The following notations are used in this document:

   ||              String concatenation

   [x]             Optional element x

   A ^ B           Exclusive-OR operation on strings A and B (where A
                   and B are of equal length)






Doherty, et al.            Expires May 1, 2008                  [Page 8]


Internet-Draft                    DSKPP                     October 2007


   ENC_X(Y)        Encryption of message Y with symmetric key X, using a
                   defined block cipher

   ENC_PX(Y)       Encryption using message Y with a public key X

   KDF_X(Y)        Key derivation function that generates an arbitrary
                   number of octets of output using secret X and seed Y

   DSKPP-PRF_X(Y,Z)  Pseudo random function that generates a fixed
                   number Z of octets using secret X and seed Y (used in
                   DSKPP methods for MAC computations and key
                   derivation)

   MAC_X(Y)        Keyed message authentication code computed over Y
                   with symmetric key X

   SIGN_x(Y)       Function that provides authentication and integrity
                   protection of message content Y using private key x

   B64(X)          Base 64 encoding of string X

   H(X)            Hash function applied to X

   Alg_List        List of encryption and MAC algorithms supported by
                   the client

   Alg_Sel         Algorithms list selected by the server for the DSKPP
                   protocol run

   DSKPP client    Manages communication between the symmetric key
                   cryptographic module and the DSKPP server

   DSKPP server    The symmetric key provisioning server that
                   participates in the DSKPP protocol run

   Issuer          The organization that issues or authorizes issuance
                   of the symmetric key to the end user of the symmetric
                   key cryptographic module (e.g., a bank who issues
                   one-time password authentication tokens to their
                   retail banking users)
   ID_C            Identifier for DSKPP client

   ID_S            Identifier for DSKPP server








Doherty, et al.            Expires May 1, 2008                  [Page 9]


Internet-Draft                    DSKPP                     October 2007


   AUTHCODE        Client Authentication Code comprised of a string of
                   numeric characters known to the device and the server
                   and containing an identifier and a password (the
                   AUTHCODE may be used to derive the AUTHDATA during
                   the DSKPP protocol exchange)

   AUTHDATA        Client Authentication Data that may be derived from
                   the AUTHCODE or using the client private key,
                   k_CLIENT

   K               Key used to encrypt R_C (either K_SERVER or K_SHARED)

   K_AUTHCODE      Secret key that is derived from AUTHCODE and used for
                   client authentication purposes

   k_CLIENT        Private key of the DSKPP client

   K_CLIENT        Public key of the DSKPP client

   K_DERIVED       Secret key derived from a passphrase that is known to
                   both the DSKPP client or user and the DSKPP server

   K_MAC           Secret key used for key confirmation and server
                   authentication purposes, and generated in DSKPP

   K_MAC'          A second secret key used for server authentication
                   purposes in 2- and 1-pass DSKPP

   K_SERVER        Public key of the DSKPP server

   K_SHARED        Secret key shared between the DSKPP client and the
                   DSKPP server

   K_TOKEN         Secret key used for cryptographic module
                   computations, and generated in DSKPP

   K_CONFDATA      Key configuration data carried within the key
                   container

   R               Pseudorandom value chosen by the DSKPP client and
                   used for MAC computations, which is mandatory for
                   2-pass DSKPP and optional for 4-pass

   R_C             Pseudorandom value chosen by the DSKPP client and
                   used as input to the generation of K_TOKEN






Doherty, et al.            Expires May 1, 2008                 [Page 10]


Internet-Draft                    DSKPP                     October 2007


   R_S             Pseudorandom value chosen by the DSKPP server and
                   used as input to the generation of K_TOKEN

   URL_S           Server address as a URL

   I               Unsigned integer representing a counter value that is
                   monotonically increasing and guaranteed not to be
                   used again by the server towards the cryptographic
                   module

   I'              Similar to I except I' is always higher than I


   The following typographical convention is used in the body of the
   text: <XMLElement>.


3.  Use Cases

   This section describes typical use cases.

3.1.  Single Key Request

   A cryptographic module hosted by a device, such as a mobile phone,
   makes a request for a symmetric key from a provisioning server.
   Depending upon how the system is deployed, the provisioning server
   may generate a new key on-the-fly or use a pre-generated key, e.g.,
   one provided by a legacy back-end issuance server.  The provisioning
   server assigns a unique key ID to the symmetric key and provisions it
   to the cryptographic module.

3.2.  Multiple Key Requests

   A cryptographic module makes multiple requests for symmetric keys
   from the same provisioning server.  The symmetric keys may or may not
   be of the same type, i.e., the keys may be used with different
   symmetric key cryptographic algorithms, including one-time password
   authentication algorithms, and AES encryption algorithm.

3.3.  Session Time-Out Policy

   Once a cryptographic module initiates a symmetric key request, the
   provisioning server may require that any subsequent actions to
   complete the provisioning cycle occur within a certain time window.
   For example, an issuer may provide a time-limited authentication code
   to a user during registration, which the user will input into the
   cryptographic module to authenticate themselves with the provisioning
   server.  If the user inputs a valid authentication code within the



Doherty, et al.            Expires May 1, 2008                 [Page 11]


Internet-Draft                    DSKPP                     October 2007


   fixed time period established by the issuer, the server will allow a
   key to be provisioned to the cryptographic module hosted by the
   user's device.

3.4.  Outsourced Provisioning

   A symmetric key issuer outsources its key provisioning to a third
   party key provisioning server provider.  The issuer is responsible
   for authenticating and granting rights to users to acquire keys while
   acting as a proxy to the cryptographic module to acquire symmetric
   keys from the provisioning server; the cryptographic module
   communicates with the issuer proxy server, which forwards
   provisioning requests to the provisioning server.

3.5.  Key Renewal

   A cryptographic module requests renewal of a symmetric key using the
   same key ID already associated with the key.  Such a need may occur
   in the case when a user wants to upgrade her device that houses the
   cryptographic module or when a key has expired.  When a user uses the
   same cryptographic module to, for example, perform strong
   authentication at multiple Web login sites, keeping the same key ID
   removes the need for the user to register a new key ID at each site.

3.6.  Pre-Loaded Key Replacement

   This use case represents a special case of symmetric key renewal in
   which a local administrator can authenticate the user procedurally
   before initiating the provisioning process.  It also allows for an
   issuer to pre-load a key onto a cryptographic module with a
   restriction that the key is replaced with a new key prior to use of
   the cryptographic module.  Another variation of this use case is the
   issuer who recycles devices.  In this case, an issuer would provision
   a new symmetric key to a cryptographic module hosted on a device that
   was previously owned by another user.

   Note that this use case is essentially the same as the last use case
   wherein the same key ID is used for renewal.

3.7.  Pre-Shared Transport Key

   A cryptographic module is loaded onto a smart card after the card is
   issued to a user.  The symmetric key for the cryptographic module
   will then be provisioned using a secure channel mechanism present in
   many smart card platforms.  This allows a direct secure channel to be
   established between the smart card chip and the provisioning server.
   For example, the card commands (i.e., Application Protocol Data
   Units, or APDUs) are encrypted with a pre-shared transport key and



Doherty, et al.            Expires May 1, 2008                 [Page 12]


Internet-Draft                    DSKPP                     October 2007


   sent directly to the smart card chip, allowing secure post-issuance
   in-the-field provisioning.  This secure flow can pass Transport Layer
   Security (TLS) and other transport security boundaries.

   Note that two pre-conditions for this use case are for the protocol
   to be tunneled and the provisioning server to know the correct pre-
   established transport key.

3.8.  SMS-Based Key Transport

   A mobile device supports Short Message Service (SMS) but is not able
   to support a data service allowing for HTTP or HTTPS transports.  In
   addition, an application may use a cryptographic module to enforce an
   acceptable level of protection for download of the symmetric key via
   SMS.  In such a case, the cryptographic module hosted by the mobile
   device may initiate a symmetric key request from a desktop computer
   and ask the server to send the key to the mobile device through SMS.
   User authentication is carried out via the online communication
   established between the desktop computer and the provisioning server.

3.9.  Non-Protected Transport Layer

   Some devices are not able to support a secure transport channel such
   as SSL or TLS to provide data confidentiality.  A cryptographic
   module hosted by such a device requests a symmetric key from the
   provisioning server.  It is up to DSKPP to ensure data
   confidentiality over non-secure networks.

3.10.  Non-Authenticated Transport Layer

   Some devices are not able to use a transport protocol that provides
   server authentication such as SSL or TLS.  A cryptographic module
   hosted by such a device wants to be sure that it sends a request for
   a symmetric key to a legitimate provisioning server.  It is up to
   DSKPP to provide proper client and server authentication.


4.  DSKPP Overview

4.1.  Entities

   In principle, the protocol involves a DSKPP client and a DSKPP
   server.  The DSKPP client manages communication between the
   cryptographic module and the provisioning server.  The DSKPP server
   herein represents the provisioning server.

   A high-level object model that describes the client-side entities and
   how they relate to each other is shown in Figure 1.



Doherty, et al.            Expires May 1, 2008                 [Page 13]


Internet-Draft                    DSKPP                     October 2007


   -----------          -------------
   | User    |          | Device    |
   |---------|*  owns  *|-----------|
   | UserID  |--------->| DeviceID  |
   | ...     |          | ...       |
   -----------          -------------
                            | 1
                            |
                            | contains
                            |
                            | *
                            V
                      -----------------------
                      |Cryptographic Module |
                      |---------------------|
                      |CryptoModuleID
                      |Encryption Algorithms|
                      |MAC Algorithms       |
                      |...                  |
                      -----------------------
                            | 1
                            |
                            | contains
                            |
                            | *
                            V
                      -----------------------
                      |Key Container        |
                      |---------------------|
                      |KeyID                |
                      |Key Type             |
                      |...                  |
                      -----------------------

                          Figure 1: Object Model

   Conceptually, each entity represents the following:

   User:                   The person or client to whom devices are
                           issued

   UserID:                 A unique identifier for the user or client

   Device:                 A physical piece of hardware or software
                           framework that hosts symmetric key
                           cryptographic modules





Doherty, et al.            Expires May 1, 2008                 [Page 14]


Internet-Draft                    DSKPP                     October 2007


   DeviceID:               A unique identifier for the device

   Cryptographic Module:   A component of an application, which enables
                           symmetric key cryptographic functionality

   CryptoModuleID:         A unique identifier for an instance of the
                           cryptographic module

   Encryption Algorithms:  Encryption algorithms supported by the
                           cryptographic module

   MAC Algorithms:         MAC algorithms supported by the cryptographic
                           module

   Key Container:          An object that encapsulates a symmetric key
                           and its configuration data

   KeyID:                  A unique identifier for the symmetric key

   Key Type:               The type of symmetric key cryptographic
                           methods for which the key will be used (e.g.,
                           OATH HOTP or RSA SecurID authentication, AES
                           encryption, etc.)

   It is assumed that a device will host an application layered above
   the cryptographic module, and this application will manage
   communication between the DSKPP client and cryptographic module.  The
   manner in which the communicating application will transfer DSKPP
   protocol elements to and from the cryptographic module is transparent
   to the DSKPP server.  One method for this transfer is described in
   [CT-KIP-P11].

4.2.  Overview of Protocol Usage

   DSKPP enables symmetric key provisioning between a DSKPP server and
   DSKPP client.  The DSKPP protocol supports the following types of
   requests and responses:

      <KeyProvClientHello>

          With this request, a DSKPP client initiates contact with the
          DSKPP server, indicating what protocol versions and variants,
          key types, encryption and MAC algorithms that it supports.  In
          addition, the request may include client authentication data
          that the DSKPP server uses to verify proof-of-possession of
          the device.

      <KeyProvServerHello>



Doherty, et al.            Expires May 1, 2008                 [Page 15]


Internet-Draft                    DSKPP                     October 2007


          Upon reception of a <KeyProvClientHello> request, the DSKPP
          server uses the <KeyProvServerHello> response to specify which
          protocol version and variant, key type, encryption algorithm,
          and MAC algorithm that will be used by the DSKPP server and
          DSKPP client during the protocol run.  The decision of which
          variant, key type, and cryptographic algorithms to pick is
          policy- and implementation-dependent and therefore outside the
          scope of this document.
          The <KeyProvServerHello> response includes the DSKPP server's
          random nonce, R_S. The response also consists of information
          about either a shared secret key, or its own public key, that
          the DSKPP client uses when sending its protected random nonce,
          R_C, in the <KeyProvClientNonce> request (see below).
          Optionally, the DSKPP server may provide a MAC that the DSKPP
          client may use for server authentication.


      <KeyProvClientNonce>

          With this request, a DSKPP client and DSKPP server securely
          exchange protected data, e.g., the protected random nonce R_C.
          In addition, the request may include client authentication
          data that the DSKPP server uses to verify proof-of-possession
          of the device.

      <KeyProvServerFinished>

          The <KeyProvServerFinished> response is a confirmation message
          that includes a key container that holds configuration data,
          and may also contain protected key material (this depends on
          the protocol variant, as discussed below).
          Optionally, the DSKPP server may provide a MAC that the DSKPP
          client may use for server authentication.

   To initiate a DSKPP session:
   1.  A user may use a browser to connect to a web server that is
       running on some host.  The user may then identify (and optionally
       authenticate) herself (through some means that essentially are
       out of scope for this document) and request a symmetric key.
   2.  A client application may request a symmetric key by invoking the
       DSKPP client.
   3.  A DSKPP server may send a trigger message to a client
       application, which would then invoke the DSKPP client.

   To contact the DSKPP server:






Doherty, et al.            Expires May 1, 2008                 [Page 16]


Internet-Draft                    DSKPP                     October 2007


   1.  A user may indicate how the DSKPP client is to contact a certain
       DSKPP server during a browsing session.
   2.  A DSKPP client may be pre-configured to contact a certain DSKPP
       server.
   3.  A user may be informed out-of-band about the location of the
       DSKPP server.

   Once the location of the DSKPP server is known, the DSKPP client and
   the DSKPP server engage in a 4-pass, 2-pass, or 1-pass protocol.
   Depending upon the policy and implementation, a DSKPP server selects
   which variant of the protocol to use: 4-pass, 2-pass, or 1-pass.
   With the four-pass variant, keys are mutually generated by the DSKPP
   server and DSKPP client; provisioned keys are not transferred over-
   the-wire or over-the-air.  Two- and one-pass variants enable secure
   and efficient download and installation of symmetric keys to a DSKPP
   client in environments where near real-time communication may not be
   possible.Figure 2 shows which messages get exchanged during each type
   of protocol run (4-pass, 2-pass, or 1-pass).
   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        [ <---- DSKPP trigger ----- ]       |
           |                                            |
           |        ------- Client Hello ------->       |
           |        (Applicable to 4- and 2-pass)       |
           |                                            |
           |        <------ Server Hello --------       |
           |         (Applicable to 4-pass only)        |
           |                                            |
           |        ------- Client Nonce ------->       |
           |         (Applicable to 4-pass only)        |
           |                                            |
           |        <----- Server Finished ------       |
           |      (Applicable to 4-, 2-, and 1-pass)    |
           |                                            |

      Figure 2: The DSKPP protocol (with OPTIONAL preceding trigger)

   The table below identifies which protocol variants may be applied to
   the use cases from Section 3:








Doherty, et al.            Expires May 1, 2008                 [Page 17]


Internet-Draft                    DSKPP                     October 2007


   ----------------------------------------------------------
   Protocol   Applicable                Applicable
   Variant    Use Cases                 Deployment Scenarios
   ----------------------------------------------------------
   4-pass     All but 3.6 and           Near real-time
              3.8 if mutual key         communication is
              generation is desired;    possible
              none if transport of
              a pre-generated key

   2-pass     All                       Either near real-time
                                        or non real-time
                                        communication may be
                                        possible

   1-pass     All but 3.8               Either near real-time
                                        or non real-time
                                        communication may be
                                        possible

            Figure 3: Mapping of protocol variants to use cases

4.3.  Four-Pass Protocol Usage

   The 4-pass protocol flow is suitable for environments wherein there
   is near real-time communication possible between the DSKPP client and
   DSKPP server.  It is not suitable for environments wherein
   administrative approval is a required step in the flow, nor for
   provisioning of pre-generated keys.

   The full four-pass protocol exchange is as follows:

   [<Trigger>]:

      [ID_Device], [ID_K], [URL_S], [R_S]

   <KeyProvClientHello>:

      [ID_Device], [ID_K], [R_S], Alg_List

   <KeyProvServerHello>:

      R_S, Alg_Sel, [K_SERVER], [DSKPP-PRF_K_MAC'("MAC 1 Computation" ||
      [R] || R_S, len(R_S))

   <KeyProvClientNonce>:





Doherty, et al.            Expires May 1, 2008                 [Page 18]


Internet-Draft                    DSKPP                     October 2007


      AUTHDATA, ENC_PK_SERVER(R_C) OR AUTHDATA, ENC_K_SHARED(R_C)

   <KeyProvServerFinished>:

      K_CONFDATA, DSKPP-PRF_K_MAC("MAC 2 Computation"||R_C, len(R_C))

   The following subsections describe the exchange in more detail.

4.3.1.  Message Flow

   The 4-pass protocol flow consists of two round trips between the
   DSKPP client and DSKPP server (see Figure 2), where each round-trip
   involves two "passes", i.e., one request message and one response
   message:

   Round-trip #1:  Pass 1 = <KeyProvClientHello>, Pass 2 =
                   <KeyProvServerHello>

   Round-trip #2:  Pass 3 = <KeyProvClientNonce>, Pass 4 =
                   <KeyProvServerFinished>

4.3.1.1.  Round-trip #1: <KeyProvClientHello> and <KeyProvServerHello>

   The DSKPP client sends a <KeyProvClientHello> message to the DSKPP
   server.  The message provides information to the DSKPP server about
   the DSKPP versions, protocol variants, key types, encryption and MAC
   algorithms supported by the cryptographic module for the purposes of
   this protocol.

   The DSKPP server responds to the DSKPP client with a
   <KeyProvServerHello> message, whose content includes a random nonce,
   R_S, along with information about the type of key to generate, and
   the encryption algorithm chosen to protect sensitive data sent in the
   protocol.  The length of the nonce R_S may depend on the selected key
   type.  The <KeyProvServerHello> message also provides information
   about either a shared secret key to use for encrypting the
   cryptographic module's random nonce (see description of
   <KeyProvClientNonce> below), or its own public key.  Optionally,
   <KeyProvServerHello> may include a MAC that the DSKPP client may use
   for server authentication during key replacement.

4.3.1.2.  Round-trip #2: <KeyProvClientNonce> and
          <KeyProvServerFinished>

   Based on information contained in the <KeyProvServerHello> message,
   the cryptographic module generates a random nonce, R_C. The length of
   the nonce R_C may depend on the selected key type.  The cryptographic
   module encrypts R_C using the selected encryption algorithm and with



Doherty, et al.            Expires May 1, 2008                 [Page 19]


Internet-Draft                    DSKPP                     October 2007


   a key, K, that is either the DSKPP server's public key, K_SERVER, or
   a shared secret key, K_SHARED, as indicated by the DSKPP server.  If
   K is equivalent to K_SERVER, then the cryptographic module SHOULD
   verify the server's certificate before using it to encrypt R_C in
   accordance with [RFC3280].  The DSKPP client then sends the encrypted
   random nonce to the DSKPP server in a <KeyProvClientNonce> message,
   and may include client authentication data, such as a certificate or
   MAC derived from an authentication code and R_C. Finally, the
   cryptographic module calculates a symmetric key, K_TOKEN, of the
   selected type from the combination of the two random nonces R_S and
   R_C, the encryption key K, and possibly some other data, using the
   DSKPP-PRF function defined in Section 5.1.

   The DSKPP server decrypts R_C, calculates K_TOKEN from the
   combination of the two random nonces R_S and R_C, the encryption key
   K, and possibly some other data, using the DSKPP-PRF function defined
   in Section 5.1.  The server then associates K_TOKEN with the
   cryptographic module in a server-side data store.  The intent is that
   the data store later on will be used by some service that needs to
   verify or decrypt data produced by the cryptographic module and the
   key.

   Once the association has been made, the DSKPP server sends a
   confirmation message to the DSKPP client called
   <KeyProvServerFinished>.  Optionally, <KeyProvServerFinished> may
   include a MAC that the DSKPP client may use for server
   authentication.  The confirmation message includes a key container
   that holds an identifier for the generated key (but not the key
   itself) and additional configuration information, e.g., the identity
   of the DSKPP server.  The default symmetric key container format that
   is used in the <KeyProvServerFinished> message is based on the
   Portable Symmetric Key Container (PSKC) defined in [PSKC].
   Alternative formats MAY include PKCS#12 [PKCS-12] or PKCS#5 XML
   [PKCS-5-XML] format.

   Upon receipt of the DSKPP server's confirmation message, the
   cryptographic module associates the provided key container with the
   generated key K_TOKEN, and stores any provided configuration data.


4.3.2.  Generation of Symmetric Keys for Cryptographic Modules

   With 4-pass DSKPP, the symmetric key that is the target of
   provisioning, is generated on-the-fly without being transferred
   between the DSKPP client and DSKPP server.  A sample data flow
   depicting how this works followed by computational information are
   provided in the subsections below.




Doherty, et al.            Expires May 1, 2008                 [Page 20]


Internet-Draft                    DSKPP                     October 2007


4.3.2.1.  Data Flow

   A sample data flow showing key generation during the 4-pass protocol
   is shown in Figure 4.
   +----------------------+    +-------+     +----------------------+
   |    +------------+    |    |       |     |                      |
   |    | Server key |    |    |       |     |                      |
   | +<-|  Public    |------>------------->-------------+---------+ |
   | |  |  Private   |    |    |       |     |          |         | |
   | |  +------------+    |    |       |     |          |         | |
   | |        |           |    |       |     |          |         | |
   | V        V           |    |       |     |          V         V |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |      |  +--------+ |    |       |     |            ^       | |
   | |      |  | Server | |    |       |     |            |       | |
   | |      |  | Random |--->------------->------+  +----------+  | |
   | |      |  +--------+ |    |       |     |   |  | Client   |  | |
   | |      |      |      |    |       |     |   |  | Random   |  | |
   | |      |      |      |    |       |     |   |  +----------+  | |
   | |      |      |      |    |       |     |   |        |       | |
   | |      V      V      |    |       |     |   V        V       | |
   | |   +------------+   |    |       |     | +------------+     | |
   | +-->|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |<----+ |
   |     +------------+   |    |       |     | +------------+       |
   |           |          |    |       |     |       |              |
   |           V          |    |       |     |       V              |
   |       +-------+      |    |       |     |   +-------+          |
   |       |  Key  |      |    |       |     |   |  Key  |          |
   |       +-------+      |    |       |     |   +-------+          |
   |       +-------+      |    |       |     |   +-------+          |
   |       |Key Id |-------->------------->------|Key Id |          |
   |       +-------+      |    |       |     |   +-------+          |
   +----------------------+    +-------+     +----------------------+
         DSKPP Server         DSKPP Client         DSKPP Client
                               (PC Host)      (cryptographic module)

   Figure 4: Principal data flow for DSKPP key generation             -
                          using public server key

   Note: Conceptually, although R_C is one pseudorandom string, it may
   be viewed as consisting of two components, R_C1 and R_C2, where R_C1
   is generated during the protocol run, and R_C2 can be pre-generated
   and loaded on the cryptographic module before the device is issued to
   the user.  In that case, the latter string, R_C2, SHOULD be unique
   for each cryptographic module.




Doherty, et al.            Expires May 1, 2008                 [Page 21]


Internet-Draft                    DSKPP                     October 2007


   The inclusion of the two random nonces R_S and R_C in the key
   generation provides assurance to both sides (the cryptographic module
   and the DSKPP server) that they have contributed to the key's
   randomness and that the key is unique.  The inclusion of the
   encryption key K ensures that no man-in-the-middle may be present, or
   else the cryptographic module will end up with a key different from
   the one stored by the legitimate DSKPP server.

   Note: A man-in-the-middle (in the form of corrupt client software or
   a mistakenly contacted server) may present his own public key to the
   cryptographic module.  This will enable the attacker to learn the
   client's version of K_TOKEN.  However, the attacker is not able to
   persuade the legitimate server to derive the same value for K_TOKEN,
   since K_TOKEN is a function of the public key involved, and the
   attacker's public key must be different than the correct server's (or
   else the attacker would not be able to decrypt the information
   received from the client).  Therefore, once the attacker is no longer
   "in the middle," the client and server will detect that they are "out
   of sync" when they try to use their keys.  In the case of encrypting
   R_C with K_SERVER, it is therefore important to verify that K_SERVER
   really is the legitimate server's key.  One way to do this is to
   independently validate a newly generated K_TOKEN against some
   validation service at the server (e.g. by using a connection
   independent from the one used for the key generation).

4.3.2.2.  Computing the Symmetric Key

   In DSKPP, keys are generated using the DSKPP-PRF function defined in
   Section 5.1, a secret random value R_C chosen by the DSKPP client, a
   random value R_S chosen by the DSKPP server, and the key k used to
   encrypt R_C. The input parameter s of DSKPP-PRF is set to the
   concatenation of the (ASCII) string "Key generation", k, and R_S, and
   the input parameter dsLen is set to the desired length of the key,
   K_TOKEN (the length of K_TOKEN is given by the key's type):

   dsLen = (desired length of K_TOKEN)

   K_TOKEN = DSKPP-PRF (R_C, "Key generation" || k || R_S, dsLen)

   When computing K_TOKEN above, the output of DSKPP-PRF MAY be subject
   to an algorithm-dependent transform before being adopted as a key of
   the selected type.  One example of this is the need for parity in DES
   keys.








Doherty, et al.            Expires May 1, 2008                 [Page 22]


Internet-Draft                    DSKPP                     October 2007


4.3.3.  Client Authentication

   To ensure that a generated key K_TOKEN ends up associated with the
   correct cryptographic module and user, the DSKPP client using any of
   the methods described in Section 5.3.  Whatever the method, the DSKPP
   server MUST ensure that a generated key is associated with the
   correct cryptographic module, and if applicable, the correct user.

4.3.4.  Key Confirmation

   In four-pass DSKPP, the client includes a nonce R_C in the
   <KeyProvClientHello> message.  The MAC value in the
   <KeyProvServerFinished> message MUST be computed on the (ASCII)
   string "MAC 2 computation", the client nonce R_C using a MAC key
   K_MAC.  This key MUST be generated together with K_TOKEN using R_C
   and R_S.

   The MAC value in <KeyProvServerFinished> MAY be computed by using the
   DSKPP-PRF function of Section 5.1, in which case the input parameter
   s MUST consist of the concatenation of the (ASCII) string "MAC 2
   computation", R_C, the parameter dsLen MUST be set to the length of
   R_C:

   dsLen = len(R_C)

   MAC = DSKPP-PRF (K_MAC, "MAC 2 computation" || R_C, dsLen)

4.3.5.  Server Authentication

   A DSKPP server MUST authenticate itself to avoid a false "Commit" of
   a symmetric key that which could cause the cryptographic module to
   end up in an initialized state for which the server does not know the
   stored key.  To do this, the DSKPP server authenticates itself by
   including a MAC value in the <KeyProvServerHello> message when
   replacing a existing key.  The MAC value is generated using the
   existing the MAC key K_MAC' (the MAC key that existed before this
   protocol run).  The MAC algorithm MUST be the same as the algorithm
   used for key confirmation purposes.  In addition, a DSKPP server can
   leverage transport layer authentication if it is available.

   When the MAC value is used for server authentication, the value MAY
   be computed by using the DSKPP-PRF function of Section 5.1, in which
   case the input parameter s MUST be set to the concatenation of the
   (ASCII) string "MAC 1 computation", R (if sent by the client), and
   R_S, and k MUST be set to the existing MAC key K_MAC' .  The input
   parameter dsLen MUST be set to the length of R_S:

   dsLen = len(R_S)



Doherty, et al.            Expires May 1, 2008                 [Page 23]


Internet-Draft                    DSKPP                     October 2007


   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || [R ||] R_S, dsLen)

4.4.  Two-Pass Protocol Usage

   The 2-pass protocol flow is suitable for environments wherein near
   real-time communication between the DSKPP client and server may not
   be possible.  It is also suitable for environments wherein
   administrative approval is a required step in the flow, and for
   provisioning of pre-generated keys.  In the 2-pass protocol flow, the
   client's initial <KeyProvClientHello> message is directly followed by
   a <KeyProvServerFinished> message.  There is no exchange of the
   <KeyProvServerHello> message or the <KeyProvClientNonce> message.
   However, as the two-pass variant of DSKPP consists of one round trip
   to the server, the client is still able to include its random nonce,
   R_C, algorithm preferences and supported key types in the
   <KeyProvClientHello> message.  Note that by including R_C in
   <KeyProvClientHello>, the DSKPP client is able to ensure the server
   is alive before "committing" the key.  Also note that the DSKPP
   "trigger" message MAY be used to trigger the client's sending of the
   <KeyProvClientHello> message.

   Essentially, two-pass DSKPP is a transport of key material from the
   DSKPP server to the DSKPP client.  Two-pass DSKPP supports multiple
   key initialization methods that ensure K_TOKEN is not exposed to any
   other entity than the DSKPP server and the cryptographic module
   itself.  Currently, three such key initialization methods are defined
   (refer to Section 11), each supporting a different usage of 2-pass
   DSKPP:

   Key Transport               This profile is intended for PKI-capable
                               devices.  Key transport is carried out
                               using a public key, K_CLIENT, whose
                               private key part resides in the
                               cryptographic module as the transport
                               key.
   Key Wrap                    This profile is ideal for pre-keyed
                               devices, e.g., SIM cards.  Key wrap is
                               carried out using a symmetric key-
                               wrapping key, K_SHARED, which is known in
                               advance by both the cryptographic module
                               and the DSKPP server.
   Passphrase-Based Key Wrap   This profile is a variation of the Key
                               Wrap Profile.  It is applicable to
                               constrained devices with keypads, e.g.,
                               mobile phones.  Key wrap is carried out
                               using a passphrase-derived key-wrapping
                               key, K_DERIVED, which is known in advance
                               by both the cryptographic module and



Doherty, et al.            Expires May 1, 2008                 [Page 24]


Internet-Draft                    DSKPP                     October 2007


                               DSKPP server.

   The full 2-pass protocol exchange when the key is transported using
   the client public key is as follows:

   [<Trigger>]:

      [ID_Device], [ID_K], [URL_S],[R_S]

   <KeyProvClientHello>:

      [ID_Device], ID_K, R_S, R_C, AUTHDATA, Alg_List

   <KeyProvServerFinished>:

      ENC_K_CLIENT ( K_TOKEN || K_MAC)), K_CONFDATA, ID_S, DSKPP-
      PRF_K_MAC("MAC 1 Computation" || ID_S || R_C, len(R_C) ), [ DSKPP-
      PRF_K_MAC'("MAC 1 Computation" || ID_S || R_C), 16]


   The full 2-pass protocol exchange when the key is wrapped using a
   shared key is as follows:

   [<Trigger>]:

      [ID_Device], [ID_K], [URL_S],[R_S]

   <KeyProvClientHello>:

      [ID_Device], ID_K, R_S, R_C, AUTHDATA, Alg_List

   <KeyProvServerFinished>:

      ENC_K_SHARED(K_TOKEN || K_MAC), K_CONFDATA, ID_S, DSKPP-
      PRF_K_MAC("MAC 1 Computation" || ID_S || R_C), [ DSKPP-
      PRF_K_MAC'("MAC 1 Computation "|| ID_S||R_C)]

   The full 2-pass protocol when the key is wrapped using a passphrase
   based derived key is as follows:

   [<Trigger>]:

      [ID_Device], [ID_K], [URL_S],[R_S]

   <KeyProvClientHello>:






Doherty, et al.            Expires May 1, 2008                 [Page 25]


Internet-Draft                    DSKPP                     October 2007


      [ID_Device], ID_K, R_S, R_C, AUTHDATA, Alg_List

   <KeyProvServerFinished>:

      ENC_K_DERIVED(K_TOKEN || K_MAC), K_CONFDATA, ID_S, DSKPP-
      PRF_K_MAC("MAC 1 Computation" || ID_S || R_C), [ DSKPP-
      PRF_K_MAC'("MAC 1 Computation" || ID_S || R_C)]

   The following subsections describe these exchanges in more detail.

4.4.1.  Message Flow

   The 2-pass protocol flow consists of one round trip between the DSKPP
   client and DSKPP server, which consists of two "passes", i.e., one
   request message and one response message:

   Round-trip #1: Pass 1=<KeyProvClientHello>, Pass
   2=<KeyProvServerFinished>

   a.  The DSKPP client sends a <KeyProvClientHello> message to the
       DSKPP server.  The message provides the client nonce, R_C, and
       information about the DSKPP versions, protocol variants, key
       types, encryption and MAC algorithms supported by the
       cryptographic module for the purposes of this protocol.  The
       message may also include client authentication data, such as
       device certificate or MAC derived from authentication code and
       R_C. Authentication code is sent in clear only when underlying
       transport layer can ensure data confidentiality.  Unlike 4-pass
       DSKPP, 2-pass DSKPP client uses the <KeyProvClientHello> message
       to declare which key initialization method it supports, providing
       required payload information, e.g., K_CLIENT for the Key
       Transport Profile.
   b.  The DSKPP server generates a key K from which two keys, K_TOKEN
       and K_MAC are derived.  (Alternatively, the key K may have been
       pre-generated as described in Section 3.1.  K is either
       transported or wrapped in accordance with the key initialization
       method specified by the DSKPP client in the <KeyProvClientHello>
       message.  The server then associates K_TOKEN with the
       cryptographic module in a server-side data store.  The intent is
       that the data store later on will be used by some service that
       needs to verify or decrypt data produced by the cryptographic
       module and the key.
   c.  Once the association has been made, the DSKPP server sends a
       confirmation message to the DSKPP client called
       <KeyProvServerFinished>.  The confirmation message includes a key
       container that holds an identifier for the key, the key K from
       which K_TOKEN and K_MAC are derived, and additional configuration
       information (note that the latter MUST include the identity of



Doherty, et al.            Expires May 1, 2008                 [Page 26]


Internet-Draft                    DSKPP                     October 2007


       the DSKPP server for authentication purposes).  In addition,
       <KeyProvServerFinished> MUST include two MACs whose values are
       calculated with contribution from the client nonce, R_C, provided
       in the <KeyProvClientHello> message.  The data will allow the
       cryptographic module to perform key confirmation and server
       authentication before "committing" the key.  Note that the second
       MAC value that is intended for key confirmation MAY only be used
       for replacing and existing key.
   d.  Upon receipt of the DSKPP server's confirmation message, the
       cryptographic module extracts the key data from the provided key
       container, uses the provided MAC values to perform key
       confirmation and server authentication, and stores the key
       material locally.

4.4.2.  Key Confirmation

   In two-pass DSKPP, the client is REQUIRED to include a nonce R in the
   <KeyProvClientHello> message.  Further, the server is REQUIRED to
   include an identifier, ID_S, for itself (via the key container) in
   the <KeyProvServerFinished> message.  The MAC value in the
   <KeyProvServerFinished> message MUST be computed on the (ASCII)
   string "MAC 1 computation", the server identifier ID_S, and R using a
   MAC key K_MAC.  This key MUST be provided together with K_TOKEN to
   the cryptographic module.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1
   computation" and R, and the parameter dsLen MUST be set to the length
   of R:

   dsLen = len(R)

   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || R, dsLen)

4.4.3.  Server Authentication

   A server MUST authenticate itself when attempting to replace an
   existing K_TOKEN.  In 2-pass DSKPP, servers authenticate themselves
   by including a second MAC value in the AuthenticationDataType element
   of <KeyProvServerFinished>.  The MAC value in the
   AuthenticationDataType element MUST be computed on the (ASCII) string
   "MAC 1 computation", the server identifier ID_S, and R, using the
   existing MAC key K_MAC' (the MAC key that existed before this
   protocol run).  The MAC algorithm MUST be the same as the algorithm
   used for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1



Doherty, et al.            Expires May 1, 2008                 [Page 27]


Internet-Draft                    DSKPP                     October 2007


   computation" ID_S, and R. The parameter dsLen MUST be set to at least
   16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || R, dsLen)

4.5.  One-Pass Protocol Usage

   The one-pass protocol flow is suitable for environments wherein near
   real-time communication between the DSKPP client and server may not
   be possible.  It is also suitable for environments wherein
   administrative approval is a required step in the flow, and for
   provisioning of pre-generated keys.  In one-pass DSKPP, the server
   simply sends a <KeyProvServerFinished> message to the DSKPP client.
   In this case, there is no exchange of the <KeyProvClientHello>,
   <KeyProvServerHello>, and <KeyProvClientNonce> DSKPP messages, and
   hence there is no way for the client to express supported algorithms
   or key types.  Before attempting one-pass DSKPP, the server MUST
   therefore have prior knowledge not only that the client is able and
   willing to accept this variant of DSKPP, but also of algorithms and
   key types supported by the client.

   Essentially, one-pass DSKPP is a transport of key material from the
   DSKPP server to the DSKPP client.  As with two-pass DSKPP, the one-
   pass variant relies on key initialization methods that ensure K_TOKEN
   is not exposed to any other entity than the DSKPP server and the
   cryptographic module itself.  The same key initialization profiles
   are defined as described in Section 4.4 and Section 11.

   Outside the specific cases where one-pass DSKPP is desired, clients
   SHOULD be constructed and configured to only accept DSKPP server
   messages in response to client-initiated transactions.

   The 1-pass protocol when the key is transported using the client
   public Key is as follows:

   <KeyProvServerFinished>:

      ENC_K_CLIENT ( K_TOKEN || K_MAC)), K_CONFDATA, DSKPP-PRF_K_MAC
      ("MAC 1 Computation" || ID_S || I), [ DSKPP-PRF_K_MAC'("MAC 2
      Computation"||ID_S||I')]

   The 1-pass protocol when the key is wrapped using a shared key is as
   follows:

   <KeyProvServerFinished>:




Doherty, et al.            Expires May 1, 2008                 [Page 28]


Internet-Draft                    DSKPP                     October 2007


      ENC_K_SHARED (K_TOKEN || K_MAC), K_CONFDATA, DSKPP-PRF_K_MAC("MAC
      1 Computation" || ID_S || I), [ PRF_K_MAC'("MAC 2 Computation" ||
      ID_S || I')]

   The 1-pass protocol when the key is wrapped using a passphrase
   derived key is as follows:

   <KeyProvServerFinished>:

      ENC_K_DERIVED(K_TOKEN || K_MAC), K_CONFDATA, DSKPP-PRF_K_MAC("MAC
      1 Computation" || ID_S || I), [DSKPP-PRF_K_MAC'("MAC 2
      Computation" || ID_S || I')]

   The subsections below describe the 1-pass protocol in more detail.

4.5.1.  Message Flow

   The 1-pass protocol flow consists of one "pass", i.e., a single
   message sent from the DSKPP server to the DSKPP client:

   Pass 1: <KeyProvServerFinished>

   a.  The DSKPP server generates a key K from which two keys, K_TOKEN
       and K_MAC are derived.  K is either transported or wrapped in
       accordance with the key initialization method known in advance by
       the DSKPP server.  The server then associates K_TOKEN with the
       cryptographic module in a server-side data store.  The intent is
       that the data store later on will be used by some service that
       needs to verify or decrypt data produced by the cryptographic
       module and the key.
   b.  Once the association has been made, the DSKPP server sends a
       confirmation message to the DSKPP client called
       <KeyProvServerFinished>.  The confirmation message includes a key
       container that holds an identifier for the key, the key K from
       which K_TOKEN and K_MAC are derived, and additional configuration
       information (note that the latter MUST include the identity of
       the DSKPP server for authentication purposes).  In addition,
       <KeyProvServerFinished> MUST include two MACs, which will allow
       the cryptographic module to perform key confirmation and server
       authentication before "commuting" the key.  Note that unlike two-
       pass DSKPP, in the one-pass variant, the server does not have the
       client nonce, R_C, and therefore the MACs values are calculated
       with contribution from an unsigned integer, I, generated by the
       server during the protocol run.







Doherty, et al.            Expires May 1, 2008                 [Page 29]


Internet-Draft                    DSKPP                     October 2007


   c.  Upon receipt of the DSKPP server's confirmation message, the
       cryptographic module extracts the key data from the provided key
       container, uses the two MAC values to perform key confirmation
       and server authentication, and stores the key material locally.

4.5.2.  Key Confirmation

   In one-pass DSKPP, the server MUST include an identifier, ID_S, for
   itself (via the key container) in the <KeyProvServerFinished>
   message.  The MAC value in the <KeyProvServerFinished> message MUST
   be computed on the (ASCII) string "MAC 1 computation", the server
   identifier ID_S, and an unsigned integer value I, using a MAC key
   K_MAC.  The value I MUST be monotonically increasing and guaranteed
   not to be used again by this server towards this cryptographic
   module.  It could for example be the number of seconds since some
   point in time with sufficient granularity, a counter value, or a
   combination of the two where the counter value is reset for each new
   time value.  In contrast to the MAC calculation in four-pass DSKPP,
   the MAC key K_MAC MUST be provided together with K_TOKEN to the
   cryptographic module.

   Note: The integer I does not necessarily need to be maintained by the
   DSKPP server on a per cryptographic module basis (it is enough if the
   server can guarantee that the same value is never being sent twice to
   the same cryptographic module).

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1
   computation", ID_S, and I. The parameter dsLen MUST be set to at
   least 16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || I, dsLen)

   The server MUST provide I to the client in the Nonce attribute of the
   <Mac> element of the <KeyProvServerFinished> message using the
   AuthenticationCodeMacType defined in Section 6.2.2.4.

4.5.3.  Server Authentication

   As discussed in , servers need to authenticate themselves when
   attempting to replace an existing K_TOKEN.  In 1-pass DSKPP, servers
   authenticate themselves by including a second MAC value in the
   AuthenticationDataType element of <KeyProvServerFinished>.  The MAC
   value in the AuthenticationDataType element MUST be computed on the
   (ASCII) string "MAC 1 computation", the server identifier ID_S, and a
   new value I', I' > I, using the existing MAC key K_MAC' (the MAC key



Doherty, et al.            Expires May 1, 2008                 [Page 30]


Internet-Draft                    DSKPP                     October 2007


   that existed before this protocol run).  The MAC algorithm MUST be
   the same as the algorithm used for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1
   computation" ID_S, and I'.  The parameter dsLen MUST be set to at
   least 16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || I', dsLen)

   The server MUST provide I' to the client in the Nonce attribute of
   the <Mac> element of the AuthenticationDataType extension.  If the
   protocol run is successful, the client stores I' as the new value of
   I for this server.


5.  Methods Common to More Than One Protocol Variant

   The mechanisms contained in this section are used in more than one
   variant of DSKPP.

5.1.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF

5.1.1.  Introduction

   All of the protocol variants depend on DSKPP-PRF.  The general
   requirements on DSKPP-PRF are the same as on keyed hash functions: It
   MUST take an arbitrary length input, and be one-way and collision-
   free (for a definition of these terms, see, e.g., [FAQ]).  Further,
   the DSKPP-PRF function MUST be capable of generating a variable-
   length output, and its output MUST be unpredictable even if other
   outputs for the same key are known.

   It is assumed that any realization of DSKPP-PRF takes three input
   parameters: A secret key k, some combination of variable data, and
   the desired length of the output.  The combination of variable data
   can, without loss of generalization, be considered as a salt value
   (see PKCS#5 Version 2.0 [PKCS-5], Section 4), and this
   characterization of DSKPP-PRF SHOULD fit all actual PRF algorithms
   implemented by cryptographic modules.  From the point of view of this
   specification, DSKPP-PRF is a "black-box" function that, given the
   inputs, generates a pseudorandom value.

   Separate specifications MAY define the implementation of DSKPP-PRF
   for various types of cryptographic modules.  Appendix B contains two
   example realizations of DSKPP-PRF.



Doherty, et al.            Expires May 1, 2008                 [Page 31]


Internet-Draft                    DSKPP                     October 2007


5.1.2.  Declaration

   DSKPP-PRF (k, s, dsLen)

   Input:

   k     secret key in octet string format
   s     octet string of varying length consisting of variable data
         distinguishing the particular string being derived
   dsLen desired length of the output

   Output:

   DS    pseudorandom string, dsLen-octets long
   For the purposes of this document, the secret key k MUST be at least
   16 octets long.

5.2.  Encryption of Pseudorandom Nonces Sent from the DSKPP Client
      (Applicable to Four-Pass and Two-Pass DSKPP)

   During 4- and 2-pass message exchanges, DSKPP client random nonce(s)
   are either encrypted with the public key provided by the DSKPP server
   or by a shared secret key.  For example, in the case of a public RSA
   key, an RSA encryption scheme from PKCS #1 [PKCS-1] MAY be used.

   In the case of a shared secret key, to avoid dependence on other
   algorithms, the DSKPP client MAY use the DSKPP-PRF function described
   herein with the shared secret key K_SHARED as input parameter k (in
   this case, K_SHARED SHOULD be used solely for this purpose), the
   concatenation of the (ASCII) string "Encryption" and the server's
   nonce R_S as input parameter s, and dsLen set to the length of R_C:

   dsLen = len(R_C)

   DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)

   This will produce a pseudorandom string DS of length equal to R_C.
   Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:

   Enc-R_C = DS ^ R_C

   The DSKPP server will then perform the reverse operation to extract
   R_C from Enc-R_C.

5.3.  Client Authentication Mechanisms (Applicable to Four- and Two-Pass
      DSKPP)

   To ensure that a generated K_TOKEN ends up associated with the



Doherty, et al.            Expires May 1, 2008                 [Page 32]


Internet-Draft                    DSKPP                     October 2007


   correct cryptographic module and user, the DSKPP server MAY couple an
   initial user authentication to the DSKPP execution in several ways,
   as discussed in the following sub-sections.  Whatever the method, the
   DSKPP server MUST ensure that a generated key is associated with the
   correct cryptographic module, and if applicable, the correct user.
   For a further discussion of this, and threats related to man-in-the-
   middle attacks in this context, see Section 14.

5.3.1.  Device Certificate

   Instead of requiring an Authentication Code for in-band
   authentication, a device private key and certificate could be used,
   which was supplied with the cryptographic module by its issuer for
   client authentication at the transport layer e.g TLS/HTTPS.  When the
   Device certificate is available and client authentication is not
   provided in the transport layer, the DSKPP client may include a
   device's certificate signed data for the authentication data.

5.3.2.  Device Identifier

   The DSKPP server could be pre-configured with a unique device
   identifier corresponding to a particular cryptographic module.  The
   DSKPP server MAY then include this identifier in the DSKPP
   initialization trigger, and the DSKPP client would include it in its
   message(s) to the DSKPP server for authentication.  Note that it is
   also legitimate for a DSKPP client to initiate the DSKPP protocol run
   without having received an initialization message from a server, but
   in this case any provided device identifier MUST NOT be accepted by
   the DSKPP server unless the server has access to a unique key for the
   identified device and that key will be used in the protocol.

5.3.3.  Authentication Code

   As shown in Figure 5, a key issuer may provide a one-time value,
   called an Authentication Code, to the user or device out-of-band and
   require this value to be used by the DSKPP client when contacting the
   DSKPP server.  The DSKPP client MAY include the authentication data
   in its <KeyProvClientHello> (and <KeyProvClientNonce> for four-pass)
   message, and the DSKPP server MUST verify the data before continuing
   with the protocol run.

   Note: An alternate method for getting the Authentication Code to the
   client, is for the DSKPP server to place the value in the
   <TriggerNonce> element of the DSKPP initialization trigger (if
   triggers are used; see Section 12.2.7) .  When this method is used, a
   transport providing privacy and integrity MUST be used to deliver the
   DSKPP initialization trigger from the DSKPP server to the DSKPP
   client, e.g.  HTTPS.



Doherty, et al.            Expires May 1, 2008                 [Page 33]


Internet-Draft                    DSKPP                     October 2007


   +------------+  Get Authentication Code  +------------+
   |    User    |<------------------------->|   Issuer   |
   +------------+                           +------------+
          |                                        |
          |                                        |
          |                                        |
          V                                        V
   +--------------+                        +--------------+
   |    DSKPP     |   Authentication Data  |    DSKPP     |
   |    Client    |----------------------->|    Server    |
   +--------------+                        +--------------+

      Figure 5: User Authentication with One-Time               Code


   The Authentication Code, AUTHCODE, may be considered as a special
   form of a shared secret between a User and a DSKPP server.  The
   Issuer may generate the Authentication Code as follows:

   AUTHCODE = passwordLen || identifier || password || checksum


   where

   passwordLen  : 1 digit indicating the 'password' length.  The maximum
             length of the password is 10.  A passwordLen value '0'
             indicates a password of 10 digits.

   identifier  : A globally unique identifier of the user's order for
             token provisioning.  The length of the identifier may be
             fixed e.g. 10 digits or variable e.g. 1 to 20 digits.  The
             identifier may be generated as a sequence number.

   password  : 6 to 10 digits.  The password should be generated by the
             system as a random number to make the AUTHCODE more
             difficult to guess.

   checksum  : 1 digit calculated from the remaining digits in the code.

   The Authentication Data, AUTHDATA, may be derived from the AUTHCODE
   and other information as follows:


   MAC = DSKPP-PRF-AES(K_AUTHCODE, AUTHCODE->Identifier || URL_S ||
   [R_S], 16)


   where



Doherty, et al.            Expires May 1, 2008                 [Page 34]


Internet-Draft                    DSKPP                     October 2007


      Refer to Section 5.1 for a description of DSKPP-PRF in general and
      Appendix B for a description of DSKPP-PRF-AES.

      In four-pass DSKPP, the cryptographic module uses the client nonce
      R_C, the server nonce R_S, and the server URL URL_S to calculate
      the MAC.  In two-pass DSKPP, the cryptographic module does not
      have access to the server nonce R_S therefore only the client
      nonce R_C is used in combination with the server URL URL_S to
      produce the MAC.

      The K_AUTHCODE MAY be derived from AUTHCODE>password as follows:
         K_AUTHCODE = truncate( Hash( Hash(...n times...(
         AUTHCODE->password ||R_C||[K]) ) ) )

      where

         K is optional and MAY be one of the following:

                   K_CLIENT: The device public key when a device
                   certificate is available and used for key transport
                   in 2-pass

                   K_SHARED: The shared key between the Client and the
                   Server when it is used for key wrap in two-pass or
                   for R_C protection in four-pass

                   K_DERIVED: when a passphrase derived key is used for
                   key wrap in two-pass.

         'truncate()' returns the first 16 bytes from the result of the
         last hash iteration, and n is the number of hash iterations. n
         may be any number between 10 and 1000.

   Notes:
   1  Authentication data MAY be omitted if client certificate
      authentication has been provided by the transport channel such as
      TLS.

   2  When an issuer delegates symmetric key provisioning to a third
      party provisioning service provider, both client authentication
      and issuer authentication are required by the provisioning server.
      Client authentication to the issuer MAY be in-band or out-of-band
      as described above.  The issuer acts as a proxy for the
      provisioning server.  The issuer authenticates to the provisioning
      service provider either using a certificate or a pre-established
      secret key.





Doherty, et al.            Expires May 1, 2008                 [Page 35]


Internet-Draft                    DSKPP                     October 2007


5.4.  Client Authentication Examples

5.4.1.  Example Using a MAC from an Authentication Code

     <AuthenticationData>
       <ClientID>31300257</ClientID>
       <AuthenticationCodeMac>
         <IterationCount>512</IterationCount>
         <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
       </AuthenticationCodeMac>
                 </AuthenticationData>

5.4.2.  Example Using a Device Certificate

  <AuthenticationData>
    <DigitalSignature>
      <ds:SignedInfo>
        <ds:CanonicalizationMethod
          Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" />
        <ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>
        <ds:Reference URI="#Nonce">
          <ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
          <ds:DigestValue></ds:DigestValue>
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue></ds:SignatureValue>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </ds:KeyInfo>
      <ds:Object Id="Nonce">xwQzwEl0CjPAiQeDxwRJdQ==</ds:Object>
              </DigitalSignature>


6.  Four-Pass Protocol

   In this section, example messages are used to describe parameters,
   encoding and semantics in a 4-pass DSKPP exchanges.  The examples are
   written using XML.  While they are syntactically correct, MAC and
   cipher values are fictitious.

6.1.  XML Basics

   The DSKPP XML schema can be found in Section 13.  Some DSKPP elements
   rely on the parties being able to compare received values with stored
   values.  Unless otherwise noted, all elements in this document that
   have the XML Schema "xs:string" type, or a type derived from it, MUST



Doherty, et al.            Expires May 1, 2008                 [Page 36]


Internet-Draft                    DSKPP                     October 2007


   be compared using an exact binary comparison.  In particular, DSKPP
   implementations MUST NOT depend on case-insensitive string
   comparisons, normalization or trimming of white space, or conversion
   of locale-specific formats such as numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [UNICODE], and then
   performing an exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

6.2.  Round-Trip #1:  <KeyProvClientHello> and <KeyProvServerHello>

6.2.1.  Examples

































Doherty, et al.            Expires May 1, 2008                 [Page 37]


Internet-Draft                    DSKPP                     October 2007


6.2.1.1.  Example Without a Preceding Trigger

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>
  </SupportedKeyTypes>
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>
  <SupportedProtocolVariants><FourPass/></SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
</dskpp:KeyProvClientHello>










Doherty, et al.            Expires May 1, 2008                 [Page 38]


Internet-Draft                    DSKPP                     October 2007


<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
  keyprov-dskpp-1.0.xsd">
  <KeyType>
    urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
  </KeyType>
  <EncryptionAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </EncryptionAlgorithm>
  <MacAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </MacAlgorithm>
  <EncryptionKey>
    <ds:KeyName>KEY-1</ds:KeyName>
  </EncryptionKey>
  <KeyContainerFormat>
    urn:ietf:params:xml:schema:keyprov:container#KeyContainer
  </KeyContainerFormat>
  <Payload>
    <Nonce>qw2ewasde312asder394jw==</Nonce>
  </Payload>
</dskpp:KeyProvServerHello>

6.2.1.2.  Example Assuming a Preceding Trigger






















Doherty, et al.            Expires May 1, 2008                 [Page 39]


Internet-Draft                    DSKPP                     October 2007


<?xml version="1.0" encoding="UTF-8"?>

<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <KeyID>SE9UUDAwMDAwMDAx</KeyID>
  <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>
  </SupportedKeyTypes>
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>
  <SupportedProtocolVariants><FourPass/></SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
</dskpp:KeyProvClientHello>









Doherty, et al.            Expires May 1, 2008                 [Page 40]


Internet-Draft                    DSKPP                     October 2007


<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <KeyType>
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
  </KeyType>
  <EncryptionAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </EncryptionAlgorithm>
  <MacAlgorithm>
    urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
  </MacAlgorithm>
  <EncryptionKey>
    <ds:KeyName>KEY-1</ds:KeyName>
  </EncryptionKey>
  <KeyContainerFormat>
    urn:ietf:params:xml:schema:keyprov:container#KeyContainer
  </KeyContainerFormat>
  <Payload>
    <Nonce>qw2ewasde312asder394jw==</Nonce>
  </Payload>
  <Mac MacAlgorithm=
    "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
  </Mac>
</dskpp:KeyProvServerHello>

6.2.2.  Components of the <KeyProvClientHello> Request

   The components of this message have the following meaning:
   o  Version: (attribute inherited from the AbstractRequestType type)
      The highest version of this protocol the client supports.  Only
      version one ("1.0") is currently specified.
   o  <DeviceIdentifierData>: An identifier for the cryptographic module
      as defined in Section 5.3 above.  The identifier MUST only be
      present if such shared secrets exist or if the identifier was
      provided by the server in a <KeyProvTrigger> element (see
      Section 12.2.7 below).  In the latter case, it MUST have the same
      value as the identifier provided in that element.
   o  <KeyID>: An identifier for the key that will be overwritten if the
      protocol run is successful.  The identifier MUST only be present
      if the key exists or if the identifier was provided by the server
      in a <KeyProvTrigger> element, in which case, it MUST have the



Doherty, et al.            Expires May 1, 2008                 [Page 41]


Internet-Draft                    DSKPP                     October 2007


      same value as the identifier provided in that element (see a
      (Section 9) and Section 12.2.7 below).
   o  <KeyProvClientNonce>: This is the nonce R, which, when present,
      MUST be used by the server when calculating MAC values (see
      below).  It is RECOMMENDED that clients include this element
      whenever the <KeyID> element is present.
   o  <TriggerNonce>: This OPTIONAL element MUST be present if and only
      if the DSKPP run was initialized with a <KeyProvTrigger> message
      (see Section 12.2.7 below), and MUST, in that case, have the same
      value as the <TriggerNonce> child of that message.  A server using
      nonces in this way MUST verify that the nonce is valid and that
      any device or key identifier values provided in the
      <KeyProvTrigger> message match the corresponding identifier values
      in the <KeyProvClientHello> message.
   o  <SupportedKeyTypes>: A sequence of URIs indicating the key types
      for which the cryptographic module is willing to generate keys
      through DSKPP.
   o  <SupportedEncryptionAlgorithms>: A sequence of URIs indicating the
      encryption algorithms supported by the cryptographic module for
      the purposes of DSKPP.  The DSKPP client MAY indicate the same
      algorithm both as a supported key type and as an encryption
      algorithm.
   o  <SupportedMacAlgorithms>: A sequence of URIs indicating the MAC
      algorithms supported by the cryptographic module for the purposes
      of DSKPP.  The DSKPP client MAY indicate the same algorithm both
      as an encryption algorithm and as a MAC algorithm (e.g.,
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes defined
      in Appendix B).
   o  <SupportedProtocolVariants>: This OPTIONAL element is used by the
      DSKPP client to indicate support for four-pass or two-pass DSKPP.
      If two-pass support is specified, then <KeyProvClientNonce> MUST
      be set to nonce R in the <KeyProvClientHello> message unless
      <TriggerNonce> is already present.
   o  <SupportedKeyContainers>: This OPTIONAL element is a sequence of
      URIs indicating the key container formats supported by the DSKPP
      client.  If this element is not provided, then the DSKPP server
      MUST proceed with
      "urn:ietf:params:xml:schema:keyprov:container#KeyContainer" (see
      [PSKC]).
   o  <AuthenticationData>: This OPTIONAL element contains data that the
      DSKPP client uses to authenticate the user or device to the DSKPP
      server.  The element is set as specified in Section 5.3.
   o  <Extensions>: A sequence of extensions.  One extension is defined
      for this message in this version of DSKPP: the ClientInfoType (see
      Section 10).






Doherty, et al.            Expires May 1, 2008                 [Page 42]


Internet-Draft                    DSKPP                     October 2007


6.2.2.1.  The DSKPP Client:  The DeviceIdentifierDataType Type

   The DeviceIdentifierDataType type is used to uniquely identify the
   device that houses the cryptographic module, e.g., a mobile phone.
   The device identifier allows the DSKPP server to find, e.g., a pre-
   shared transport key for 2-pass DSKPP and/or the correct shared
   secret for MAC'ing purposes.  The default DeviceIdentifierDataType is
   defined in [PSKC].

6.2.2.2.  Selecting a Protocol Variant: The ProtocolVariantsType Type

   The ProtocolVariantsType type is OPTIONAL for a DSKPP client, who MAY
   use it to indicate the number of passes of the DSKPP protocol that it
   supports.  The ProtocolVariantsType MAY be used to indicate support
   for 4-pass or 2-pass DSKPP.  Because 1-pass DSKPP does not include a
   client request to the server, the ProtocolVariantsType type MAY NOT
   be used to indicate support for 1-pass DSKPP.  If the
   ProtocolVariantsType is not used, then the DSKPP server will proceed
   with ordinary 4-pass DSKPP.  However, it does not support 4-pass
   DSKPP, then the server MUST find a suitable two-pass variant or else
   the protocol run will fail.

   The TwoPassSupportType type signals client support for the 2-pass
   version of DSKPP, informs the server of supported two-pass variants,
   and provides OPTIONAL payload data to the DSKPP server.  The payload
   is sent in an opportunistic fashion, and MAY be discarded by the
   DSKPP server if the server does not support the two-pass variant the
   payload is associated with.  The elements of this type have the
   following meaning:
   o  <SupportedKeyInitializationMethod>: A two-pass key initialization
      method supported by the DSKPP client.  Multiple supported methods
      MAY be present, in which case they MUST be listed in order of
      precedence.
   o  <Payload>: An OPTIONAL payload associated with each supported key
      initialization method.
   A DSKPP client that indicates support for two-pass DSKPP MUST also
   include the nonce R in its <KeyProvClientHello> message (this will
   enable the client to verify that the DSKPP server it is communicating
   with is alive).

6.2.2.3.  Selecting a Key Container Format: The KeyContainersFormatType
          Type

   The OPTIONAL KeyContainersFormatType type is a list of type-value
   pairs that a DSKPP client or server MAY use to define key container
   formats it supports.  Key container formats are identified through
   URIs, e.g., the PSKC KeyContainer URI
   "urn:ietf:params:xml:schema:keyprov:container#KeyContainer" (see



Doherty, et al.            Expires May 1, 2008                 [Page 43]


Internet-Draft                    DSKPP                     October 2007


   [PSKC]).

6.2.2.4.  Selecting a Client and Server Authentication Mechanism: The
          AuthenticationDataType Type

   The OPTIONAL AuthenticationDataType type is used by DSKPP clients and
   server to carry authentication values in DSKPP messages.  The element
   MAY contain a device certificate or MAC derived from an
   authentication code as follows:
   a.  A DSKPP client MAY include a one-time use AuthenticationCode that
       was given by the issuer to the user for acquiring a symmetric
       key.  An AuthenticationCode MAY or MAY NOT contain alphanumeric
       characters in addition to numeric digits depending on the device
       type and policy of the issuer.  For example, if the device is a
       mobile phone, a code that the user enters on the keypad would
       typically be restricted to numeric digits for ease of use.  An
       authentication code MAY be sent to the DSKPP server as MAC data
       calculated according to section Section 5.3.3.
   b.  A DSKPP client MAY contain Authentication Data consisting of
       signed data of client Nonce with a client certificate's private
       key.  A service provider may have a policy to issue symmetric
       keys for a device only if it has a trusted device certificate.
       An authentication code isn't required in this case.
   c.  A DSKPP server MAY use the AuthenticationDataType element
       AuthenticationCodeMac to carry a MAC for authenticating itself to
       the client.  For example, when a successful 1- or 2-pass DSKPP
       protocol run will result in an existing key being replaced, then
       the DSKPP server MUST include a MAC proving to the DSKPP client
       that the server knows the value of the key it is about to
       replace.

   The element of the AuthenticationDataType type have the following
   meaning:
   o  <ClientID>: A requester's identifier.  The value MAY be a user ID,
      a device ID, or a keyID associated with the requester's
      authentication value.  When the authentication data is based on a
      certificate, <ClientID> can be omitted, as the certificate itself
      is typically sufficient to identify the requester.  Also, if a
      <KeyProvTrigger> message was provided by the server to initiate
      the DSKPP protocol run, <ClientID> can be omitted, as the
      DeviceID, KeyID, and/or nonce provided in the
      <InitializationTriggerType> element ought to be sufficient to
      identify the requester.
   o  <AuthenticationCodeMac>: An authentication MAC and OPTIONAL
      additional information (e.g., MAC algorithm).  The value could be
      a one-time use value sent as a MAC value to the DSKPP server; or,
      it could be a MAC value sent to the DSKPP client.  Refer to
      section Section 5.3.3 for calculation of MAC with an



Doherty, et al.            Expires May 1, 2008                 [Page 44]


Internet-Draft                    DSKPP                     October 2007


      authentication code.
   o  <DigitalSignature>: Client nonce R_C signed using the device
      certificate and sent in KeyProvClientHello for two-pass protocol
      or in KeyProvClientNonce for four-pass protocol.

6.2.3.  Components of the <KeyProvServerHello> Response

   This message is the first message sent from the DSKPP server to the
   DSKPP client (assuming a trigger message has not been sent to
   initiate the protocol, in which case, this message is the second
   message sent from the DSKPP server to the DSKPP client).  It is sent
   upon reception of a <KeyProvClientHello> message.  The components of
   this message have the following meaning:

   o  Version: (attribute inherited from the AbstractResponseType type)
      The version selected by the DSKPP server.  MAY be lower than the
      version indicated by the DSKPP client, in which case, local policy
      at the client MUST determine whether or not to continue the
      session.
   o  SessionID: (attribute inherited from the AbstractResponseType
      type) An identifier for this session.
   o  Status: (attribute inherited from the AbstractResponseType type)
      Return code for the <KeyProvClientHello>.  If Status is not
      "Continue", only the Status and Version attributes will be
      present; otherwise, all the other element MUST be present as well.
   o  <KeyType>: The type of the key to be generated.
   o  <EncryptionAlgorithm>: The encryption algorithm to use when
      protecting R_C.
   o  <MacAlgorithm>: The MAC algorithm to be used by the DSKPP server.
   o  <EncryptionKey>: Information about the key to use when encrypting
      R_C. It will either be the server's public key (the <ds:KeyValue>
      alternative of ds:KeyInfoType) or an identifier for a shared
      secret key (the <ds:KeyName> alternative of ds:KeyInfoType).
   o  <KeyContainerFormat>: The key container format type to be used by
      the DSKPP server.  The default setting relies on the
      KeyContainerType element defined in
      "urn:ietf:params:xml:schema:keyprov:container" [PSKC].
   o  <Payload>: The actual payload.  For this version of the protocol,
      only one payload is defined: the pseudorandom string R_S.
   o  <Extensions>: A list of server extensions.  Two extensions are
      defined for this message in this version of DSKPP: the
      ClientInfoType and the ServerInfoType (see Section 10).
   o  <Mac>: The MAC MUST be present if the DSKPP run will result in the
      replacement of an existing symmetric key with a new one (i.e., if
      the <KeyID> element was present in the <ClientHello message).  In
      this case, the DSKPP server MUST prove to the cryptographic module
      that it is authorized to replace it.




Doherty, et al.            Expires May 1, 2008                 [Page 45]


Internet-Draft                    DSKPP                     October 2007


      The DSKPP client MUST verify the MAC if the successful execution
      of the protocol will result in the replacement of an existing
      symmetric key with a newly generated one.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST
      delete any nonces, keys, and/or secrets associated with the failed
      run of the DSKPP protocol.
      The MacType's MacAlgorithm attribute MUST, when present, identify
      the negotiated MAC algorithm.

6.3.  Round-Trip #2: <KeyProvClientNonce> and <KeyProvServerFinished>

6.3.1.  Examples

6.3.1.1.  Example Using Default Encryption

   This message contains the nonce chosen by the cryptographic module,
   R_C, encrypted by the specified encryption key and encryption
   algorithm.

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvClientNonce Version="1.0" SessionID="4114"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
       keyprov-dskpp-1.0.xsd">
     <EncryptedNonce>VXENc+Um/9/NvmYKiHDLaErK0gk=</EncryptedNonce>
     <AuthenticationData>
       <ClientID>31300257</ClientID>
       <AuthenticationCodeMac>
         <IterationCount>512</IterationCount>
         <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
       </AuthenticationCodeMac>
     </AuthenticationData>
   </dskpp:KeyProvClientNonce>

















Doherty, et al.            Expires May 1, 2008                 [Page 46]


Internet-Draft                    DSKPP                     October 2007


<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <pskc:Device>
        <pskc:Key
          KeyAlgorithm=
          "http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES"
          KeyId="XL0000000001234">
          <pskc:Issuer>CredentialIssuer</pskc:Issuer>
          <pskc:Usage otp="true">
            <pskc:ResponseFormat format="DECIMAL" length="6"/>
          </pskc:Usage>
          <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
          <pskc:Data Name="TIME">
            <pskc:Value>AAAAADuaygA=</pskc:Value>
          </pskc:Data>
          <pskc:Expiry>10/30/2012</pskc:Expiry>
        </pskc:Key>
      </pskc:Device>
    </KeyContainer>
  </KeyContainer>
  <Mac
    MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
</dskpp:KeyProvServerFinished>

6.3.2.  Components of a <KeyProvClientNonce> Request

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractRequestType type) MUST be the
      same version as in the <KeyProvServerHello> message.
   o  <SessionID>: MUST have the same value as the SessionID attribute
      in the received <KeyProvServerHello> message.
   o  <EncryptedNonce>: The nonce generated and encrypted by the
      cryptographic module.  The encryption MUST be made using the
      selected encryption algorithm and identified key, and as specified
      in Section 5.1.





Doherty, et al.            Expires May 1, 2008                 [Page 47]


Internet-Draft                    DSKPP                     October 2007


   o  <AuthenticationData>: The authentication data value MUST be set as
      specified in Section 5.3 and Section 6.2.2.4.
   o  <Extensions>: A list of extensions.  Two extensions are defined
      for this message in this version of DSKPP: the ClientInfoType and
      the ServerInfoType (see Section 10)

6.3.3.  Components of a <KeyProvServerFinished> Response

   This message is the last message of the DSKPP protocol run.  In a
   4-pass exchange, the DSKPP server sends this message in response to a
   <KeyProvClientNonce> message, whereas in a 2-pass exchange, the DSKPP
   server sends this message in response to a <KeyProvClientHello>
   message.  In a 1-pass exchange, the DSKPP server sends only this
   message to the client.  The components of this message have the
   following meaning:

   o  Version: (inherited from the AbstractResponseType type) The DSKPP
      version used in this session.
   o  SessionID: (inherited from the AbstractResponseType type) The
      previously established identifier for this session.
   o  Status: (inherited from the AbstractResponseType type) Return code
      for the <KeyProvServerFinished> message.  If Status is not
      "Success", only the Status, SessionID, and Version attributes will
      be present (the presence of the SessionID attribute is dependent
      on the type of reported error); otherwise, all the other elements
      MUST be present as well.  In this latter case, the
      <KeyProvServerFinished> message can be seen as a "Commit" message,
      instructing the cryptographic module to store the generated key
      and associate the given key identifier with this key.
   o  <KeyContainer>: The key container containing symmetric key values
      (in the case of a 2- or 1-pass exchange) and configuration data.
      The default container format is based on the KeyContainerType type
      from PSKC, as defined in [PSKC].
   o  <Extensions>: A list of extensions chosen by the DSKPP server.
      For this message, this version of DSKPP defines one extension, the
      ClientInfoType (see Section 10).
   o  <Mac>: To avoid a false "Commit" message causing the cryptographic
      module to end up in an initialized state for which the server does
      not know the stored key, <KeyProvServerFinished> messages MUST
      always be authenticated with a MAC.  The MAC MUST be made using
      the already established MAC algorithm.
      When receiving a <KeyProvServerFinished> message with
      Status="Success" for which the MAC verifies, the DSKPP client MUST
      associate the generated key K_TOKEN with the provided key
      identifier and store this data permanently.  After this operation,
      it MUST NOT be possible to overwrite the key unless knowledge of
      an authorizing key is proven through a MAC on a later
      <KeyProvServerHello> (and <KeyProvServerFinished>) message.



Doherty, et al.            Expires May 1, 2008                 [Page 48]


Internet-Draft                    DSKPP                     October 2007


      The DSKPP client MUST verify the MAC.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST,
      in this case, also delete any nonces, keys, and/or secrets
      associated with the failed run of the DSKPP protocol.
      The MacType's MacAlgorithm attribute MUST, when present, identify
      the negotiated MAC algorithm.

6.4.  DSKPP Server Results:  The StatusCode Type

   The StatusCode type enumerates all possible return codes.  Upon
   transmission or receipt of a message for which the Status attribute's
   value is not "Success" or "Continue", the default behavior, unless
   explicitly stated otherwise below, is that both the DSKPP server and
   the DSKPP client MUST immediately terminate the DSKPP session.  DSKPP
   servers and DSKPP clients MUST delete any secret values generated as
   a result of failed runs of the DSKPP protocol.  Session identifiers
   MAY be retained from successful or failed protocol runs for replay
   detection purposes, but such retained identifiers MUST NOT be reused
   for subsequent runs of the protocol.

   When possible, the DSKPP client SHOULD present an appropriate error
   message to the user.

   These status codes are valid in all 4-Pass DSKPP Response messages
   unless explicitly stated otherwise:
   o  "Continue" indicates that the DSKPP server is ready for a
      subsequent request from the DSKPP client.  It cannot be sent in
      the server's final message.
   o  "Success" indicates successful completion of the DSKPP session.
      It can only be sent in the server's final message.
   o  "Abort" indicates that the DSKPP server rejected the DSKPP
      client's request for unspecified reasons.
   o  "AccessDenied" indicates that the DSKPP client is not authorized
      to contact this DSKPP server.
   o  "MalformedRequest" indicates that the DSKPP server failed to parse
      the DSKPP client's request.
   o  "UnknownRequest" indicates that the DSKPP client made a request
      that is unknown to the DSKPP server.
   o  "UnknownCriticalExtension" indicates that a critical DSKPP
      extension (see below) used by the DSKPP client was not supported
      or recognized by the DSKPP server.
   o  "UnsupportedVersion" indicates that the DSKPP client used a DSKPP
      protocol version not supported by the DSKPP server.  This error is
      only valid in the DSKPP server's first response message.
   o  "NoSupportedKeyTypes" indicates that the DSKPP client only
      suggested key types that are not supported by the DSKPP server.
      This error is only valid in the DSKPP server's first response
      message.



Doherty, et al.            Expires May 1, 2008                 [Page 49]


Internet-Draft                    DSKPP                     October 2007


   o  "NoSupportedEncryptionAlgorithms" indicates that the DSKPP client
      only suggested encryption algorithms that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.
   o  "NoSupportedMacAlgorithms" indicates that the DSKPP client only
      suggested MAC algorithms that are not supported by the DSKPP
      server.  This error is only valid in the DSKPP server's first
      response message.
   o  "NoProtocolVariants" indicates that the DSKPP client only
      suggested a protocol variant (either 2-pass or 4-pass) that is not
      supported by the DSKPP server.  This error is only valid in the
      DSKPP server's first response messagei
   o  "NoSupportedKeyContainers" indicates that the DSKPP client only
      suggested key container formats that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.
   o  "AuthenticationDataMissing" indicates that the DSKPP client didn't
      provide authentication data that the DSKPP server required.
   o  "AuthenticationDataInvalid" indicates that the DSKPP client
      supplied user or device authentication data that the DSKPP server
      failed to validate.
   o  "InitializationFailed" indicates that the DSKPP server could not
      generate a valid key given the provided data.  When this status
      code is received, the DSKPP client SHOULD try to restart DSKPP, as
      it is possible that a new run will succeed.
   o  "ProvisioningPeriodExpired" indicates that the provisioning period
      set by the DSKPP server has expired.  When the status code is
      received, the DSKPP client SHOULD report the key initialization
      failure reason to the user and the user MUST register with the
      DSKPP server to initialize a new key.


7.  Two-Pass Protocol

   In this section, example messages are used to describe parameters,
   encoding and semantics in a 2-pass DSKPP exchanges.  The examples are
   written using XML.  While they are syntactically correct, MAC and
   cipher values are fictitious.

7.1.  XML Basics

   The DSKPP XML schema can be found in Section 13.  Some DSKPP elements
   rely on the parties being able to compare received values with stored
   values.  Unless otherwise noted, all elements in this document that
   have the XML Schema "xs:string" type, or a type derived from it, MUST
   be compared using an exact binary comparison.  In particular, DSKPP
   implementations MUST NOT depend on case-insensitive string
   comparisons, normalization or trimming of white space, or conversion



Doherty, et al.            Expires May 1, 2008                 [Page 50]


Internet-Draft                    DSKPP                     October 2007


   of locale-specific formats such as numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [UNICODE], and then
   performing an exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

7.2.  Round-Trip #1:  <KeyProvClientHello> and <KeyProvServerFinished>

7.2.1.  Examples

7.2.1.1.  Example Using the Key Transport Profile

   The client indicates support all the Key Transport, Key Wrap, and
   Passphrase-Based Key Wrap profiles (see Section 11):

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
  keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</ClientNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>
  </SupportedKeyTypes>
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128</Algorithm>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes</Algorithm>
  </SupportedEncryptionAlgorithms>



Doherty, et al.            Expires May 1, 2008                 [Page 51]


Internet-Draft                    DSKPP                     October 2007


  <SupportedMacAlgorithms>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes</Algorithm>
  </SupportedMacAlgorithms>
  <SupportedProtocolVariants>
    <TwoPass>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </Payload>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#transport
      </SupportedKeyInitializationMethod>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </Payload>
    </TwoPass>
  </SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
  <AuthenticationData>
    <DigitalSignature>
      <ds:SignedInfo>
        <ds:CanonicalizationMethod
          Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" />
        <ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>
        <ds:Reference URI="#Nonce">
          <ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
          <ds:DigestValue></ds:DigestValue>
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue></ds:SignatureValue>
      <ds:KeyInfo>
        <ds:X509Data>
          <ds:X509Certificate>miib</ds:X509Certificate>
        </ds:X509Data>
      </ds:KeyInfo>
      <ds:Object Id="Nonce">xwQzwEl0CjPAiQeDxwRJdQ==</ds:Object>
    </DigitalSignature>



Doherty, et al.            Expires May 1, 2008                 [Page 52]


Internet-Draft                    DSKPP                     October 2007


  </AuthenticationData>
</dskpp:KeyProvClientHello>

   In this example, the server responds to the previous request using
   the key transport profile.

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <pskc:EncryptionMethod
        Algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
        <pskc:KeyInfo>
          <ds:X509Data>
            <ds:X509Certificate>miib</ds:X509Certificate>
          </ds:X509Data>
        </pskc:KeyInfo>
      </pskc:EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP"
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2012</Expiry>
        </Key>
      </Device>



Doherty, et al.            Expires May 1, 2008                 [Page 53]


Internet-Draft                    DSKPP                     October 2007


    </KeyContainer>
  </KeyContainer>
  <Mac
    MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvServerFinished>

7.2.1.2.  Example Using the Key Wrap Profile

   The client sends a request that specifies a shared key to protect the
   K_TOKEN, and the server responds using the Key Wrap Profile.
   Authentication data in this example is basing on an authentication
   code rather than a device certificate.

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:pkcs-5="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
  keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</ClientNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>
  </SupportedKeyTypes>
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128</Algorithm>
    <Algorithm>
      http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2



Doherty, et al.            Expires May 1, 2008                 [Page 54]


Internet-Draft                    DSKPP                     October 2007


    </Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>
  <SupportedProtocolVariants>
    <TwoPass>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </Payload>
    </TwoPass>
  </SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
  <AuthenticationData>
    <ClientID>31300257</ClientID>
    <AuthenticationCodeMac>
      <IterationCount>512</IterationCount>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvClientHello>

   In this example, the server responds to the previous request using
   the key wrap profile.

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
  keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <ServerID>https://www.somedskppservice.com/</ServerID>



Doherty, et al.            Expires May 1, 2008                 [Page 55]


Internet-Draft                    DSKPP                     October 2007


    <KeyContainer Version="1.0">
      <EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#kw-aes128"
        xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <KeyInfo>
           <ds:KeyName>Key-001</ds:KeyName>
         </KeyInfo>
      </EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP"
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              JSPUyp3azOkqJENSsh6b2hdXz1WBYypzJxEr+ikQAa22M6V/BgZhRg==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2012</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvServerFinished>

7.2.1.3.  Example Using the Passphrase-Based Key Wrap Profile

   The client sends a request similar to that in Section 7.2.1.1 with
   authentication data basing on an authentication code, and the server
   responds using the Passphrase-Based Key Wrap Profile.  The
   authentication data is set in clear text when it is sent over a



Doherty, et al.            Expires May 1, 2008                 [Page 56]


Internet-Draft                    DSKPP                     October 2007


   secure transport channel such as TLS.

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:pkcs-5="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
  keyprov-dskpp-1.0.xsd">
  <DeviceIdentifierData>
    <DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </DeviceId>
  </DeviceIdentifierData>
  <ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</ClientNonce>
  <SupportedKeyTypes>
    <Algorithm>urn:ietf:params:xml:schema:keyprov:otpalg#HOTP</Algorithm>
    <Algorithm>
      http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
    </Algorithm>
  </SupportedKeyTypes>
  <SupportedEncryptionAlgorithms>
    <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
    <Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128</Algorithm>
    <Algorithm>
      http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
    </Algorithm>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedEncryptionAlgorithms>
  <SupportedMacAlgorithms>
    <Algorithm>
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
    </Algorithm>
  </SupportedMacAlgorithms>
  <SupportedProtocolVariants>
    <TwoPass>
      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#wrap
      </SupportedKeyInitializationMethod>
      <Payload xsi:type="ds:KeyInfoType">
        <ds:KeyName>Key_001</ds:KeyName>
      </Payload>



Doherty, et al.            Expires May 1, 2008                 [Page 57]


Internet-Draft                    DSKPP                     October 2007


      <SupportedKeyInitializationMethod>
        urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
      </SupportedKeyInitializationMethod>
    </TwoPass>
  </SupportedProtocolVariants>
  <SupportedKeyContainers>
    <KeyContainerFormat>
      urn:ietf:params:xml:schema:keyprov:container#KeyContainer
    </KeyContainerFormat>
  </SupportedKeyContainers>
  <AuthenticationData>
    <ClientID>31300257</ClientID>
    <AuthenticationCodeMac>
      <IterationCount>512</IterationCount>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvClientHello>

   In this example, the server responds to the previous request using
   the Passphrase-Based Key Wrap Profile.

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <EncryptionMethod
        Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2"
        xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
          <PBEEncryptionParam
             EncryptionAlgorithm="http://www.w3.org/2001/04/xmlenc#kw-aes128-cbc">
            <PBESalt>y6TzckeLRQw=</PBESalt>
            <PBEIterationCount>1024</PBEIterationCount>
          </PBEEncryptionParam>
          <IV>c2FtcGxlaXY=</IV>
        </EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP"
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>



Doherty, et al.            Expires May 1, 2008                 [Page 58]


Internet-Draft                    DSKPP                     October 2007


          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>
          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              JSPUyp3azOkqJENSsh6b2hdXz1WBYypzJxEr+ikQAa22M6V/BgZhRg==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2012</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvServerFinished>

7.2.2.  Components of the <KeyProvClientHello> Request

   The components of this message have the following meaning:
   o  Version: (attribute inherited from the AbstractRequestType type)
      The highest version of this protocol the client supports.  Only
      version one ("1.0") is currently specified.
   o  <DeviceIdentifierData>: An identifier for the cryptographic module
      as defined in Section 5.3 above.  The identifier MUST only be
      present if such shared secrets exist or if the identifier was
      provided by the server in a <KeyProvTrigger> element (see
      Section 12.2.7 below).  In the latter case, it MUST have the same
      value as the identifier provided in that element.
   o  <KeyID>: An identifier for the key that will be overwritten if the
      protocol run is successful.  The identifier MUST only be present
      if the key exists or the identifier was provided by the server in
      a <KeyProvTrigger> element (see Section 12.2.7 below).  In the
      latter case, it MUST have the same value as the identifier
      provided in that element.



Doherty, et al.            Expires May 1, 2008                 [Page 59]


Internet-Draft                    DSKPP                     October 2007


   o  <KeyProvClientNonce>: This is the nonce R, which, when present,
      MUST be used by the server when calculating MAC values (see
      below).  It is RECOMMENDED that clients include this element
      whenever the <KeyID> element is present.
   o  <TriggerNonce>: This OPTIONAL element MUST be present if and only
      if the DSKPP run was initialized with a <KeyProvTrigger> message
      (see Section 12.2.7 below), and MUST, in that case, have the same
      value as the <TriggerNonce> child of that message.  A server using
      nonces in this way MUST verify that the nonce is valid and that
      any device or key identifier values provided in the
      <KeyProvTrigger> message match the corresponding identifier values
      in the <KeyProvClientHello> message.
   o  <SupportedKeyTypes>: A sequence of URIs indicating the key types
      for which the cryptographic module is willing to generate keys
      through DSKPP.
   o  <SupportedEncryptionAlgorithms>: A sequence of URIs indicating the
      encryption algorithms supported by the cryptographic module for
      the purposes of DSKPP.  The DSKPP client MAY indicate the same
      algorithm both as a supported key type and as an encryption
      algorithm.
   o  <SupportedMacAlgorithms>: A sequence of URIs indicating the MAC
      algorithms supported by the cryptographic module for the purposes
      of DSKPP.  The DSKPP client MAY indicate the same algorithm both
      as an encryption algorithm and as a MAC algorithm (e.g.,
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes defined
      in Appendix B).
   o  <SupportedProtocolVariants>: This OPTIONAL element is used by the
      DSKPP client to indicate support for four-pass or two-pass DSKPP.
      If two-pass support is specified, then <KeyProvClientNonce> MUST
      be set to nonce R in the <KeyProvClientHello> message unless
      <TriggerNonce> is already present.
   o  <SupportedKeyContainers>: This OPTIONAL element is a sequence of
      URIs indicating the key container formats supported by the DSKPP
      client.  If this element is not provided, then the DSKPP server
      MUST proceed with
      "urn:ietf:params:xml:schema:keyprov:container#KeyContainer" (see
      [PSKC].
   o  <AuthenticationData>: This OPTIONAL element contains data that the
      DSKPP client uses to authenticate the user or device to the DSKPP
      server.  The element is set as specified in Section 5.3.
   o  <Extensions>: A sequence of extensions.  One extension is defined
      for this message in this version of DSKPP: the ClientInfoType (see
      Section 10).

7.2.3.  Components of a <KeyProvServerFinished> Response

   This message is the last message of the DSKPP protocol run.  In a
   4-pass exchange, the DSKPP server sends this message in response to a



Doherty, et al.            Expires May 1, 2008                 [Page 60]


Internet-Draft                    DSKPP                     October 2007


   <KeyProvClientNonce> message, whereas in a 2-pass exchange, the DSKPP
   server sends this message in response to a <KeyProvClientHello>
   message.  In a 1-pass exchange, the DSKPP server sends only this
   message to the client.  The components of this message have the
   following meaning:

   o  Version: (inherited from the AbstractResponseType type) The DSKPP
      version used in this session.
   o  SessionID: (inherited from the AbstractResponseType type) The
      previously established identifier for this session.
   o  Status: (inherited from the AbstractResponseType type) Return code
      for the <KeyProvServerFinished> message.  If Status is not
      "Success", only the Status, SessionID, and Version attributes will
      be present (the presence of the SessionID attribute is dependent
      on the type of reported error); otherwise, all the other elements
      MUST be present as well.  In this latter case, the
      <KeyProvServerFinished> message can be seen as a "Commit" message,
      instructing the cryptographic module to store the generated key
      and associate the given key identifier with this key.
   o  <KeyContainer>: The key container containing symmetric key values
      (in the case of a 2- or 1-pass exchange) and configuration data.
      The default container format is based on the KeyContainerType type
      from PSKC, as defined in [PSKC].
   o  <Extensions>: A list of extensions chosen by the DSKPP server.
      For this message, this version of DSKPP defines one extension, the
      ClientInfoType (see Section 10).
   o  <Mac>: To avoid a false "Commit" message causing the cryptographic
      module to end up in an initialized state for which the server does
      not know the stored key, <KeyProvServerFinished> messages MUST
      always be authenticated with a MAC.  The MAC MUST be made using
      the already established MAC algorithm.
   o  <AuthenticationData>: This OPTIONAL element contains data that
      allows the DSKPP client to authenticate the DSKPP server.  The MAC
      value is calculated with K_MAC' as specified in Section 4.4.3.
      When receiving a <KeyProvServerFinished> message with
      Status="Success" for which the MAC verifies, the DSKPP client MUST
      associate the generated key K_TOKEN with the provided key
      identifier and store this data permanently.  After this operation,
      it MUST not be possible to overwrite the key unless knowledge of
      an authorizing key is proven through a MAC on a later
      <KeyProvServerHello> (and <KeyProvServerFinished>) message.
      The DSKPP client MUST verify the MAC.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST,
      in this case, also delete any nonces, keys, and/or secrets
      associated with the failed run of the DSKPP protocol.
      The MacType's MacAlgorithm attribute MUST, when present, identify
      the negotiated MAC algorithm.




Doherty, et al.            Expires May 1, 2008                 [Page 61]


Internet-Draft                    DSKPP                     October 2007


7.3.  DSKPP Server Results:  The StatusCode Type

   The StatusCode type enumerates all possible return codes.  Upon
   transmission or receipt of a message for which the Status attribute's
   value is not "Success" or "Continue", the default behavior, unless
   explicitly stated otherwise below, is that both the DSKPP server and
   the DSKPP client MUST immediately terminate the DSKPP session.  DSKPP
   servers and DSKPP clients MUST delete any secret values generated as
   a result of failed runs of the DSKPP protocol.  Session identifiers
   MAY be retained from successful or failed protocol runs for replay
   detection purposes, but such retained identifiers MUST not be reused
   for subsequent runs of the protocol.

   When possible, the DSKPP client SHOULD present an appropriate error
   message to the user.

   These status codes are valid in all DSKPP Response messages unless
   explicitly stated otherwise:
   o  "Continue" indicates that the DSKPP server is ready for a
      subsequent request from the DSKPP client.  It cannot be sent in
      the server's final message.
   o  "Success" indicates successful completion of the DSKPP session.
      It can only be sent in the server's final message.
   o  "Abort" indicates that the DSKPP server rejected the DSKPP
      client's request for unspecified reasons.
   o  "AccessDenied" indicates that the DSKPP client is not authorized
      to contact this DSKPP server.
   o  "MalformedRequest" indicates that the DSKPP server failed to parse
      the DSKPP client's request.
   o  "UnknownRequest" indicates that the DSKPP client made a request
      that is unknown to the DSKPP server.
   o  "UnknownCriticalExtension" indicates that a critical DSKPP
      extension (see below) used by the DSKPP client was not supported
      or recognized by the DSKPP server.
   o  "UnsupportedVersion" indicates that the DSKPP client used a DSKPP
      protocol version not supported by the DSKPP server.  This error is
      only valid in the DSKPP server's first response message.
   o  "NoSupportedKeyTypes" indicates that the DSKPP client only
      suggested key types that are not supported by the DSKPP server.
      This error is only valid in the DSKPP server's first response
      message.
   o  "NoSupportedEncryptionAlgorithms" indicates that the DSKPP client
      only suggested encryption algorithms that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.  Note that the error will only occur if
      the DSKPP server does not support any of the DSKPP client's
      suggested encryption algorithms.




Doherty, et al.            Expires May 1, 2008                 [Page 62]


Internet-Draft                    DSKPP                     October 2007


   o  "NoSupportedMacAlgorithms" indicates that the DSKPP client only
      suggested MAC algorithms that are not supported by the DSKPP
      server.  This error is only valid in the DSKPP server's first
      response message.  Note that the error will only occur if the
      DSKPP server does not support any of the DSKPP client's suggested
      MAC algorithms.
   o  "NoProtocolVariants" indicates that the DSKPP client only
      suggested a protocol variant (either 2-pass or 4-pass) that is not
      supported by the DSKPP server.  This error is only valid in the
      DSKPP server's first response message.  Note that the error will
      only occur if the DSKPP server does not support any of the DSKPP
      client's suggested protocol variants.
   o  "NoSupportedKeyContainers" indicates that the DSKPP client only
      suggested key container formats that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.  Note that the error will only occur if
      the DSKPP server does not support any of the DSKPP client's
      suggested key container formats.
   o  "AuthenticationDataMissing" indicates that the DSKPP client didn't
      provide authentication data that the DSKPP server required.
   o  "AuthenticationDataInvalid" indicates that the DSKPP client
      supplied user or device authentication data that the DSKPP server
      failed to validate.
   o  "InitializationFailed" indicates that the DSKPP server could not
      generate a valid key given the provided data.  When this status
      code is received, the DSKPP client SHOULD try to restart DSKPP, as
      it is possible that a new run will succeed.
   o  "ProvisioningPeriodExpired" indicates that the provisioning period
      set by the DSKPP server has expired.  When the status code is
      received, the DSKPP client SHOULD report the key initialization
      failure reason to the user and the user MUST register with the
      DSKPP server to initialize a new key.


8.  One-Pass Protocol

   In this section, example messages are used to describe parameters,
   encoding and semantics in a 1-pass DSKPP protocol.  The examples are
   written using XML.  While they are syntactically correct, MAC and
   cipher values are fictitious.

8.1.  XML Basics

   The DSKPP XML schema can be found in Section 13.  Some DSKPP elements
   rely on the parties being able to compare received values with stored
   values.  Unless otherwise noted, all elements in this document that
   have the XML Schema "xs:string" type, or a type derived from it, MUST
   be compared using an exact binary comparison.  In particular, DSKPP



Doherty, et al.            Expires May 1, 2008                 [Page 63]


Internet-Draft                    DSKPP                     October 2007


   implementations MUST NOT depend on case-insensitive string
   comparisons, normalization or trimming of white space, or conversion
   of locale-specific formats such as numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [UNICODE], and then
   performing an exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

8.2.  Server to Client Only: <KeyProvServerFinished>

8.2.1.  Example

   The Server sends a provisioned key to a client with prior knowledge
   about the client's capabilities:

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
  xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <KeyContainer>
    <KeyContainer Version="1.0">
      <pskc:EncryptionMethod
        Algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
        <pskc:KeyInfo>
          <ds:X509Data>
            <ds:X509Certificate>miib</ds:X509Certificate>
          </ds:X509Data>
        </pskc:KeyInfo>
      </pskc:EncryptionMethod>
      <pskc:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"/>
      <Device xmlns="urn:ietf:params:xml:ns:keyprov:1.0:container">
        <Key KeyAlgorithm="urn:ietf:params:xml:schema:keyprov:otpalg#HOTP"
          KeyId="SDU312345678">
          <Issuer>CredentialIssuer</Issuer>
          <Usage otp="true">
            <ResponseFormat format="DECIMAL" length="6"/>
          </Usage>



Doherty, et al.            Expires May 1, 2008                 [Page 64]


Internet-Draft                    DSKPP                     October 2007


          <FriendlyName>MyFirstToken</FriendlyName>
          <Data Name="SECRET">
            <Value>
              7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
            </Value>
            <ValueDigest>
              i8j+kpbfKQsSlwmJYS99lQ==
            </ValueDigest>
          </Data>
          <Data Name="COUNTER">
            <Value>AAAAAAAAAAA=</Value>
          </Data>
          <Expiry>10/30/2009</Expiry>
        </Key>
      </Device>
    </KeyContainer>
  </KeyContainer>
  <Mac MacAlgorithm="urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
    miidfasde312asder394jw==
  </Mac>
  <AuthenticationData>
    <AuthenticationCodeMac>
      <Mac>4bRJf9xXd3KchKoTenHJiw==</Mac>
    </AuthenticationCodeMac>
  </AuthenticationData>
</dskpp:KeyProvServerFinished>

8.2.2.  Components of a <KeyProvServerFinished> Response

   This message is the last message of the DSKPP protocol run.  In a
   4-pass exchange, the DSKPP server sends this message in response to a
   <KeyProvClientNonce> message, whereas in a 2-pass exchange, the DSKPP
   server sends this message in response to a <KeyProvClientHello>
   message.  In a 1-pass exchange, the DSKPP server sends only this
   message to the client.  The components of this message have the
   following meaning:

   o  Version: (inherited from the AbstractResponseType type) The DSKPP
      version used in this session.
   o  SessionID: (inherited from the AbstractResponseType type) The
      previously established identifier for this session.
   o  Status: (inherited from the AbstractResponseType type) Return code
      for the <KeyProvServerFinished> message.  If Status is not
      "Success", only the Status, SessionID, and Version attributes will
      be present (the presence of the SessionID attribute is dependent
      on the type of reported error); otherwise, all the other elements
      MUST be present as well.  In this latter case, the
      <KeyProvServerFinished> message can be seen as a "Commit" message,



Doherty, et al.            Expires May 1, 2008                 [Page 65]


Internet-Draft                    DSKPP                     October 2007


      instructing the cryptographic module to store the generated key
      and associate the given key identifier with this key.
   o  <KeyContainer>: The key container containing symmetric key values
      (in the case of a 2- or 1-pass exchange) and configuration data.
      The default container format is based on the KeyContainerType type
      from PSKC, as defined in [PSKC].
   o  <Extensions>: A list of extensions chosen by the DSKPP server.
      For this message, this version of DSKPP defines one extension, the
      ClientInfoType (see Section 10).
   o  <Mac>: To avoid a false "Commit" message causing the cryptographic
      module to end up in an initialized state for which the server does
      not know the stored key, <KeyProvServerFinished> messages MUST
      always be authenticated with a MAC.  The MAC MUST be made using
      the already established MAC algorithm.
   o  <AuthenticationData>: This OPTIONAL element contains data that
      allows the DSKPP client to authenticate the DSKPP server.  The MAC
      value is calculated with K_MAC' as specified in Section 4.5.3.
      When receiving a <KeyProvServerFinished> message with
      Status="Success" for which the MAC verifies, the DSKPP client MUST
      associate the generated key K_TOKEN with the provided key
      identifier and store this data permanently.  After this operation,
      it MUST not be possible to overwrite the key unless knowledge of
      an authorizing key is proven through a MAC on a later
      <KeyProvServerHello> (and <KeyProvServerFinished>) message.
      The DSKPP client MUST verify the MAC.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST,
      in this case, also delete any nonces, keys, and/or secrets
      associated with the failed run of the DSKPP protocol.
      The MacType's MacAlgorithm attribute MUST, when present, identify
      the negotiated MAC algorithm.


9.  Trigger

   In this section, an example is used to describe parameters, encoding
   and semantics in a DSKPP Trigger message.  The example is written
   using XML.

9.1.  XML Basics

   The DSKPP XML schema can be found in Section 13.  Some DSKPP elements
   rely on the parties being able to compare received values with stored
   values.  Unless otherwise noted, all elements in this document that
   have the XML Schema "xs:string" type, or a type derived from it, MUST
   be compared using an exact binary comparison.  In particular, DSKPP
   implementations MUST NOT depend on case-insensitive string
   comparisons, normalization or trimming of white space, or conversion
   of locale-specific formats such as numbers.



Doherty, et al.            Expires May 1, 2008                 [Page 66]


Internet-Draft                    DSKPP                     October 2007


   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [UNICODE], and then
   performing an exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

9.2.  Example


<dskpp:KeyProvTrigger Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:1.0:protocol
    keyprov-dskpp-1.0.xsd">
  <InitializationTrigger>
    <DeviceIdentifierData>
      <DeviceId>
        <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
        <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
        <pskc:Model>U2</pskc:Model>
      </DeviceId>
    </DeviceIdentifierData>
    <KeyID>SE9UUDAwMDAwMDAx</KeyID>
    <TokenPlatformInfo KeyLocation="Hardware" AlgorithmLocation="Software"/>
    <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
    <DSKPPServerUrl>https://www.somekeyprovservice.com/</DSKPPServerUrl>
  </InitializationTrigger>
</dskpp:KeyProvTrigger>

9.3.  Components of the <KeyProvTrigger> Message

   The DSKPP server MAY initialize the DSKPP protocol by sending a
   <KeyProvTrigger> message.  This message MAY, e.g., be sent in
   response to a user requesting key initialization in a browsing
   session.

   The <KeyProvTrigger> element is intended for the DSKPP client and MAY
   inform the DSKPP client about the identifier for the device that
   houses the cryptographic module to be initialized, and optionally of
   the identifier for the key on that module.  The latter would apply to
   key renewal.  The trigger always contains a nonce to allow the DSKPP
   server to couple the trigger with a later DSKPP <KeyProvClientHello>
   request.  Finally, the trigger MAY contain a URL to use when



Doherty, et al.            Expires May 1, 2008                 [Page 67]


Internet-Draft                    DSKPP                     October 2007


   contacting the DSKPP server.  The <xs:any> elements are for future
   extensibility.  Any provided <DeviceIdentifierData> or <KeyID> values
   MUST be used by the DSKPP client in the subsequent
   <KeyProvClientHello> request.  The OPTIONAL <TokenPlatformInfo>
   element informs the DSKPP client about the characteristics of the
   intended cryptographic module platform, and applies in the public-key
   variant of DSKPP in situations when the client potentially needs to
   decide which one of several modules to initialize.


10.  Extensibility

10.1.  The ClientInfoType Type

   present in a <KeyProvClientHello> or a <KeyProvClientNonce> message,
   the OPTIONAL ClientInfoType extension contains DSKPP client-specific
   information.  DSKPP servers MUST support this extension.  DSKPP
   servers MUST NOT attempt to interpret the data it carries and, if
   received, MUST include it unmodified in the current protocol run's
   next server response.  Servers need not retain the ClientInfoType's
   data after that response has been generated.

10.2.  The ServerInfoType Type

   When present, the OPTIONAL ServerInfoType extension contains DSKPP
   server-specific information.  This extension is only valid in
   <KeyProvServerHello> messages for which Status = "Continue".  DSKPP
   clients MUST support this extension.  DSKPP clients MUST NOT attempt
   to interpret the data it carries and, if received, MUST include it
   unmodified in the current protocol run's next client request (i.e.,
   the <KeyProvClientNonce> message).  DSKPP clients need not retain the
   ServerInfoType's data after that request has been generated.  This
   extension MAY be used, e.g., for state management in the DSKPP
   server.

10.3.  The KeyInitializationDataType Type

   This extension is used for 2- and 1-pass DSKPP exchange; it carries
   an identifier for the selected key initialization method as well as
   key initialization method-dependent payload data.

   Servers MAY include this extension in a <KeyProvServerFinished>
   message that is being sent in response to a received
   <KeyProvClientHello> message if and only if that <KeyProvClientHello>
   message selected TwoPassSupport as the ProtocolVariantType and the
   client indicated support for the selected key initialization method.
   Servers MUST include this extension in a <KeyProvServerFinished>
   message that is sent as part of a 1-pass DSKPP.



Doherty, et al.            Expires May 1, 2008                 [Page 68]


Internet-Draft                    DSKPP                     October 2007


   The elements of this type have the following meaning:

   o  <KeyInitializationMethod>: A two-pass key initialization method
      supported by the DSKPP client.
   o  <Payload>: A payload associated with the key initialization
      method.  Since the syntax is a shorthand for <xs:element
      name="Payload" type="xs:anyType"/>, any well-formed payloads can
      be carried in this element.


11.  Key Initialization Profiles of Two- and One-Pass DSKPP

11.1.  Introduction

   This appendix introduces three profiles of DSKPP for key
   initialization.  They MAY all be used for two- as well as one-pass
   initialization of cryptographic modules.  Further profiles MAY be
   defined by external entities or through the IETF process.

11.2.  Key Transport Profile

11.2.1.  Introduction

   This profile initializes the cryptographic module with a symmetric
   key, K_TOKEN, through key transport and key derivation.  The key
   transport is carried out using a public key, K_CLIENT, whose private
   key part resides in the cryptographic module as the transport key.  A
   key K from which two keys, K_TOKEN and K_MAC are derived MUST be
   transported.

11.2.2.  Identification

   This profile MUST be identified with the following URN:

   urn:ietf:params:xml:schema:keyprov:protocol#transport

11.2.3.  Payloads

   In the two-pass version of DSKPP, the client MUST send a payload
   associated with this key initialization method.  The payload MUST be
   of type ds:KeyInfoType ([XMLDSIG]), and only those choices of the ds:
   KeyInfoType that identify a public key are allowed.  The ds:
   X509Certificate option of the ds:X509Data alternative is RECOMMENDED
   when the public key corresponding to the private key on the
   cryptographic module has been certified.

   The server payload associated with this key initialization method
   MUST be of type xenc:EncryptedKeyType ([XMLENC]), and only those



Doherty, et al.            Expires May 1, 2008                 [Page 69]


Internet-Draft                    DSKPP                     October 2007


   encryption methods utilizing a public key that are supported by the
   DSKPP client (as indicated in the <SupportedEncryptionAlgorithms>
   element of the <KeyProvClientHello> message in the case of 2-pass
   DSKPP, or as otherwise known in the case of 1-pass DSKPP) are allowed
   as values for the <xenc:EncryptionMethod> element.  Further, in the
   case of 2-pass DSKPP, the <ds:KeyInfo> element MUST contain the same
   value (i.e. identify the same public key) as the <Payload> of the
   corresponding supported key initialization method in the
   <KeyProvClientHello> message that triggered the response.  The
   <CarriedKeyName> element MAY be present, but MUST, when present,
   contain the same value as the <KeyID> element of the
   <KeyProvServerFinished> message.  The Type attribute of the xenc:
   EncryptedKeyType MUST be present and MUST identify the type of the
   wrapped key.  The type MUST be one of the types supported by the
   DSKPP client (as reported in the <SupportedKeyTypes> of the preceding
   <KeyProvClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The transported key
   MUST consist of two parts of equal length.  The first half
   constitutes K_MAC and the second half constitutes K_TOKEN.  The
   length of K_TOKEN (and hence also the length of K_MAC) is determined
   by the type of K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the http://www.w3.org/2001/04/xmlenc#rsa-1_5 key-wrapping
   mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <KeyProvServerFinished> message MUST be present and
   MUST identify the selected MAC algorithm.  The selected MAC algorithm
   MUST be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMacAlgorithms> element of the
   <KeyProvClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The MAC MUST be
   calculated as described in Section 4.4 for Two-Pass DSKPP and
   Section 4.5 for One-Pass DSKPP.

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element in their <KeyProvServerFinished> messages whenever a
   successful protocol run will result in an existing K_TOKEN being
   replaced.

11.3.  Key Wrap Profile

11.3.1.  Introduction

   This profile initializes the cryptographic module with a symmetric
   key, K_TOKEN, through key wrap and key derivation.  The key wrap MUST
   be carried out using a (symmetric) key-wrapping key, K_SHARED, known



Doherty, et al.            Expires May 1, 2008                 [Page 70]


Internet-Draft                    DSKPP                     October 2007


   in advance by both the cryptographic module and the DSKPP server.  A
   key K from which two keys, K_TOKEN and K_MAC are derived MUST be
   wrapped.

11.3.2.  Identification

   This profile MUST be identified with the following URI:

   urn:ietf:params:xml:schema:keyprov:protocol#wrap

11.3.3.  Payloads

   In the 2-pass version of DSKPP, the client MUST send a payload
   associated with this key initialization method.  The payload MUST be
   of type ds:KeyInfoType ([XMLDSIG]), and only those choices of the ds:
   KeyInfoType that identify a symmetric key are allowed.  The ds:
   KeyName alternative is RECOMMENDED.

   The server payload associated with this key initialization method
   MUST be of type xenc:EncryptedKeyType ([XMLENC]), and only those
   encryption methods utilizing a symmetric key that are supported by
   the DSKPP client (as indicated in the <SupportedEncryptionAlgorithms>
   element of the <KeyProvClientHello> message in the case of 2-pass
   DSKPP, or as otherwise known in the case of 1-pass DSKPP) are allowed
   as values for the <xenc:EncryptionMethod> element.  Further, in the
   case of 2-pass DSKPP, the <ds:KeyInfo> element MUST contain the same
   value (i.e. identify the same symmetric key) as the <Payload> of the
   corresponding supported key initialization method in the
   <KeyProvClientHello> message that triggered the response.  The
   <CarriedKeyName> element MAY be present, and MUST, when present,
   contain the same value as the <KeyID> element of the
   <KeyProvServerFinished> message.  The Type attribute of the xenc:
   EncryptedKeyType MUST be present and MUST identify the type of the
   wrapped key.  The type MUST be one of the types supported by the
   DSKPP client (as reported in the <SupportedKeyTypes> of the preceding
   <KeyProvClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The wrapped key MUST
   consist of two parts of equal length.  The first half constitutes
   K_MAC and the second half constitutes K_TOKEN.  The length of K_TOKEN
   (and hence also the length of K_MAC) is determined by the type of
   K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the http://www.w3.org/2001/04/xmlenc#kw-aes128 key-wrapping
   mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <KeyProvServerFinished> message MUST be present and



Doherty, et al.            Expires May 1, 2008                 [Page 71]


Internet-Draft                    DSKPP                     October 2007


   MUST identify the selected MAC algorithm.  The selected MAC algorithm
   MUST be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMacAlgorithms> element of the
   <KeyProvClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The MAC MUST be
   calculated as described in Section 4.4.

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element in their <KeyProvServerFinished> messages whenever a
   successful protocol run will result in an existing K_TOKEN being
   replaced.

11.4.  Passphrase-Based Key Wrap Profile

11.4.1.  Introduction

   This profile is a variation of the key wrap profile.  It initializes
   the cryptographic module with a symmetric key, K_TOKEN, through key
   wrap and key derivation, using a passphrase-derived key-wrapping key,
   K_DERIVED.  The passphrase is known in advance by both the device
   user and the DSKPP server.  To preserve the property of not exposing
   K_TOKEN to any other entity than the DSKPP server and the
   cryptographic module itself, the method SHOULD be employed only when
   the device contains facilities (e.g. a keypad) for direct entry of
   the passphrase.  A key K from which two keys, K_TOKEN and K_MAC are
   derived MUST be wrapped.

11.4.2.  Identification

   This profile MUST be identified with the following URI:

   urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap

11.4.3.  Payloads

   In the 2-pass version of DSKPP, the client MUST send a payload
   associated with this key initialization method.  The payload MUST be
   of type ds:KeyInfoType ([XMLDSIG]).  The ds:KeyName option MUST be
   used and the key name MUST identify the passphrase that will be used
   by the server to generate the key-wrapping key.  As an example, the
   identifier could be a user identifier or a registration identifier
   issued by the server to the user during a session preceding the DSKPP
   protocol run.

   The server payload associated with this key initialization method
   MUST be of type xenc:EncryptedKeyType ([XMLENC]), and only those
   encryption methods utilizing a passphrase to derive the key-wrapping
   key that are supported by the DSKPP client (as indicated in the



Doherty, et al.            Expires May 1, 2008                 [Page 72]


Internet-Draft                    DSKPP                     October 2007


   <SupportedEncryptionAlgorithms> element of the <KeyProvClientHello>
   message in the case of 2-pass DSKPP, or as otherwise known in the
   case of 1-pass DSKPP) are allowed as values for the <xenc:
   EncryptionMethod> element.  Further, in the case of 2-pass DSKPP, the
   <ds:KeyInfo> element MUST contain the same value (i.e. identify the
   same passphrase) as the <Payload> of the corresponding supported key
   initialization method in the <KeyProvClientHello> message that
   triggered the response.  The <CarriedKeyName> element MAY be present,
   and MUST, when present, contain the same value as the <KeyID> element
   of the <KeyProvServerFinished> message.  The Type attribute of the
   xenc:EncryptedKeyType MUST be present and MUST identify the type of
   the wrapped key.  The type MUST be one of the types supported by the
   DSKPP client (as reported in the <SupportedKeyTypes> of the preceding
   <KeyProvClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The wrapped key MUST
   consist of two parts of equal length.  The first half constitutes
   K_MAC and the second half constitutes K_TOKEN.  The length of K_TOKEN
   (and hence also the length of K_MAC) is determined by the type of
   K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the PBES2 password based encryption scheme defined in
   [PKCS-5] (and identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
   [PKCS-5-XML]), the PBKDF2 passphrase-based key derivation function
   also defined in [PKCS-5] (and identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
   [PKCS-5-XML]), and the http://www.w3.org/2001/04/xmlenc#kw-aes128
   key-wrapping mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <KeyProvServerFinished> message MUST be present and
   MUST identify the selected MAC algorithm.  The selected MAC algorithm
   MUST be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMacAlgorithms> element of the
   <KeyProvClientHello> message in the case of 2-pass DSKPP, or as
   otherwise known in the case of 1-pass DSKPP).  The MAC MUST be
   calculated as described in Section 4.4.

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element in their <KeyProvServerFinished> messages whenever a
   successful protocol run will result in an existing K_TOKEN being
   replaced.


12.  Protocol Bindings





Doherty, et al.            Expires May 1, 2008                 [Page 73]


Internet-Draft                    DSKPP                     October 2007


12.1.  General Requirements

   DSKPP assumes a reliable transport.

12.2.  HTTP/1.1 Binding for DSKPP

12.2.1.  Introduction

   This section presents a binding of the previous messages to HTTP/1.1
   [RFC2616].  Note that the HTTP client normally will be different from
   the DSKPP client, i.e., the HTTP client will only exist to "proxy"
   DSKPP messages from the DSKPP client to the DSKPP server.  Likewise,
   on the HTTP server side, the DSKPP server MAY receive DSKPP PDUs from
   a "front-end" HTTP server.

12.2.2.  Identification of DSKPP Messages

   The MIME-type for all DSKPP messages MUST be

   application/vnd.ietf.keyprov.dskpp+xml

12.2.3.  HTTP Headers

   HTTP proxies MUST NOT cache responses carrying DSKPP messages.  For
   this reason, the following holds:
   o  When using HTTP/1.1, requesters SHOULD:
      *  Include a Cache-Control header field set to "no-cache, no-
         store".
      *  Include a Pragma header field set to "no-cache".
   o  When using HTTP/1.1, responders SHOULD:
      *  Include a Cache-Control header field set to "no-cache, no-must-
         revalidate, private".
      *  Include a Pragma header field set to "no-cache".
      *  NOT include a Validator, such as a Last-Modified or ETag
         header.
   There are no other restrictions on HTTP headers, besides the
   requirement to set the Content-Type header value according to
   Section 12.2.2.

12.2.4.  HTTP Operations

   Persistent connections as defined in HTTP/1.1 are assumed but not
   required.  DSKPP requests are mapped to HTTP POST operations.  DSKPP
   responses are mapped to HTTP responses.







Doherty, et al.            Expires May 1, 2008                 [Page 74]


Internet-Draft                    DSKPP                     October 2007


12.2.5.  HTTP Status Codes

   A DSKPP HTTP responder that refuses to perform a message exchange
   with a DSKPP HTTP requester SHOULD return a 403 (Forbidden) response.
   In this case, the content of the HTTP body is not significant.  In
   the case of an HTTP error while processing a DSKPP request, the HTTP
   server MUST return a 500 (Internal Server Error) response.  This type
   of error SHOULD be returned for HTTP-related errors detected before
   control is passed to the DSKPP processor, or when the DSKPP processor
   reports an internal error (for example, the DSKPP XML namespace is
   incorrect, or the DSKPP schema cannot be located).  If the type of a
   DSKPP request cannot be determined, the DSKPP responder MUST return a
   400 (Bad request) response.

   In these cases (i.e., when the HTTP response code is 4xx or 5xx), the
   content of the HTTP body is not significant.

   Redirection status codes (3xx) apply as usual.

   Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
   responder MUST use the 200 status code and provide a suitable DSKPP
   message (possibly with DSKPP error information included) in the HTTP
   body.

12.2.6.  HTTP Authentication

   No support for HTTP/1.1 authentication is assumed.

12.2.7.  Initialization of DSKPP

   The DSKPP server MAY initialize the DSKPP protocol by sending an HTTP
   response with Content-Type set according to Section 12.2.2 and
   response code set to 200 (OK).  This message MAY, e.g., be sent in
   response to a user requesting key initialization in a browsing
   session.  The initialization message MAY carry data in its body.  If
   this is the case, the data MUST be a valid instance of a
   <KeyProvTrigger> element.

12.2.8.  Example Messages

   a.  Initialization from DSKPP server:
       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP initialization data in XML form...



Doherty, et al.            Expires May 1, 2008                 [Page 75]


Internet-Draft                    DSKPP                     October 2007


   b.  Initial request from DSKPP client:
       POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1
       Cache-Control: no-store
       Pragma: no-cache
       Host: example.com
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (supported version, supported
       algorithms...)

   c.  Initial response from DSKPP server:
       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (server random nonce, server public key,
       ...)


13.  DSKPP Schema


<?xml version="1.0" encoding="UTF-8"?>

 <xs:schema
   xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:1.0:container"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
   targetNamespace="urn:ietf:params:xml:ns:keyprov:1.0:protocol"
   elementFormDefault="unqualified" attributeFormDefault="unqualified"
   version="1.0">

   <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
     schemaLocation="http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/>

   <xs:import namespace="urn:ietf:params:xml:ns:keyprov:1.0:container"
     schemaLocation="keyprov-pskc-1.0.xsd"/>

   <!-- Basic types -->
   <xs:complexType name="AbstractRequestType" abstract="true">
     <xs:attribute name="Version" type="dskpp:VersionType" use="required"/>
   </xs:complexType>

   <xs:complexType name="AbstractResponseType" abstract="true">



Doherty, et al.            Expires May 1, 2008                 [Page 76]


Internet-Draft                    DSKPP                     October 2007


     <xs:attribute name="Version" type="dskpp:VersionType" use="required"/>
     <xs:attribute name="SessionID" type="dskpp:IdentifierType"/>
     <xs:attribute name="Status" type="dskpp:StatusCode" use="required"/>
   </xs:complexType>

   <xs:simpleType name="VersionType">
     <xs:restriction base="xs:string">
       <xs:pattern value="\d{1,2}\.\d{1,3}"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="IdentifierType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="128"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue"/>
       <xs:enumeration value="Success"/>
       <xs:enumeration value="Abort"/>
       <xs:enumeration value="AccessDenied"/>
       <xs:enumeration value="MalformedRequest"/>
       <xs:enumeration value="UnknownRequest"/>
       <xs:enumeration value="UnknownCriticalExtension"/>
       <xs:enumeration value="UnsupportedVersion"/>
       <xs:enumeration value="NoSupportedKeyTypes"/>
       <xs:enumeration value="NoSupportedEncryptionAlgorithms"/>
       <xs:enumeration value="NoSupportedMacAlgorithms"/>
       <xs:enumeration value="NoProtocolVariants"/>
       <xs:enumeration value="NoSupportedKeyContainers"/>
       <xs:enumeration value="AuthenticationDataMissing"/>
       <xs:enumeration value="AuthenticationDataInvalid"/>
       <xs:enumeration value="InitializationFailed"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceId" type="pskc:DeviceIdType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:simpleType name="PlatformType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Hardware"/>



Doherty, et al.            Expires May 1, 2008                 [Page 77]


Internet-Draft                    DSKPP                     October 2007


       <xs:enumeration value="Software"/>
       <xs:enumeration value="Unspecified"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="TokenPlatformInfoType">
     <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
     <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
   </xs:complexType>

   <xs:simpleType name="NonceType">
     <xs:restriction base="xs:base64Binary">
       <xs:minLength value="16"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AlgorithmsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Algorithm" type="dskpp:AlgorithmType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AlgorithmType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element name="FourPass" minOccurs="0"/>
       <xs:element name="TwoPass" type="dskpp:TwoPassSupportType"
         minOccurs="0"/>
       <xs:element name="OnePass" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="TwoPassSupportType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyInitializationMethod"
         type="xs:anyURI"/>
       <xs:element name="Payload" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="KeyContainersFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="KeyContainerFormat"
         type="dskpp:KeyContainerFormatType"/>
     </xs:sequence>



Doherty, et al.            Expires May 1, 2008                 [Page 78]


Internet-Draft                    DSKPP                     October 2007


   </xs:complexType>

   <xs:simpleType name="KeyContainerFormatType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complexType name="AuthenticationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Authentication data can consist of either authentication code
         for authenticating a user of the protocol, or an X.509 Certificate for
         authenticating a device. When a device certificate is used over a
         transport layer that is not secure, the Signature is calculated over
         a nonce value specified in ds:Signature/Object. When used in
         conjunction with the KeyProvServerFinished PDU, it contains a MAC
         authenticating the DSKPP server to the client.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:element name="ClientID" type="dskpp:IdentifierType"
                   minOccurs="0"/>
       <xs:choice minOccurs="0">
           <xs:element name="AuthenticationCodeMac"
                       type="dskpp:AuthenticationCodeMacType"/>
           <xs:element name="DigitalSignature"
                       type="ds:SignatureType"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AuthenticationCodeMacType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         An authentication MAC calculated from an authentication code and
         optionally server information as well as nonce value if they are
         available.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:element name="Nonce" type="dskpp:NonceType" minOccurs="0"/>
       <xs:element name="IterationCount" type="xs:int" minOccurs="0"/>
       <xs:element name="Mac" type="dskpp:MacType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="MacType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">



Doherty, et al.            Expires May 1, 2008                 [Page 79]


Internet-Draft                    DSKPP                     October 2007


         <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="KeyContainerType">
     <xs:sequence>
       <xs:element name="ServerID" type="xs:anyURI" minOccurs="0"/>
       <xs:choice>
         <xs:element name="KeyContainer" type="pskc:KeyContainerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
       <xs:element name="KeyID" type="xs:base64Binary" minOccurs="0"/>
       <xs:element name="TokenPlatformInfo"
         type="dskpp:TokenPlatformInfoType" minOccurs="0"/>
       <xs:element name="TriggerNonce" type="dskpp:NonceType"/>
       <xs:element name="DSKPPServerUrl" type="xs:anyURI" minOccurs="0"/>
       <xs:any namespace="##other" processContents="strict"
         minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <!-- Extension types -->
   <xs:complexType name="ExtensionsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Extension" type="dskpp:AbstractExtensionType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AbstractExtensionType" abstract="true">
     <xs:attribute name="Critical" type="xs:boolean"/>
   </xs:complexType>

   <xs:complexType name="ClientInfoType">
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>



Doherty, et al.            Expires May 1, 2008                 [Page 80]


Internet-Draft                    DSKPP                     October 2007


     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="ServerInfoType">
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="PayloadType">
     <xs:choice>
       <xs:element name="Nonce" type="dskpp:NonceType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:complexType name="KeyInitializationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         This extension is only valid in KeyProvServerFinished PDUs. It
         contains key initialization data and its presence results in a
         two-pass (or one-pass, if no KeyProvClientHello was sent) DSKPP
         exchange.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="KeyInitializationMethod" type="xs:anyURI"/>
           <xs:element name="Payload" type="dskpp:PayloadType"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- DSKPP PDUs -->

   <xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType"/>

   <xs:complexType name="KeyProvTriggerType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a



Doherty, et al.            Expires May 1, 2008                 [Page 81]


Internet-Draft                    DSKPP                     October 2007


         DSKPP protocol run.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType"/>
   </xs:complexType>

   <!-- KeyProvClientHello PDU -->
   <xs:element name="KeyProvClientHello" type="dskpp:KeyProvClientHelloPDU"/>

   <xs:complexType name="KeyProvClientHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractRequestType">
         <xs:sequence>
           <xs:element name="DeviceIdentifierData"
             type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
           <xs:element name="KeyID" type="xs:base64Binary"
             minOccurs="0"/>
           <xs:element name="ClientNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="TriggerNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedMacAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" minOccurs="0"/>
           <xs:element name="SupportedKeyContainers"
             type="dskpp:KeyContainersFormatType" minOccurs="0"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions" type="dskpp:ExtensionsType"
             minOccurs="0"/>



Doherty, et al.            Expires May 1, 2008                 [Page 82]


Internet-Draft                    DSKPP                     October 2007


         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- KeyProvServerHello PDU -->
   <xs:element name="KeyProvServerHello" type="dskpp:KeyProvServerHelloPDU"/>

   <xs:complexType name="KeyProvServerHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP server to DSKPP client
         in response to a received KeyProvClientHello PDU.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="MacAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionKey"
             type="ds:KeyInfoType"/>
           <xs:element name="KeyContainerFormat"
             type="dskpp:KeyContainerFormatType"/>
           <xs:element name="Payload"
             type="dskpp:PayloadType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac" type="dskpp:MacType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- KeyProvClientNonce PDU -->
   <xs:element name="KeyProvClientNonce" type="dskpp:KeyProvClientNoncePDU"/>

   <xs:complexType name="KeyProvClientNoncePDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Second message sent from DSKPP client to
         DSKPP server in a DSKPP session.
       </xs:documentation>



Doherty, et al.            Expires May 1, 2008                 [Page 83]


Internet-Draft                    DSKPP                     October 2007


     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce"
             type="xs:base64Binary"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required"/>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- KeyProvServerFinished PDU -->
   <xs:element name="KeyProvServerFinished" type="dskpp:KeyProvServerFinishedPDU"/>

   <xs:complexType name="KeyProvServerFinishedPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to DSKPP client in a DSKPP
         session. A MAC value serves for key confirmation, and optional
         AuthenticationData servers for server authentication.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyContainer"
             type="dskpp:KeyContainerType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac"
             type="dskpp:MacType"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

 </xs:schema>






Doherty, et al.            Expires May 1, 2008                 [Page 84]


Internet-Draft                    DSKPP                     October 2007


14.  Security Considerations

14.1.  General

   DSKPP is designed to protect generated key material from exposure.
   No other entities than the DSKPP server and the cryptographic module
   will have access to a generated K_TOKEN if the cryptographic
   algorithms used are of sufficient strength and, on the DSKPP client
   side, generation and encryption of R_C and generation of K_TOKEN take
   place as specified in the cryptographic module.  This applies even if
   malicious software is present in the DSKPP client.  However, as
   discussed in the following, DSKPP does not protect against certain
   other threats resulting from man-in-the-middle attacks and other
   forms of attacks.  DSKPP SHOULD, therefore, be run over a transport
   providing privacy and integrity, such as HTTP over Transport Layer
   Security (TLS) with a suitable ciphersuite, when such threats are a
   concern.  Note that TLS ciphersuites with anonymous key exchanges are
   not suitable in those situations.

14.2.  Active Attacks

14.2.1.  Introduction

   An active attacker MAY attempt to modify, delete, insert, replay, or
   reorder messages for a variety of purposes including service denial
   and compromise of generated key material.  Section 14.2.2 through
   Section 14.2.7.

14.2.2.  Message Modifications

   Modifications to a <DSKPPTrigger> message will either cause denial-
   of-service (modifications of any of the identifiers or the nonce) or
   will cause the DSKPP client to contact the wrong DSKPP server.  The
   latter is in effect a man-in-the-middle attack and is discussed
   further in Section 14.2.7.

   An attacker may modify a <KeyProvClientHello> message.  This means
   that the attacker could indicate a different key or device than the
   one intended by the DSKPP client, and could also suggest other
   cryptographic algorithms than the ones preferred by the DSKPP client,
   e.g., cryptographically weaker ones.  The attacker could also suggest
   earlier versions of the DSKPP protocol, in case these versions have
   been shown to have vulnerabilities.  These modifications could lead
   to an attacker succeeding in initializing or modifying another
   cryptographic module than the one intended (i.e., the server
   assigning the generated key to the wrong module), or gaining access
   to a generated key through the use of weak cryptographic algorithms
   or protocol versions.  DSKPP implementations MAY protect against the



Doherty, et al.            Expires May 1, 2008                 [Page 85]


Internet-Draft                    DSKPP                     October 2007


   latter by having strict policies about what versions and algorithms
   they support and accept.  The former threat (assignment of a
   generated key to the wrong module) is not possible when the shared-
   key variant of DSKPP is employed (assuming existing shared keys are
   unique per cryptographic module), but is possible in the public-key
   variant.  Therefore, DSKPP servers MUST NOT accept unilaterally
   provided device identifiers in the public-key variant.  This is also
   indicated in the protocol description.  In the shared-key variant,
   however, an attacker may be able to provide the wrong identifier
   (possibly also leading to the incorrect user being associated with
   the generated key) if the attacker has real-time access to the
   cryptographic module with the identified key.  In other words, the
   generated key is associated with the correct cryptographic module but
   the module is associated with the incorrect user.  See further
   Section 14.5 for a discussion of this threat and possible
   countermeasures.

   An attacker may also modify a <KeyProvServerHello> message.  This
   means that the attacker could indicate different key types,
   algorithms, or protocol versions than the legitimate server would,
   e.g., cryptographically weaker ones.  The attacker may also provide a
   different nonce than the one sent by the legitimate server.  Clients
   MAY protect against the former through strict adherence to policies
   regarding permissible algorithms and protocol versions.  The latter
   (wrong nonce) will not constitute a security problem, as a generated
   key will not match the key generated on the legitimate server.  Also,
   whenever the DSKPP run would result in the replacement of an existing
   key, the <Mac> element protects against modifications of R_S.

   Modifications of <KeyProvClientNonce> messages are also possible.  If
   an attacker modifies the SessionID attribute, then, in effect, a
   switch to another session will occur at the server, assuming the new
   SessionID is valid at that time on the server.  It still will not
   allow the attacker to learn a generated K_TOKEN since R_C has been
   wrapped for the legitimate server.  Modifications of the
   <EncryptedNonce> element, e.g., replacing it with a value for which
   the attacker knows an underlying R'C, will not result in the client
   changing its pre-DSKPP state, since the server will be unable to
   provide a valid MAC in its final message to the client.  The server
   MAY, however, end up storing K'TOKEN rather than K_TOKEN.  If the
   cryptographic module has been associated with a particular user, then
   this could constitute a security problem.  For a further discussion
   about this threat, and a possible countermeasure, see Section 14.5
   below.  Note that use of Secure Socket Layer (SSL) or TLS does not
   protect against this attack if the attacker has access to the DSKPP
   client (e.g., through malicious software, "trojans").

   Finally, attackers may also modify the <KeyProvServerFinished>



Doherty, et al.            Expires May 1, 2008                 [Page 86]


Internet-Draft                    DSKPP                     October 2007


   message.  Replacing the <Mac> element will only result in denial-of-
   service.  Replacement of any other element may cause the DSKPP client
   to associate, e.g., the wrong service with the generated key.  DSKPP
   SHOULD be run over a transport providing privacy and integrity when
   this is a concern.

14.2.3.  Message Deletion

   Message deletion will not cause any other harm than denial-of-
   service, since a cryptographic module MUST NOT change its state
   (i.e., "commit" to a generated key) until it receives the final
   message from the DSKPP server and successfully has processed that
   message, including validation of its MAC.  A deleted
   <KeyProvServerFinished> message will not cause the server to end up
   in an inconsistent state vis-a-vis the cryptographic module if the
   server implements the suggestions in Section 14.5.

14.2.4.  Message Insertion

   An active attacker may initiate a DSKPP run at any time, and suggest
   any device identifier.  DSKPP server implementations MAY receive some
   protection against inadvertently initializing a key or inadvertently
   replacing an existing key or assigning a key to a cryptographic
   module by initializing the DSKPP run by use of the <KeyProvTrigger>.
   The <TriggerNonce> element allows the server to associate a DSKPP
   protocol run with, e.g., an earlier user-authenticated session.  The
   security of this method, therefore, depends on the ability to protect
   the <TriggerNonce> element in the DSKPP initialization message.  If
   an eavesdropper is able to capture this message, he may race the
   legitimate user for a key initialization.  DSKPP over a transport
   providing privacy and integrity, coupled with the recommendations in
   Section 14.5, is RECOMMENDED when this is a concern.

   Insertion of other messages into an existing protocol run is seen as
   equivalent to modification of legitimately sent messages.

14.2.5.  Message Replay

   During 4-pass DSKPP, attempts to replay a previously recorded DSKPP
   message will be detected, as the use of nonces ensures that both
   parties are live.  For example, a DSKPP client knows that a server it
   is communicating with is "live" since the server MUST create a MAC on
   information sent by the client.

   The same is true for 2-pass DSKPP thanks to the requirement that the
   client sends R in the <KeyProvClientHello> message and that the
   server includes R in the MAC computation.




Doherty, et al.            Expires May 1, 2008                 [Page 87]


Internet-Draft                    DSKPP                     October 2007


   In 1-pass DSKPP clients that record the latest I used by a particular
   server (as identified by ID_S) will be able to detect replays.

14.2.6.  Message Reordering

   An attacker may attempt to re-order 4-pass DSKPP messages but this
   will be detected, as each message is of a unique type.  Note: Message
   re-ordering attacks cannot occur in 2- and 1-pass DSKPP since each
   party sends at most one message each.

14.2.7.  Man-in-the-Middle

   In addition to other active attacks, an attacker posing as a man in
   the middle may be able to provide his own public key to the DSKPP
   client.  This threat and countermeasures to it are discussed in
   Section 4.3.  An attacker posing as a man-in-the-middle may also be
   acting as a proxy and, hence, may not interfere with DSKPP runs but
   still learn valuable information; see Section 14.3.

14.3.  Passive Attacks

   Passive attackers may eavesdrop on DSKPP runs to learn information
   that later on may be used to impersonate users, mount active attacks,
   etc.

   If DSKPP is not run over a transport providing privacy, a passive
   attacker may learn:
   o  What cryptographic modules a particular user is in possession of;
   o  The identifiers of keys on those cryptographic modules and other
      attributes pertaining to those keys, e.g., the lifetime of the
      keys; and
   o  DSKPP versions and cryptographic algorithms supported by a
      particular DSKPP client or server.
   Whenever the above is a concern, DSKPP SHOULD be run over a transport
   providing privacy.  If man-in-the-middle attacks for the purposes
   described above are a concern, the transport SHOULD also offer
   server-side authentication.

14.4.  Cryptographic Attacks

   An attacker with unlimited access to an initialized cryptographic
   module may use the module as an "oracle" to pre-compute values that
   later on may be used to impersonate the DSKPP server.  Section 5.2
   and Section 4 contain discussions of this threat and steps
   RECOMMENDED to protect against it.






Doherty, et al.            Expires May 1, 2008                 [Page 88]


Internet-Draft                    DSKPP                     October 2007


14.5.  Attacks on the Interaction between DSKPP and User Authentication

   If keys generated in DSKPP will be associated with a particular user
   at the DSKPP server (or a server trusted by, and communicating with
   the DSKPP server), then in order to protect against threats where an
   attacker replaces a client-provided encrypted R_C with his own R'C
   (regardless of whether the public-key variant or the shared-secret
   variant of DSKPP is employed to encrypt the client nonce), the server
   SHOULD not commit to associate a generated K_TOKEN with the given
   cryptographic module until the user simultaneously has proven both
   possession of the device that hosts the cryptographic module
   containing K_TOKEN and some out-of-band provided authenticating
   information (e.g., a temporary password).  For example, if the
   cryptographic module is a one-time password token, the user could be
   required to authenticate with both a one-time password generated by
   the cryptographic module and an out-of-band provided temporary PIN in
   order to have the server "commit" to the generated OTP value for the
   given user.  Preferably, the user SHOULD perform this operation from
   another host than the one used to initialize keys on the
   cryptographic module, in order to minimize the risk of malicious
   software on the client interfering with the process.

   Note: This scenario, wherein the attacker replaces a client-provided
   R_C with his own R'C, does not apply to 2- and 1-pass DSKPP as the
   client does not provide any entropy to K_TOKEN.  The attack as such
   (and its countermeasures) still applies to 2- and 1-pass DSKPP,
   however, as it essentially is a man-in-the-middle attack.

   Another threat arises when an attacker is able to trick a user to
   authenticate to the attacker rather than to the legitimate service
   before the DSKPP protocol run.  If successful, the attacker will then
   be able to impersonate the user towards the legitimate service, and
   subsequently receive a valid DSKPP trigger.  If the public-key
   variant of DSKPP is used, this may result in the attacker being able
   to (after a successful DSKPP protocol run) impersonate the user.
   Ordinary precautions MUST, therefore, be in place to ensure that
   users authenticate only to legitimate services.

14.6.  Additional Considerations Specific to 2- and 1-pass DSKPP

14.6.1.  Client Contributions to K_TOKEN Entropy

   In 4-pass DSKPP, both the client and the server provide randomizing
   material to K_TOKEN , in a manner that allows both parties to verify
   that they did contribute to the resulting key.  In the 1- and 2-pass
   DSKPP versions defined herein, only the server contributes to the
   entropy of K_TOKEN.  This means that a broken or compromised
   (pseudo-)random number generator in the server may cause more damage



Doherty, et al.            Expires May 1, 2008                 [Page 89]


Internet-Draft                    DSKPP                     October 2007


   than it would in the 4-pass variant.  Server implementations SHOULD
   therefore take extreme care to ensure that this situation does not
   occur.

14.6.2.  Key Confirmation

   4-pass DSKPP servers provide key confirmation through the MAC on R_C
   in the <KeyProvServerFinished> message.  In the 1- and 2-pass DSKPP
   variants described herein, key confirmation is provided by the MAC
   including I (in the 1-pass case) or R (2-pass case), using K_MAC.

14.6.3.  Server Authentication

   DSKPP servers MUST authenticate themselves whenever a successful
   DSKPP 1- or 2-pass protocol run would result in an existing K_TOKEN
   being replaced by a K_TOKEN', or else a denial-of-service attack
   where an unauthorized DSKPP server replaces a K_TOKEN with another
   key would be possible.  In 1- and 2-pass DSKPP, servers authenticate
   by including the AuthenticationDataType extension containing a MAC as
   described in Section 4.4 for Two-Pass DSKPP and Section 4.5 for One-
   Pass DSKPP.

14.6.4.  Client Authentication

   A DSKPP server MUST authenticate a client to ensure that K_TOKEN is
   delivered to the intended device.  The following measures SHOULD be
   considered:
   o  When a device certificate is used for client authentication, the
      DSKPP server SHOULD follow standard certificate verification
      processes to ensure that it is a trusted device.
   o  When an Authentication Code is used for client authentication, a
      password dictionary attack on the authentication data is possible.
   o  The length of the Authentication Code when used over a non-secure
      channel SHOULD be longer than what is used over a secure channel.
      When a device, e.g., some mobile phones with small screens, cannot
      handle a long Authentication Code in a user-friendly manner, DSKPP
      SHOULD rely on a secure channel for communication.
   o  In the case that a non-secure channel has to be used, the
      Authentication Code SHOULD be sent to the server MAC's as
      specified in Section 5.3.  The Authentication Code and nonce value
      MUST be strong enough to prevent offline brute-force recovery of
      the Authentication Code from the HMAC data.  Given that the nonce
      value is sent in plaintext format over a non-secure transport, the
      cryptographic strength of the AuthenticationData depends more on
      the quality of the AuthenticationCode.
   o  When the AuthenticationCode is sent from the DSKPP server to the
      device in a DSKPP initialization trigger message, an eavesdropper
      may be able to capture this message and race the legitimate user



Doherty, et al.            Expires May 1, 2008                 [Page 90]


Internet-Draft                    DSKPP                     October 2007


      for a key initialization.  To prevent this, the transport layer
      used to send the DSKPP trigger MUST provide privacy and integrity
      e.g. secure browser session.

14.6.5.  Key Protection in the Passphrase Profile

   The passphrase-based key wrap profile uses the PBKDF2 function from
   [PKCS-5] to generate an encryption key from a passphrase and salt
   string.  The derived key, K_DERIVED is used by the server to encrypt
   K_TOKEN and by the cryptographic module to decrypt the newly
   delivered K_TOKEN.  It is important to note that passphrase-based
   encryption is generally limited in the security that it provides
   despite the use of salt and iteration count in PBKDF2 to increase the
   complexity of attack.  Implementations SHOULD therefore take
   additional measures to strengthen the security of the passphrase-
   based key wrap profile.  The following measures SHOULD be considered
   where applicable:

   o  The passphrase SHOULD be selected well, and usage guidelines such
      as the ones in [NIST-PWD] SHOULD be taken into account.
   o  A different passphrase SHOULD be used for every key initialization
      wherever possible (the use of a global passphrase for a batch of
      cryptographic modules SHOULD be avoided, for example).  One way to
      achieve this is to use randomly-generated passphrases.
   o  The passphrase SHOULD be protected well if stored on the server
      and/or on the cryptographic module and SHOULD be delivered to the
      device's user using secure methods.
   o  User pre-authentication SHOULD be implemented to ensure that
      K_TOKEN is not delivered to a rogue recipient.
   o  The iteration count in PBKDF2 SHOULD be high to impose more work
      for an attacker using brute-force methods (see [PKCS-5] for
      recommendations).  However, it MUST be noted that the higher the
      count, the more work is required on the legitimate cryptographic
      module to decrypt the newly delivered K_TOKEN.  Servers MAY use
      relatively low iteration counts to accommodate devices with
      limited processing power such as some PDA and cell phones when
      other security measures are implemented and the security of the
      passphrase-based key wrap method is not weakened.
   o  Transport level security (e.g.  TLS) SHOULD be used where possible
      to protect a 2-pass or 1-pass protocol run.  Transport level
      security provides a second layer of protection for the newly
      generated K_TOKEN.


15.  Internationalization Considerations

   The DSKPP protocol is mostly meant for machine-to-machine
   communications; as such, most of its elements are tokens not meant



Doherty, et al.            Expires May 1, 2008                 [Page 91]


Internet-Draft                    DSKPP                     October 2007


   for direct human consumption.  If these tokens are presented to the
   end user, some localization may need to occur.  DSKPP exchanges
   information using XML.  All XML processors are required to understand
   UTF-8 and UTF-16 encoding, and therefore all DSKPP clients and
   servers MUST understand UTF-8 and UTF-16 encoded XML.  Additionally,
   DSKPP servers and clients MUST NOT encode XML with encodings other
   than UTF-8 or UTF-16.


16.  IANA Considerations

   This document calls for registration of new URNs within the IETF sub-
   namespace per RFC3553 [RFC3553].  The following URNs are RECOMMENDED:
   o  DSKPP XML schema: "urn:ietf:params:xml:schema:keyprov:protocol"
   o  DSKPP XML namespace: "urn:ietf:params:xml:ns:keyprov:protocol"


17.  Intellectual Property Considerations

   RSA and RSA Security are registered trademarks or trademarks of RSA
   Security Inc. in the United States and/or other countries.  The names
   of other products and services mentioned may be the trademarks of
   their respective owners.


18.  Contributors

   This work is based on information contained in [RFC4758], authored by
   Magnus Nystrom, with enhancements (esp.  Client Authentication, and
   support for multiple key container formats) from an individual
   Internet-Draft co-authored by Mingliang Pei and Salah Machani.

   We would like to thank Shuh Chang for contributing the DSKPP object
   model, and Philip Hoyer for his work in aligning DSKPP and PSKC
   schemas.

   We would also like to thank Hannes Tschofenig for his draft reviews,
   feedback, and text contributions.


19.  Acknowledgements

   We would like to thank the following for detailed review of previous
   DSKPP document versions:

   o  Dr. Ulrike Meyer (Review June 2007)





Doherty, et al.            Expires May 1, 2008                 [Page 92]


Internet-Draft                    DSKPP                     October 2007


   o  Niklas Neumann (Review June 2007)

   o  Shuh Chang (Review June 2007)

   o  Hannes Tschofenig (Review June 2007 and again in August 2007)

   o  Sean Turner (Review August 2007)

   o  John Linn (Review August 2007)

   o  Philip Hoyer (Review September 2007)

   We would also like to thank the following for their input to selected
   design aspects of the DSKPP protocol:

   o  Anders Rundgren (Key Container Format and Client Authentication
      Data)

   o  Hannes Tschofenig (HTTP Binding)

   o  Phillip Hallam-Baker (Registry for Algorithms)

   Finally, we would like to thank Robert Griffin for opening
   communication channels for us with the IEEE P1619.3 Key Management
   Group, and facilitating our groups in staying informed of potential
   areas (esp. key provisioning and global key identifiers of
   collaboration) of collaboration.


20.  References

20.1.  Normative references

   [UNICODE]  Davis, M. and M. Duerst, "Unicode Normalization Forms",
              March 2001,
              <http://www.unicode.org/unicode/reports/tr15/
              tr15-21.html>.

   [XMLDSIG]  W3C, "XML Signature Syntax and Processing",
              W3C Recommendation, February 2002,
              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

   [XMLENC]   W3C, "XML Encryption Syntax and Processing",
              W3C Recommendation, December 2002,
              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.






Doherty, et al.            Expires May 1, 2008                 [Page 93]


Internet-Draft                    DSKPP                     October 2007


20.2.  Informative references

   [CT-KIP-P11]
              RSA Laboratories, "PKCS #11 Mechanisms for the
              Cryptographic Token Key Initialization Protocol", PKCS #11
              Version 2.20 Amd.2, December 2005,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [FAQ]      RSA Laboratories, "Frequently Asked Questions About
              Today's Cryptography",  Version 4.1, 2000.

   [FIPS180-SHA]
              National Institute of Standards and Technology, "Secure
              Hash Standard", FIPS 180-2, February 2004, <http://
              csrc.nist.gov/publications/fips/fips180-2/
              fips180-2withchangenotice.pdf>.

   [FIPS197-AES]
              National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard
              (AES)", FIPS 197, November 2001, <http://csrc.nist.gov/
              publications/fips/fips197/fips-197.pdf>.

   [FSE2003]  Iwata, T. and K. Kurosawa, "OMAC: One-Key CBC MAC. In Fast
              Software Encryption", FSE 2003, Springer-Verlag , 2003,
              <http://crypt.cis.ibaraki.ac.jp/omac/docs/omac.pdf>.

   [NIST-PWD]
              National Institute of Standards and Technology, "Password
              Usage", FIPS 112, May 1985,
              <http://www.itl.nist.gov/fipspubs/fip112.htm>.

   [OATH]     "Initiative for Open AuTHentication", 2005,
              <http://www.openauthentication.org>.

   [PKCS-1]   RSA Laboratories, "RSA Cryptography Standard", PKCS #1
              Version 2.1, June 2002,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-11]  RSA Laboratories, "Cryptographic Token Interface
              Standard", PKCS #11 Version 2.20, June 2004,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-12]  "Personal Information Exchange Syntax Standard", PKCS #12
              Version 1.0, 2005,
              <ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/
              pkcs-12v1.pdf>.




Doherty, et al.            Expires May 1, 2008                 [Page 94]


Internet-Draft                    DSKPP                     October 2007


   [PKCS-5]   RSA Laboratories, "Password-Based Cryptography Standard",
              PKCS #5 Version 2.0, March 1999,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-5-XML]
              RSA Laboratories, "XML Schema for PKCS #5 Version 2.0",
              PKCS #5 Version 2.0 Amd.1 (FINAL DRAFT), October 2006,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PSKC]     "Portable Symmetric Key Container", 2005, <http://
              www.ietf.org/internet-drafts/
              draft-hoyer-keyprov-portable-symmetric-key-container-
              00.txt>.

   [RFC2104]  Krawzcyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              February 1997.

   [RFC2119]  "Key words for use in RFCs to Indicate Requirement
              Levels", BCP 14, RFC 2119, March 1997,
              <http://www.ietf.org/rfc/rfc2119.txt>.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999,
              <http://www.ietf.org/rfc/rfc2616.txt>.

   [RFC3280]  Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", RFC 3280,
              April 2002.

   [RFC3553]  Mealling, M., Masinter, L., Hardie, T., and G. Klyne, "An
              IETF URN Sub-namespace for Registered Protocol
              Parameters", RFC 3553, BCP 73, June 2003.

   [RFC4758]  RSA, The Security Division of EMC, "Cryptographic Token
              Key Initialization Protocol (CT-KIP)", November 2006,
              <http://www.ietf.org/rfc/rfc4758.txt>.


Appendix A.  Integration with PKCS #11

   A DSKPP client that needs to communicate with a connected
   cryptographic module to perform a DSKPP exchange MAY use PKCS #11
   [PKCS-11]as a programming interface.





Doherty, et al.            Expires May 1, 2008                 [Page 95]


Internet-Draft                    DSKPP                     October 2007


A.1.  The 4-pass Variant

   When performing 4-pass DSKPP with a cryptographic module using the
   PKCS #11 programming interface, the procedure described in
   [CT-KIP-P11], Appendix B, is RECOMMENDED.

A.2.  The 2-pass Variant

   A suggested procedure to perform 2-pass DSKPP with a cryptographic
   module through the PKCS #11 interface using the mechanisms defined in
   [CT-KIP-P11] is as follows:

   a.  On the client side,
       1.  The client selects a suitable slot and token (e.g. through
           use of the <DeviceIdentifier> or the <PlatformInfo> element
           of the DSKPP trigger message).
       2.  A nonce R is generated, e.g. by calling C_SeedRandom and
           C_GenerateRandom.
       3.  The client sends its first message to the server, including
           the nonce R.
   b.  On the server side,
       1.  A generic key K = K_TOKEN | K _MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K MUST
           allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
           also be set to CK_TRUE), and also to be used for further key
           derivation.  From K, a token key K_TOKEN of suitable type is
           derived by calling C_DeriveKey using the PKCS #11 mechanism
           CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
           the first bit of the generic secret key (i.e. set to 0).
           Likewise, a MAC key K_MAC is derived from K by calling
           C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,
           this time setting CK_EXTRACT_PARAMS to the length of K (in
           bits) divided by two.
       2.  The server wraps K with either the token's public key
           K_CLIENT, the shared secret key K_SHARED, or the derived
           shared secret key K_DERIVED by using C_WrapKey.  If use of
           the DSKPP key wrap algorithm has been negotiated then the
           CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           MUST be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure MUST point to the nonce R provided by
           the DSKPP client, and the ulSeedLen parameter MUST indicate
           the length of R. The hWrappingKey parameter in the call to
           C_WrapKey MUST be set to refer to the wrapping key.





Doherty, et al.            Expires May 1, 2008                 [Page 96]


Internet-Draft                    DSKPP                     October 2007


       3.  Next, the server needs to calculate a MAC using K_MAC.  If
           use of the DSKPP MAC algorithm has been negotiated, then the
           MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, K_MAC MUST be the signature key, the hKey
           parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
           MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
           set to zero.  In the call to C_Sign, the pData parameter MUST
           be set to the concatenation of the string ID_S and the nonce
           R, and the ulDataLen parameter MUST be set to the length of
           the concatenated string.  The desired length of the MAC MUST
           be specified through the pulSignatureLen parameter and MUST
           be set to the length of R.
       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server MUST
           calculate a second MAC.  Again, if use of the DSKPP MAC
           algorithm has been negotiated, then the MAC is calculated by
           calling C_SignInit with the CKM_KIP_MAC mechanism followed by
           a call to C_Sign.  In this call to C_SignInit, the K_MAC
           existing before this DSKPP protocol run MUST be the signature
           key, the hKey parameter in the CK_KIP_PARAMS structure MUST
           be set to NULL, the pSeed parameter of the CT_KIP_PARAMS
           structure MUST be set to NULL_PTR, and the ulSeeidLen
           parameter MUST be set to zero.  In the call to C_Sign, the
           pData parameter MUST be set to the concatenation of the
           string ID_S and the nonce R, and the ulDataLen parameter MUST
           be set to the length of concatenated string.  The desired
           length of the MAC MUST be specified through the
           pulSignatureLen parameter and MUST be set to the length of R.
       5.  The server sends its message to the client, including the
           wrapped key K, the MAC and possibly also the authenticating
           MAC.
   c.  On the client side,
       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client MUST use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           MUST be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K MUST be destroyed after deriving K_TOKEN
           and K_MAC.





Doherty, et al.            Expires May 1, 2008                 [Page 97]


Internet-Draft                    DSKPP                     October 2007


       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
           ulSeedLen MUST be set to 0.  The hKey parameter of
           C_VerifyInit MUST refer to K_MAC.  In the call to C_Verify,
           pData MUST be set to the concatenation of the string ID_S and
           the nonce R, and the ulDataLen parameter MUST be set to the
           length of the concatenated string, pSignature to the MAC
           value received from the server, and ulSignatureLen to the
           length of the MAC.  If the MAC does not verify the protocol
           session ends with a failure.  The token MUST be constructed
           to not "commit" to the new K_TOKEN or the new K_MAC unless
           the MAC verifies.
       3.  If an authenticating MAC was received (REQUIRED if the new
           K_TOKEN will replace an existing key on the token), then it
           is verified in a similar vein but using the K_MAC associated
           with this server and existing before the protocol run.
           Again, if the MAC does not verify the protocol session ends
           with a failure, and the token MUST be constructed no to
           "commit" to the new K_TOKEN or the new K_MAC unless the MAC
           verifies.

A.3.  The 1-pass Variant

   A suggested procedure to perform 1-pass DSKPP with a cryptographic
   module through the PKCS #11 interface using the mechanisms defined in
   [CT-KIP-P11] is as follows:

   a.  On the server side,
       1.  A generic key K = K_TOKEN | K _MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K MUST
           allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
           also be set to CK_TRUE), and also to be used for further key
           derivation.  From K, a token key K_TOKEN of suitable type is
           derived by calling C_DeriveKey using the PKCS #11 mechanism
           CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
           the first bit of the generic secret key (i.e. set to 0).
           Likewise, a MAC key K_MAC is derived from K by calling
           C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,
           this time setting CK_EXTRACT_PARAMS to the length of K (in
           bits) divided by two.






Doherty, et al.            Expires May 1, 2008                 [Page 98]


Internet-Draft                    DSKPP                     October 2007


       2.  The server wraps K with either the token's public key,
           K_CLIENT, the shared secret key, K_SHARED, or the derived
           shared secret key, K_DERIVED by using C_WrapKey.  If use of
           the DSKPP key wrap algorithm has been negotiated, then the
           CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           MUST be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure MUST point to the octet-string
           representation of an integer I whose value MUST be
           incremented before each protocol run, and the ulSeedLen
           parameter MUST indicate the length of the octet-string
           representation of I. The hWrappingKey parameter in the call
           to C_WrapKey MUST be set to refer to the wrapping key.

           Note: The integer-to-octet string conversion MUST be made
           using the I2OSP primitive from [PKCS-1].  There MUST be no
           leading zeros.
       3.  For the server's message to the client, if use of the DSKPP
           MAC algorithm has been negotiated, then the MAC is calculated
           by calling C_SignInit with the CKM_KIP_MAC mechanism followed
           by a call to C_Sign.  In the call to C_SignInit, K_MAC MUST
           be the signature key, the hKey parameter in the CK_KIP_PARAMS
           structure MUST be set to NULL_PTR, the pSeed parameter of the
           CT_KIP_PARAMS structure MUST be set to NULL_PTR, and the
           ulSeedLen parameter MUST be set to zero.  In the call to
           C_Sign, the pData parameter MUST be set to the concatenation
           of the string ID_S and the octet-string representation of the
           integer I, and the ulDataLen parameter MUST be set to the
           length of concatenated string.  The desired length of the MAC
           MUST be specified through the pulSignatureLen parameter as
           usual, and MUST be equal to, or greater than, sixteen (16).
       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server calculates a
           second MAC.  If the DSKPP MAC mechanism is used, the server
           does this by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, the K_MAC existing on the token before this
           protocol run MUST be the signature key, the hKey parameter in
           the CK_KIP_PARAMS structure MUST be set to NULL_PTR, the
           pSeed parameter of the CT_KIP_PARAMS structure MUST be set to
           NULL_PTR, and the ulSeedLen parameter MUST be set to zero.
           In the call to C_Sign, the pData parameter MUST be set to the
           concatenation of the string ID_S and the octet-string
           representation of the integer I+1 (i.e.  I MUST be
           incremented before each use), and the ulDataLen parameter
           MUST be set to the length of the concatenated string.  The
           desired length of the MAC MUST be specified through the
           pulSignatureLen parameter as usual, and MUST be equal to, or



Doherty, et al.            Expires May 1, 2008                 [Page 99]


Internet-Draft                    DSKPP                     October 2007


           greater than, sixteen (16).
       5.  The server sends its message to the client, including the MAC
           and possibly also the authenticating MAC.
   b.  On the client side,
       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client MUST use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           MUST be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K MUST be destroyed after deriving K_TOKEN
           and K_MAC.
       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
           ulSeedLen MUST be set to 0.  The hKey parameter of
           C_VerifyInit MUST refer to K_MAC.  In the call to C_Verify,
           pData MUST be set to the concatenation of the string ID_S and
           the octet-string representation of the provided value for I,
           and the ulDataLen parameter MUST be set to the length of the
           concatenated string, pSignature to the MAC value received
           from the server, and ulSignatureLen to the length of the MAC.
           If the MAC does not verify or if the provided value of I is
           not larger than any stored value I' for the identified server
           ID_S the protocol session ends with a failure.  The token
           MUST be constructed to not "commit" to the new K_TOKEN or the
           new K_MAC unless the MAC verifies.  If the verification
           succeeds, the token MUST store the provided value of I as a
           new I' for ID_S.
       3.  If an authenticating MAC was received (REQUIRED if K_TOKEN
           will replace an existing key on the token), it is verified in
           a similar vein but using the K_MAC existing before the
           protocol run.  Again, if the MAC does not verify the protocol
           session ends with a failure, and the token MUST be
           constructed no to "commit" to the new K_TOKEN or the new
           K_MAC unless the MAC verifies.


Appendix B.  Example of DSKPP-PRF Realizations






Doherty, et al.            Expires May 1, 2008                [Page 100]


Internet-Draft                    DSKPP                     October 2007


B.1.  Introduction

   This example appendix defines DSKPP-PRF in terms of AES [FIPS197-AES]
   and HMAC [RFC2104].

B.2.  DSKPP-PRF-AES

B.2.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URI MAY be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes

   When this URI is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 5.2 MUST
   be used.

B.2.2.  Definition

   DSKPP-PRF-AES (k, s, dsLen)

   Input:
   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output block size of AES in octets:

       bLen = (AES output block length in octets)
       (normally, bLen = 16)
   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop
   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = ROUND( dsLen / bLen)
       j = dsLen - (n - 1) * bLen






Doherty, et al.            Expires May 1, 2008                [Page 101]


Internet-Draft                    DSKPP                     October 2007


   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)
   The function F is defined in terms of the OMAC1 construction from
   [FSE2003], using AES as the block cipher:

   F (k, s, i) = OMAC1-AES (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of OMAC1 is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:

   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

B.2.3.  Example

   If we assume that dsLen = 16, then:

   n = 16 / 16 = 1

   j = 16 - (1 - 1) * 16 = 16

   DS = B1 = F (k, s, 1) = OMAC1-AES (k, INT (1) || s)

B.3.  DSKPP-PRF-SHA256

B.3.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URI MAY be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-sha256

   When this URI is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 5.2 MUST
   be used.





Doherty, et al.            Expires May 1, 2008                [Page 102]


Internet-Draft                    DSKPP                     October 2007


B.3.2.  Definition

   DSKPP-PRF-SHA256 (k, s, dsLen)

   Input:
   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output size of SHA-256 in octets of [FIPS180-SHA]
       (no truncation is done on the HMAC output):

       bLen = 32
       (normally, bLen = 16)
   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop
   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = ROUND( dsLen / bLen)
       j = dsLen - (n - 1) * bLen
   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)
   The function F is defined in terms of the HMAC construction from
   [RFC2104], using SHA-256 as the digest algorithm:

   F (k, s, i) = HMAC-SHA256 (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of HMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:




Doherty, et al.            Expires May 1, 2008                [Page 103]


Internet-Draft                    DSKPP                     October 2007


   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

B.3.3.  Example

   If we assume that sLen = 256 (two 128-octet long values) and dsLen =
   16, then:

   n = ROUND ( 16 / 32 ) = 1

   j = 16 - (1 - 1) * 32 = 16

   B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)

   DS = B1<0 ... 15>

   That is, the result will be the first 16 octets of the HMAC output.


Authors' Addresses

   Andrea Doherty
   RSA, The Security Division of EMC
   174 Middlesex Tpk.
   Bedford, MA  01730
   USA

   Email: adoherty@rsa.com


   Mingliang Pei
   Verisign, Inc.
   487 E. Middlefield Road
   Mountain View, CA  94043
   USA

   Email: mpei@verisign.com


   Salah Machani
   Diversinet Corp.
   2225 Sheppard Avenue East, Suite 1801
   Toronto, Ontario  M2J 5C2
   Canada

   Email: smachani@diversinet.com




Doherty, et al.            Expires May 1, 2008                [Page 104]


Internet-Draft                    DSKPP                     October 2007


   Magnus Nystrom
   RSA, The Security Division of EMC
   Arenavagen 29
   Stockholm, Stockholm Ln  121 29
   SE

   Email: mnystrom@rsa.com












































Doherty, et al.            Expires May 1, 2008                [Page 105]


Internet-Draft                    DSKPP                     October 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).





Doherty, et al.            Expires May 1, 2008                [Page 106]




