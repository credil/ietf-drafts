<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>
<rfc ipr="trust200902"  category="std"
     docName="draft-bierman-netconf-yang-api-01" >
    <front>
    <title abbrev="YANG-API">YANG-API Protocol</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' >
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>
	<date/>
    <abstract>
	<t>
This document describes a RESTful protocol that provides 
a programmatic interface over HTTP for accessing data
defined in YANG, using the datastores defined in NETCONF.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
There is a need for standard mechanisms to allow WEB applications
to access the configuration data, operational data, and
data-model specific protocol operations within
a networking device, in a modular and extensible manner.
    </t>
    <t>
This document describes a RESTful protocol called YANG-API,
running over HTTP <xref target="RFC2616"/>, for accessing data defined
in YANG <xref target="RFC6020"/>, using datastores defined in NETCONF <xref target="RFC6241"/>.
    </t>
    <t>
The NETCONF protocol defines configuration datastores and
a set of Create, Retrieve, Update, Delete (CRUD) operations 
that can be used to access these datastores.  The YANG language
defines the syntax and semantics of datastore content
and operational data. RESTful operations are used to
access the hierarchical data within a datastore.
    </t>
    <t>
A RESTful API can be created that provides CRUD operations on a
NETCONF datastore containing YANG-defined data.  This can be done in a
simplified manner, compatible with HTTP and RESTful design principles.
Since NETCONF protocol operations are not relevant, the user should
not need any prior knowledge of NETCONF in order to use the RESTful
API.
    </t>
    <t>
Configuration data and state data are exposed as resources that
can be retrieved with the GET method.  
Resources representing configuration data
can be modified with the DELETE, PATCH, POST, and PUT methods.
Data-model specific protocol operations defined with
the YANG &quot;rpc&quot; statement can be invoked with the POST method.
    </t>
<section title="Simple Subset of NETCONF Functionality">
    <t>
The framework and meta-model used for a RESTful API does not need to
mirror those used by the NETCONF protocol. It just needs to be compatible
with NETCONF.  A simplified framework and protocol is needed
that utilizes the three NETCONF datastores (candidate, running, startup),
but hides the complexity of multiple datastores from the client.
    </t>
    <t>
A simplified transaction model is needed that allows basic
CRUD operations on a hierarchy of conceptual resources.
This represents a limited subset of the transaction capabilities
of the NETCONF protocol.
    </t>
    <t>
Applications that require more complex transaction capabilities
might consider NETCONF instead of YANG-API.  The following
transaction features are not provided in YANG-API:
    </t>
<t>
 <list style="symbols">
 <t>
datastore locking (full or partial)
 </t>
 <t>
candidate datastore
 </t>
 <t>
validate operation
 </t>
 <t>
confirmed-commit procedure
 </t>
 </list>
</t>
    <t>
The RESTful API is not intended to replace NETCONF, but rather provide
an additional simplified interface that follows RESTful principles and
is compatible with a resource-oriented device abstraction.  It is
expected that applications that need the full feature set of NETCONF
such as notifications will continue to use NETCONF.
    </t>
    <t>
The following figure shows the system components:
    </t>
	<figure>
	    <artwork><![CDATA[
      +-----------+           +-----------------+
      |  WEB app  | <-------> |                 |
      +-----------+   HTTP    | network device  |
                              |                 |
      +-----------+           |   +-----------+ |
      |  NMS app  | <-------> |   | datastore | |
      +-----------+  NETCONF  |   +-----------+ |
                              +-----------------+
	    ]]></artwork>
	</figure>
</section>
<section title="Data Model Driven API">
    <t>
YANG-API combines the simplicity of a RESTful API over HTTP
with the predictability and automation potential
of a schema-driven API.
    </t>
    <t>
A RESTful client using YANG-API will not use any data modelling
language to define the application-specific content
of the API.  The client would discover each new child
resource as it traverses the URIs return as Location IDs
to discover the server capabilities.
    </t>
    <t>
This approach has 3 significant weaknesses wrt/ control
of complex networking devices:
    </t>
<t>
 <list style="symbols">
 <t>
inefficient performance: configuration APIs will be quite
complex and may require thousands of protocol messages to
discover all the schema information.  Typically the 
data type information has to be passed in the protocol messages,
which is also wasteful overhead.
 </t>
 <t>
no data model richness: without a data model, the schema-level
semantics and validation constraints are not available to the application.
Data model modules such as YANG modules serve as an &quot;API contract&quot;
that will be honored by the server.  An application designer
can code to the data model, knowing in advance important details
about the exact protocol operations and datastore content
a conforming server implementation will support.
 </t>
 <t>
no tool automation: API automation tools need some sort of
content schema to function.  Such tools can automate
various programming and documentation tasks related
to specific data models.
 </t>
 </list>
</t>
    <t>
YANG-API provides the YANG module capability information supported by the
server, in case the client wants to use it.
The URIs for custom protocol operations and datastore content
are predictable, based on the YANG module definitions.
Note that the YANG modules and predictable URIs are optional
to use by the client.  They can be completely ignored without
any loss of protocol functionality.
    </t>
    <t>
Operational experience with CLI and SNMP indicates that
operators learn the &apos;location&apos; of specific service
or device related data and do not expect such information
to be arbitrary and discovered each time the
client opens a management session to a server.
    </t>
</section>
<section title="Terminology">
    <t>
The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <xref target="RFC2119"/>.
    </t>
<section title="NETCONF">
    <t>
The following terms are defined in <xref target="RFC6241"/>:
    </t>
<t>
 <list style="symbols">
 <t>
candidate configuration datastore
 </t>
 <t>
client
 </t>
 <t>
configuration data
 </t>
 <t>
datastore
 </t>
 <t>
configuration datastore
 </t>
 <t>
protocol operation
 </t>
 <t>
running configuration datastore
 </t>
 <t>
server
 </t>
 <t>
startup configuration datastore
 </t>
 <t>
state data
 </t>
 <t>
user
 </t>
 </list>
</t>
</section>
<section title="HTTP">
    <t>
The following terms are defined in <xref target="RFC2616"/>:
    </t>
<t>
 <list style="symbols">
 <t>
entity tag
 </t>
 <t>
fragment
 </t>
 <t>
header line
 </t>
 <t>
message body
 </t>
 <t>
method
 </t>
 <t>
path
 </t>
 <t>
query
 </t>
 <t>
request URI
 </t>
 <t>
response body
 </t>
 </list>
</t>
</section>
<section title="YANG">
    <t>
The following terms are defined in <xref target="RFC6020"/>:
    </t>
<t>
 <list style="symbols">
 <t>
container
 </t>
 <t>
data node
 </t>
 <t>
key leaf
 </t>
 <t>
leaf
 </t>
 <t>
leaf-list
 </t>
 <t>
list
 </t>
 <t>
presence container (or P-container)
 </t>
 <t>
RPC operation (now called protocol operation)
 </t>
 <t>
non-presence container (or NP-container)
 </t>
 <t>
ordered-by system
 </t>
 <t>
ordered-by user
 </t>
 </list>
</t>
</section>
<section title="Terms">
    <t>
The following terms are used within this document:
    </t>
<t>
 <list style="symbols">
 <t>
API resource: a resource with the media type 
&quot;application/vnd.yang.api+xml&quot; or &quot;&quot;application/vnd.yang.api+json&quot;.
 </t>
 <t>
data resource: a resource with the media type 
&quot;application/vnd.yang.data+xml&quot; or &quot;application/vnd.yang.data+json&quot;.
 </t>
 <t>
datastore resource: a resource with the media type 
&quot;application/vnd.yang.datastore+xml&quot; or 
&quot;application/vnd.yang.datastore+json&quot;
 </t>
 <t>
edit operation: a YANG-API operation on a data resource
using the POST, PUT, PATCH, or DELETE method.
 </t>
 <t>
operation: the conceptual YANG-API operation for a message, derived from the
method, request URI, headers, and message body.
 </t>
 <t>
operation resource: a resource with the media type 
&quot;vnd.yang.operation+xml&quot; or &quot;vnd.yang.operation+json&quot;
 </t>
 <t>
optional key: a key leaf for a YANG list data node,
which MAY be omitted by the client when an instance of the list
is created.
 </t>
 <t>
query parameter: a parameter (and its value if any),
encoded within the query portion of the request URI.
 </t>
 <t>
resource: a conceptual object representing a manageable 
component within a device.
 </t>
 <t>
retrieval request: an operation using the GET or HEAD methods.
 </t>
 <t>
target resource: the resource that is associated with
a particular message, identified by the &quot;path&quot; component
of the request URI.
 </t>
 </list>
</t>
</section>
</section>
<section title="Overview">
    <t>
This document defines the YANG-API protocol, a RESTful API for accessing
conceptual datastores containing data defined with YANG language.
YANG-API provides an application framework and meta-model,
using HTTP operations.
    </t>
    <t>
The YANG-API resources are accessed via a set of 
URIs defined in this document.  
The set of YANG modules supported by the server
will determine the additional data model specific operations 
and top-level data node resources available on the server.
    </t>
<section title="Resource URI Map">
    <t>
The URI hierarchy for the YANG-API resources
consists of an entry point
and up to 4 top-level resources and/or fields.
Refer to <xref target="resources"/> for details on each URI.
    </t>
	<figure>
	    <artwork><![CDATA[
  /yang-api
     /datastore
        /<top-level-data-nodes> (config=true or false)
     /modules
        /module
     /operations
        /<custom protocol operations>
     /version
	    ]]></artwork>
	</figure>
</section>
<section title="YANG-API Message Examples" anchor="main-examples">
    <t>
The examples within this document use the non-normative
example YANG module defined in <xref target="example-module"/>.
    </t>
    <t>
This section shows some typical YANG-API message exchanges.
    </t>
<section title="Retrieve the Top-level API Resource">
    <t>
By default, when a resource is retrieved, all of its fields are
returned, but none (if any) of the nested resources are
returned. Also, the default encoding is JSON.  Data resources are
encoded according to the encoding rules in <xref target="I-D.lhotka-netmod-json"/>.
    </t>
    <t>
The client starts by retrieving the top-level
API resource, using the entry point URI &quot;/yang&#8209;api&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
The &quot;module&quot; lines below are split for display
purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Content-Type: application/vnd.yang.api+json

   {
     "yang-api": {
       "modules": {
         "module": [
           "urn:ietf:params:xml:ns:yang:ietf-yang-api
              ?module=ietf-yang-api&revision=2012-05-27",
           "example.com?module=example-jukebox
              &revision=2012-05-30"
         ]
       },
       "version": "1.0"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
To request that the response content to be encoded in XML,
the &quot;Accept&quot; header can be used, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.api+xml
	    ]]></artwork>
	</figure>
    <t>
An alternate approach is provided using the &quot;format&quot; query
parameter, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api?format=xml HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server will return the same response either way,
which might be as follows :
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.api+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <yang-api>
     <modules> <!-- wrapped for display only -->
       <module>urn:ietf:params:xml:ns:yang:ietf-yang-api
          ?module=ietf-yang-api
          &amp;revision=2012-05-27</module>
       <module>example.com?module=example-jukebox
           &amp;revision=2012-05-30</module>        
     </modules>
     <version>1.0</version>
   </yang-api>
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="get"/> for details on the GET operation.
    </t>
</section>
<section title="Create New Data Resources">
    <t>
To create a new &quot;jukebox&quot; resource, the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/jukebox HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/datastore/jukebox
   Last-Modified: Mon, 23 Apr 2012 17:01:00 GMT
   ETag: b3a3e673be2
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;artist&quot; resource within the &quot;jukebox&quot;
resource, the client might send the following request,
Note that the arbitrary integer &quot;index&quot; is not provided,
since it is an optional key:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/jukebox/artist HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "artist" : {
       "name" : "The Foo Fighters"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/datastore/jukebox/artist/1
   Last-Modified: Mon, 23 Apr 2012 17:02:00 GMT
   ETag: b3830f23a4c
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;album&quot; resource for this artist within the &quot;jukebox&quot;
resource, the client might send the following request,
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/jukebox/artist/1/album HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:Alternative",
       "year" : 2012
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond
as follows.  Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
   Location: http://example.com/yang-api/datastore/
     jukebox/artist/1/album/Wasting%20Light
   Last-Modified: Mon, 23 Apr 2012 17:03:00 GMT
   ETag: b8389233a4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="post"/> for details on the POST operation.
    </t>
</section>
<section title="Replace an Existing Data Resource">
    <t>
Note: replacing a resource is a fairly drastic operation.
The PATCH operation is often more appropriate.
    </t>
    <t>
The album sub-resource is re-added here for example
purposes only.
To replace the &quot;artist&quot; resource contents,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   PUT /yang-api/datastore/jukebox/artist/1 HTTP/1.1
   Host: example.com
   If-Match: b3830f23a4c
   Content-Type: application/vnd.yang.data+json

   {
     "artist" : {
       "name" : "Foo Fighters",
       "album" : {
         "name" : "Wasting Light",
         "genre" : "example-jukebox:Alternative",
         "year" : 2012
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:04:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:04:00 GMT
   ETag: b27480aeda4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="put"/> for details on the PUT operation.
    </t>
</section>
<section title="Patch an Existing Data Resource">
    <t>
To replace just the &quot;year&quot; field in the &quot;album&quot; resource,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /yang-api/datastore/jukebox/artist/1/album/
      Wasting%20Light/year HTTP/1.1
   Host: example.com
   If-Match: b8389233a4c
   Content-Type: application/vnd.yang.data+json

   { "year" : 2011 }
	    ]]></artwork>
	</figure>
    <t>
If the resource is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:30 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:49:30 GMT
   ETag: b2788923da4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="patch"/> for details on the PATCH operation.
    </t>
</section>
<section title="Delete an Existing Data Resource">
    <t>
To delete a resource such as the &quot;album&quot; resource,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   DELETE /yang-api/datastore/jukebox/artist/1/album/
      Wasting%20Light HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the resource is deleted, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:40 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="delete"/> for details on the DELETE operation.
    </t>
</section>
<section title="Invoke a Data Model Specific Operation">
    <t>
To invoke a data-model specific operation via an
operation resource, the POST operation is used.
A client might send a &quot;backup&#8209;datastore&quot; request as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/backup-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:50:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="protocol-ops"/> for details on using the POST operation
with operation resources.
    </t>
</section>
</section>
</section>
</section>
<section title="Framework">
    <t>
The YANG-API protocol defines a framework
that can be used to implement a common API for
configuration management.  This section describes
the components of the YANG-API framework.
    </t>
<section title="Message Model">
    <t>
The YANG-API protocol uses HTTP entities for messages.
A single HTTP message corresponds to a single protocol operation.
A message can perform a single task on a single resource,
such as retrieving a resource or editing a resource.  It cannot be used
to combine multiple tasks.  The client cannot provide
multiple (possibly unrelated) edit operations within a single request,
like the NETCONF &lt;edit&#8209;config&gt; protocol operation.
    </t>
</section>
<section title="Resource Model">
    <t>
The YANG-API protocol operates on a hierarchy of resources,
starting with the top-level API resource itself. Each resource represents
a manageable component within the device.
    </t>
    <t>
A resource can be considered a collection of conceptual data 
and the set of allowed operations on that data.  It can contain
child nodes that are either &quot;fields&quot; or other resources.
The child resource types and operations allowed on them
are data-model specific.
    </t>
    <t>
A resource has its own media type identifier, represented
by the &quot;Content&#8209;Type&quot; header in the HTTP response message.
A resource can contain zero or more fields and zero or
more resources. A resource can be
created and deleted independently of its 
parent resource, as long as the parent resource exist.
    </t>
    <t>
A field is a child node defined within a resource.
A field can contain zero or more fields and zero or
more resources.  A field cannot be
created and deleted independently of its parent resource.
    </t>
    <t>
All YANG-API resources and fields are defined in this document except
datastore contents and protocol operations.  These resource types are
defined with YANG data definition statements and the &quot;rpc&quot; statement.
A default mapping is defined to differentiate sub-resources from fields
within data resources.
    </t>
<section title="YANG-API Resource Types">
    <t>
The YANG-API protocol defines some application specific media types
to identify each of the available resource types.  The following table
summarizes the purpose of each resource.
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Media Types">
<ttcol align='left'> Resource</ttcol>
<ttcol align='left'>Media Type</ttcol>
<c>API</c>
<c>application/vnd.yang.api</c>
<c>Datastore</c>
<c>application/vnd.yang.datastore</c>
<c>Data</c>
<c>application/vnd.yang.data</c>
<c>Operation</c>
<c>application/vnd.yang.operation</c>
</texttable>
<?rfc compact="no"?>    <t>
These resources are described in <xref target="resources"/>.
    </t>
</section>
<section title="Resource Discovery" anchor="resource-discovery">
    <t>
A client SHOULD start by retrieving the top-level
API resource, using the entry point URI &quot;/yang&#8209;api&quot;.
    </t>
    <t>
The YANG-API protocol does not include a
resource discovery mechanism.  Instead, the definitions
within the YANG modules advertised by the server
are used to construct a predictable operation or data
resource identifier. 
    </t>
    <t>
The &quot;depth&quot; query parameter can be used to control how many 
descendant levels should be included when retrieving
sub-resources. This parameter can be used with the GET operation
to discover sub-resources within a particular resource.
    </t>
    <t>
Refer to <xref target="depth-param"/> for more details on the &quot;depth&quot; parameter.
    </t>
</section>
</section>
<section title="Datastore Model">
    <t>
A conceptual &quot;unified datastore&quot; is used to simplify resource
management for the client. The YANG-API datastore is a
combination of the running configuration and any
non-configuration data supported by the device.
By default only configuration data is returned
by a GET operation on the datastore contents.
    </t>
    <t>
The underlying NETCONF datastores can be used
to implement the unified datastore, but the server design
is not limited to the exact datastore procedures defined
in NETCONF.
    </t>
    <t>
The &quot;candidate&quot; and &quot;startup&quot; datastores are not visible
in the YANG-API protocol.  Transaction management and
configuration persistence are handled by the server
and not controlled by the client.
    </t>
<section title="Content Model">
    <t>
The YANG-API protocol operates on a conceptual datastore defined with
the YANG data modeling language.  The server lists each YANG module it
supports in the &quot;/yang&#8209;api/modules/module&quot; field in the
top-level API resource type, using the YANG module capability
URI format defined in RFC 6020.
    </t>
    <t>
The conceptual datastore contents and data-model-specific
operations are identified by the set of
YANG module capability URIs.  All YANG-API content identified 
as either a data resource or an operation resource
is defined with the YANG language.
    </t>
    <t>
The classification of data as configuration or
non-configuration is derived from the YANG &quot;config&quot; statement.
Data retrieval with the GET operation can be filtered
in several ways, including the &quot;config&quot; parameter
to retrieve configuration or non-configuration data.
    </t>
    <t>
The classification of data as a resource or field within
a resource is derived from the rules specified in <xref target="identify-yang"/>.
    </t>
    <t>
Data ordering behavior is derived from the YANG &quot;ordered&#8209;by&quot;
statement.  Editing mechanisms are provided to allow
list or leaf-list resources to be inserted or moved
in the same manner as NETCONF, and defined in YANG.
    </t>
    <t>
The server is not required to maintain system ordered data 
in any particular persistent order. The server SHOULD
maintain the same data ordering for system ordered data
until the next reboot or termination of the server.
    </t>
</section>
<section title="Editing Model">
    <t>
The YANG-API datastore editing model is simple and direct,
similar to the behavior of the &quot;:writable&#8209;running&quot;
capability in NETCONF.
    </t>
    <t>
Each YANG-API edit of a datastore resource is
activated upon successful completion of the transaction.
It is an implementation-specific matter how the server
accomplishes a YANG-API edit request. For example,
a server which only accepts edits through a candidate
datastore may internally edit this datastore and perform
the &quot;commit&quot; operation automatically.
    </t>
    <t>
Applications which need more control over the editing model
might consider using NETCONF instead of YANG-API.
    </t>
<section title="Edit Operation Discovery">
    <t>
Sometimes a server does not implement every operation
for every resource.  Sometimes data model requirements
cause a node to implement a subset of the edit operations.
For example, a server may not allow modification of a
particular configuration data node after the 
parent resource has been created.
    </t>
    <t>
The OPTIONS operation can be used to identify which
operations are supported by the server for a particular
resource.  For example, if the server will allow a data resource 
node to be created then the POST operation will be
returned in the response.
    </t>
</section>
<section title="Edit Collision Detection" anchor="edit-collision">
    <t>
Two &quot;edit collision detection&quot; mechanisms are provided
in YANG-API, for datastore and data resources.
    </t>
<t>
 <list style="symbols">
 <t>
timestamp: the last change time is maintained and the
&quot;Last&#8209;Modified&quot; and &quot;Date&quot; headers are returned in the
response for a retrieval request. 
The &quot;If&#8209;Unmodified&#8209;Since&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource has been modified
since the specified timestamp.
 </t>
 <t>
entity tag: a unique opaque string is maintained and
the &quot;ETag&quot; header is returned in the
response for a retrieval request. 
The &quot;If&#8209;Match&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource entity tag
does not match the specified value.
 </t>
 </list>
</t>
    <t>
Note that the server is only required to maintain these fields
for a datastore resource, not for individual data resources.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the server just supports the
mandatory datastore last-changed timestamp.
The client has previously retrieved the &quot;Last&#8209;Modified&quot;
header and has some value cached to provide in
the following request to replace a list entry
with key value &quot;11&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /yang-api/datastore/jukebox/artist/1/album/
     Wasting%20Light/year HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+json
   If-Unmodified-Since: Mon, 23 Apr 2012 17:01:00 GMT
   Content-Type: application/vnd.yang.data+json   

   { "year" : "2011" }
	    ]]></artwork>
	</figure>
    <t>
In this example the datastore resource has changed
since the time specified in the &quot;If&#8209;Unmodified&#8209;Since&quot;
header.  The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 304 Not Modified
   Date: Mon, 23 Apr 2012 19:01:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:45:00 GMT
   ETag: b34aed893a4c
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Locking Model">
    <t>
Datastore locking is not provided by YANG-API.
An application that needs to make several changes
to the running configuration datastore
contents in sequence, without disturbance from other clients
might consider using the NETCONF protocol instead of YANG-API.
    </t>
</section>
<section title="Persistence Model" anchor="persistence-model">
    <t>
Each YANG-API edit of a datastore resource is
saved to non-volatile storage in an 
implementation-specific matter by the server.
There is no guarantee that configuration changes
are saved immediately, or that the saved configuration
is always a mirror of the running configuration.
    </t>
    <t>
Applications which need more control over the persistence model
might consider using NETCONF instead of YANG-API.
    </t>
</section>
<section title="Defaults Model">
    <t>
NETCONF has a rather complex defaults handling model for
leafs.  YANG-API attempts to avoid this complexity by
restricting the operations that can be applied to
a resource and fields within that resource.
    </t>
    <t>
The GET method returns only nodes that exist, which will
be determined by the server.  There is no mechanism for
the client to ask the server for the default values
that would be used for any nodes not present, but some
default value is in use by the server. (There is no
    </t>
	<figure>
	    <artwork><![CDATA[
 retrieval mode like "with-defaults=report-all" in NETCONF.)
	    ]]></artwork>
	</figure>
    <t>
If a leaf definition has a default value, and the leaf has not been
given a value yet, the server SHOULD NOT return any value
for the leaf in the response for a GET operation.
    </t>
    <t>
Applications which need more control over the defaults model
might consider using NETCONF instead of YANG-API.
    </t>
</section>
</section>
<section title="Transaction Model" anchor="transaction-model">
    <t>
The YANG-API protocol does not provide a complex transaction
model that allows for multiple protocol operations, or even
operations on multiple resources in one protocol operation.
A very simple &quot;one operation one one resource&quot; per transaction
model is used instead.
    </t>
    <t>
Applications which need more control over the transaction model
might consider using NETCONF instead of YANG-API.
    </t>
</section>
<section title="Extensibility Model">
    <t>
The YANG-API protocol is designed to be extensible for
datastore content and data-model specific protocol operations.
New protocol operations can be added without changing
the entry point if they are optional and do not alter
any existing operations.
    </t>
    <t>
Separate namespaces for each YANG module are used.
Content encoded in XML will indicate the module
using the &quot;namespace&quot; URI value in the YANG module.
Content encoded in JSON will indicate the module
using the module name specified in the YANG module.
JSON encoding rules for module namespaces are specified 
in <xref target="I-D.lhotka-netmod-json"/>.
    </t>
</section>
<section title="Versioning Model">
    <t>
The version of a resource instance is identified with an entity tag,
as defined by HTTP.
The version identifiers in this section apply to the 
version of the schema definition of a resource.
There are two types of schema versioning information used
in the YANG-API protocol:
    </t>
<t>
 <list style="symbols">
 <t>
the YANG-API protocol version
 </t>
 <t>
data and operation resource definition versions
 </t>
 </list>
</t>
    <t>
The protocol version is identified by the string used for the 
well-known URI entry point &quot;/yang&#8209;api&quot;.
This would be changed (e.g., &quot;/yang&#8209;api2&quot;) 
if non-backward compatible changes are ever needed.  
Minor version changes that do not break
backward-compatibility will not cause the entry point to change.
    </t>
    <t>
The API &quot;yang&#8209;api/version&quot; field can be used by the client to identify
the exact version of the YANG-API protocol implemented by the server.
This value will include the complete YANG-API protocol version.
The &quot;/yang&#8209;api&quot; entry point will only change (e.g., &quot;/yang&#8209;api2&quot;)
if non-backward compatible changes are made to the protocol.
The &quot;/yang&#8209;api/version&quot; field MUST be updated every time
the protocol specification is republished.
    </t>
    <t>
The resource definition version for a data or operation 
resource is a date string,
which is the revision date of the YANG module that defines the resource.
The resource version for all other resource types is a numeric string,
defined by the &quot;/yang&#8209;api/version&quot; field.
    </t>
</section>
<section title="Retrieval Filtering Model">
    <t>
There are four types of filtering for retrieval of data resources
in the YANG-API protocol.
    </t>
<t>
 <list style="symbols">
 <t>
conditional all-or-nothing: use some conditional test
mechanism in the request headers and retrieve either a
complete &quot;200 OK&quot; response if the condition is met,
or a &quot;304 Not Modified&quot; Status-Line if the condition is not met.
 </t>
 <t>
data classification: request configuration or non-configuration data.
 </t>
 <t>
subset: request a subset of all possible instances of a
list or leaf-list data resource.
 </t>
 <t>
filter: request a subset of all possible descendant nodes
within the target resource.  The &quot;select&quot; query parameter can be used
for this purpose.
 </t>
 </list>
</t>
    <t>
Refer to <xref target="data-retrieval"/> for details on data retrieval filtering.
    </t>
</section>
<section title="Access Control Model">
    <t>
The YANG-API protocol provides no granular access control for any
content except for operation and data resources.  The NETCONF
Access Control Model (NACM) is defined in <xref target="RFC6536"/>.
There is a specific mapping between YANG-API operations
and NETCONF edit operations, defined in <xref target="table-crud-operations"/>.
The resource path also needs to be converted internally
by the server to the corresponding YANG instance-identifier.
Using this information, the server can apply the NACM
access control rules to YANG-API messages.
    </t>
    <t>
The server MUST NOT allow any operation to any resources that
the client is not authorized to access.  
    </t>
</section>
</section>
<section title="Operations" anchor="operations">
    <t>
The YANG-API protocol uses HTTP methods to identify
the CRUD operation requested for a particular resource
or field within a resource.  The following table
shows how the YANG-API operations relate to NETCONF 
protocol operations:
    </t>
<?rfc compact="yes"?><texttable anchor="table-crud-operations" title="CRUD Operations in YANG-API">
<ttcol align='left'> YANG-API</ttcol>
<ttcol align='left'>NETCONF</ttcol>
<c>OPTIONS</c>
<c>none</c>
<c>HEAD</c>
<c>none</c>
<c>GET</c>
<c>&lt;get-config&gt;, &lt;get&gt;</c>
<c>POST</c>
<c>&lt;edit-config&gt; (operation=&quot;create&quot;)</c>
<c>PUT</c>
<c>&lt;edit-config&gt; (operation=&quot;replace&quot;)</c>
<c>PATCH</c>
<c>&lt;edit-config&gt; (operation=&quot;merge&quot;)</c>
<c>DELETE</c>
<c>&lt;edit-config&gt; (operation=&quot;delete&quot;)</c>
</texttable>
<?rfc compact="no"?>    <t>
The NETCONF &quot;remove&quot; operation attribute is not supported
by the HTTP DELETE method. The resource must exist or
the DELETE operation will fail.
    </t>
    <t>
This section defines the YANG-API protocol usage for
each HTTP method.
    </t>
<section title="OPTIONS" anchor="options">
    <t>
The OPTIONS method is sent by the client to
discover which methods are supported by the server
for a specific resource, or field within a resource.
It is supported for all media types.
Note that implementation
of this operation is part of HTTP, and this section does
not introduce any additional requirements.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The server will return a &quot;Status&#8209;Line&quot; header containing &quot;204 No Content&quot;.
and include the &quot;Allow&quot; header in the response.
This header will be filled in, based on the target resource media type.
Other headers MAY also be included in the response.
    </t>
    <t>
Example 1:
    </t>
    <t>
A client might request the methods supported for a data
resource called &quot;library&quot;
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /yang-api/datastore/jukebox/library HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond (for a config=true list):
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Allow: OPTIONS,HEAD,GET,POST,PUT,PATCH,DELETE
	    ]]></artwork>
	</figure>
    <t>
Example 2:
    </t>
    <t>
A client might request the methods supported for a 
non-configuration leaf within a data resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /yang-api/datastore/jukebox/library/
       song-count HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Allow: OPTIONS,HEAD,GET
	    ]]></artwork>
	</figure>
    <t>
Example 3:
    </t>
    <t>
A client might request the methods supported for an
operation resource called &quot;play&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /yang-api/operations/play HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Allow: POST
	    ]]></artwork>
	</figure>
</section>
<section title="HEAD" anchor="head">
    <t>
The HEAD operation is sent by the client to
retrieve just the headers that would be returned
for the comparable GET operation, without the response body.
The HTTP HEAD method is used for this operation.
It is supported for all resource types, except operation resources.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The same query parameters supported by the GET operation
are supported by the HEAD operation.  For example,
the &quot;select&quot; query parameter can be used to
specify a field within the target resource.
    </t>
    <t>
The access control behavior is enforced
as if the method was GET instead of HEAD.
The server MUST respond the same as if the method
was GET instead of HEAD, except that no
response body is included.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for the default
(JSON) representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   HEAD /yang-api/datastore/jukebox/library HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/vnd.yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT
	    ]]></artwork>
	</figure>
</section>
<section title="GET" anchor="get">
    <t>
The GET operation is sent by the client to
retrieve data and meta-data for a resource or
field within a resource.
The HTTP GET method is used for this operation.
It is supported for all resource types, except operation resources.
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The following query parameters are supported
by the GET operation:
    </t>
<?rfc compact="yes"?><texttable title="GET Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>config</c>
<c><xref format="counter" target="config-param"/></c>
<c>Request either configuration or non-configuration data</c>
<c>depth</c>
<c><xref format="counter" target="depth-param"/></c>
<c>Control the depth of a retrieval request</c>
<c>format</c>
<c><xref format="counter" target="format-param"/></c>
<c>Request either JSON or XML content in the response</c>
<c>select</c>
<c><xref format="counter" target="select-param"/></c>
<c>Specify a field within the target resource</c>
</texttable>
<?rfc compact="no"?>    <t>
The server MUST NOT return any data resources or fields within
any data resources for which the user does not have read privileges. 
    </t>
    <t>
If the user is not authorized to read any portion of
the target resource, an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  
    </t>
    <t>
If the user is authorized to read some but not all of
the target resource, the unauthorized content is omitted
from the response message body, and the authorized content
is returned to the client.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for a
JSON representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/jukebox/library/artist/
     1/album HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/vnd.yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT

   {
     "album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:Alternative",
       "year" : 2011
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="POST" anchor="post">
    <t>
The POST operation is sent by the client for various
reasons.  The HTTP POST method is used for this purpose.
The request MUST contain a request URI
that contains a target resource that
identifies one of the following resource types:
    </t>
<?rfc compact="yes"?><texttable title="Resource Types that Support POST">
<ttcol align='left'> Type</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Data</c>
<c>Create a configuration data resource</c>
<c>Operation</c>
<c>Invoke protocol operation</c>
<c>Transaction</c>
<c>Create a new transaction</c>
</texttable>
<?rfc compact="no"?>    <t>
The following query parameters are supported
by the POST operation:
    </t>
<?rfc compact="yes"?><texttable title="POST Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>insert</c>
<c><xref format="counter" target="insert-param"/></c>
<c>Specify where to insert a resource</c>
<c>point</c>
<c><xref format="counter" target="point-param"/></c>
<c>Specify the insert point for a resource</c>
</texttable>
<?rfc compact="no"?>    <t>
If the POST operation succeeds, a &quot;200 OK&quot; Status-Line
is returned if there is no response message body, and
a &quot;204 No Content&quot; Status-Line is returned if there is
a response message body.
    </t>
    <t>
If the user is not authorized to invoke the target (operation) resource,
or create the target resource,
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="PUT" anchor="put">
    <t>
The PUT operation is sent by the client to replace
the target resource.
    </t>
    <t>
The HTTP PUT method is used for this purpose.
The request MUST contain a request URI
that contains a target resource that
identifies the data resource to replace.
    </t>
    <t>
The following query parameters are supported
by the PUT operation:
    </t>
<?rfc compact="yes"?><texttable title="PUT Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>insert</c>
<c><xref format="counter" target="insert-param"/></c>
<c>Specify where to move a resource</c>
<c>point</c>
<c><xref format="counter" target="point-param"/></c>
<c>Specify the move point for a resource</c>
</texttable>
<?rfc compact="no"?>    <t>
If the PUT operation succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to replace the target resource
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="PATCH" anchor="patch">
    <t>
The PATCH operation uses the HTTP PATCH method defined
in <xref target="RFC5789"/> to provide a &quot;merge&quot; editing mode for
data resources.  Instead of replacing all or part of the
target resource, the supplied values are merged into the
target resource.
    </t>
    <t>
If the PATCH operation succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to alter the target resource
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="DELETE" anchor="delete">
    <t>
The DELETE operation uses the HTTP DELETE method
to delete the target resource.
    </t>
    <t>
If the DELETE operation succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to delete the target resource then
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="Query Parameters" anchor="query-parameters">
    <t>
Each YANG-API operation allows zero or more query
parameters to be present in the request URI.
Refer to <xref target="operations"/>
for details on the query parameters used
in the definition of each operation.
    </t>
    <t>
Query parameters can be given in any order.
Each parameter can appear zero or one time.
A default value may apply if the parameter is missing.
    </t>
    <t>
This section defines all the YANG-API query parameters.
    </t>
<section title="&quot;config&quot; Parameter" anchor="config-param">
    <t>
The &quot;config&quot; parameter is used to specify whether 
configuration or non-configuration data is requested.
    </t>
    <t>
This parameter is only supported for the GET and HEAD methods.
It is also only supported if the target resource is a data resource.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: config= true | false
     default: true
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
This example request by the client
would retrieve only the non-configuration data nodes
that exist within the second-level &quot;library&quot; resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/jukebox/library?config=false HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+xml
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.data+json

   {
     "library" : {
        "artist-count" : 42,
        "album-count" : 59,
        "song-count" : 374
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;depth&quot; Parameter" anchor="depth-param">
    <t>
The &quot;depth&quot; parameter is used to specify the number
of nest levels returned in a response for a GET operation.
A nest-level consists of the target resource and any
child nodes which are optional data nodes (anyxml, leaf, or 
leaf-list).  A non-presence container
is transparent when determining the nest level.  
A child node (which is not a non-presence container)
within a non-presence container is used to determine the nest-level.
    </t>
    <t>
The start level is determined by the target resource
for the operation.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: depth=<range: 1..max> | unbounded
     default: 1
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
This example operation would retrieve 2 levels of configuration data nodes
that exist within the top-level &quot;jukebox&quot; resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/jukebox?depth=2 HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.data+json

   {
     "jukebox" : {
       "library" : {
         "artist" : {
           "index" : 1,
           "name" : "Foo Fighters"
         }
       },
       "player" : {
         "gap" : 0.5
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;format&quot; Parameter" anchor="format-param">
    <t>
The &quot;format&quot; parameter is used to specify the format
of any content returned in the response.  Note that
the &quot;Accept&quot; header MAY be used instead of this
parameter to identify the format desired in the response.
For example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/routing HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+xml
	    ]]></artwork>
	</figure>
    <t>
This example request would retrieve only the configuration data nodes
that exist within the top-level &quot;routing&quot; resource, and retrieve
them in XML encoding instead of JSON encoding.
    </t>
    <t>
The &quot;format&quot; parameter is only supported for the GET and HEAD methods.
It is supported for all YANG-API media types.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: format= xml | json
     default: json
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api/datastore/routing?format=xml HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
This example URI would retrieve only the configuration data nodes
that exist within the top-level &quot;routing&quot; resource, and retrieve
them in XML encoding instead of JSON encoding.
    </t>
</section>
<section title="&quot;insert&quot; Parameter" anchor="insert-param">
    <t>
The &quot;insert&quot; parameter is used to specify how a
resource should be inserted (or moved) within
the user-ordered list or leaf-list data resource.
    </t>
    <t>
This parameter is only supported for the POST and PUT methods.
It is also only supported if the target resource is
a data resource, and that data represents
a YANG list or leaf-list that is ordered by the user, not the system.
    </t>
    <t>
If the values &quot;before&quot; or &quot;after&quot; are used, then a &quot;point&quot;
parameter for the insertion parameter MUST also be present.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: insert= first | last | before | after
     default: last
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   POST /yang-api/datastore/jukebox/library/artist/1/album
      /Wasting%20Light/song?insert=first HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "song" : {
        "name" : "Bridge Burning",
        "location" : "/media/bridge_burning.mp3",
        "format" : "MP3",
        "length" : 286
     }
   }

 Response from server:  201 status

   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT

   Location: http://example.com/yang-api/datastore/jukebox
      /library/artist/1/album?Wasting%20Light/song/1
   ETag: eeeada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;point&quot; Parameter" anchor="point-param">
    <t>
The &quot;point&quot; parameter is used to specify the insertion point
for a data resource that is being created or moved within
a user ordered list or leaf-list.  It is ignored unless the &quot;insert&quot;
query parameter is also present, and has the value &quot;before&quot; or &quot;after&quot;.
    </t>
    <t>
This parameter contains the instance identifier of the
resource, or field within a resource, to be used as the
insertion point for a POST or PUT operation.  It is
encoded according to the rules defined in <xref target="uri-encoding"/>.
There is no default for this parameter.
    </t>
	<figure>
	    <artwork><![CDATA[
   syntax: point= <instance-identifier of insertion point node>
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
In this example, the client is moving an existing &quot;song&quot; resource
within an &quot;album&quot; resource after another song.
The request URI is split for display purposes only.
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   PUT /yang-api/datastore/jukebox/library/artist/1/album/
     Wasting%20Light/song/2?insert=after
     &point=/yang-api/datastore/jukebox/library/artist/1/
     album/Wasting%20Light/song/4   HTTP/1.1
   Host: example.com

 Response from server:

   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   ETag: abcada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;select&quot; Parameter" anchor="select-param">
    <t>
The &quot;select&quot; query parameter is used to specify an
expression which can represent a subset of all data nodes
within the target resource. It contains a relative
path expression, using the target resource as the context node.
    </t>
    <t>
It is supported for all resource types except operation resources.
The contents are encoded according to the &quot;api&#8209;select&quot;
rule defined in <xref target="uri-encoding"/>.  This parameter is only allowed
for GET and HEAD operations.
    </t>
    <t>
[FIXME: the syntax of the select string is still TBD;
XPath, schema-identifier, regular expressions, something else]
    </t>
    <t>
Refer to <xref target="main-examples"/> for example request messages
using the &quot;select&quot; parameter.
    </t>
</section>
</section>
<section title="Protocol Operations" anchor="protocol-ops">
    <t>
The YANG-API also allows data-model specific protocol operations
to be invoked using the POST method.  The media type 
&quot;vnd.yang.operation+xml&quot; or &quot;vnd.yang.operation+json&quot;
MUST be used in the &quot;Content&#8209;Type&quot; field in the message header.
    </t>
    <t>
Data model specific operations are supported.
The syntax and semantics of these operations
exactly correspond to the YANG &quot;rpc&quot; statement definition
for the operation.
    </t>
    <t>
Any input for a protocol operation is encoded in an element
called &quot;input&quot;, which corresponds to the &lt;input&gt; element
in a NETCONF message.  The child nodes of the &quot;input&quot;
element are encoded according to the data definition statements
in the input section of the &quot;rpc&quot; statement.
    </t>
    <t>
Any output for a protocol operation is encoded in an element
called &quot;output&quot;, which corresponds to the &lt;rpc&#8209;reply&gt; element
in a NETCONF message.  The child nodes of the &quot;output&quot;
element are encoded according to the data definition statements
in the output section of the &quot;rpc&quot; statement.
    </t>
</section>
</section>
<section title="Messages" anchor="messages">
    <t>
This section describes the messages that are used in the YANG-API
protocol.
    </t>
<section title="Request URI Structure">
    <t>
Resources are represented with URIs following the structure
for generic URIs in <xref target="RFC3986"/>.
    </t>
    <t>
A YANG-API operation is derived from the HTTP method
and the request URI, using the following conceptual fields:
    </t>
	<figure>
	    <artwork><![CDATA[
     <OP> /yang-api/<path>?<query>#<fragment>
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
      ^      ^       ^        ^         ^   
      |      |       |        |         |   
    method entry  resource  query    fragment

      M       M        O        O         I


    M=mandatory, O=optional, I=ignored
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
    <text> replaced by client with real values
	    ]]></artwork>
	</figure>
<t>
 <list style="symbols">
 <t>
method: the HTTP method identifying the YANG-API operation
requested by the client, to act upon the target resource
specified in the request URI.  YANG-API operation details are
described in <xref target="operations"/>.
 </t>
 <t>
entry: the well-known YANG-API entry point (&quot;/yang&#8209;api&quot;).
 </t>
 <t>
resource: the path expression identifying the resource
that is being accessed by the operation.
If this field is not present, then the target resource
is the API itself, represented by the media type &quot;vnd.yang.api&quot;.
 </t>
 <t>
query: the set of parameters associated with the YANG-API
message. These have the familiar form of &quot;name=value&quot; pairs.
There is a specific set of parameters defined,
although the server MAY choose to support additional
parameters not defined in this document.
 </t>
 <t>
fragment: This field is not used by the YANG-API protocol.
 </t>
 </list>
</t>
    <t>
The client SHOULD NOT assume the final structure of
a URI path for a resource.  Instead, existing resources can
be discovered with the GET operation.  When new resources
are created by the client, a &quot;Location&quot; header
is returned, which identifies the path of the newly created resource.
The client MUST use this exact path identifier to access
the resource once it has been created.
    </t>
    <t>
The &quot;target&quot; of an operation is a resource.
The &quot;path&quot; field in the request URI represents
the target resource for the operation.  
    </t>
</section>
<section title="Message Headers">
    <t>
There are several HTTP header lines utilized in YANG-API messages.
Messages are not limited to the HTTP headers listed in this section.
    </t>
    <t>
HTTP defines which header lines are required for particular circumstances.
Refer to each operation definition section in <xref target="operations"/>
for examples on how particular headers are used.
    </t>
    <t>
There are some request headers that are used within YANG-API,
usually applied to data resources.
The following tables summarize the headers most relevant
in YANG-API message requests:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Request Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Accept</c>
<c>Response Content-Types that are acceptable</c>
<c>Content-Type</c>
<c>The media type of the request body</c>
<c>Host</c>
<c>The host address of the server</c>
<c>If-Match</c>
<c>Only perform the action if the entity matches ETag</c>
<c>If-Modified-Since</c>
<c>Only perform the action if modified since time</c>
<c>If-Range</c>
<c>Only retrieve range if resource unchanged</c>
<c>If-Unmodified-Since</c>
<c>Only perform the action if un-modified since time</c>
<c>Range</c>
<c>Specify a range of data resource entries</c>
</texttable>
<?rfc compact="no"?>    <t>
The following tables summarize the headers most relevant
in YANG-API message responses:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Response Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Allow</c>
<c>Valid actions when 405 error returned</c>
<c>Content-Type</c>
<c>The media type of the response body</c>
<c>Date</c>
<c>The date and time the message was sent</c>
<c>ETag</c>
<c>An identifier for a specific version of a resource</c>
<c>Last-Modified</c>
<c>The last modified date and time of a resource</c>
<c>Location</c>
<c>The resource identifier for a newly created resource</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Message Encoding">
    <t>
YANG-API messages are encoded in HTTP according to RFC 2616.
The &quot;utf&#8209;8&quot; character set is used for all messages.
YANG-API message content is sent in the HTTP message body.
    </t>
    <t>
Content is encoded in either JSON or XML format.
    </t>
    <t>
XML encoding rules for data nodes are defined in <xref target="RFC6020"/>.
The same encoding rules are used for all XML content.
XML attributes are not used and will be ignored if present
in an XML-encoded message.
    </t>
    <t>
JSON encoding rules are defined in <xref target="I-D.lhotka-netmod-json"/>.
Special encoding rules are needed to handle multiple
module namespaces and provide consistent data type processing.
    </t>
    <t>
Request input content encoding format is identified with the Content-Type
header.  This field MUST be present if message input is sent
by the client.
    </t>
    <t>
Response output content encoding format is identified with the Accept
header, the &quot;format&quot; query parameter, or if
neither is specified, the request input encoding format is used.
If there was no request input, then the default output encoding is JSON.
File extensions encoded in the request are not used to identify
format encoding.
    </t>
</section>
<section title="Return Status">
    <t>
Each message represents some sort of resource access.
An HTTP &quot;Status&#8209;Line&quot; header line is returned for each request.
If a 4xx or 5xx range status code is returned in the Status-Line,
then the error information will be returned in the response,
according to the format defined in <xref target="errors"/>.
    </t>
</section>
<section title="Message Caching">
    <t>
Since the datastore contents change at unpredictable times,
responses from a YANG-API server generally SHOULD NOT be cached.
    </t>
    <t>
The server SHOULD include a &quot;Cache&#8209;Control&quot; header in every response
that specifies whether the response should be cached.
A &quot;Pragma&quot; header specifying &quot;no&#8209;cache&quot; MAY also be sent
in case the &quot;Cache&#8209;Control&quot; header is not supported.
    </t>
    <t>
Instead of using HTTP caching, the client SHOULD track the &quot;ETag&quot;
and/or &quot;Last&#8209;Modified&quot; headers returned by the server for the
datastore resource (or data resource if the server supports it).
    </t>
    <t>
A retrieval request for a resource can include headers 
such as &quot;If&#8209;None&#8209;Match&quot; or &quot;If&#8209;Modified&#8209;Since&quot; which
will cause the server to return a &quot;304 Not Modified&quot; Status-Line
if the resource has not changed.
    </t>
    <t>
The client MAY use the HEAD operation to retrieve just
the message headers, which SHOULD include the &quot;ETag&quot; 
and &quot;Last&#8209;Modified&quot; headers, if this meta-data is maintained
for the target resource.
    </t>
</section>
</section>
<section title="Resources" anchor="resources">
    <t>
The resources used in the YANG-API protocol are identified
by the &quot;path&quot; component in the request URI.  Each operation
is performed on a target resource.
    </t>
<section title="API Resource (/yang-api) ">
    <t>
The API resource contains the state and access points for
the YANG-API features.
    </t>
    <t>
It is the top-level resource and has the media type 
&quot;application/vnd.yang.api+xml&quot; or &quot;application/vnd.yang.api+json&quot;.
It is accessible through the well-known URI &quot;/yang&#8209;api&quot;.
    </t>
    <t>
This resource has the following fields:
    </t>
<?rfc compact="yes"?><texttable title="YANG-API Resource Fields">
<ttcol align='left'> Field Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>datastore</c>
<c>Link to &quot;datastore&quot; resource</c>
<c>modules</c>
<c>YANG module capability URIs</c>
<c>operations</c>
<c>Data-model specific operations</c>
</texttable>
<?rfc compact="no"?><section title="/yang-api/datastore">
    <t>
This mandatory resource represents the running configuration
datastore and any non-configuration data available.
It may be retrieved and edited directly.
It cannot be created or deleted by the client.
This resource type is defined in <xref target="datastore-resource"/>.
    </t>
</section>
<section title="/yang-api/modules">
    <t>
This mandatory field contains the identifiers 
for the YANG data model modules supported by the server.
There MUST be exactly one instance of this field.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this 
field, and return the &quot;Last&#8209;Modified&quot; header when this 
field is retrieved with the GET or HEAD methods.
    </t>
</section>
<section title="/yang-api/operations ">
    <t>
This optional field provides access to the 
data-model specific protocol operations supported by the server.
The server MAY omit this field if no data-model specific
operations are advertised.
    </t>
    <t>
Any data-model specific operations defined in the YANG
modules advertised by the server SHOULD be available
as child nodes of this field.
    </t>
<section title="/yang-api/modules/module">
    <t>
This mandatory field contains one URI string
for each YANG data model module supported by the server.
There MUST be an instance of this field for every
YANG module that is accessible via an operation resource
or a data resource.
    </t>
    <t>
The server MAY maintain a last-modified timestamp for 
each instance of this resource, and return the 
&quot;Last&#8209;Modified&quot; header when this resource is retrieved 
with the GET or HEAD methods.  If not supported
then the timestamp for the parent &quot;modules&quot; field
MUST NOT be used instead.
    </t>
    <t>
The contents of this field are encoded with the &quot;uri&quot;
derived type from the &quot;ietf&#8209;iana&#8209;types&quot; modules
in <xref target="RFC6021"/>.  
    </t>
    <t>
There are additional encoding requirements for this field.
The URI MUST follow the YANG module capability URI formatting
defined in section 5.6.4 of <xref target="RFC6020"/>.
    </t>
</section>
<section title="Retrieval Example">
    <t>
In this example the client is retrieving the modules field
from the server in the default JSON format:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /yang-api?select=modules HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.api+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
Note that the content below is split across multiple
lines for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
   Content-Type: application/vnd.yang.api+json

   {
     "yang-api": {
       "modules": {
         "module": [
           "example.com?module=foo&revision=2012-01-02",
           "example.com?module=bar&revision=2011-10-10"
           "example.com?module=itf&revision=2011-10-10
               &feature=restore"
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="/yang-api/version">
    <t>
This mandatory field identifies the specific version
of the YANG-API protocol implemented by the server.
    </t>
    <t>
The same server-wide response MUST be returned
each time this field is retrieved.  It is assigned
by the server when the server is started.
The server MUST return the value &quot;1.0&quot; for this
version of the YANG-API protocol.
    </t>
    <t>
This field is encoded with the rules for an &quot;enumeration&quot; data type,
using the following leaf definition:
    </t>
	<figure>
	    <artwork><![CDATA[
   leaf version {
     config false;
     type enum {
       enum "1.0" {
         description 
           "Version 1.0 of the YANG-API protocol.";
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Datastore Resource" anchor="datastore-resource">
    <t>
A datastore resource represents the conceptual root
of a tree of data resources.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this 
resource, and return the &quot;Last&#8209;Modified&quot; header when this 
resource is retrieved with the GET or HEAD methods.
Only changes to configuration data resources within
the datastore affect this timestamp.
    </t>
    <t>
The server SHOULD maintain a resource entity tag for this 
resource, and return the &quot;ETag&quot; header when this 
resource is retrieved with the GET or HEAD methods.
The resource entity tag SHOULD be changed to a new
previously unused value if changes to any configuration
data resources within the datastore are made.
    </t>
    <t>
A datastore resource can be retrieved with the GET operation,
to retrieve either configuration data resources or non-configuration
data resources within the datastore.  The &quot;config&quot; query
parameter is used to choose between them.
Refer to <xref target="config-param"/> for more details.
    </t>
    <t>
The depth of the subtrees returned in retrieval operations
can be controlled with the &quot;depth&quot; query parameter.
The number of nest levels, starting at the target resource,
can be specified, or an unlimited number can be returned.
Refer to <xref target="depth-param"/> for more details.
    </t>
    <t>
A datastore resource cannot be written directly with
any edit operation. Only the configuration data resources
within the datastore resource can be edited.
    </t>
</section>
<section title="Data Resource" anchor="data-resource">
    <t>
A data resource represents a YANG data node that is a descendant
node of a datastore resource.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a last-modified timestamp for the
resource, and return the &quot;Last&#8209;Modified&quot; header when it
is retrieved with the GET or HEAD methods.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a resource entity tag for the
resource, and return the &quot;ETag&quot; header when it
is retrieved as the target resource with the GET or HEAD methods.
The resource entity tag SHOULD be changed to a new
previously unused value if changes to the resource
or any configuration field within the resource is altered.
    </t>
    <t>
A data resource can be retrieved with the GET operation,
to retrieve either configuration data resources or non-configuration
data resources within the target resource.  The &quot;config&quot; query
parameter is used to choose between them.
Refer to <xref target="config-param"/> for more details.
    </t>
    <t>
The depth of the subtrees returned in retrieval operations
can be controlled with the &quot;depth&quot; query parameter.
The number of nest levels, starting at the target resource,
can be specified, or an unlimited number can be returned.
Refer to <xref target="depth-param"/> for more details.
    </t>
    <t>
A configuration data resource can be altered by the client
with some of all of the edit operations, depending on the
target resource and the specific operation. Refer to <xref target="operations"/>
for more details on edit operations.
    </t>
<section title="Encoding YANG Instance Identifiers in the Request URI" anchor="uri-encoding">
    <t>
In YANG, data nodes are named with an absolute
XPath expression, from the document root to the target resource.
In YANG-API, URL friendly path expressions are used instead.
    </t>
    <t>
The YANG &quot;instance&#8209;identifier&quot; (i-i) data type is represented
in YANG-API with the path expression format defined
in this section. 
    </t>
<?rfc compact="yes"?><texttable title="YANG-API instance-identifier Type Conversion">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Comments</ttcol>
<c>point</c>
<c>Insertion point is always a full i-i</c>
<c>path</c>
<c>Request URI path is a full or partial i-i</c>
</texttable>
<?rfc compact="no"?>    <t>
The &quot;path&quot; component of the request URI contains the
absolute path expression that identifies the
target resource.  The &quot;select&quot; query parameter is
used to optionally identify the requested data nodes
within the target resource to be retrieved in a GET operation.
    </t>
    <t>
A predictable location for a data resource
is important, since applications will code to the YANG
data model module, which uses static naming and defines an
absolute path location for all data nodes.
    </t>
    <t>
A YANG-API data resource identifier is not an XPath expression.
It is encoded from left to right, starting with the top-level
data node, according to the &quot;api&#8209;path&quot; rule in <xref target="path-abnf"/>.
The node name of each ancestor of the target resource node
is encoded in order, ending with the node name for the
target resource.
    </t>
    <t>
If the &quot;select&quot; is present, it is encoded,
starting with a child node of the target resource,
according to the &quot;api&#8209;select&quot; rule defined in <xref target="path-abnf"/>.
    </t>
    <t>
If a data node in the path expression is a YANG list node,
then the key values for the list (if any) are encoded
according to the &quot;key&#8209;value&quot; rule.  If the list node
is the target resource, then the key values MAY be omitted,
according to the operation.  For example, the POST
operation to create a new data resource for a list node
does not allow the key values to be present in the request URI.
    </t>
    <t>
The key leaf values for a data resource representing a YANG list
MUST be encoded as follows:
    </t>
<t>
 <list style="symbols">
 <t>
The value of each leaf identified in the &quot;key&quot; statement
is encoded in order.
 </t>
 <t>
All the components in the &quot;key&quot; statement MUST be encoded.
Partial instance identifiers are not supported.
 </t>
 <t>
Each value is encoded using the &quot;key&#8209;value&quot; rule in <xref target="path-abnf"/>,
according to the encoding rules for the data type of the key leaf.
 </t>
 <t>
An empty string can be a valid key value
(e.g., &quot;/top/list/key1//key3&quot;).
 </t>
 <t>
The &quot;/&quot; character MUST be URL-encoded (i.e., &quot;%2F&quot;).
 </t>
 <t>
All whitespace MUST be URL-encoded.
 </t>
 <t>
A &quot;null&quot; value is not allowed since the &quot;empty&quot; data type is
not allowed for key leafs.
 </t>
 <t>
The XML encoding is defined in <xref target="RFC6020"/>.
 </t>
 <t>
The JSON encoding is defined in <xref target="I-D.lhotka-netmod-json"/>.
 </t>
 <t>
The entire &quot;key&#8209;value&quot; MUST be properly URL-encoded,
according to the rules defined in <xref target="RFC3986"/>.
 </t>
 </list>
</t>
    <t>
Notifications are not supported by YANG-API because they
are not supported by HTTP.  YANG notification statements
are ignored by a YANG-API server.
    </t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
  /yang-api/datastore/jukebox/library/artist/17&select=name

  /yang-api/datastore/newlist/17&select=nextlist/22/44/myleaf

  /yang-api/datastore/somelist/fred%20and%20wilma

  /yang-api/datastore/somelist/fred%20and%20wilma/address
	    ]]></artwork>
	</figure>
<section title="ABNF For Data Resource Identifiers" anchor="path-abnf">
    <t>
The following ABNF syntax is used to construct YANG-API
path identifiers:
    </t>
	<figure>
	    <artwork><![CDATA[
    api-path = "/" api-identifier
                    0*("/" (api-identifier | key-value ))

    [FIXME: the syntax for the select string is still TBD]
    api-select = api-identifier
                    0*("/" (api-identifier | key-value ))

    api-identifier = [module-name ":"] identifier

    module-name = identifier

    key-value = string 

    ;; An identifier MUST NOT start with 
    ;; (('X'|'x') ('M'|'m') ('L'|'l'))
    identifier  = (ALPHA / "_")
                  *(ALPHA / DIGIT / "_" / "-" / ".")

    string = <an unquoted string>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Identifying YANG-defined Data Resources" anchor="identify-yang">
    <t>
The data resources used in YANG-API are
defined with YANG data definition statements.
    </t>
    <t>
Not every data node defined in a YANG module
should be treated as a resource. The YANG-API needs to know
which YANG data nodes are resources, and which are fields
within a resource.
    </t>
    <t>
For data resources, YANG-API uses a simple algorithm for defining
resource boundaries, within the conceptual sub-trees
described by YANG data definition statements.
    </t>
    <t>
All top-level data nodes are considered to
be resources. For nodes within a top-level resource:
    </t>
<t>
 <list style="symbols">
 <t>
a presence container starts a new resource
 </t>
 <t>
a list starts a new resource
 </t>
 <t>
an optional terminal node (anyxml, leaf, or leaf-list) starts a new resource
 </t>
 <t>
a data node of type &quot;anyxml&quot; cannot have any sub-resources
 </t>
 </list>
</t>
    <t>
A non-configuration data node cannot be a separate resource
from its parent.  Only top-level data nodes are considered
to be resources (which only support retrieval methods).
    </t>
</section>
<section title="Identifying Optional Keys" anchor="optional-keys">
    <t>
It is sometimes useful to have the server assign
the key(s) for a new resource.  The &quot;Location&quot;
header will indicate the key value(s) that the server
selected, so the client does not need to provide all the key leaf
values.
    </t>
    <t>
It is useful to identify in the YANG data model module
which key leafs are optional to provide, and which are not.
The YANG extension statement &quot;optional&#8209;key&quot; is provided
to indicate that the leaf definition represents
an optional key.
    </t>
    <t>
The client MAY provide a value for a key leaf 
in a POST operation.  Refer to <xref target="module"/> for details
on the &quot;optional&#8209;key&quot; extension.  Refer to <xref target="example-module"/>
for usage examples of this YANG extension statement.
    </t>
</section>
<section title="Data Resource Retrieval" anchor="data-retrieval">
    <t>
There are four types of filtering for retrieval of data resources.
This section defines each mode.
    </t>
<section title="Conditional Retrieval">
    <t>
The HTTP headers (such as &quot;If&#8209;Modified&#8209;Since&quot; and &quot;If&#8209;Match&quot;)
can by used in for a request message for a GET operation
to check a condition within the server state, such as the
last time the datastore resource was modified, or the resource entity tag
of the target resource.  
    </t>
    <t>
If the condition is met according to the header
definition, a &quot;200 OK&quot; Status-Line and the data requested is 
returned in the response message.
If the condition is not met, a &quot;304 Not Modified&quot;
Status-Line is returned in response message instead.
    </t>
</section>
<section title="Data Classification Retrieval">
    <t>
The &quot;config&quot; query parameter
can be used with the GET operation to specify whether
configuration or non-configuration data is requested.
Refer to <xref target="config-param"/> for more details on the &quot;config&quot;
query parameter.
    </t>
</section>
<section title="Subset Retrieval">
    <t>
The &quot;Range&quot; header is used to request a specific
subset of the instances of a list or leaf-list 
data resource that are returned by the
server for a retrieval operation.  Normally, if the target resource
in a request message does not specify an instance,
then all instances are returned.
    </t>
    <t>
The YANG-API protocol uses the token &quot;entries&quot; instead
of &quot;bytes&quot; as the range units.
    </t>
    <t>
The entries are numbered
starting from &quot;0&quot;.  A list or leaf-list can change order
between requests so the client needs to be aware of
the data model semantics, and whether the list contents
are stable enough to use the subset retrieval mechanism.
    </t>
    <t>
If the requested range cannot be returned
because the range specification includes index
values for entries that do not exist,
then an error occurs, and the server MUST return
a &quot;416 Requested range not satisfiable&quot; Status-Line.
    </t>
    <t>
If the range request can be satisfied, then a &quot;200 OK&quot;
Status-Line is returned, and the response MUST include
a &quot;Content&#8209;Range&quot; header indicating which entries are
returned.  The response message body contains the
data for the requested range of entries.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the client is requesting 5 &quot;artist&quot;
resource entries, starting with the 10th entry:
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   GET /yang-api/datastore/jukebox/library/artist HTTP/1.1
   Host: example.com
   Accept: application/vnd.yang.data+json
   Range: entries 10-14

 Response from server:

   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/vnd.yang.data+json
   Content-Range: entries 10-14
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 02:12:20 GMT
   ETag: abcada438af

   {
     "artist" : {
         // content removed for brevity
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Filtered Retrieval">
    <t>
The &quot;select&quot; query parameter is used to specify a filter
that should be applied to the target resource to
request a subset of all possible descendant nodes
within the target resource.
    </t>
    <t>
The format of the &quot;select&quot; parameter string is defined
in <xref target="select-param"/>.  The set of nodes selected by the
filter expression is applied to each context node
identified by the target resource.
    </t>
</section>
</section>
</section>
<section title="Operation Resource ">
    <t>
An operation resource represents an protocol operation
defined with the YANG &quot;rpc&quot; statement.
    </t>
    <t>
All operation resources share the same module namespace
as any top-level data resources, so the name of an operation
resource cannot conflict with the name of a top-level
data resource defined within the same module.
    </t>
    <t>
If 2 different YANG modules define the same &quot;rpc&quot; identifier,
then the module name MUST be used in the request URI.
For example, if &quot;module&#8209;A&quot; and &quot;module&#8209;B&quot; both defined
a &quot;reset&quot; operation, then invoking the operation from &quot;module&#8209;A&quot;
would be requested as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/module-A:reset HTTP/1.1
   Server example.com
	    ]]></artwork>
	</figure>
    <t>
Any usage of an operation resource from the same module,
with the same name, refers to the same &quot;rpc&quot; statement
definition.  This behavior can be used to design protocol operations
that perform the same general function on different
resource types.
    </t>
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then a message body
MAY be sent by the client in the request, otherwise the request
message MUST NOT include a message body.
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then a message body
MAY be sent by the server in the response. Otherwise the 
server MUST NOT include a message body in the response message,
and MUST send a &quot;204 No Content&quot; Status-Line instead.
    </t>
<section title="Encoding Operation Input Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then
the &quot;input&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;input&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc reboot {
      input {
        leaf delay {
          units seconds;
          type uint32;
          default 0;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/operations/reboot HTTP/1.1
   Host: example.com
   Content-Type: application/vnd.yang.data+json

   {
     "input" : {
       "delay" : 600,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 11:01:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="Encoding Operation Output Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then
the &quot;output&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;output&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc get-reboot-info {
      input {
        leaf reboot-time {
          units seconds;
          type uint32;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/datastore/operations/get-reboot-info HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 25 Apr 2012 11:10:30 GMT
   Server: example-server
   Content-Type: application/vnd.yang.data+json

   {
     "output" : {
       "reboot-time" : 30,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Identifying YANG-defined Operation Resources" anchor="identify-yang-op">
    <t>
The operation resources used in YANG-API are
defined with YANG &quot;rpc&quot; statements.
All &quot;rpc&quot; statements within a YANG module that are
supported by the server are available as operation resources.
    </t>
</section>
</section>
</section>
<section title="Error Reporting" anchor="error-reporting">
    <t>
HTTP Status-Lines are used to report success or failure
for YANG-API operations.
The &lt;rpc&#8209;error&gt; element returned in NETCONF error responses
contains some useful information.  This error information
is adapted for use in YANG-API, and error information
is returned for &quot;4xx&quot; class of status codes.
    </t>
    <t>
The following table summarizes the return status codes
used specifically by YANG-API operations:
    </t>
<?rfc compact="yes"?><texttable title="HTTP Status Codes used in YANG-API">
<ttcol align='left'> Status-Line</ttcol>
<ttcol align='left'>Description</ttcol>
<c>100 Continue</c>
<c>POST accepted, 201 should follow</c>
<c>200 OK</c>
<c>Success with response body</c>
<c>201 Created</c>
<c>POST to create a resource success</c>
<c>202 Accepted</c>
<c>POST to create a resource accepted</c>
<c>204 No Content</c>
<c>Success without response body</c>
<c>304 Not Modified</c>
<c>Conditional operation not done</c>
<c>400 Bad Request</c>
<c>Invalid request message</c>
<c>403 Forbidden</c>
<c>Access to resource denied</c>
<c>404 Not Found</c>
<c>Resource target or resource node not found</c>
<c>405 Method Not Allowed</c>
<c>Method not allowed for target resource</c>
<c>409 Conflict</c>
<c>Resource or lock in use</c>
<c>413 Request Entity Too Large</c>
<c>too-big error</c>
<c>414 Request-URI Too Large</c>
<c>too-big error</c>
<c>415 Unsupported Media Type</c>
<c>non YANG-API media type</c>
<c>416 Requested range not satisfiable</c>
<c>If-Range error</c>
<c>500 Internal Server Error</c>
<c>operation-failed</c>
<c>501 Not Implemented</c>
<c>unknown-operation</c>
<c>503 Service Unavailable</c>
<c>Recoverable server error</c>
</texttable>
<?rfc compact="no"?>    <t>
Since an operation resource is defined with a YANG &quot;rpc&quot;
statement, a mapping between the NETCONF &lt;error&#8209;tag&gt; value
and the HTTP status code is needed.   The specific error
condition and response code to use are data-model specific
and might be contained in the YANG &quot;description&quot; statement
for the &quot;rpc&quot; statement.
    </t>
<?rfc compact="yes"?><texttable title="Mapping from error-tag to status code">
<ttcol align='left'> &lt;error&#8209;tag&gt;</ttcol>
<ttcol align='left'>status code</ttcol>
<c>in-use</c>
<c>409</c>
<c>invalid-value</c>
<c>400</c>
<c>too-big</c>
<c>413</c>
<c>missing-attribute</c>
<c>400</c>
<c>bad-attribute</c>
<c>400</c>
<c>unknown-attribute</c>
<c>400</c>
<c>bad-element</c>
<c>400</c>
<c>unknown-element</c>
<c>400</c>
<c>unknown-namespace</c>
<c>400</c>
<c>access-denied</c>
<c>403</c>
<c>lock-denied</c>
<c>409</c>
<c>resource-denied</c>
<c>409</c>
<c>rollback-failed</c>
<c>500</c>
<c>data-exists</c>
<c>409</c>
<c>data-missing</c>
<c>409</c>
<c>operation-not-supported</c>
<c>501</c>
<c>operation-failed</c>
<c>500</c>
<c>partial-operation</c>
<c>500</c>
<c>malformed-message</c>
<c>400</c>
</texttable>
<?rfc compact="no"?><section title="Error Response Message" anchor="errors">
    <t>
When an error occurs for a request message on a data resource
or an operation resource, and a &quot;4xx&quot; class of status codes
(except for status code &quot;403&quot;),
then the server SHOULD send a response body containing
the information described by the following YANG data definition
statement:
    </t>
	<figure>
	    <artwork><![CDATA[
    container errors {
      config false;

      list error {
        reference "RFC 6241, Section 4.3";
        leaf error-type { 
          mandatory true;
          type enumeration {
            enum transport;
            enum rpc;
            enum protocol;
            enum application;
          }
        }
        leaf error-tag { 
          mandatory true;
          type string;
        }
        leaf error-app-tag { 
          type string;
        }
        leaf error-path { 
          type string;  // YANG-API encoded instance-identifier
        }
        leaf error-message { 
          type string;
        }
        container error-info { 
           // anyxml content here
        }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
The following example shows an error returned for
an &quot;lock&#8209;denied&quot; error on a datastore resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /yang-api/operations/lock-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 17:11:00 GMT
   Server: example-server
   Content-Type: application/vnd.yang.api+json

   {
     "errors": {
       "error": {
         "error-type": "protocol",
         "error-tag": "lock-denied",
         "error-message": "Lock failed, lock is already held",
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="RelaxNG Grammar">
    <t>
TBD
    </t>
</section>
<section title="YANG-API module" anchor="module">
    <t>
RFC Ed.: update the date below with the date of RFC publication and
remove this note.
    </t>
<t>&lt;CODE BEGINS> file "ietf-yang-api@2012-11-30.yang"</t>
	<figure>
	    <artwork><![CDATA[
module ietf-yang-api {
  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-api";
  prefix "api";

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "Editor:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>";
  
  description
    "This module contains a collection of YANG language extensions
     to describe REST API Resources using YANG data definition 
     statements.

     Copyright (c) 2012 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  // RFC Ed.: replace XXXX with actual RFC number and remove this
  // note.

  // RFC Ed.: remove this note
  // Note: extracted from draft-bierman-netconf-yang-api-01.txt

  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  revision 2012-11-30 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: YANG-API Protocol.";
  }
  
  /*
   * Extensions
   */ 

  extension optional-key {
    description 
      "This extension is used to allow the client to create
       a new instance of a resource without providing a
       value for the key leaf containing this statement.
       This extension is ignored for NETCONF, and only
       applies to YANG-API resources and fields.
       This extension is ignored unless it appears
       directly within a 'leaf' data definition statement.";
  }

}

	    ]]></artwork>
	</figure>
<t>&lt;CODE ENDS></t>
</section>
<section title="IANA Considerations" anchor="iana">
    <t>
This document registers one URI in the IETF XML registry
<xref target="RFC3688"/>. Following the format in RFC 3688, the following
registration is requested to be made.
    </t>
	<figure>
	    <artwork><![CDATA[
     URI: urn:ietf:params:xml:ns:yang:ietf-yang-api
     Registrant Contact: The NETMOD WG of the IETF.
     XML: N/A, the requested URI is an XML namespace.
	    ]]></artwork>
	</figure>
    <t>
This document registers one YANG module in the YANG Module Names
registry <xref target="RFC6020"/>.
    </t>
	<figure>
	    <artwork><![CDATA[
  name:         ietf-yang-api
  namespace:    urn:ietf:params:xml:ns:yang:ietf-yang-api
  prefix:       api
  reference:    RFC XXXX
	    ]]></artwork>
	</figure>
</section>
<section title="Security Considerations">
    <t>
TBD
    </t>
</section>
<section title="Change Log">
	<figure>
	    <artwork><![CDATA[
    -- RFC Ed.: remove this section before publication.  
	    ]]></artwork>
	</figure>
<section title="00-01">
<t>
 <list style="symbols">
 <t>
expanded introduction
 </t>
 <t>
removed transactions
 </t>
 <t>
removed capabilities
 </t>
 <t>
simplified editing model
 </t>
 <t>
removed global protocol operations from ietf-yang-api.yang
 </t>
 <t>
changed RPC operation terminology to protocol operation
 </t>
 <t>
updated JSON draft reference
 </t>
 <t>
updated open issues section
 </t>
 <t>
updated IANA section
 </t>
 </list>
</t>
</section>
</section>
<section title="Open Issues">
<t>
 <list style="symbols">
 <t>
Which WG should do this work? NETCONF? NETMOD?
It is not clear since YANG-API builds on concepts and
standards from documents owned by both working groups.
 </t>
 <t>
Resource creation order and other dependencies between resources
are not well identified in YANG.
YANG has leafrefs and instance-identifiers, which can be used 
to identify some order dependencies.
Are any new mechanisms needed in YANG-API needed to identify
resource creation order and other dependency requirements?
 </t>
 <t>
There is no &quot;message&#8209;id&quot; field in a YANG-API message.
Is a message identifier needed?  If so, should either the &quot;Message&#8209;ID&quot;
or &quot;Content&#8209;ID&quot; header from RFC 2392 be used for this purpose?
 </t>
 <t>
Should sessions be used or not?
Should &quot;reusable sessions&quot; be used? Better for auditing?
How does locking of the /yang-api/datastore resource
work for multiple edits if a session is 1 operation?
When does the server release the lock and decide it has
been abandoned or client was disconnected?
 </t>
 <t>
What syntax should be used for the &quot;select&quot; query parameter?
 </t>
 <t>
Should the &quot;/yang&#8209;api/modules&quot; field within the API resource
be a separate resource, with its own timestamp?  Currently the
API timestamp is coupled to any changes to the list of loaded
modules.  Should the API resource be static and cacheable?
 </t>
 <t>
What to do about no REMOVE operation, just DELETE?
The effect is local to the request; in a NETCONF
edit-config it is worse, since the netconf request might
create/delete/modify many nodes
 </t>
 <t>
Should every YANG data node be a data resource and every YANG RPC 
statement an operation resource? Is a YANG extension needed to
allow data modeler control of resource boundaries?
 </t>
 <t>
Encoding of leafrefs?  Is there some additional meta-data needed?
Do leafref nodes need to be identified in responses (RFC 5988) or
is the YANG module definition sufficient to provide this meta-data?
 </t>
 <t>
What should the default algorithm be for defining data resources?
Should the default for an augment from another namespace be to
start a new resource? Top-level data node defaults as a resource OK?
 </t>
 <t>
Is the token &quot;entries&quot; legal in the YANG-API usage of Range?
What units should be used?  &quot;bytes&quot; is the only token defined by HTTP.
 </t>
 <t>
Are all header lines used by YANG-API supported by common application
frameworks, such as FastCGI and WSGI?  If not, then should
query parameters be used instead, since the QUERY_STRING is
widely available to WEB applications?
 </t>
 <t>
Should the &lt;errors&gt; element returned in error responses
be a separate media type?
 </t>
 <t>
How should additional datastores be supported, which may be added to the
NETCONF/NETMOD framework in the future?
 </t>
 </list>
</t>
</section>
<section title="Example YANG Module" anchor="example-module">
	<figure>
	    <artwork><![CDATA[
module example-jukebox {

   namespace "http://example.com/ns/example-jukebox";
   prefix "jbox";

   import ietf-yang-api { prefix api; }

   organization "Example, Inc.";
   description "Example Jukebox Data Model Module";
   revision "2012-05-30";


   identity genre {
     description "Base for all genre types";
   }

   // abbreviated list of genre classifications
   identity Alternative {
     base genre;
   }
   identity Blues {
     base genre;
   }
   identity Country {
     base genre;
   }
   identity Jazz {
     base genre;
   }
   identity Pop {
     base genre;
   }
   identity Rock {
     base genre;
   }

   container jukebox {
     presence 
       "An empty container indicates that the jukebox
        service is available";

     container library {
       list artist {
         key index;
         unique name;

         leaf index {
           api:optional-key;
           type uint32;
           description
             "Optional key used instead of natural key for
              example. Also rare but possible artists with
              the same name are really different entities.";
         }
         leaf name {
           type string;
         }

         list album {
           key name;
           leaf name {
             type string {
               length "1 .. max";
             }
           }
           leaf genre {
             type identityref { base genre; }
           }
           leaf year {
             type uint16 {
               range "1900 .. max";
             }
           }
           list song {
             api:optional-key;
             key index;
             ordered-by user;
             leaf index {
               type uint32;
             }
             leaf name {
               mandatory true;
               type string;
             }
             leaf location {
               mandatory true;
               type string;
             }
             leaf format {
               type string;
             }
             leaf length {
               units "seconds";
               type uint32;
             }
           }
         }
       }
       leaf artist-count {
          config false;
          type uint32;
          units "songs";
          description "Number of artists in the library";
       }
       leaf album-count {
          config false;
          type uint32;
          units "albums";
          description "Number of albums in the library";
       }
       leaf song-count {
          type uint32;
          units "songs";
          description "Number of songs in the library";
       }
     }
  
     list playlist {
       description 
         "Example configuration data resource";
       key name;
       leaf name {
         type string;
       }
       leaf description {
         type string;
       }
       list song {
         description 
           "Example nested configuration data resource";
         ordered-by user;
         key index;
         leaf index {
           api:optional-key;
           type uint32;
         }
         leaf id {
           mandatory true;
           type instance-identifier;
           description 
             "Song identifier. Must identify an instance of
              /jukebox/library/artist/album/song.

              The id is not the key to allow duplicates
              in a playlist";
         }
       }
     }
  
     container player {
       leaf gap {
         description "Time gap between each song";
         units "tenths of seconds";
         type decimal64 {
           fraction-digits 1;
           range "0.0 .. 2.0";
         }
       }
     }
   }

   rpc play {
     description "Control function for the jukebox player";
     input {
       leaf playlist {           
         type string;
         mandatory true;
         description "playlist name";
       }
       leaf song-number {
         type uint32;
         mandatory true;
         description "Song number in playlist to play";
       }
     }
   }         
}

	    ]]></artwork>
	</figure>
</section>
</middle>
<back>
<references title="Normative References">

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author initials="S." surname="Bradner" fullname="S.  Bradner">
        <organization>Harvard University</organization>
      </author>
      <date month="March" year="1997"/>
      <abstract>
        <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.</t>
      </abstract>
    </front>
    <seriesInfo name="BCP" value="14"/>
    <seriesInfo name="RFC" value="2119"/>
    <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
  </reference>


<reference anchor="RFC2616">

<front>
<title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="UC Irvine">Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="J." surname="Gettys" fullname="James Gettys">
<organization abbrev="Compaq/W3C">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
<organization abbrev="Compaq">Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Xerox">Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials="P." surname="Leach" fullname="Paul J. Leach">
<organization abbrev="Microsoft">Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year="1999" month="June"/>
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name="RFC" value="2616"/>
<format type="TXT" octets="422317" target="http://www.rfc-editor.org/rfc/rfc2616.txt"/>
<format type="PS" octets="5529857" target="http://www.rfc-editor.org/rfc/rfc2616.ps"/>
<format type="PDF" octets="550558" target="http://www.rfc-editor.org/rfc/rfc2616.pdf"/>
<format type="HTML" octets="636125" target="http://xml.resource.org/public/rfc/html/rfc2616.html"/>
<format type="XML" octets="493420" target="http://xml.resource.org/public/rfc/xml/rfc2616.xml"/>
</reference>  


  <reference anchor='RFC3688'>
    <front>
      <title>The IETF XML Registry</title>
      <author initials='M.' surname='Mealling' fullname='M. Mealling'>
        <organization /></author>
      <date year='2004' month='January' />
      <abstract>
        <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front>
    
    <seriesInfo name='BCP' value='81' />
    <seriesInfo name='RFC' value='3688' />
    <format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />
  </reference>
  
<reference anchor="RFC3986">

<front>
<title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="Day Software">Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year="2005" month="January"/>
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name="STD" value="66"/>
<seriesInfo name="RFC" value="3986"/>
<format type="TXT" octets="141811" target="http://www.rfc-editor.org/rfc/rfc3986.txt"/>
<format type="HTML" octets="213584" target="http://xml.resource.org/public/rfc/html/rfc3986.html"/>
<format type="XML" octets="163534" target="http://xml.resource.org/public/rfc/xml/rfc3986.xml"/>
</reference>


<reference anchor="RFC5789">

<front>
<title>PATCH Method for HTTP</title>
<author initials="L." surname="Dusseault" fullname="L. Dusseault">
<organization/></author>
<author initials="J." surname="Snell" fullname="J. Snell">
<organization/></author>
<date year="2010" month="March"/>
<abstract>
<t>Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing HTTP PUT method only allows a complete replacement of a document.  This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="5789"/>
<format type="TXT" octets="21706" target="http://www.rfc-editor.org/rfc/rfc5789.txt"/>
</reference>



  <reference anchor='RFC6241'>
      <front>
        <title>Network Configuration Protocol (NETCONF)</title>
        <author initials='R.' surname='Enns' fullname='R. Enns' role="editor">
          <organization/>
        </author>
        <author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role="editor">
          <organization/>
        </author>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder' role="editor">
          <organization/>
        </author>
        <author initials='A.' surname='Bierman' fullname='A. Bierman' role="editor">
          <organization/>
        </author>
        <date year='2011' month='June'/>
      </front>
      <seriesInfo name='RFC' value='6241'/>
  </reference>


  <reference anchor="RFC6020">
    <front>
      <title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
      <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
        <organization/>
      </author>
      <date year="2010" month="October"/>
      <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
    </front>
    <seriesInfo name="RFC" value="6020"/>
    <format type="TXT" octets="324178" target="http://www.rfc-editor.org/rfc/rfc6020.txt"/>
  </reference>

    <reference anchor='RFC6021'>
      <front>
        <title>Common YANG Data Types</title>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
          <organization/>
        </author>
        <date year='2010' month='October'/>
      </front>
      <seriesInfo name='RFC' value='6021'/>
    </reference>


<reference anchor="RFC6536">

<front>
<title>Network Configuration Protocol (NETCONF) Access Control Model</title>
<author initials="A." surname="Bierman" fullname="A. Bierman">
<organization/></author>
<author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
<organization/></author>
<date year="2012" month="March"/>
<abstract>
<t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF protocol access for particular users to a pre-configured subset of all available NETCONF protocol operations and content.  This document defines such an access control model. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="6536"/>
<format type="TXT" octets="90803" target="http://www.rfc-editor.org/rfc/rfc6536.txt"/>
</reference>

  <reference anchor="I-D.lhotka-netmod-json">
    <front>
      <title>Modeling JSON Text with YANG</title>
      <author initials="L." surname="Lhotka" fullname="L. Lhotka">
        <organization>CZ.NIC</organization>
      </author>
      <date year="2012" month="October"/>
    </front>
    <seriesInfo name="Internet-Draft"
                value="draft-lhotka-netmod-yang-json-00"/>
    <format type='TXT'
    target='http://www.ietf.org/id/draft-lhotka-netmod-yang-json-00.txt'/>
  </reference>

</references>

</back></rfc>
