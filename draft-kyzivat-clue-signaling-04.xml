<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc='yes'?>
<?rfc tocdepth='4'?>
<?rfc compact="yes"?>
<rfc category="std" ipr="trust200902" docName='draft-kyzivat-clue-signaling-04'>

<!--56789012345678901234567890123456789012345678901234567890123456789-->

<!-- Notes:

Paul's messages from 12/18/12 4:11PM and 12/19/12 11:21AM
formed a starting point for this draft.

-->

<front>
   <title abbrev="CLUE Signaling">
      CLUE Signaling
   </title>
   <author initials="P." surname="Kyzivat" fullname="Paul Kyzivat">
      <organization>Huawei</organization>
      <address>
         <email>pkyzivat@alum.mit.edu</email>
      </address>
   </author>
   <author initials="L." surname="Xiao" fullname="Lennard Xiao">
      <organization>Huawei</organization>
      <address>
         <email>lennard.xiao@huawei.com</email>
      </address>
   </author>
   <author initials="C." surname="Groves" fullname="Christian Groves">
      <organization>Huawei</organization>
      <address>
         <email>Christian.Groves@nteczone.com</email>
      </address>
   </author>
   <author initials="R." surname="Hansen" fullname="Robert Hansen">
         <organization>Cisco Systems</organization>
         <address>
            <email>rohanse2@cisco.com</email>
         </address>
      </author>
   
   <date year="2013" />
   <abstract>
      <t>

This document specifies how signaling is conducted in the course of CLUE sessions.
This includes how SIP/SDP signaling is applied to CLUE sessions as well as defining 
a CLUE-specific signaling protocol that complements SIP/SDP and supports negotiation
of CLUE application level data.

      </t>
   </abstract>
</front>
<middle>
   <section title="Introduction">
      <t>

This document specifies how signaling is conducted in the course of CLUE sessions.
This includes how SIP/SDP signaling is applied to CLUE sessions as well as defining 
a CLUE-specific signaling protocol that complements SIP/SDP and supports negotiation
of CLUE application level data. 

      </t>
      <t>

[Yes, this is a dup of the abstract for now. Eventually it should say more.]

      </t>

   </section>

   <section title="Terminology">
      <t>

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.

      </t>
      <t>

This document draws liberally from the terminology defined in the
<xref target="I-D.ietf-clue-framework">CLUE Framework</xref>.

      </t>

      <t>

Other terms introduced here:

      </t>
      <t><list style='hanging'>
         <t hangText="CLUE Channel:">

A reliable, bidirectional, transport mechanism used to convey CLUE messages.
A CLUE channel consists of one SCTP stream in each direction over a DTLS/SCTP session.

         </t>

      </list></t>

   </section>

   <section title="CLUE-Specific Signaling Protocol " anchor="sec.protocol">
      <t>
The <xref target="I-D.ietf-clue-framework">CLUE Framework</xref> mentions a CLUE-specific 
protocol for the exchange of ADVERTISEMENT and CONFIGURE messages, but gives little detail.
The <xref target="I-D.presta-clue-data-model-schema">Data Model</xref> specifies a model
and XML representation for CLUE-related data, but doesn't currently specify exactly what
data belongs in each message, or how messages are sequenced. 
This document provides the detail missing from those documents.
      </t>

         <section title="Protocol Versioning, Options &amp; Extensions" anchor="sec.versioning">

            <section title="Versioning">
               <t>
There must be some provision for identifying incompatible protocol versions. 
               </t>
               <t>
NOTE: We probably don't want to have incompatible versions.
Typically changes will be introduced in a backward compatible way.
But a time may come when this isn't possible, and we should be prepared for that.
This is more likely to occur before an RFC is published. 
While it is probably unwise to deploy a product based on a draft,
there will certainly be prototypes developed for testing, and those tests
may lead to a need for incompatible change. So whatever the mechanism is,
it should be applicable to changes that occur from draft to draft, as well
as after an RFC has been published.
               </t>
            </section>

            <section title="Options and/or Extensions">
               <t>
There must be some provision for dealing with optional-to-implement features in the 
specification, and/or for backward compatible extensions to the protocol. 
These are superficially different, but in practice they are more-or-less equivalent.
To an implementation of the base protocol and some extensions, those extensions must
be viewed as optional-to-implement features in peers.
               </t>
               <t>
One decision is whether extensions may be implemented mix-and-match, or whether there is
a sequence of extensions, and one extension may only be supported if all the prior extensions
have been supported.
               </t>
            </section>

            <section title="Negotiation">
               <t>
Both version and options can be negotiated. Some mechanisms may work for both,
while others are only appropriate for one or the other.
Some possibilities:
               </t>
               <t><list style='symbols'>
                  <t>
No negotiation at all. 
Instead, unrecognized syntax in certain "extension points" is to be ignored.
If it is recognized, then a corresponding extension specification defines
what to do.
                  </t>
                  <t>
Negotiate via the SIP signaling.
                  </t>
                  <t>
Negotiate as part of the O/A exchange that establishes the channel. 
(E.g. it is likely that individual channels of the SCTP association will be 
specified in SDP with a specific sub-protocol type. There could be a separate
sub-protocol for each new version.)
                  </t>
                  <t>
Negotiate within the CLUE channel, via a special message exchange, 
before exchanging "normal" CLUE messages.
                  </t>
                  <t>
Declare versioning in every CLUE message. Define errors for unsupported
versions and fallback to earlier versions.
                  </t>
               </list></t>
            </section>

            <section title="Principles">
               <t><list style='symbols'>
                  <t>
CLUE SHOULD allow forwards and backwards compatibility through a version and extension mechanism. 
Forward compatibility allows a version of a protocol to communicate effectively with and interwork 
with future versions of the protocol. 
A version should not restrict the future protocol from providing extra capabilities. 
                 </t>
                  <t>
Whenever possible backwards compatibility should be maintained. 
Backward compatibility rules will be defined to ensure that endpoints implementing 
future versions of CLUE will be able to send protocol messages of the previous versions 
which will be understood and fully processed by the remote endpoint.
                  </t>
                  <t>
Existing protocol elements should not be changed unless a protocol error needs to be corrected.
                  </t>
                  <t>
The semantics of existing elements and values should not be changed.
                  </t>
                  <t>
Established rules for formatting and encoding messages and elements should not be changed.
                  </t>
                  <t>
When information elements are found to be obsolete they can be marked as not used. 
However, the identifier for that information element will be marked as reserved. 
In that way it cannot be used in future versions.
                  </t>
               </list></t>
            </section>
         </section>

           <section title="Acknowledging Messages" anchor="sec.ack">

            <t>
The CLUE channel is reliable, so there is no need for acknowledgement to
guarantee delivery. But there is still a need for application-to-application acknowledgement
to report that the message has been received, parsed, and found to be of an acceptable format.
One possibility is to introduce separate ACK and NAK messages.
Another possibility is to add a confirmation element to each CLUE message, 
so that confirmation can be piggybacked on the basic messages.
Some alternatives follow.
[OTHER PROPOSALS WELCOME.]
            </t>

              <section title="Explicit Acknowledgment of Each Message">
               <t>
The characteristics of this approach are:
               </t>
               <t><list style='symbols'>
                  <t>
There are separate request and response messages. (This is similar to SIP.)
                  </t>
                  <t>
Every request message expects exactly one response message.
                  </t>
                  <t>
Every request message carries a sequence number that identifies it.
                  </t>
                  <t>
Each end of the connection assigns sequential sequence numbers to the requests it sends.
                  </t>
                  <t>
Every response message carries the sequence number of the message to which it responds.
                  </t>
                  <t>
Responses are to be sent promptly upon the receipt of a request. (Needs more detail.)
                  </t>
                  <t>
Responses are either ACK or NAK. NAK responses also carry info describing the error.
                  </t>
                  <t>
Each CONFIGURE message is to be understood in the context of the most recent ACKed
ADVERTISEMENT message. A CONFIGURE message may be rejected if there is an outstanding
ADVERTISEMENT for which no response has been received. 
(Or it may be accepted if the advertiser is able to do so meaningfully.)
                  </t>
               </list></t>
              </section>

              <section title="Piggybacking ACK on Requests">
               <t>
The characteristics of this approach are:
               </t>
               <t><list style='symbols'>
                  <t>
Every message carries a sequence number that identifies it.
                  </t>
                  <t>
Each end of the connection assigns sequential sequence numbers to the messages it sends.
                  </t>
                  <t>
Every message carries the sequence number of the last message received and found valid. 
                  </t>
                  <t>
If a message is received and found invalid, then a NAK message is sent that refers to it
and indicates what is wrong with it.
                  </t>
                  <t>
If a valid message is received and a new message needs to be sent in response, 
then the responding message implicitly acknowledges the prior message.
                  </t>
                  <t>
If a valid message is received and there is no need to immediately send another message,
then a NO-OP message is sent to acknowledge the received message. But a NO-OP message
is never sent in response to a NO-OP message.
                  </t>
                  <t>
Each CONFIGURE message is to be understood in the context of the most recent *acknowledged*
ADVERTISEMENT message. A CONFIGURE message may be rejected if it doesn't acknowledge 
the most recently sent ADVERTISEMENT. (Or it may be accepted if the advertiser
is able to do so meaningfully.)
                  </t>
               </list></t>
               <t>
The general format of every message is:
                  <list style='symbols'>
                     <t>sequence # of this message</t>
                     <t>sequence # of most recently *received* and *valid* message</t>
                     <t>message type (ADVERTISEMENT, CONFIG, NO-OP, NAK)</t>
                     <t>body of the message, according to type</t>
                  </list>
(The exact representation is TBD - by XML experts.) 
               </t>
               <t>
There are loose ends to resolve here. In particular, how to acknowledge
messages after NAKing one.
               </t>
              </section>

            <section title="Reporting Message Errors" anchor="sec.ReportingErrors">
               <t>
There needs to be a mechanism to report errors with other messages.
The details of form, content, and usage still need to be specified,
and need to be tuned to the details of the protocol.
This could use distinct messages or be incorporated into the other messages.
Errors this message must be able to report include:
               </t>

               <t><list style='hanging'>
                  <t hangText="Syntax error in message:">
The message has been disregarded due to a syntax error detected at the message level.
The message does not conform to the productions of messages in [Protocol Document]. 
Used when the message cannot be parsed.
                  </t>
                  <t hangText="Sequencing Error:">
Sequence number has already been used, or is greater than the expected number.
(Details of possible errors depend upon the specific sequence numbering mechanism.)
                  </t>
                  <t hangText="Version not supported:">
This indicates a lack of support for the protocol version indicated in the message header of the message. 
In the case of the version number being indicated in the message header, 
the message contents are disregarded.
                  </t>
                  <t hangText="Option not supported:">
This indicates a lack of support for the protocol option the used in the message. 
The message contents are disregarded.
                  </t>
                  <t hangText="Unknown capture identity:">
The received Configure message contains an unknown capture identity 
not previously declared by an Advertisement. 
The message contents are disregarded.
                  </t>
                  <t hangText="Invalid identity:">
The received message contains an invalid capture identity. 
For example a duplicated Capture scene identity or some other semantically incorrect usage. 
The message contents are disregarded.
                  </t>
                  <t hangText="Invalid value:">
The received message contains an invalid parameter value. 
The value is not according to the protocol definition in [protocol document] 
or according the extension documentation.
                  </t>
                  <t hangText="Missing element:">
The received message is missing an element. 
Certain parameters require multiple values, 
e.g. Point of capture requires X,Y,Z co-ordinates 
if one or more elements are missing this error code is used.
                  </t>
                  <t hangText="Conflicting parameters or values:">
The received message contains multiple values that may not be used together.
                  </t>
                  <t hangText="Invalid capture area:">
The received message defines a capture area that cannot be rendered in a sensible manner. 
For example the capture area does not define a quadrilateral region.
                  </t>
                  <t hangText="Invalid point of line of capture:">
The indicated co-ordinate for the point on line of capture is invalid. 
For example: does not lie between the point of capture and the area of capture 
or it is the same as the point of capture.
                  </t>
                  <t hangText="Invalid capture scene entry:">
The message contains an invalid capture scene entry. 
For example the capture scene entry contains more than one media type.
                  </t>
                  <t hangText="Invalid Simultaneous Set:">
The simultaneous set contained in the message is invalid. 
For example the simultaneous set refers to an undefined capture set 
or does not match the specified capture scene entries.
                  </t>
                  <t hangText="Invalid Configuration:">
The Configure message requests a configuration that the provider cannot support.
                  </t>
                  <t hangText="Invalid Advertisement reference:">
The Configure message refers to an invalid Advertisement. 
The message refers-to/depends-upon out-of-date ADVERTISEMENT message 
or provides an invalid reference.
                  </t>
               </list></t>
           </section>
         </section>

         <section title="Stand-alone messages or deltas?">
               <t>

Each message exchanged within a CLUE session could contain a complete description
of the state it wishes to achieve. 
Or each message could describe just the changes that it wishes to make to the current state.
Or the protocol could support both message forms.
Which direction to pursue is TBD.
               </t>
               <t>
[Paul: while this does need to be decided, it is fundamentally just an optimization.
IMO it does not have major impact on the other parts of this document,
so I would prefer to continue deferring it until we are so far along with the
remainder of the document that we can no longer defer it.]
               </t>

         </section>

         <section title="Message Sequencing" anchor="sec.sequencing">

            <t>
There is a very basic introduction to this topic in section 4 (Overview) of the
<xref target="I-D.ietf-clue-framework">CLUE Framework</xref>. 
After removing extraneous material it would look like:
            </t>

            <figure align="center">
               <artwork align="center"><![CDATA[
 +-----------+                     +-----------+
 | Endpoint1 |                     | Endpoint2 |
 +----+------+                     +-----+-----+
      |                                  |
      | ADVERTISEMENT 1                  |
      |*********************************>|
      |                  ADVERTISEMENT 2 |
      |<*********************************|
      |                                  |
      |                      CONFIGURE 1 |
      |<*********************************|
      | CONFIGURE 2                      |
      |*********************************>|
      |                                  |
               ]]></artwork>
            </figure>
            <t>

But we need much more than this, to show multiple CONFIGUREs per ADVERTISEMENT, 
interleaving of ADVERTISEMENTs and CONFIGUREs in both directions, etc.

            </t>

            <t>
Message sequencing needs to be described at two levels:
            </t>

            <t><list style='symbols'>
               <t>

Basic sequencing of the CLUE messages themselves, 
without regard for the SIP/SDP signaling that may be going on at the same time.
This is useful to cover the basic concepts. That should be covered in this section.
It provides context for understanding the more detailed treatment later.
<vspace blankLines='1'/>
This could include some simple state machines.

               </t>
               <t>

In reality there is a complex dependency between CLUE signaling and 
SDP Offer/Answer exchanges carried in SIP signaling.
So there is a need to describe the valid ways in which these
two forms of signaling interact. That is covered in
<xref target="sec.coordination"/>.

               </t>
            </list></t>

         <section title="Signaling Changes in Provider State">
            <t>
Once a CLUE session has been established, ADVERTISEMENTs and CONFIGUREs exchanged,
and media is flowing, a provider may experience a change in state that has an
effect on what it wishes or is able to provide. In this case it may need to
alter what it is sending and/or send a new ADVERTISEMENT. In some cases it 
will be necessary to alter what is being sent without first sending a new
ADVERTISEMENT and waiting for a CONFIGURE conforming to it.
            </t>
            <t>
The following is a non-exhaustive list of situations and recommended actions:
            </t>
            <t><list style='symbols'>
               <t>
An advertised capture, that is not currently configured, is no longer available.
   <vspace blankLines='1'/>
To recover from this: Send a new ADVERTISEMENT that omits this capture. 
               </t>
               <t>
An advertised capture, that has been configured, is no longer available.
   <vspace blankLines='1'/>
To recover from this: (1) stop transmitting the configured encoding of this capture. 
(2) Send a new ADVERTISEMENT that omits this capture.
               </t>
               <t>
The provider loses some resource and must reduce the frame rate, frame size,
or resolution of a capture encoding.
   <vspace blankLines='1'/>
If the reduced values still fall within the advertised values for the capture
then the change may be made without any further signaling.
   <vspace blankLines='1'/>
If the change must be outside the range of what was advertised,
then the provider must cease transmitting the capture encoding. 
It then must send a new ADVERTISEMENT reflecting what it is now capable of delivering.
               </t>
               <t>
New or changed scenes or scene geometry. 
For instance, the addition of a new scene containing presentation captures.
Also, an MCU may make significant changes in what it advertises as new
endpoints join a conference.
               </t>
               <t>
[Add more]
               </t>
            </list></t>
         </section>

         <section title="Signaling Changes in Consumer State">
            <t>
If the Consumer for some reason looses the CLUE state information 
how does it ask for an Advertisement from the provider? 
There could be multiple possibilities. A error code approach? 
However error codes would typically be associated with a NACK so it may not be good for a Config message. 
Maybe send a message which means “send me a complete update”.
An alternative may be to release the connection or just do new signaling to establish a new CLUE session.
            </t>
         </section>

      </section>

         <section title="Message Transport" anchor="sec.transport">
            <t>

CLUE messages are transported over a bidirectional CLUE channel.  
In a two-party CLUE session, a CLUE channel connects the two endpoints.
In a CLUE conference, each endpoint has a CLUE channel connecting it to an MCU. 
(In conferences with cascaded mixers <xref target="RFC4353"/>, 
two MCUs will be connected by a CLUE channel.)

            </t>

            <section title="CLUE Channel Lifetime">
               <t>
The transport mechanism used for CLUE messages is DTLS/SCTP as specified in 
<xref target="I-D.tuexen-tsvwg-sctp-dtls-encaps"/> and 
<xref target="I-D.ietf-mmusic-sctp-sdp"/>. 
A CLUE channel consists of one SCTP stream in each direction over a DTLS/SCTP session.
The mechanism for establishing the DTLS/SCTP session is described in
<xref target="sec.sdp_oa"/>.
               </t>
               <t>
The CLUE channel will usually be offered during the initial SIP INVITE,
and remain connected for the duration of the CLUE/SIP session.
However this need not be the case. The CLUE channel may be established
mid-session after desire and capability for CLUE have been determined,
and the CLUE channel may be dropped mid-call if the desire and/or capability
to support it is lost.
               </t>
               <t>
There may be cases when it becomes necessary to "reset" the CLUE channel.
This by be as a result of an error on the underlying SCTP association,
a need to change the endpoint address of the SCTP association, 
loss of CLUE protocol state, or something else TBD.
               </t>
               <t>
The precise mechanisms used to determine when a reset is required,
and how to accomplish it and return to a well defined state are TBS.
               </t>
            </section>

            <section title="Channel Error Handling" anchor="sec.channel-errors">
               <t>
We will need to specify behavior in the face of transport errors that are so
severe that they can't be managed via CLUE messaging within the CLUE channel.
Some errors of this sort are:
               <list style='symbols'>
                  <t>
Unable to establish the SCTP association after signaling it in SDP.
                  </t>
                  <t>
CLUE channel setup rejected by peer.
                  </t>
                  <t>
Error reported by transport while writing message to CLUE channel. 
                  </t>
                  <t>
Error reported by transport while reading message from CLUE channel.
                  </t>
                  <t>
Timeout - overdue acknowledgement of a CLUE message. 
(Requirements for now soon a message must be responded to are TBD.)
                  </t>
                  <t>
Application fault. CLUE protocol state lost.
                  </t>
               </list>
The worst case is to drop the entire CLUE call.
Another possibility is to fall back to legacy compatibility mode.
Or perhaps a "reset" can be done on the protocol. E.g. this might be
accomplished by sending a new O/A and establishing a replacement SCTP association.
Or a new CLUE channel might be established within the existing SCTP association.
               </t>
            </section>

         </section>

         <section title="CLUE Messages" anchor="sec.messages">
            <t>
CLUE messages are encoded in XML.
The <xref target="I-D.presta-clue-data-model-schema">Data Model</xref>
defines many/most of the elements from which CLUE messages are composed.
This document specifies an XML schema that contains an element definition for each CLUE message,
with much of the content of those elements being drawn from the Data Model.
            </t>

            <section title="ADVERTISEMENT Message">
               <t>
This message contains XML representations of captures, capture scenes, encoding groups, and simultaneous sets
using the types defined for those in the 
<xref target="I-D.presta-clue-data-model-schema">Data Model</xref>.
               </t>
               <t>
The XML definition for this is element &lt;advertisement&gt; in section
<xref target="sec.syntax"/>
               </t>
               <t>
[[ Currently this does not contain any representation of encodings. 
It assumes those will be defined in SDP. ]]
               </t>
           </section>

            <section title="CONFIGURE Message">
               <t>
This message optionally contains an XML representations of captureEncodings
using the type defined in the 
<xref target="I-D.presta-clue-data-model-schema">Data Model</xref>.
A configure message with no captureEncodings indicates that no captures are requested.
               </t>
               <t>
[[ It currently also contains a reference to the request number of the advertisement
it is based upon. Whether this should be present, or if it should implicitly reference
the most recently acknowledged advertisement is TBD. ]]
               </t>
               <t>
The XML definition for this is element &lt;configure&gt; in section
<xref target="sec.syntax"/>
               </t>
            </section>

            <section title="ACK Message">
               <t>
Need for, and details of, the ACK message are TBD.
               </t>
               <t>
The XML element &lt;response&gt; in section <xref target="sec.syntax"/>
could serve as the representation, either with no reason element, 
or a reason element with a special value.
               </t>
            </section>

            <section title="NAK Message">
               <t>
Need for, and details of, the NACK message are TBD.
               </t>
               <t>
The XML element &lt;response&gt; in section <xref target="sec.syntax"/>
could serve to as the representation, with the reason element providing the details.
Then the code value in the reason element should map to the errors in section
<xref target="sec.ReportingErrors"/>.
               </t>
            </section>

         </section>

         <section title="Message Syntax" anchor="sec.syntax">

               <t>
[[ The following is a first cut at a schema for the actual messages in the clue protocol.
It uses &lt;encodingGroups&gt; from the data model but not &lt;encodings&gt;.
Rather, it assumes that encodings are described in SDP as m-lines with a text identifier, 
and that the identifier has the same value as the encodingIDs embedded in the &lt;encodingGroups&gt;.
If we stick with this the data model should be adjusted to agree, but until then it should "work".
The SDP encoding of the identifier is proposed to be 'a=label:ID', though 'a=mid:ID' is another candidate. ]] 
               </t>
               <t>
For now there only &lt;advertisement&gt; and &lt;configure&gt; are defined.
More messages will be needed for acknowledgment.
               </t>

            <figure><artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema
   targetNamespace="urn:ietf:params:xml:ns:clue-message"
   xmlns:tns="urn:ietf:params:xml:ns:clue-message"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:dm="urn:ietf:params:xml:ns:clue-info"
   xmlns="urn:ietf:params:xml:ns:clue-message"
   elementFormDefault="qualified"
   attributeFormDefault="unqualified">

<!-- Import data model schema -->
   <xs:import namespace="urn:ietf:params:xml:ns:clue-info" 
              schemaLocation="clue-data-model-04-wip.xsd"/>

<!-- ELEMENT DEFINITIONS -->
<xs:element name="advertisement" type="advertisementMessageType"/>
<xs:element name="configure" type="configureMessageType"/>
<xs:element name="response" type="responseMessageType"/>

<!-- CLUE MESSAGE TYPE -->
<xs:complexType name="clueMessageType" abstract="true">
  <xs:sequence>
    <!-- mandatory fields -->
    <!-- TBS: version info -->
  </xs:sequence>
</xs:complexType>

<!-- CLUE REQUEST MESSAGE TYPE -->
<xs:complexType name="clueRequestMessageType" abstract="true">
 <xs:complexContent>
  <xs:extension base="clueMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="requestNumber" type="xs:integer"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE RESPONSE MESSAGE TYPE -->
<xs:complexType name="clueResponseMessageType">
 <xs:complexContent>
  <xs:extension base="clueMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="requestNumber" type="xs:integer"/>
     <!-- optional fields -->
     <xs:element name="reason" type="reasonType" minOccurs="0"/>
     <xs:any namespace="##other"
         processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE ADVERTISEMENT MESSAGE TYPE -->
<xs:complexType name="advertisementMessageType">
 <xs:complexContent>
  <xs:extension base="clueRequestMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="mediaCaptures"
                 type="dm:mediaCapturesType"/>
     <xs:element name="encodingGroups"
                 type="dm:encodingGroupsType"/>
     <!-- The encodings are defined via identifiers in the SDP, 
          referenced in encodingGroups -->
     <xs:element name="captureScenes"
                 type="dm:captureScenesType"/>
     <!-- optional fields -->
     <xs:element name="simultaneousSets"  
                 type="dm:simultaneousSetsType" minOccurs="0"/>
     <xs:any namespace="##other"
             processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- CLUE CONFIGURE MESSAGE TYPE -->
<xs:complexType name="configureMessageType">
 <xs:complexContent>
  <xs:extension base="clueRequestMessageType">
   <xs:sequence>
     <!-- mandatory fields -->
     <xs:element name="advertisementNumber" type="xs:integer"/>
     <!-- advertisementNumber is requestNumber
          of the advertisement-->
     <!-- optional fields -->
     <xs:element name="captureEncodings" 
                 type="dm:captureEncodingsType" minOccurs="0"/>
     <xs:any namespace="##other" 
             processContents="lax" minOccurs="0"/>
   </xs:sequence>
  </xs:extension>
 </xs:complexContent>
</xs:complexType>

<!-- REASON TYPE -->
<xs:complexType name="reasonType">
  <xs:simpleContent>
    <xs:extension base="xs:string">
      <xs:attribute type="xs:short" name="code" use="required"/>
    </xs:extension>
  </xs:simpleContent>
</xs:complexType>

</xs:schema>   
            ]]></artwork></figure>

            <t>
            </t>
         </section>

         <section title="Message Framing">
            <t>
Message framing is provided by the SCTP transport protocol.
Each CLUE message is carried in one SCTP message.
            </t>
         </section>

         <section title="other">
            <t>
            </t>
         </section>

   </section>

   <section title="CLUE use of SDP O/A" anchor="sec.sdp_oa">

      <section title="Establishing the CLUE channel" anchor="sec.sdp_clue_channel">
         <t>
The CLUE channel is usually offered in the first SIP O/A exchange between two parties in an intended CLUE session.
The offer of the CLUE channel is the indicator that this SIP session is proposing to establish a CLUE session.
         </t>
         <t>
(However it is also acceptable to start with a non-CLUE SIP session and upgrade it to a CLUE session later.)
         </t>
         <t>
The mechanism for negotiating a DTLS/SCTP connection is specified in <xref target="I-D.ietf-mmusic-sctp-sdp"/>.
We need to specify how to select the specific pair of SCTP streams that comprise the CLUE channel.
         </t>
         <t>
The presence of an active m-line for the CLUE channel in an SDP offer is an indication that the offer that the sender is CLUE-capable and hence can understand CLUE-specific syntax.    
         </t>
      </section>

      <section title="Representing CLUE Encodings in SDP">
         <t>
Many CLUE constructs have no good analog in SDP. Entities such as 'captures', 
which describe spatial and other properties of a capture source such as a camera,
are not tied directly to RTP streams, do not have negotiated properties and would prove a significant challenge to represent in SDP syntax (while also greatly increasing the size of the SDP).
         </t>
         <t>
However, two entities defined in the <xref target="I-D.ietf-clue-framework">CLUE Framework</xref> are a much closer fit for SDP:
Encodings and Encoding Groups. Both describe RTP media properties and limitations,
though unlike most SDP usage they describe the sender's capabilities, not the receiver's.
Representing encodings in CLUE splits media limitations across two protocols,
and risks duplicated and potentially contradictory information being sent in CLUE and SDP.
As such we are exploring representing this information in SDP,
with the decision to convey them in the CLUE messages only to be made if the SDP approach proves impractical.
         </t>
         <t>
This draft presents an attempt to describe CLUE encodings in SDP. 
As a decision has not yet been reached on how multiplexed RTP streams are to be expressed in SDP,
at this stage the draft does so without multiplexing, using existing SDP attributes,
with a seperate "m" line and hence port per unidirectional RTP stream. 
This is done with the understanding that when a decision is reached on new syntax for multiplexing RTP streams in SDP the CLUE SDP signaling will be modified to use it.
Further, the framework document states that the multiplexing of streams by an implementation is optional,
and in the case of a disaggregated system, with media streams going to different addresses, may not be possible.
         </t>
         <t>
With the current scheme of using existing syntax,
an encoding is specified in SDP as a unicast "m" line, which MUST be marked as sendonly with the "a=sendonly" attribute
or as inactive with the "a=inactive" attribute.
The encoder capabilities of the stream are defined here using existing syntax; 
for instance, for H.264 see Table 6 in <xref target="RFC6184" /> for a list of valid parameters for representing encoder sender stream limits.
         </t>
         <t>
Every "m" line representing a CLUE encoding SHOULD contain a "label" attribute as defined in <xref target="RFC4574" />.
This label is used to identify the encoding by the sender in CLUE Advertisement messages and by the receiver in CLUE Configure messages.
         </t>
         <t>
A receiver who wishes to receive a CLUE stream via this encoding requires a matching "a=recvonly" "m" line.
As well as the normal restrictions defined in <xref target="RFC3264" /> media MUST NOT be sent on this stream
until the sender has received a valid CLUE Configure message specifying the capture to be used for this stream.
         </t>
      </section>
    
      <section title="Representing CLUE Encoding Groups in SDP">
         <t>
As per the previous section, there would be advantages to conveying encoding group information in SDP.
However, with current SDP syntax there is no way to express the encoding group limits defined in the  <xref target="I-D.presta-clue-data-model-schema">Data Model</xref>.
As such the current draft keeps encoding groups as part of the Advertisement message for the time being.
         </t>
      </section>

      <section title="Signaling CLUE control of &quot;m&quot; lines">
         <t>
In many cases an implementation may wish to mix media channels that are under CLUE control with those that are not.
It may want to ensure that there are non-CLUE streams for purposes of interoperability,
or that can provide media from the start of the call before CLUE negotiation completes,
or because the implementation wants CLUE-controlled video but traditional audio,
or for any other reasons.
         </t>
         <t>
Which "m" lines in an SDP body are under control of the CLUE channel is signalled via the <xref target="RFC5888">SDP Grouping Framework</xref>.
Devices that wish to negotiate CLUE MUST support the grouping framework.
         </t>
         <t>
A new semantic for the "group" session-level attribute, "CLUE", is used to signal which "m" lines are under the control of a CLUE channel.
As per the framework, all of the "m" lines of a session description that uses "group" MUST be identified with a "mid" attribute whether they are controlled by CLUE or not.
The "mid" id of any "m" lines controlled by a CLUE channel MUST be included in the "CLUE" group attribute alongside the "mid" id of the CLUE channel controlling them.
         </t>
         <t>
The CLUE group MUST NOT include more than one "m" line for a CLUE channel.
If a CLUE channel is part of the CLUE group attribute other media "m" lines  included in the group are under the control of that CLUE channel;
media MUST NOT be sent or received on these "m" lines until the CLUE channel has been negotiated and negotiation has taken place as defined in this document.
If no CLUE channel is part of the CLUE group attribute then media MUST NOT be sent or received on these "m" lines. 
         </t>
         <t>
"m" lines not specified as under CLUE control follow normal rules for media streams negotiated in SDP as defined in documents such as <xref target="RFC3264" />.
         </t>
         <t>
An SDP MAY include more than one group attribute with the "CLUE" semantic. An "mid" id for a given "m" line MUST NOT be included in more than one CLUE group.
         </t>
      </section>
      <section title="Ensuring interoperability with non-CLUE devices">
         <t>
A CLUE-capable device sending an initial SDP offer SHOULD include an "m" line for the CLUE channel,
but SHOULD NOT include any other CLUE-controlled "m" lines. 
Once each side of the call is aware that the other side is CLUE-capable a new 
O/A exchange MAY be used to add CLUE-controlled "m" lines.
        </t>
      </section>
   </section>

   <section title="Interaction of CLUE and SDP negotiations" anchor="sec.coordination">
      <t>
Information about media streams in CLUE is split between two message types:
SDP, which defines media addresses and limits, and the CLUE channel,
which defines properties of capture devices available, scene information and additional constraints.
As a result certain operations, such as advertising support for a new transmissible capture with associated stream,
cannot be performed atomically, as they require changes to both SDP and CLUE messaging.
      </t>
      <t>
This section defines how the negotiation of the two protocols interact,
provides some recommendations on dealing with intermediary stages in non-atomic operations,
and mandates additional constraints on when CLUE-configured media can be sent.   
      </t>      
      <section title="Independence of SDP and CLUE negotiation">         
         <t>
To avoid complicated state machines with the potential to reach invalid states if messages were to be lost,
or be rewritten en-route by middle boxes, the current proposal is that SDP and CLUE messages are independent.
The state of the CLUE channel does not restrict when an implementation may send a new SDP offer or answer,
and likewise the implementation's ability to send a new CLUE Advertisement or Configure message is not restricted
by the results of or the state of the most recent SDP negotiation.
         </t>
         <t>
The primary implication of this is that a device may receive an SDP with a CLUE
encoding it does not yet have capture information for,
or receive a CLUE Configure message specifying a capture encoding for which the
far end has not negotiated a media stream in SDP.
         </t>
         <t>
CLUE messages contain an EncodingID which is used to identify a specific encoding in SDP.
The non-atomic nature of CLUE negotiation means that a sender may wish to send a new Advertisement before the corresponding SDP message.
As such the sender of the CLUE message MAY include an EncodingID which does not currently match an extant id in SDP.
         </t>
      </section>
      <section title="Recommendations for operating with non-atomic operations">
         <t>
Generally, implementations that receive messages for which they have incomplete information
SHOULD wait until they have the corresponding information they lack before sending messages to make changes related to that information.
For instance, an implementation that receives a new SDP offer with three new "a=sendonly" 
CLUE "m" lines that has not received the corresponding CLUE Advertisement providing the
capture information for those streams SHOULD NOT include corresponding "a=recvonly" lines in its answer,
but instead should make a new SDP offer when and if a new Advertisement arrives with captures relevant to those encodings.
         </t>         
         <t>
Because of the constraints of offer/answer and because new SDP negotiations are generally more 'costly' than sending a new CLUE message,
implementations needing to make changes to both channels SHOULD prioritize sending the updated CLUE message over sending the new SDP message.
The aim is for the recipient to receive the CLUE changes before the SDP changes, 
allowing the recipient to send their SDP answers without incomplete information,
reducing the number of new SDP offers required.
         </t>
      </section>
     <section title="Constraints on sending media">
         <t>
While SDP and CLUE message states do not impose constraints on each other, both impose constraints on the sending of media - 
media MUST NOT be sent unless it has been negotiated in both CLUE and SDP:
an implementation MUST NOT send a specific CLUE capture encoding unless its most
recent SDP exchange contains an active media channel for that encoding AND
the far end has sent a CLUE Configure message specifying a valid capture for that encoding.
         </t>
      </section>
   </section>

   <section title="Example: A call between two CLUE-capable endpoints" anchor="sec-clueexample">
      <t>
This example illustrates a call between two CLUE-capable endpoints.
Alice, initiating the call, is a system with three cameras and three screens.
Bob, receiving the call, is a system with two cameras and two screens.
A call-flow diagram is presented, followed by an summary of each message.
      </t>
      <t>
To manage the size of this section only video is considered, and SDP snippets only
illustrate video 'm' lines. ACKs are not discussed.
      </t>
      <figure>
         <artwork>
            <![CDATA[ 
                  	
              +----------+                      +-----------+
              |  Alice   |                      |    Bob    |
              |          |                      |           |
              +----+-----+                      +-----+-----+
                   |                                  |
                   |                                  |
                   | INVITE 1 (BASIC SDP+COMEDIA)     |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |     200 OK 2 (BASIC SDP+COMEDIA) |
                   |<---------------------------------|
                   |                                  |
                   |                                  |
                   | ACK 1                            |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<########### MEDIA 1 ############>|
                   |   1 video A->B, 1 video B->A     |
                   |<################################>|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<================================>|
                   |   CLUE CTRL CHANNEL ESTABLISHED  |
                   |<================================>|
                   |                                  |
                   |                                  |
                   | ADVERTISEMENT 1                  |
                   |*********************************>|
                   |                                  |
                   |                                  |
                   |                  ADVERTISEMENT 2 |
                   |<*********************************|
                   |                                  |
                   |                                  |
                   | INVITE 2 (+3 sendonly)           |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |                      CONFIGURE 1 |
                   |<*********************************|                   
                   |                                  |
                   |                                  |
                   |           200 OK 2 (+2 recvonly) |
                   |<---------------------------------|
                   |                                  |
                   |                                  |
                   | ACK 2                            |
                   |--------------------------------->|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<########### MEDIA 2 ############>|
                   |   2 video A->B, 1 video B->A     |
                   |<################################>|
                   |                                  |
                   |                                  |
                   |           INVITE 3 (+2 sendonly) |
                   |<---------------------------------|
                   |                                  |                   
                   |                                  |
                   | CONFIGURE 3                      |
                   |*********************************>|
                   |                                  |
                   |                                  |
                   | 200 OK 3 (+2 recvonly)           |
                   |--------------------------------->|                   
                   |                                  |
                   |                                  |
                   |                                  |
                   |                            ACK 3 |
                   |<---------------------------------|
                   |                                  |
                   |                                  |
                   |                                  |
                   |<########### MEDIA 3 ############>|
                   |   2 video A->B, 2 video B->A     |
                   |<################################>|                   
                   |                                  |
                   |                                  |
                   |                                  |
                   v                                  v	
            ]]>
         </artwork>
      </figure>    
      <t>
In INVITE 1, Alice sends Bob a SIP INVITE including in the SDP body the basilar audio and video capabilities 
("BASIC SDP") and the information needed for opening a control channel to be used 
for CLUE protocol messages exchange, according to what is envisioned in the COMEDIA approach ("COMEDIA") 
for DTLS/SCTP channel <xref target="I-D.ietf-mmusic-sctp-sdp"/>.
A snippet of the SDP showing the grouping attribute and the video m-line are shown below (mid 3 represents the CLUE channel):  
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2                           
               ]]>
            </artwork>
         </figure>         
      </t>
      <t>
Bob responds with a similar SDP (200 OK 1); due to their similiarity no SDP snippet is shown here.
Alice and Bob are each able to send a single audio and video stream (whether they choose to send this initial media
before CLUE has been negotiated is implementation-dependent). This is illustrated as MEDIA 1.
      </t>
      <t>
With the successful initial O/A Alice and Bob are also free to negotiate the CLUE channel.
Once this is successfully established CLUE negotiation can begin.   This is illustrated as CLUE CHANNEL ESTABLISHED.  
      </t>
      <t>
Alice now sends her CLUE Advertisement (ADVERTISEMENT 1). 
She advertises three static captures representing her three cameras. 
She also includes switched captures suitable for two- and one-screen systems.
All of these captures are in a single capture scene,
with suitable capture scene entries to tell Bob that he should either subscribe to the three static captures,
the two switched capture view or the one switched capture view.
Alice has no simultaneity constraints, so includes all six captures in one simultaneous set.
Finally, Alice includes an encoding group with three encoding IDs: "enc1", "enc2" and "enc3".
These encoding ids aren't currently valid, but will match the next SDP offer she sends.
      </t>  
      <t>
Bob received ADVERTISEMENT 1 but does not yet send a Configure message, 
because he has not yet received Alice's encoding information, 
so as yet he does not know if she will have sufficient resources to send him the two streams he ideally wants at a quality he is happy with.
      </t>  
      <t>
Bob also sends his CLUE Advertisement (ADVERTISEMENT 2). 
He advertises two static captures representing his cameras. 
He also includes a single composed capture for single-screen systems,
in which he will composite the two camera views into a single video stream.
All three captures are in a single capture scene,
with suitable capture scene entries to tell Alice that she should either subscribe to the two static captures,
or the single composed capture.
Bob also has no simultaneity constraints, so includes all three captures in one simultaneous set.
Bob also includes a single encoding group with two encoding IDs: "foo" and "bar".
      </t>
      <t>
Similarly, Alices receives ADVERTISEMENT 2 but does not yet send a Configure message,
because she has not yet received Bob's encoding information.
      </t>
      <t>
Alice now sends INVITE 2. She maintains the sendrecv audio, video and CLUE m-lines,
and she adds three new sendonly m-lines to represents the maximum three encodings she can send.
Each of these m-lines has a label corresponding to one of the encoding ids from ADVERTISEMENT 1.
Each also has its mid added to the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 3 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3 4 5 6
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2
   ...
   m=video 6004 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:4
   a=label:enc1
   m=video 6006 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:5
   a=label:enc2
   m=video 6008 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:6
   a=label:enc3                           
               ]]>
            </artwork>
        </figure>         
      </t>    
      <t>
Bob now has all the information he needs to decide which streams to configure.
As such he now sends CONFIGURE 1. This requests the pair of switched captures that represent Alice's scene,
and he configures them with encoder ids "enc1" and "enc2".
      </t>
      <t>
Alice receives Bob's message CONFIGURE 1 but does not yet send the capture encodings specified,
because at this stage Bob hasn't negotiated the ability to receive these streams in SDP.
      </t>
      <t>
Bob now sends his SDP answer as part of 200 OK 2.
Alongside his original audio, video and CLUE m-lines he includes two active recvonly m-lines and a zeroed m-line for the third.
He adds their mid values to the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 100 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 11 12 100
   ...
   m=video 58722 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:10
   ...
   m=video 58724 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600   
   a=recvonly
   a=mid:11
   m=video 58726 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:12
   m=video 0 RTP/AVP 96                          
               ]]>
            </artwork>
         </figure>         
      </t>
      <t>
On receiving 200 OK 2 from Bob Alice is now able to send the two streams of video Bob requested -
this is illustrated as MEDIA 2.
      </t>
      <t>
The constraints of offer/answer meant that Bob could not include his encoder information as new m-lines in 200 OK 2.
As such Bob now sends INVITE 3 to generate a new offer. Along with all the streams from 200 OK 2
Bob also includes two new sendonly streams.
Each stream has a label corresponding to the encoding ids  in his ADVERTISEMENT 2 message.
He also adds their mid values to the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 100 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 11 12 13 14 100
   ...
   m=video 58722 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:10
   ...
   m=video 58724 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600   
   a=recvonly
   a=mid:11
   m=video 58726 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:12
   m=video 0 RTP/AVP 96
   m=video 58728 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=label:foo
   a=mid:13
   m=video 58730 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=label:bar
   a=mid:14
               ]]>
            </artwork>
         </figure>
      </t>
      <t>
Having received this Alice now has all the information she needs to send CONFIGURE 2.
She requests the two static captures from Bob, to be sent on encodings "foo" and "bar".
      </t>
      <t>
Bob receives Alice's message CONFIGURE 2 but does not yet send the capture encodings specified,
because Alice hasn't yet negotiated the ability to receive these streams in SDP.
      </t>      
      <t>
Alice now sends 200 OK 3, matching two recvonly m-lines to Bob's new sendonly lines.
She includes their mid values in the grouping attribute to show they are controlled by the CLUE channel.
A snippet of the SDP showing the grouping attribute and the video m-lines are shown below (mid 3 represents the CLUE channel):
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3 4 5 7 8
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2
   ...
   m=video 6004 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:4
   a=label:enc1
   m=video 6006 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016
   a=sendonly
   a=mid:5
   a=label:enc2
   m=video 0 RTP/AVP 96
   m=video 6010 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:7
   m=video 6012 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=recvonly
   a=mid:8
               ]]>
         </artwork>
      </figure>
      </t>
      <t>
Finally, on receiving 200 OK 3 Bob is now able to send the two streams of video Alice requested -
this is illustrated as MEDIA 3.
      </t>
      <t>
Both sides of the call are now sending multiple video streams with their sources defined via CLUE negotiation.
As the call progresses either side can send new Advertisement or Configure or new SDP negotiation to add,
remove or change what they have available or want to receive.
      </t>
   </section>     

   <section title="Example: A call between a CLUE and non-CLUE-capable endpoint" anchor="sec-nonclueexample">
      <t>
In this brief example Alice is a CLUE-capable endpoint making a call to Bob,
who is not CLUE-capable, i.e., it is not able to use the CLUE protocol.
      </t>
         <figure>
            <artwork>
               <![CDATA[

      +----------+                      +-----------+
      |   EP1    |                      |    EP2    |
      |          |                      |           |
      +----+-----+                      +-----+-----+
           |                                  |
           |                                  |
           | INVITE 1 (BASIC SDP+COMEDIA)     |
           |--------------------------------->|
           |                                  |
           |                                  |
           | 200 0K 1 (BASIC SDP+*NO*COMEDIA) |
           |<---------------------------------|
           |                                  |
           |                                  |
           | ACK 1                            |
           |--------------------------------->|
           |                                  |
           |                                  |
           |                                  |
           |<########### MEDIA 1 ############>|
           |   1 video A->B, 1 video B->A     |
           |<################################>|
           |                                  |
           |                                  |
           |                                  |
           |                                  |
           v                                  v	
               ]]>
            </artwork>
         </figure>
      <t>
In INVITE 1, Alice sends Bob a SIP INVITE including in the SDP body the basilar audio and video capabilities 
("BASIC SDP") and the information needed for opening a control channel to be used 
for CLUE protocol messages exchange, according to what is envisioned in the COMEDIA approach ("COMEDIA") 
for DTLS/SCTP channel <xref target="I-D.ietf-mmusic-sctp-sdp"/>.
A snippet of the SDP showing the grouping attribute and the video m-line are shown below (mid 3 represents the CLUE channel):  
         <figure>
            <artwork>
               <![CDATA[
   ...
   a=group:CLUE 3
   ...
   m=video 6002 RTP/AVP 96
   a=rtpmap:96 H264/90000
   a=fmtp:96 profile-level-id=42e016;max-mbps=108000;max-fs=3600
   a=sendrecv
   a=mid:2                           
               ]]>
            </artwork>
         </figure>         
      </t>
      <t>
Bob is not CLUE capable, and hence does not recognize the "CLUE" semantic for the grouping attribute,
not does he support the CLUE channel. He responds with an answer with audio and video,
but with the CLUE channel zeroed.
      </t>
      <t>
From the lack of the CLUE channel Alice understands that Bob does not support CLUE, or does not wish to use it.
Both sides are now able to send a single audio and video stream to each other.
Alice at this point begins to send her fallback video:
in this case likely a switched view from whichever camera shows the current loudest participant on her side.
      </t>
   </section>

   <section title="CLUE requirements on SDP O/A" anchor="sec.sdp_rqmts">
      <t>
The current proposal calls for a new "CLUE" semantic for the <xref target="RFC5888">SDP Grouping Framework</xref>.
      </t>
      <t>
Any other SDP extensions required to support CLUE signaling should also be specified here.
Then we will need to take action within MMUSIC to make those happen.
This section should be empty and removed before this document becomes an RFC.
      </t>
      <t>
NOTE: The RTP mapping document 
<xref target="I-D.even-clue-rtp-mapping"/>
is also likely to call for SDP extensions.
We will have to reconcile how to coordinate these two documents.
      </t>
   </section>

   <section title="SIP Signaling" anchor="sec.sip_signaling">
      <t>
(Placeholder) This may be unremarkable. If so we can drop it.
      </t>
   </section>

   <section title="Interoperation with Legacy SIP Devices" anchor="sec.interop">
      <t>
This may just describe how the degenerate form of the general mechanisms
work for legacy devices. Or it may describe special case handling that we
mandate as part of CLUE. Or it may just discuss non-normative things for implementors
should consider.
      </t>
   </section>

   <section title="CLUE over RTCWEB">
      <t>
We may want to rule this out of scope for now. 
But we should be thinking about this.
      </t>
   </section>

   <section title="Open Issues">
      <t>

Here are issues pertinent to signaling that need resolution.
Resolution will probably result in changes somewhere in this document,
but may also impact other documents.


        <list style='symbols'>
         <t>
While the preference is to multiplex multiple capture encodings over a single RTP session,
this will not always be desirable or possible. The factors that prevent multiplexing
may come from either the provider or the consumer. So the extent of multiplexing
must be negotiated. The decision about how to multiplex affects the number and
grouping of m-lines in the SDP. The endpoint of a CLUE session that sends an offer
needs to know the mapping of capture encodings to m-lines for both sides. 
<vspace blankLines='1'/>
AFAIK this issue hasn't yet been considered at all.
         </t>
         <t>
The current method for expressing encodings in SDP limits the parameters available
when describing H264 encoder capabilities to those defined in Table 6 in <xref target="RFC6184" />
         </t>
        </list>
      </t>
   </section>

   <section title="What else?">
      <t>
      </t>
   </section>

   <section title="Acknowledgements">
      <t>
The team focusing on this draft consists of:
Roni Even,
Rob Hansen,
Christer Holmberg,
Paul Kyzivat,
Simon Pietro-Romano,
Roberta Presta.
      </t>
      <t>
Christian Groves has contributed detailed comments and suggestions.
      </t>
      <t>
The author list should be updated as people contribute substantial text to this document.
      </t>
   </section>

   <section title="IANA Considerations">
      <t>

TBD

      </t>
   </section>
   <section title="Security Considerations">
      <t>

TBD

      </t>
   </section>

   <section title="Change History">
      <t><list style='hanging'>
         <t hangText="-03:">
         <list style='symbols'>
            <t>
Added a syntax section with an XML schema for CLUE messages.
This is a strawhorse, and is very incomplete, but it establishes
a template for doing this based on elements defined in the data model.
(Thanks to Roberta for help with this!)
            </t>
            <t>
Did some rewording to fit the syntax section in and reference it.
            </t>
            <t>
Did some relatively minor restructuring of the document to make
it flow better in a logical way.
            </t>
         </list>

         </t>
         <t hangText="-02:">

A bunch of revisions by pkyzivat: 
         <list style='symbols'>
            <t>
Moved roberta's call flows to a more appropriate place in the document.
            </t>
            <t>
New section on versioning.
            </t>
            <t>
New section on NAK.
            </t>
            <t>
A couple of possible alternatives for message acknowledgment.
            </t>
            <t>
Some discussion of when/how to signal changes in provider state.
            </t>
            <t>
Some discussion about the handling of transport errors.
            </t>
            <t>
Added a change history section.
            </t>
         </list>
These were developed by Lennard Xiao, Christian Groves and Paul, 
so added Lennard and Christian as authors.

         </t>
         <t hangText="-01:">

Updated by roberta to include some sample call flows.

         </t>
         <t hangText="-00:">

Initial version by pkyzivat. Established general outline for the document,
and specified a few things thought to represent wg consensus.

         </t>
      </list></t>
   </section>

</middle>

<back>
   <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.I-D.ietf-clue-framework"?>
      <?rfc include="reference.I-D.presta-clue-data-model-schema"?>
      <?rfc include="reference.I-D.ietf-mmusic-sctp-sdp"?>
      <?rfc include="reference.I-D.tuexen-tsvwg-sctp-dtls-encaps"?>
      <?rfc include="reference.RFC.4574"?>
      <?rfc include="reference.RFC.5888"?>
   </references>
   <references title="Informative References">
      <?rfc include="reference.RFC.4353"?>
      <?rfc include="reference.RFC.3264"?>
      <?rfc include="reference.RFC.6184"?>
      <?rfc include="reference.I-D.even-clue-sdp-clue-relation"?>
      <?rfc include="reference.I-D.even-clue-rtp-mapping"?>
      <?rfc include="reference.I-D.hansen-clue-sdp-interaction"?>
   </references>
</back>
</rfc>
