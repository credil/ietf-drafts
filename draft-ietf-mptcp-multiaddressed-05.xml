<?xml version="1.0" encoding="US-ASCII"?>
<!-- Convert to HTML and Text with xml2rfc: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC5533 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5533">
  <!ENTITY RFC5062 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5062">
  <!ENTITY RFC5061 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5061">
  <!ENTITY RFC4960 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4960">
  <!ENTITY RFC4634 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4634">
  <!ENTITY RFC4086 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086">
  <!ENTITY RFC3168 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3168">
  <!ENTITY RFC2581 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2581">
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119">
  <!ENTITY RFC2979 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2979">
  <!ENTITY RFC2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104">
  <!ENTITY RFC2018 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2018">
  <!ENTITY RFC1918 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1918">
  <!ENTITY RFC0793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793">
  <!ENTITY RFC1323 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1323">
  <!ENTITY RFC1122 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1122">
  <!ENTITY RFC3135 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3135">
  <!ENTITY RFC3022 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3022">
  <!ENTITY RFC6181 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6181">
  <!ENTITY RFC6182 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6182">
  <!ENTITY RFC6356 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6356">
  <!ENTITY MPAPI SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-mptcp-api-03">
  <!ENTITY TCPSEC SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tcpm-tcp-security-02">
  <!ENTITY EYEBALLS SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-v6ops-happy-eyeballs-07">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="no"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="exp" docName="draft-ietf-mptcp-multiaddressed-05" ipr="trust200902">
  <front>
    <title abbrev="Multipath TCP">TCP Extensions for Multipath Operation with Multiple Addresses</title>

    <author fullname="Alan Ford" initials="A." surname="Ford">
<!--      <organization>Roke Manor Research</organization> -->
      <address>
<!--        <postal>
          <street>Old Salisbury Lane</street>
          <city>Romsey</city>
          <region>Hampshire</region>
          <code>SO51 0ZN</code>
          <country>UK</country>
        </postal>
        <phone>+44 1794 833 465</phone>
        <email>alan.ford@roke.co.uk</email> -->
        <email>alan.ford@gmail.com</email>
      </address>
    </author>

    <author fullname="Costin Raiciu" initials="C." surname="Raiciu">
      <organization>University Politehnica of Bucharest</organization>
      <address>
        <postal>
          <street>Splaiul Independentei 313</street>
          <city>Bucharest</city>
          <country>Romania</country>
        </postal>
        <email>costin.raiciu@cs.pub.ro</email>
      </address>
    </author>

    <author fullname="Mark Handley" initials="M." surname="Handley">
      <organization>University College London</organization>
      <address>
        <postal>
          <street>Gower Street</street>
          <city>London</city>
          <code>WC1E 6BT</code>
          <country>UK</country>
        </postal>
        <email>m.handley@cs.ucl.ac.uk</email>
      </address>
    </author>

    <author fullname="Olivier Bonaventure" initials="O." surname="Bonaventure">
      <organization>Universit&eacute; catholique de Louvain</organization>
      <address>
        <postal>
          <street>Pl. Ste Barbe, 2</street>
          <code>1348</code>
          <city>Louvain-la-Neuve</city>
          <country>Belgium</country>
        </postal>
        <email>olivier.bonaventure@uclouvain.be</email>
      </address>
    </author>

    <date year="2012" />

    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>multipath tcp</keyword>
    <abstract>
      <t>TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network, and thus improve user experience through higher throughput and improved resilience to network failure.</t>

      <t>Multipath TCP provides the ability to simultaneously use multiple paths between peers. This document presents a set of extensions to traditional TCP to support multipath operation. The protocol offers the same type of service to applications as TCP (i.e. reliable bytestream), and provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths.
</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" anchor="sec_intro">
      <t>MPTCP is a set of extensions to regular TCP <xref target="RFC0793"/> to provide a Multipath TCP <xref target="RFC6182"/> service, which enables a transport connection to operate across multiple paths
simultaneously. This document presents the protocol changes required to add multipath capability to TCP; specifically, those for signaling and setting up multiple paths ("subflows"), managing these subflows, reassembly of data, and termination of sessions.
      This is not the only information required to create a Multipath TCP implementation, however. This document is complemented by three others:
        <list style="symbols">
          <t>Architecture <xref target="RFC6182"/>, which explains the motivations behind Multipath TCP, contains a discussion of high-level design decisions on which this design is based, and an explanation of a functional separation through which an extensible MPTCP implementation can be developed.</t>
          <t>Congestion Control <xref target="RFC6356"/>, presenting a safe congestion control algorithm for coupling the behaviour of the multiple paths in order to "do no harm" to other network users.</t>
          <t>Application Considerations <xref target="I-D.ietf-mptcp-api"/>, discussing what impact MPTCP will have on applications, what applications will want to do with MPTCP, and as a consequence of these factors, what API extensions an MPTCP implementation should present.</t>
        </list>
      </t>
      
      <section title="Design Assumptions" anchor="sec_assum">
        <t>In order to limit the potentially huge design space, the authors imposed two key constraints on the multipath TCP design presented in this document:
          <list style="symbols">
            <t>It must be backwards-compatible with current, regular TCP, to increase its chances of deployment</t>
            <t>It can be assumed that one or both hosts are multihomed and multiaddressed</t>
          </list>
        </t>
        <t>To simplify the design we assume that the presence of multiple addresses at a host is sufficient to indicate the existence of multiple paths. These paths need not be entirely disjoint: they may share one or many routers between them. Even in such a situation making use of multiple paths is beneficial, improving resource utilisation and resilience to a subset of node failures. The congestion control algorithms as discussed in <xref target="RFC6356"/> ensure this does not act detrimentally.</t>
        <t>There are three aspects to the backwards-compatibility listed above (discussed in more detail in <xref target="RFC6182"/>):
          <list style="hanging">
            <t hangText="External Constraints:"> The protocol must function through the vast majority of existing 
middleboxes such as NATs, firewalls and proxies, and as such must resemble existing TCP as far as possible on the 
wire. Furthermore, the protocol must not assume the segments it sends on the wire arrive unmodified at the destination:
they may be split or coalesced; TCP options may be removed or duplicated. </t>
            <t hangText="Application Constraints:"> The protocol must be usable with no change to existing applications that use the standard TCP API (although it is reasonable that not all features would be available to such legacy applications). Furthermore, the protocol must provide the same service model as regular TCP to the application.</t>
            <t hangText="Fall-back:"> The protocol should be able to fall back to standard TCP with no interference from the user, to be able to communicate with legacy hosts.</t>
          </list>
        </t>
        <t>Further discussion of the design constraints and associated design decisions are given in the MPTCP Architecture document <xref target="RFC6182"/>.</t>
      </section>

      <section title="Multipath TCP in the Networking Stack" anchor="sec_layers">
        <t>MPTCP operates at the transport layer and aims to be transparent to both higher and lower 
layers. It is a set of additional features on top of standard TCP; <xref target="fig_arch" /> illustrates 
this layering. MPTCP is designed to be usable by legacy applications with no changes; detailed discussion 
of its interactions with applications is given in <xref target="I-D.ietf-mptcp-api"/>.</t>

        <figure align="center" anchor="fig_arch" title="Comparison of Standard TCP and MPTCP Protocol Stacks">
          <artwork align="left"><![CDATA[
                                +-------------------------------+
                                |           Application         |
   +---------------+            +-------------------------------+
   |  Application  |            |             MPTCP             |
   +---------------+            + - - - - - - - + - - - - - - - +
   |      TCP      |            | Subflow (TCP) | Subflow (TCP) |
   +---------------+            +-------------------------------+
   |      IP       |            |       IP      |      IP       |
   +---------------+            +-------------------------------+
            ]]></artwork>
        </figure>
      </section>

      <section title="Terminology">
        <t>
        <list style="hanging">
          <t hangText="Path:"> A sequence of links between a sender and a receiver, defined in this context by a source and destination address pair.</t>
          <t hangText="Subflow:"> A flow of TCP segments operating over an individual path, which forms part of a larger MPTCP connection. A subflow is started and terminated similarly to a regular TCP connection.</t>
          <t hangText="(MPTCP) Connection:"> A set of one or more subflows, over which an application can communicate between two hosts. There is a one-to-one mapping between a connection and an application socket.</t>
          <t hangText="Data-level:"> The payload data is nominally transferred over a connection, which in turn is transported over subflows.  Thus the term "data-level" is synonymous with "connection level", in contrast to "subflow-level" which refers to properties of an individual subflow.</t>
          <t hangText="Token:"> A locally unique identifier given to a multipath connection by a host. May also be referred to as a "Connection ID".</t>
          <t hangText="Host:"> A end host operating an MPTCP implementation, and either initiating or accepting an MPTCP connection.</t>
          <!-- <t hangText="Subflow ID:"> A unique identifier given by an endpoint to a subflow within a multipath connection.</t> -->
        </list>
        </t>
      </section>

      <section title="MPTCP Concept" anchor="sec_operation">
        <t>This section provides a high-level summary of normal 
operation of MPTCP, and is illustrated by the scenario shown in 
<xref target="fig_scenario"/>. A detailed description of operation is given in <xref target="sec_protocol"/>.
          <list style="symbols">
            <t>To a non-MPTCP-aware application, MPTCP will behave the same as normal TCP. Extended APIs could provide 
additional control to MPTCP-aware applications <xref target="I-D.ietf-mptcp-api"/>. 
An application begins by opening a TCP socket in the normal way.
MPTCP signaling and operation is handled by the MPTCP implementation.
</t>
            <t>An MPTCP connection begins similarly to a regular TCP connection. This is 
illustrated in <xref target="fig_scenario"/> where a TCP connection is established between 
addresses A1 and B1 on Hosts A and B respectively.</t>
            <t>If extra paths are available, additional TCP sessions (termed "subflows") 
are created on these paths, and are combined with the existing session, which continues 
to appear as a single connection to the applications at both ends. The creation of the 
additional TCP session is illustrated between Address A2 on Host A and Address B1 on 
Host B.</t>
            <t>MPTCP identifies multiple paths by the presence of multiple addresses 
at hosts. Combinations of these multiple addresses equate to the additional paths. 
In the example, other potential paths that could be set up are A1&lt;-&gt;B2 and A2&lt;-&gt;B2. 
Although this additional session is shown as being initiated from A2, it could equally have 
been initiated from B1.</t>
            <t>The discovery and setup of additional subflows
will be achieved through a path management method; this document describes a mechanism 
by which a host can initiate new subflows by using its own additional addresses, or by 
signaling its available addresses to the other host.</t>
            <t>MPTCP adds connection-level sequence numbers to allow the reassembly of 
segments arriving on multiple subflows with differing network delays. </t>
            <t>Subflows are terminated as regular TCP connections, with a four way FIN
handshake. The MPTCP connection is terminated by a connection-level FIN.</t>
          </list>
        </t>
          <?rfc needLines='17'?>
          <figure align="center" anchor="fig_scenario" title="Example MPTCP Usage Scenario">
            <artwork align="left"><![CDATA[
            Host A                               Host B
   ------------------------             ------------------------
   Address A1    Address A2             Address B1    Address B2
   ----------    ----------             ----------    ----------
       |             |                      |             |
       |     (initial connection setup)     |             |
       |----------------------------------->|             |
       |<-----------------------------------|             |
       |             |                      |             | 
       |            (additional subflow setup)            |
       |             |--------------------->|             |
       |             |<---------------------|             |
       |             |                      |             |
       |             |                      |             |
              ]]></artwork>
          </figure>
      </section>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>

    <section title="Operation Overview" anchor="sec_overview">
      <t>This section presents a single description of standard MPTCP operation, with reference to the protocol operation. Considerable reference is made to symbolic names of MPTCP options throughout this section - these are subtypes of the IANA-assigned MPTCP option (see <xref target="IANA"/>), and their formats are defined in the detailed protocol specification which follows in <xref target="sec_protocol"/>.</t>

<t>A Multipath TCP connection provides a bidirectionnal bytestream between two hosts communicating hosts like normal TCP and thus does not require any change to the applications. However, Multipath TCP enables the hosts to use different paths with different IP addresses to exchange packets belonging to the MPTCP connection. A Multipath TCP connection appears like a normal TCP connection to an application. However, to the network layer each MPTCP subflows looks like a regular TCP flow whose segments carry a new TCP option type. Multipath TCP manages the creation, removal and utilization of these subflows to send data. The number of subflows that are managed within a Multipath TCP connection is not fixed and it can fluctuate during the lifetime of the Multipath TCP connection.</t>

<t>All MPTCP operations are signaled with a TCP option - a single numerical type for MPTCP, with "sub-types" for each MPTCP message. What follows is a summary of the purpose and rationale of these messages.</t>

<section title="Initiating an MPTCP connection">
<t>This is the same signaling as for initiating a normal TCP connection, but the SYN, SYN/ACK and ACK packets also carry the MP_CAPABLE option. This is variable-length and serves multiple purposes. Firstly, it verifies whether the remote host supports Multipath TCP; and secondly, this option allows the hosts to exchange some information that is used to authenticate the establishment of additional subflows. Further details are given in <xref target="sec_init"/>.</t>

<figure><artwork align="left"><![CDATA[
   Host-A                                  Host-B
   ------                                  ------
   MP_CAPABLE            ->
   [A's key, flags]
                         <-                MP_CAPABLE
                                           [B's key, flags]
   ACK MP_CAPABLE        ->
   [A's key, B's key, flags]
]]></artwork></figure>
</section>

<section title="Associating a new subflow with an existing MPTCP connection">
<t>The exchange of keys in the MP_CAPABLE handshake provides material that can be used to authenticate the endpoints when new subflows will be setup. 
Additional subflows begin in the same way as initiating a normal TCP connection, but the SYN, SYN/ACK and ACK packets also carry the MP_JOIN option. </t>

<t>Host-A initiates a new subflow between one of its addresses and one of Host-B's addresses. The token - generated from the key - is used to identify which MPTCP connection it is joining, and the MAC is used for authentication. MP_JOIN also contains flags and an Address ID that can be used to refer to the source address without the sender needing to know if it has been changed by a NAT. Further details in <xref target="sec_join"/>.</t>

<figure><artwork align="left"><![CDATA[
   Host-A                                  Host-B
   ------                                  ------
   MP_JOIN               ->
   [B's token, A's nonce, 
    A's Address ID, flags]
                         <-                MP_JOIN
                                           [B's MAC, B's nonce,
                                            B's Address ID, flags]
   ACK MP_JOIN           ->
   [A's MAC]
]]></artwork></figure>
</section>

<section title="Informing the other Host about another potential address">
<t>The set of IP addresses associated to a multihomed host may change during the lifetime of an MPTCP connection. MPTCP supports the addition and removal of addresses on a host both implicitly and explicitly. If Host-A has established a subflow starting at address IP#-A1 and wants to open a second subflow starting at address IP#-A2, it simply initiates the establishment of the subflow as explained above. The remote host will then be implictly informed about the new address.</t>

<t>In some circumstances, a host may want to advertise to the remote host the availability of an address without establishing a new subflow, for example when a NAT prevents setup in one direction.  In the example below, Host-A informs Host-B about its alternative IP address (IP#-A2). Host-B may later send an MP_JOIN to this new address. Due to the presence of middleboxes that may translate IP addresses, this option uses an address identifier to unambiguously identify an address on a host. Further details in <xref target="sec_add_address"/>.</t>

<figure><artwork align="left"><![CDATA[
   Host-A                                 Host-B
   ------                                 ------
   ADD_ADDR                  ->
   [IP#-A2, 
    IP#-A2's Address ID]
]]></artwork></figure>

<t>There is a corresponding signal for address removal, making use of the Address ID that is signalled in the add address handshake. Further details in <xref target="sec_remove_addr"/>.</t>

<figure><artwork align="left"><![CDATA[
   Host-A                                 Host-B
   ------                                 ------
   REMOVE_ADDR               ->
   [IP#-A2's Address ID]
]]></artwork></figure>
</section>

<section title="Data transfer using MPTCP">
<t>To ensure reliable, in-order delivery of data over subflows that may appear and disappear at anytime, MPTCP uses a 64-bit Data Sequence Number (DSN) to number all data sent over the MPTCP connection. Each subflow has its own 32 bits sequence number space and a MPTCP option allows to map the subflow sequence space to the data sequence space. In this way, data can be retransmitted on different subflows (mapped to the same DSN) in the event of failure.</t>

<t>The "Data Sequence Signal" option which carries this mapping can also carry a connection-level acknowledgement (the "Data ACK") for the received DSN.</t>

<t>With MPTCP, all subflows share the same receive buffer and advertise the same receive window. There are two levels of acknowledgement in MPTCP. Regular TCP acknowledgements are used on each subflow to acknowledge the reception of the segments sent over the subflow independently of their DSN. In addition, there are connection-level acknowledgements for the data sequence space. These acknowledgements track the advancement of the bytestream and slide the receiving window.</t>

<t>Further details are in <xref target="sec_generalop"/>.</t>

<figure><artwork align="left"><![CDATA[
   Host-A                                 Host-B
   ------                                 ------
   DATA_SEQUENCE_SIGNAL      ->
   [Data Sequence Mapping]
   [Data ACK]
   [Checksum]
]]></artwork></figure>
</section>

<section title="Requesting a change in a path's priority">
<t>Hosts can indicate at initial subflow setup whether they wish the subflow to be used as a regular or backup path - a backup path being only used if there are no regular paths available. During a connection, Host-A can request a change in the priority of a subflow through the MP_PRIO signal to Host-B. Further details in <xref target="sec_policy"/>.</t>

<figure><artwork align="left"><![CDATA[
   Host-A                                 Host-B
   ------                                 ------
   MP_PRIO                   ->                 
]]></artwork></figure>
</section>

<section title="Closing an MPTCP connection">
<t>When Host-A wants to inform Host-B that it has no more data to send, it signals this "Data FIN" as part of the Data Sequence Signal (see above). It has the same semantics and behaviour as a regular TCP FIN, but at the connection level. Once all the data on the MPTCP connection has been successfully received, then this message is acknowledged at the connection level with a DATA ACK. Further details in <xref target="sec_close"/>.</t>
                       
<figure><artwork align="left"><![CDATA[
   Host-A                                 Host-B
   ------                                 ------
   DATA_SEQUENCE_SIGNAL      ->
   [Data FIN]

                             <-           (MPTCP DATA ACK)
]]></artwork></figure>
</section>

<section title="Notable features">
<t>It is worth highlighting that MPTCP's signaling has been designed with several key requirements in mind:

<list style="symbols">
<t>To cope with NATs on the path, addresses are referred to by Address IDs, in case the IP packet's source 
address gets changed by a NAT. Setting up a new TCP flow is not possible if the passive opener is behind a NAT; 
to allow subflows to be created when either end is behind a NAT, MPTCP uses the MP-ADD-ADDR message. </t>

<t>MPTCP falls back to ordinary TCP if MPTCP operation is not possible. For example if one host is not MPTCP capable, or if a middlebox alters the payload.</t>

<t>To meet the threats identified in <xref target="RFC6181"/>, the following steps are taken: keys are sent in the clear in the MP_CAPABLE messages; MP_JOIN messages are secured with HMAC-SHA1 using those keys; and standard TCP validity checks are made on the other messages ( ensuring sequence numbers are in-window).</t>
</list></t>
</section>
    </section>

    <section title="MPTCP Protocol" anchor="sec_protocol">
      <t>This section describes the operation of the MPTCP protocol, and is subdivided into sections for each key part of the protocol operation.</t>
      <t>All MPTCP operations are signalled using optional TCP header fields. A single TCP option number ("Kind") will be assigned by IANA for MPTCP (see <xref target="IANA"/>), and then individual messages will be determined by a "sub-type", the values of which will also be stored in an IANA registry (and are also listed in <xref target="IANA"/>).</t>
      <t>Throughout this document, when reference is made to an MPTCP option by symbolic name, such as "MP_CAPABLE", this refers to a TCP option with the single MPTCP option type, and with the sub-type value of the symbolic name as defined in <xref target="IANA"/>. This sub-type is a four-bit field - the first four bits of the option payload, as shown in <xref target="fig_option"/>. The MPTCP messages are defined in the following sections.</t>

      <?rfc needLines='8'?>
      <figure align="center" anchor="fig_option" title="MPTCP option format">
        <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-----------------------+
   |     Kind      |    Length     |Subtype|                       |
   +---------------+---------------+-------+                       |
   |                     Subtype-specific data                     |
   |                       (variable length)                       |
   +---------------------------------------------------------------+
          ]]></artwork>
      </figure>

      <t>Those MPTCP options associated with subflow initiation must be included on packets with the SYN flag set. Additionally, there is one MPTCP option for signaling metadata to ensure segmented data can be recombined for delivery to the application.</t>
      <t>The remaining options, however, are signals that do not need to be on a specific packet, such as those for signaling additional addresses. Whilst an implementation may desire to send MPTCP options as soon as possible, it may not be possible to combine all desired options (both those for MPTCP and for regular TCP, such as SACK <xref target="RFC2018"/>) on a single packet. Therefore, an implementation may choose to send duplicate ACKs containing the additional signaling information. This changes the semantics of a duplicate ACK, these are usually only sent as a signal of a lost segment <xref target="RFC2581"/> in regular TCP. Therefore, an MPTCP implementation receiving a duplicate ACK which contains an MPTCP option MUST NOT treat it as a signal of congestion. Additionally, an MPTCP implementation SHOULD NOT send more than two duplicate ACKs in a row for signaling purposes, so as to ensure no middleboxes misinterpret this as a sign of congestion.</t>
      <t>Furthermore, standard TCP validity checks (such as ensuring the Sequence Number and Acknowledgement Number are within window) MUST be undertaken before processing any MPTCP signals, as described in <xref target="I-D.ietf-tcpm-tcp-security"/>.</t>
      
      <section title="Connection Initiation" anchor="sec_init">
        <t>Connection Initiation begins with a SYN, SYN/ACK, ACK exchange
        on a single path. Each packet
        contains the Multipath Capable (MP_CAPABLE) TCP option
        (<xref target="tcpm_capable"/>). This option declares its
        sender is capable of performing multipath TCP and wishes to do
        so on this particular connection.</t>

        <t>This option is used to declare the sender's 64 bit key, which is used to authenticate the addition of future subflows. This is the only time the key will be sent in clear on the wire; all future subflows will identify the connection using a 32 bit "token". This token is a cryptographic hash of this key. The token will be a truncated (most significant 32 bits) SHA-1 hash <xref target="RFC4634"/>. A different, 64 bit truncation (the least significant 64 bits) of the hash of the key will be used as the Initial Data Sequence Number.</t>
        
        <t>This key is generated by its sender and has local meaning only, and its method of generation is implementation-specific. The key MUST be hard to guess, and it MUST be unique for the sending host at any one time. Recommendations for generating random keys are given in <xref target="RFC4086"/>. Connections will be indexed at each host by the token (the truncated SHA-1 hash of the key). Therefore, an implementation will require a mapping from each token to the corresponding connection, and in turn to the keys for the connection.</t>

        <t>There is a very small risk that two different keys will hash to the same token. An implementation SHOULD check its list of connection tokens to ensure there is not a collision before sending its key in the SYN/ACK. This would, however, be costly for a server with thousands of connections. The subflow handshake mechanism (<xref target="sec_join"/>) will ensure that new subflows only join the correct connection, however, so in the worst case if there was a token collision, the second connection cannot support multiple subflows, but will otherwise provide a regular TCP service.</t>

        <t>The MP_CAPABLE option is carried on the SYN, SYN/ACK, and ACK packets that start the first subflow of an MPTCP connection. The data carried by each packet is as follows, where A = initiator and B = listener.
          <list style="symbols">
            <t>SYN (A-&gt;B): A's Key.</t>
            <t>SYN/ACK (B-&gt;A): B's Key.</t>
            <t>ACK (A-&gt;B): A's Key followed by B's Key.</t>
          </list>
        The contents of the option is determined by the SYN and ACK flags of the packet, verified by the option's length field. For the diagram shown in <xref target="tcpm_capable"/>, "sender" and "receiver" refer to the sender or receiver of the TCP packet (which can be either host). If the SYN flag is set, a single key is included; if only an ACK flag is set, both keys are present.</t>

        <t>B's Key is echoed in the ACK in order to allow the listener (host B) to act statelessly until the TCP connection reaches the ESTABLISHED state. If the listener acts in this way, however, it MUST generate its key in a verifiable fashion, allowing it to verify that it generated the key when it is echoed in the ACK.</t>

        <t>As TCP when using SYN cookies, the MPTCP handshake would be vulnerable if the third ACK (containing the MP_CAPABLE option) 
is lost. In order to ensure reliable delivery of the third ACK, a server MUST respond with an ACK segment on receipt of this, which may contain data, or will be a pure ACK if it does not have any data to send immediately. If the initiator does not receive this ACK within an RTO, it MUST re-send the ACK containing MP_CAPABLE. </t>
	<t>In effect, an MPTCP connection is in a "PRE_ESTABLISHED" state while awaiting this ACK, and only upon receipt of the ACK will it move to the ESTABLISHED state. When in the PRE_ESTABLISHED state, a host can send data, but MUST NOT attempt to create additional subflows. Only in the ESTABLISHED state does it know that MPTCP options are correctly passed in both directions on the path. If MPTCP options fail to be passed, an implementation SHOULD undertake fallback as documented in <xref target="sec_fallback"/>.</t>
        
        <t>The first four bits of the first octet in the MP_CAPABLE option (<xref target="tcpm_capable"/>) define the MPTCP option subtype (see <xref target="IANA"/>; for MP_CAPABLE, this is 0), and the remaining four bits of this octet specifies the MPTCP version in use (for this specification, this is 0).</t>
       
        <t>The second octet is reserved for flags. The leftmost bit - labeled C - indicates "Checksum required", and SHOULD be set to 1 unless specifically overridden (for example, if the system administrator has decided that checksums are not required - see <xref target="sec_generalop"/> for more discussion). The remaining bits are used for crypto algorithm negotiation. Currently only the rightmost bit - labeled S - is assigned, and indicates the use of HMAC-SHA1 (as defined in <xref target="sec_join"/>). An implementation that only supports this method MUST set this bit to 1 and all other currently reserved bits to zero. If none of these flags are set, the MP_CAPABLE option MUST be treated as invalid and ignored (i.e. it must be treated as a regular TCP handshake).</t>

        <t>These bits negotiate capabilities in similar ways. For the 'C' bit, if either host requires the use of checksums, checksums MUST be used. In other words, the only way for checksums not to be used is if both hosts in their SYNs set C=0. This decision is confirmed by the setting of the 'C' bit in the third packet (the ACK) of the handshake. For example, if the initiator sets C=0 in the SYN, but the responder sets C=1 in the SYN/ACK, checksums must be used and the initiator will set C=1 in the ACK. The decision whether to use checksums will be stored by an implementation in a per-connection binary state variable.</t>

        <t>For crypto negotiation, the responder has the choice. The initiator creates a proposal setting a bit for each algorithm it supports to 1 (in this version of the specification, there is only one proposal, so S will be always set to 1). The responder responds with only one bit set - this is the chosen algorithm. The rationale for this behaviour is that the responder will typically be a server with potentially many thousands of connections, so it may wish to choose an algorithm with minimal computational complexity, depending on the load. If a responder does not support (or does not want to support) any of the initiator's proposals, it can respond without an MP_CAPABLE option, thus forcing a fall-back to regular TCP.</t>

        <t>The MP_CAPABLE option is only used in the first subflow of a connection, in order to identify the connection; all following subflows will use the "Join" option (see <xref target="sec_join"/>) to join the existing connection.</t>
        <?rfc needLines='10'?>
        <figure align="center" anchor="tcpm_capable" title="Multipath Capable (MP_CAPABLE) option">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-------+-+-----------+-+
   |     Kind      |    Length     |Subtype|Version|C| (reservd) |S|
   +---------------+---------------+-------+-------+-+-----------+-+
   |                   Option Sender's Key (64 bits)               |
   |                                                               |
   |                                                               |
   +---------------------------------------------------------------+
   |                  Option Receiver's Key (64 bits)              |
   |                     (if option Length == 20)                  |
   |                                                               |
   +---------------------------------------------------------------+

            ]]></artwork>
        </figure>
        <t>If a SYN contains an MP_CAPABLE option but the
        SYN/ACK does not, it is assumed that the passive opener is not
        multipath capable and thus the MPTCP session MUST operate as
        a regular, single-path TCP. If a SYN does not contain a
        MP_CAPABLE option, the SYN/ACK MUST NOT contain one
        in response. If the third packet (the ACK) does not contain
        the MP_CAPABLE option, then the session MUST fall back to
        operating as a regular, single-path TCP. This is to maintain
        compatibility with middleboxes on the path that drop some 
        or all TCP options.</t>

        <!-- draft-wing-v6ops-happy-eyeballs-ipv6-01 may help here -->

        <t>If the SYN packets are unacknowledged, it is up to local
        policy to decide how to respond. It is expected that a sender
        will eventually fall back to single-path TCP (i.e. without the
        MP_CAPABLE Option) in order to work around middleboxes that
        may drop packets with unknown options; however, the number of
        multipath-capable attempts that are made first will be up to
        local policy.  
        It is possible that MPTCP and non-MPTCP SYNs could get re-ordered
        in the network. Therefore, the final state is inferred from the
        presence or absence of the MP_CAPABLE option in the third packet
        of the TCP handshake.  If this option is not present, the 
        connection should fall back to regular TCP, as documented in 
        <xref target="sec_fallback"/>.</t>

        <t>The initial Data Sequence Number (IDSN) is generated as a hash 
        from the Key, in the same way as the token, i.e. IDSN-A = Hash(Key-A)
        and IDSN-B = Hash(Key-B). The Hash mechanism here provides the
        least significant 64 bits of the SHA-1 hash of the key. The SYN with 
        MP_CAPABLE occupies the first octet of Data Sequence Space, although
        this does not need to be acknowledged at the connection level until
        the first data is sent (see <xref target="sec_generalop"/>).</t>

        <!-- Need to think about: what to do if two packets turn up
        from the same source address, to different dest addresses?
        Or indeed, from different source addresses to the same dest,
        but is the same token and in reality, same host. What do we do? -->
    
      </section>

      <section title="Starting a New Subflow" anchor="sec_join">
        <t>Once an MPTCP connection has begun with the MP_CAPABLE
        exchange, further subflows can be added to the connection.
        Hosts have knowledge of their own address(es), and can
        become aware of the other host's addresses through
        signaling exchanges as described in
        <xref target="sec_pm"/>. Using this knowledge, a host
        can initiate a new subflow over a currently unused pair of
        addresses. It is permitted for either host in a connection
        to initiate the creation of a new subflow, but it is expected
        that this will normally be the original connection initiator
        (see <xref target="heuristics"/> for heuristics).</t>

        <t>A new subflow is started as a normal TCP SYN/ACK
        exchange. The Join Connection (MP_JOIN) TCP option
        is used to identify the connection to be joined by the new subflow.  
        It uses keying material that was exchanged in the initial MP_CAPABLE
        handshake (<xref target="sec_init"/>), and that handshake also
        negotiates the crypto algorithm in use for the MP_JOIN handshake.</t>

        <t>This section specifies the behaviour of MP_JOIN using the HMAC-SHA1 
        algorithm. An MP_JOIN option is present in the SYN, SYN/ACK 
        and ACK of the three-way handshake, although in each case with a 
        different format.</t>

        <t>In the first MP_JOIN on the SYN packet, illustrated in 
        <xref target="tcpm_join"/>, the initiator sends a token, random
        number, and address ID.</t>

        <t>The token is used to identify the MPTCP connection and is a
        cryptographic hash of the receiver's key, as exchanged 
        in the initial MP_CAPABLE handshake (<xref target="sec_init"/>).  
        The tokens presented in this 
        option are generated by the SHA-1 <xref target="RFC4634"/> algorithm, 
        truncated to the most significant 32 bits.  The token
        included in the MP_JOIN option is the token that the receiver
        of the packet uses to identify this connection, i.e. Host A 
        will send Token-B (which is generated from Key-B).</t>

        <t>The MP_JOIN SYN not only sends the
        token (which is static for a connection) but also Random 
        Numbers (nonces) that are used to prevent replay
        attacks on the authentication method.</t>
        
        <t>The MP_JOIN option includes an "Address ID".  This is an
        identifier that only has significance within a single connection,
        where it identifies the source address of this packet, even if
        the address itself has been changed in transit by a middlebox. 
        This allows address 
        removal without needing to know what the source address at the 
        receiver is, thus this allows address removal through NATs.
        The sender can signal this to the receiver via 
        the REMOVE_ADDR option (<xref target="sec_remove_addr"/>).       
        It also allows correlation between new subflow setup attempts          
        and address signaling (<xref target="sec_add_address"/>),          
        to prevent setting up duplicate subflows on the same path.</t>

        <t>The Address IDs of the subflow used in the initial SYN
        exchange of the first subflow in the connection are implicit,
        and have the value zero. A host MUST store the Address IDs 
        associated with all established subflows.</t>
        
        <t>The MP_JOIN option on SYNs also includes 4 bits of flags, 3 of which are currently reserved and MUST be set to zero by the sender. The final bit, labelled 'B', indicates whether the sender of this option wishes this subflow to be used as a backup path (B=1) in the event of failure of other paths, or whether it wants it to be used as part of the connection immediately. By setting B=1, the sender of the option is requesting the other host to only send data on this subflow if there are no available subflows where B=0. Subflow policy is discussed in more detail in <xref target="sec_policy"/>.</t>

        <?rfc needLines='10'?>
        <figure align="center" anchor="tcpm_join" title="Join Connection (MP_JOIN) option (for initial SYN)">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-----+-+---------------+
   |     Kind      |  Length = 12  |Subtype|     |B|   Address ID  |
   +---------------+---------------+-------+-----+-+---------------+
   |                   Receiver's Token (32 bits)                  |
   +---------------------------------------------------------------+
   |                Sender's Random Number (32 bits)               |
   +---------------------------------------------------------------+
            ]]></artwork>
        </figure>

        <t>When receiving a SYN with an MP_JOIN option that contains
        a valid token for an existing MPTCP connection, the recipient
        SHOULD respond with a SYN/ACK also containing an MP_JOIN
        option containing a random number and a truncated (leftmost 64 bits) 
        Message Authentication Code (MAC). This 
        version of the option is shown in <xref target="tcpm_join2"/>.
        If the token is unknown, or the host wants to refuse subflow
        establishment (for example, due to a limit on the number of
        subflows it will permit), the receiver will send back an RST, 
        analogous to an unknown port in TCP. Although cryptographic
        calculations are required in the SYN/ACK, it is felt that the
        32 bit token gives sufficient protection against blind state 
        exhaustion attacks and therefore there is no need to provide
        mechanisms to allow a responder to operate statelessly at the 
        MP_JOIN stage.</t>

        <t>An MAC is sent by both hosts - by the initiator (Host A)
        in the third packet (the ACK) and by the responder (Host B) in
        the second packet (the SYN/ACK). This is to allow both hosts to
        have exchanged random data to be used as the message before
        generating the MAC. In both cases, the MAC algorithm is HMAC as 
        defined in <xref target="RFC2104"/>, using the SHA-1 hash 
        algorithm <xref target="RFC4634"/> (thus generating a 160-bit / 20 
        octet HMAC). Due to option space limitations, the MAC included in 
        the SYN/ACK is truncated to the leftmost 64 bits, but this is 
        acceptable since while in an attacker-initiated attack, the 
        attacker can retry many times; if the attacker is the responder, 
        he only has one chance to get the MAC correct.</t>
        
        <t>The initiator's
        authentication information is sent in its first ACK, and is
        shown in <xref target="tcpm_join3"/>. The same reliability
        algorithm for this packet as for the MP_CAPABLE ACK is
        applied: receipt of this packet MUST trigger an ACK in 
        response, and the packet MUST be retransmitted if this
        ACK is not received. In other words, sending the ACK/MP_JOIN 
        packet places the subflow in the PRE_ESTABLISHED state, and it 
        moves to the ESTABLISHED state only on receipt of an ACK from 
        the receiver. The reserved bits in this option MUST be set to 
        zero by the sender.</t>

        <t>The key for the MAC algorithm, in the case of the message transmitted by Host A, will be Key-A followed by Key-B, and in the case of Host B, Key-B followed by Key-A. These are the keys that were exchanged in the original MP_CAPABLE handshake. The message in each case is the concatenations of Random Number for each host (denoted by R): for Host A, R-A followed by R-B; and for Host B, R-B followed by R-A.</t>

        <?rfc needLines='10'?>
        <figure align="center" anchor="tcpm_join2" title="Join Connection (MP_JOIN) option (for responding SYN/ACK)">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-----+-+---------------+
   |     Kind      |  Length = 16  |Subtype|     |B|   Address ID  |
   +---------------+---------------+-------+-----+-+---------------+
   |                                                               |
   |                Sender's Truncated MAC (64 bits)               |
   |                                                               |
   +---------------------------------------------------------------+
   |                Sender's Random Number (32 bits)               |
   +---------------------------------------------------------------+
            ]]></artwork>
        </figure>

        <?rfc needLines='10'?>
        <figure align="center" anchor="tcpm_join3" title="Join Connection (MP_JOIN) option (for third ACK)">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-----------------------+
   |     Kind      |  Length = 24  |Subtype|      (reserved)       |
   +---------------+---------------+-------+-----------------------+
   |                                                               |
   |                                                               |
   |                 Sender's MAC (160 bits SHA-1)                 |
   |                                                               |
   |                                                               |
   +---------------------------------------------------------------+
            ]]></artwork>
        </figure>

        
        <t>These various TCP options fit together to enable authenticated subflow setup as illustrated in <xref target="fig_tokens"/>.</t>

        <?rfc needLines='24'?>
        <figure align="center" anchor="fig_tokens" title="Example use of MPTCP Authentication">
          <artwork align="left"><![CDATA[
           Host A                                  Host B
  ------------------------                       ----------
  Address A1    Address A2                       Address B1
  ----------    ----------                       ----------
      |             |                                |
      |             | SYN + MP_CAPABLE               |
      |--------------------------------------------->|
      |<---------------------------------------------|
      |          SYN/ACK + MP_CAPABLE(Key-B)         |
      |             |                                |
      |        ACK + MP_CAPABLE(Key-A, Key-B)        |
      |--------------------------------------------->|
      |             |                                |
      |             |   SYN + MP_JOIN(Token-B, R-A)  |
      |             |------------------------------->|
      |             |<-------------------------------|
      |             |  SYN/ACK + MP_JOIN(MAC-B, R-B) |
      |             |                                |
      |             |      ACK + MP_JOIN(MAC-A)      |
      |             |------------------------------->|
      |             |                                |

MAC-A = MAC(Key=(Key-A+Key-B), Msg=(R-A+R-B))
MAC-B = MAC(Key=(Key-B+Key-A), Msg=(R-B+R-A))
            ]]></artwork>
        </figure>

        <t>If the token received at Host B is unknown or local policy 
        prohibits the acceptance of the new subflow, the recipient MUST 
        respond with a TCP RST for the subflow.</t>

        <t>If the token is accepted at Host B, but the MAC returned to
        Host A does not match the one expected, Host A MUST close the 
        subflow with a TCP RST.</t>

        <t>If Host B does not receive the expected MAC, or the MP_JOIN
        option is missing from the ACK, it MUST close the subflow with a TCP RST.</t>

        <t>If the MACs are verified as correct, then both hosts have
        authenticated each other as being the same peers as existed at
        the start of the connection, and they have agreed of which 
        connection this subflow will become a part.</t>

        <t>If the SYN/ACK as received at Host A does not have an MP_JOIN
        option, Host A MUST close the subflow with a RST.</t>

        <t>This covers all cases of the loss of an MP_JOIN. In more detail,
        if MP_JOIN is stripped from the SYN on the path from A to
        B, and Host B does not have a passive opener on the relevant
        port, it will respond with an RST in the normal way.  If in
        response to a SYN with an MP_JOIN option, a SYN/ACK is
        received without the MP_JOIN option (either since it was
        stripped on the return path, or it was stripped on the
        outgoing path but the passive opener on Host B responded as if
        it were a new regular TCP session), then the subflow is
        unusable and Host A MUST close it with a RST.</t>

        <t>Note that additional subflows can be created
        between any pair of ports (but see <xref target="heuristics"/> for
        heuristics); no explicit application-level accept calls or
        bind calls are required to open additional subflows. To
        associate a new subflow with an existing connection, the token
        supplied in the subflow's SYN exchange is used for
        demultiplexing.  This then binds the 5-tuple of the TCP
        subflow to the local token of the connection. A consequence is
        that it is possible to allow any port pairs to be used for a
        connection. </t>

        <t>Deumultiplexing subflow SYNs MUST be done using the token;
        this is unlike traditional TCP, where the destination port is
        used for demultiplexing SYN packets.  Once a subflow is setup,
        demultiplexing packets is done using the five-tuple, as in
        traditional TCP. The five-tuples will be mapped to the local
        connection identifier (token). Note that Host A will know its
        local token for the subflow even though it is not sent on the
        wire - only the responder's token is sent.</t>
      </section>

      <section title="General MPTCP Operation" anchor="sec_generalop">
        <t>This section discusses operation of MPTCP for data transfer. At a high level, an MPTCP implementation will take one input data stream from an application, and split it into one or more subflows, with sufficient control information to allow it to be reassembled and delivered reliably and in-order to the recipient application. The following subsections define this behaviour in detail.</t>

        <t>During normal MPTCP operation, the Data Sequence Signal (DSS) TCP option (shown in <xref target="tcpm_dsn"/>) is used to signal the data required to enable multipath transport. This data comprises: the Data Sequence Mapping, which defines how the sequence space on the subflow maps to the connection level; and the Data ACK, for acknowledging receipt of data at the connection level. These functions are described in more detail in the following two subsections.</t>

        <t>Either or both the Data Sequence Mapping and the Data ACK can be signalled in the DSS option, dependent on the flags set.</t>

        <?rfc needLines='18'?>
        <figure align="center" anchor="tcpm_dsn" title="Data Sequence Signal (DSS) option">
          <artwork align="left"><![CDATA[
                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+----------------------+
  |     Kind      |    Length     |Subtype| (reserved) |F|m|M|a|A|
  +---------------+---------------+-------+----------------------+
  |           Data ACK (4 or 8 octets, depending on flags)       |
  +--------------------------------------------------------------+
  |   Data Sequence Number (4 or 8 octets, depending on flags)   |
  +--------------------------------------------------------------+
  |              Subflow Sequence Number (4 octets)              |
  +-------------------------------+------------------------------+
  |  Data-level Length (2 octets) |      Checksum (2 octets)     |
  +-------------------------------+------------------------------+
          ]]></artwork>
        </figure>

        <t>The flags when set define the contents of this option, as follows:

          <list style="symbols">
            <t>A = Data ACK present</t>
            <t>a = Data ACK is 8 octets (if not set, Data ACK is 4 octets)</t>
            <t>M = Data Sequence Number, Subflow Sequence Number, Data-level Length, and Checksum present</t>
            <t>m = Data Sequence Number is 8 octets (if not set, DSN is 4 octets)</t>
          </list>

        The flags 'a' and 'm' only have meaning if the corresponding 'A' or 'M' flags are set, otherwise they will be ignored. The maximum length of this option, with all flags set, is 28 octets.</t>

        <t>The 'F' flag indicates "DATA FIN". If present, this means that this mapping covers the final data from the sender. This is the connection-level equivalent to the FIN flag in single-path TCP. The purpose of the DATA FIN, along with the interactions between this flag, the subflow-level FIN flag, and the data sequence mapping are described in <xref target="sec_close"/>.
        The remaining reserved bits MUST be set to zero by an implementation of this specification.</t>

        <t>Note that the Checksum is only present in this option if the use of MPTCP checksumming has been negotiated at the MP_CAPABLE handshake (see <xref target="sec_init"/>). The presence of the checksum can be inferred from the length of the option.</t>
        
        <section title="Data Sequence Mapping" anchor="sec_dsn">

          <t>The data stream as a whole can be reassembled through the use of the Data Sequence Mapping components of the DSS option (<xref target="tcpm_dsn"/>), which define the 
mapping from the subflow sequence number to the data sequence number. This is used by the receiver to ensure in-order delivery to the application layer. Meanwhile, the subflow-level sequence numbers (i.e. the regular sequence numbers in the TCP header) have subflow-only relevance. It is expected (but not mandated) that SACK <xref target='RFC2018'/> is used at the subflow level to improve efficiency.</t>

        <t>The Data Sequence Mapping specifies a mapping from subflow sequence space to data sequence space. This is expressed in terms of starting sequence numbers for the subflow and the data level, and a length of bytes for which this mapping is valid.
This explicit mapping for a range of data was chosen rather than per-packet signaling to assist with compatibility with situations where TCP/IP segmentation or coalescing is undertaken separately from the stack that is generating the data flow (e.g. through the use of TCP segmentation offloading on network interface cards, or by middleboxes such as performance enhancing proxies). It also allows a single mapping to cover many packets, which may be useful in bulk transfer situations.</t>

        <t>A mapping is fixed, in that the subflow sequence number is bound to the data sequence number after the mapping has been processed. A sender MUST NOT change this mapping
after it has been declared; however, the same data sequence number can be mapped to by different subflows for retransmission purposes (see <xref target="sec_retransmit"/>). This would also permit the same data to be sent simultaneously on multiple subflows for resilience or efficiency purposes, especially in the case of lossy links. Although the detailed specification of such operation is outside the scope of this document, an implementation SHOULD treat the first data that is received at a subflow for the data sequence space as that which should be delivered to the application.</t>

        <t>The data sequence number is specified as an absolute value, whereas the subflow sequence numbering is relative (the SYN at the start of the subflow has relative subflow sequence number 0). This is to allow middleboxes to change the Initial Sequence Number of a subflow, such as firewalls that undertake ISN randomization.</t>

        <t>The data sequence mapping also contains a checksum of the data that this mapping covers. This is used to detect if the payload has been adjusted in any way by a non-MPTCP-aware middlebox. If this checksum fails, it will trigger a failure of the subflow, or a fallback to regular TCP, as documented in <xref target="sec_fallback"/>, since MPTCP can no longer reliably know the subflow sequence space at the receiver to build data sequence mappings.</t>

        <t>The checksum algorithm used is the standard TCP checksum <xref target="RFC0793"/>, operating over the data covered by this mapping, along with a pseudo-header as shown in <xref target="fig_pseudo"/>.</t>
        
        <?rfc needLines='18'?>
        <figure align="center" anchor="fig_pseudo" title="Pseudo-Header for DSS Checksum">
          <artwork align="left"><![CDATA[
                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +--------------------------------------------------------------+
  |                                                              |
  |                Data Sequence Number (8 octets)               |
  |                                                              |
  +--------------------------------------------------------------+
  |              Subflow Sequence Number (4 octets)              |
  +-------------------------------+------------------------------+
  |  Data-level Length (2 octets) |        Zeros (2 octets)      |
  +-------------------------------+------------------------------+
          ]]></artwork>
        </figure>

        <t>Note that the Data Sequence Number used in the pseudo-header is always the 64 bit value, irrespective of what length is used in the DSS option itself. The standard TCP checksum algorithm has been chosen since it will be calculated anyway for the TCP subflow, and if calculated first over the data before adding the pseudo-headers, it only needs to be calculated once. Furthermore, since the TCP checksum is additive, the checksum for a DSN_MAP can be constructed by simply adding together the checksums for the data of each constituent TCP segment, and adding the checksum for the DSS pseudo-header.</t>
        
        <t>Note that checksumming relies on the TCP subflow containing contiguous data, and therefore a TCP subflow MUST NOT use the Urgent Pointer to interrupt an existing mapping. Further note, however, that if Urgent data is received on a subflow, it SHOULD be mapped to the data sequence space and delivered to the application analogous to Urgent data in regular TCP.</t>

        <t>To avoid possible deadlock scenarios, subflow-level
        processing should be undertaken separately from that at
        connection-level. Therefore, even if a mapping does not exist
        from the subflow space to the data-level space, the data
        SHOULD still be ACKed at the subflow (if it is in-window). 
        This data cannot, however, be acknowledged at the data level
        (<xref target="sec_dataack"/>) because its data sequence
        numbers are unknown. Implementations MAY hold onto such
        unmapped data for a short while in the expectation that a
        mapping will arrive shortly.  Such unmapped data cannot be
        counted as being within the connection-level receive window because this is
        relative to the data sequence numbers, so if the receiver runs
        out of memory to hold this data, it will have to be discarded.
        If a mapping for that subflow-level sequence space does not
        arrive within a receive window of data, that subflow SHOULD be
        treated as broken, closed with an RST, and any unmapped data
        silently discarded.</t>

        <t>Data sequence numbers are always 64 bit quantities, and
        MUST be maintained as such in implementations.  If a
        connection is progressing at a slow rate, so protection
        against wrapped sequence numbers is not required, 
        then it is permissible to include just the lower 32
        bits of the data sequence number in the Data Sequence Mapping and/or
        Data ACK as an optimization, and an implementation can make this choice
        independently for each packet.</t>
        
        <t>An implementation MUST send the full 64 bit Data Sequence Number 
        if it is transmitting at a sufficiently high rate that the 32 bit value 
        could wrap within the Maximum Segment Lifetime 
        (MSL) <xref target="RFC1323"/>. The lengths of the DSNs used in these
        values (which may be different) are declared with flags in the
        DSS option.  Implementations MUST accept a 32 bit DSN and implicitly
        promote it to a 64 bit quantity by incrementing the upper 32
        bits of sequence number each time the lower 32
        bits wrap. A sanity check MUST be implemented to ensure that
        a wrap occurs at an expected time (e.g. the sequence number jumps
        from a very high number to a very low number) and is not triggered 
        by out-of-order packets.</t>

        <t>As with the standard TCP sequence number, the data sequence
        number should not start at zero, but at a random value to make
        blind session hijacking harder. This is done by setting the
        initial data sequence number (IDSN) of each host to the least
        significant 64 bits of the SHA-1 hash of the host's key, as
        described in <xref target="sec_init"/>.</t>

        <t>A Data Sequence Mapping does not need to be included in
        every MPTCP packet, as long as the subflow sequence space in
        that packet is covered by a mapping known at the receiver. This
        can be used to reduce overhead in cases where the mapping is
        known in advance; one such case is when there is a single
        subflow between the hosts, another is when segments of
        data are scheduled in larger than packet-sized chunks.</t>
        
        <t>An "infinite" mapping can be used to fallback to regular TCP by
        mapping the subflow-level data to the connection-level data
        for the remainder of the connection (see
        <xref target="sec_fallback"/>). This is achieved by setting
        the data-level length field to the reserved value of 0. The
        checksum, in such a case, will also be set to zero.</t>
      </section>

      <section title="Data Acknowledgements" anchor="sec_dataack">
        <t>To provide full end-to-end resilience, MPTCP provides a
        connection-level acknowledgement, to act as a cumulative ACK for
        the connection as a whole. This is the "Data ACK" field of 
        the DSS option (<xref target="tcpm_dsn"/>). The Data ACK
        is analogous to the behaviour
        of the standard TCP cumulative ACK in TCP SACK - indicating
        how much data has been successfully received (with no
        holes). The Data ACK specifies the next Data Sequence Number 
        it expects to receive.</t>

        <t>The Data ACK, as for the DSN, can be sent as the full 64 bit
        value, or as the lower 32 bits.  If data is received with a 64 
        bit DSN, it MUST be acknowledged with a 64 bit Data ACK.  If
        the DSN received is 32 bits, it is valid for the implementation 
        to choose whether to send a 32 bit or 64 bit Data ACK.</t>

        <!-- <t>The rationale for the inclusion of the Data ACK includes
        the existence of certain middleboxes that pro-actively ACK 
        packets, and thus might cause deadlock conditions if data 
        were acked at the subflow level but then fails to reach the 
        receiver.  This sort of bad interaction might be especially 
        prevalent when the receiver is mobile. The Data ACK ensures
        the data has been delivered to the receiver. </t> -->
        
        <t>The Data ACK proves that the data, and all required MPTCP
        signaling, has been received and accepted by the remote end.
        One key use of the Data ACK signal is that it is used to indicate
        the left edge of the advertised receive window. As explained in
        <xref target="sec_rwin"/>, the receive window is shared by all
        subflows and is relative to the Data ACK. Because of this, an
        implementation MUST NOT use the RCV.WND field of a TCP segment
        at connection-level if it does not also carry a DSS option with
        a Data ACK field. Furthermore,
        separating the connection-level acknowledgements from the
        subflow-level allows processing to be done separately, and
        a receiver has the freedom to drop segments after acknowledgement 
        at the subflow level, for example due to memory constraints
        when many segments arrive out-of-order.</t>

        <t>An MPTCP sender MUST only free data from the send buffer
        when it has been acknowledged by both a Data ACK received on
        any subflow and at the subflow level by any subflows the data
        was sent on.  The former condition ensures liveness of the
        connection and the latter condition ensures liveness and
        self-consistence of a subflow when data needs to be
        restransmited.
        Note, however, that if some data needs to be retransmitted multiple
        times over a subflow, there is a risk of blocking the sending
        window. In this case, the MPTCP sender can decide to terminate the
        subflow that is behaving badly by sending a RST.</t>

        <t>The Data ACK MAY be included in all segments, however optimisations 
        SHOULD be considered in more advanced implementations, where the
        Data ACK is present in segments 
        only when the Data ACK value advances, and this behaviour MUST
        be treated as valid. This behaviour ensures the sender buffer 
        is freed, while reducing overhead when the data transfer is 
        unidirectional.</t>
      </section>

      <section title="Closing a Connection" anchor="sec_close">
        <t>In regular TCP a FIN announces the receiver that the sender has no more data to send. 
In order to allow subflows to operate independently and to keep the appearance of TCP over the wire, 
a FIN in MPTCP only affects the subflow on which it is sent. This 
allows nodes to exercise considerable freedom over which paths are in use at any one time. 
The semantics of a FIN remain as for regular TCP, i.e. it is not until both sides have ACKed 
each other's FINs that the subflow is fully closed.</t>
        <t>When an application calls close() on a socket, this indicates that it has no more 
data to send, and for regular TCP this would result in a FIN on the connection. For MPTCP, an 
equivalent mechanism is needed, and this is referred to as the DATA FIN.</t>

        <t>A DATA FIN is an indication that the sender has no more data to send, and 
        as such can be used to verify that all data has been successfully received. A DATA_FIN, 
        as with the FIN on a regular TCP connection, is a unidirectional signal.</t>

        <t>The DATA FIN is signalled by setting the 'F' flag in the Data Sequence Signal option (<xref target="tcpm_dsn"/>) to 1. A DATA FIN occupies one octet (the final octet) of the connection-level sequence space. Note that the DATA FIN is included in the Data-level Length, but not at the subflow level: for example, a segment with DSN 80, and length 11, with DATA FIN set, would map 10 octets from the subflow into data sequnce space 80-89, the DATA FIN is DSN 90, and therefore this segment including DATA FIN would be acknowledged with a DATA ACK of 91.</t>

        <t>Note that when the DATA FIN is not attached to a TCP segment containing data, the Data Sequence Mapping MUST have Subflow Sequence Number of 0, a Length of 1, and the Data Sequence Number that corresponds with the DATA FIN itself. The checksum in this case will only cover the pseudo-header.</t>
        
        <t>A DATA FIN has the semantics and behaviour as a regular TCP FIN, but at the connection level. Notably, it is only DATA ACKed once all data has been successfully received at the connection level. Note therefore that a DATA FIN is decoupled from a subflow FIN. It is only permissable to combine these signals on one subflow if there is no data oustanding on other subflows. Otherwise, it may be necessary to retransmit data on different subflows. Essentially, a host MUST NOT FIN all functioning subflows unless it is safe to do so, i.e. until all outstanding data has been DATA ACKed, or that the segment with the FIN flag set is the only outstanding segment.</t>

        <t>Once a DATA FIN has been acknowledged, all remaining subflows MUST be closed with standard FIN exchanges. Both hosts SHOULD send FINs, as a courtesy to allow middleboxes to clean up state even if the subflow has failed. It is also encouraged to reduce the timeouts (Maximum Segment Life) on subflows at end hosts. In particular, any subflows where there is still outstanding data queued (which has been retransmitted on other subflows in order to get the DATA FIN acknowledged) MAY be closed with an RST.</t>

        <t>A connection is considered closed once both hosts' DATA FINs have been acknowledged by DATA ACKs.</t>
        
        <t>Note that a host may also send a FIN on an individual subflow to shut it down, but this impact is limited to the subflow in question. If all subflows have been closed with a FIN exchange, but no DATA FIN has been received and acknowledged, the MPTCP connection is treated as closed only after a timeout. This implies that an implementation will have TIME_WAIT states at both the subflow and connection levels (see <xref target="app_fsm"/>). This permits "break-before-make" scenarios where connectivity is lost on all subflows before a new one can be re-established.</t>
      </section>

        <section title="Receiver Considerations" anchor="sec_rwin">
          <t>Regular TCP advertises a receive window in each packet, telling the sender how much data the receiver
is willing to accept past the cumulative ack. The receive window is used to implement flow control, throttling
down fast senders when receivers cannot keep up. </t>

          <t>MPTCP also uses a unique receive window, shared between the subflows. The idea is to allow any
subflow to send data as long as the receiver is willing to accept it; the alternative, maintaining per subflow
receive windows, could end-up stalling some subflows while others would not use up their window.</t>

          <t>The receive window is relative to the DATA_ACK. As in TCP, a receiver MUST NOT shrink the right edge of the receive window (i.e. DATA_ACK + receive window). The receiver will
use the Data Sequence Number to tell if a packet should be accepted at connection level.</t> 

          <t>When deciding to accept packets at subflow level, normal TCP uses 
the sequence number in the packet and checks it against the allowed receive window. 
With multipath, such a check is done using only the connection level window. A sanity 
check SHOULD be performed at subflow level to ensure that the subflow and mapped sequence
numbers meet the following test: SSN - SUBFLOW_ACK &lt;= DSN - DATA_ACK, where SSN is the subflow sequence number of the received packet and SUBFLOW_ACK is the rcv_next of the subflow (with the equivalent connection-level definitions for DSN and DATA_ACK).</t>

<!--          <t>When should segments be processed at connection level?
          An implementation might wait until they arrive in order at
          subflow level, and only then do connection level processing.
          However, if many segments of data are restransmitted on more
          than one subflow, then because some data is duplicated then
          the sum total of unacknowledged data on all subflows might
          exceed the receive window that was advertised, which
          indicates buffering available for data sequence space.  This
          such a strategy is probably undesirable.</t>-->

<t>In regular TCP, once a segment is deemed in-window, it is either 
put in the in-order receive queue or in the out-of-order queue. 
In multipath TCP, the same happens but at connection-level: a segment
is placed in the connection level in-order or out-of-order queue if
it is in-window at both connection and subflow level. 
The stack still has to remember, for each subflow, which segments were
received succesfully so that it can ACK them at subflow level appropriately.
Typically, this will be implemented by keeping per subflow out-of-order
queues (containing only message headers, not the payloads) and remembering 
the value of the cumulative ACK.
</t>

          <t>It is important for implementers to understand how large
          a receiver buffer is appropriate. The lower bound for full
          network utilization is the maximum bandwidth-delay product
          of any of the paths.  However this might be insufficient
          when a packet is lost on a slower subflow and needs to be
          retransmitted (see <xref target="sec_retransmit"/>). A tight
          upper bound would be the maximum RTT of any path multiplied
          by the total bandwidth available across all paths. This
          permits all subflows to continue at full speed while a
          packet is fast-retransmitted on the maximum RTT path. Even
          this might be insufficient to maintain full performance in
          the event of a retransmit timeout on the maximum RTT path.
          It is for future study to determine the relationship between
          retransmission strategies and receive buffer sizing.</t>
        </section>

        <section title="Sender Considerations" anchor="sec_sender">
          <t>The sender remembers receiver window advertisements from the receiver. It should only update its local receive window values when the largest sequence number allowed (i.e. DATA_ACK + receive window) increases. This is important to allow using paths with different RTTs, and thus different feedback loops. </t>

          <t>MPTCP uses a single receive window across all subflows, and if the receive window was guaranteed to be unchanged end-to-end, a host could always read the most recent receive window value. However, some classes of middleboxes may alter the TCP-level receive window. Typically these will 
shrink the offered window, although for short periods of time it may be possible for the window to be larger (however 
note that this would not continue for long periods since ultimately the middlebox must keep up with 
delivering data to the receiver). Therefore, if receive window sizes differ on multiple subflows, 
when sending data MPTCP SHOULD take the largest of the most recent window sizes as the one to use in calculations.
This rule is implicit in the requirement not to reduce the right edge of the window.</t>

          <t>The sender also remembers the receive windows advertised by each subflow.
The allowed window for subflow i is (ack_i, ack_i + rcv_wnd_i), where ack_i is the
subflow-level cumulative ack of subflow i. This ensures data will not be sent to a middlebox
unless there is enough buffering for the data. </t>

          <t>Putting the two rules together, we get the following: a sender is allowed to send 
data segments with data-level sequence numbers between (DATA_ACK, DATA_ACK + receive_window).
Each of these segments will be mapped onto subflows, as long as subflow sequence numbers
are in the the allowed windows for those subflows. Note that subflow sequence numbers do not
generally affect flow control if the same receive window is advertised across all subflows. 
They will perform flow control for those subflows with a smaller advertised receive window. 
          </t>

          <t>The send buffer must be, at the minimum, as big as the receive buffer, to enable the sender to reach maximum throughput.</t>

        </section>

        <section title="Reliability and Retransmissions" anchor="sec_retransmit">

          <t>The data sequence mapping allows senders to re-send data with the same data sequence number on a different subflow. When doing this, a host must still retransmit the original data on the original subflow, in order to preserve the subflow integrity (middleboxes could replay old data, and/or could reject holes in subflows), and a receiver will ignore these retransmissions. While this is clearly suboptimal, for compatibility reasons this is the best behaviour. Optimisations could be negotiated in future versions of this protocol.</t>

          <t>This protocol specification does not mandate any mechanisms for handling retransmissions, and much will be dependent upon local policy 
(as discussed in <xref target="sec_policy"/>). One can imagine aggressive connection level retransmissions policies where every packet lost at subflow level is retransmitted on
a different subflow (hence wasting bandwidth but possibly reducing application-to-application delays), or conservative retransmission policies where connection-level retransmits
are only used after a few subflow level retransmission timeouts occur.</t>

          <t>It is envisaged that a standard connection-level retransmission mechanism 
would be implemented around a connection-level data queue: all segments that haven't 
been DATA_ACKed are stored. A timer <!-- (based on the subflow timer values) --> is set when 
the head of the connection-level is ACKed at subflow level but its corresponding data 
is not ACKed at data level. This timer will guard against failures in re-transmission
by middleboxes that pro-active ACK data.</t>

          <t>The sender MUST keep data in its send buffer as long as the data has not been acknowledged at both connection level and on all subflows it
has been sent on. In this way, the sender can always retransmit the data if needed, on the same subflow or on a different one. A special case is when a subflow fails: the sender 
will typically resend the data on other working subflows after a timeout, and will keep trying to retransmit the data 
on the failed subflow too. The sender will declare the subflow failed after a predefined upper bound on retransmissions is reached (which MAY be lower than the usual TCP limits of the Maximum Segment Life), or on the receipt of an ICMP error, and only then delete the outstanding data segments. </t>

          <t>Multiple retransmissions are triggers that will indicate that a subflow performs badly and could lead to a host resetting the subflow with an RST. However, additional research is required to understand the heuristics of how and when to reset underperforming subflows. For example, subflows that perform highly asymmetrically may be mis-diagnosed as underperforming.</t>

        </section>

        <section title="Congestion Control Considerations" anchor="sec_cc">
          <t>Different subflows in an MPTCP connection have different congestion windows.   
To achieve fairness at bottlenecks and resource pooling, it is necessary to couple the 
congestion windows in use on each subflow, in order to push most traffic to uncongested links. 
One algorithm for achieving this is presented in <xref target="RFC6356"/>; 
the algorithm does not achieve perfect resource pooling but is "safe" in that it is readily 
deployable in the current Internet. By this, we mean that it does not take up more capacity
on any one path than if it was a single path flow using only that route, so this ensures
fair coexistence with single-path TCP at shared bottlenecks.</t>

          <t>It is foreseeable that different congestion controllers will be implemented for MPTCP, each aiming to achieve different properties in the resource pooling/fairness/stability design space, as well as those for achieving different properties in quality of service, reliability and resilience.</t>

          <t>Regardless of the algorithm used,
the design of the MPTCP protocol aims to provide the congestion control implementations sufficient information 
to take the right decisions; this information includes, for each subflow, which packets were lost and when. </t>
        </section>

        <section title="Subflow Policy" anchor="sec_policy">
          <t>Within a local MPTCP implementation, a host may use any local policy it wishes to decide how to share the traffic to be sent over the available paths.</t>
          <t>In the typical use case, where the goal is to maximise throughput, all available paths will be used simultaneously for data transfer, using coupled congestion control as described in <xref target="RFC6356"/>. It is expected, however, that other use cases will appear.</t>
          <t>For instance, a possibility is an 'all-or-nothing' approach, i.e. have a second path ready for use in the event of 
failure of the first path, but alternatives could include entirely saturating one path before using an additional 
path (the 'overflow' case). Such choices would be most likely based on the monetary cost of links, but may also be 
based on properties such as the delay or jitter of links, where stability (of delay or bandwidth) is more important than throughput. Application
requirements such as these are discussed in detail in <xref target="I-D.ietf-mptcp-api"/>.</t>
          <t>The ability to make effective choices at the sender requires full knowledge of the path "cost", which 
is unlikely to be the case. It would be desirable for a receiver to be able to signal their own preferences for paths,
since they will often be the multihomed party, and may have to pay for metered incoming bandwidth.</t>
          <t>Whilst fine-grained control may be the most powerful solution, that would require some mechanism such as overloading the ECN signal <xref target="RFC3168"/>, which is undesirable, and it is felt that there would not be sufficient benefit to justify an entirely new signal. Therefore the MP_JOIN option (see <xref target="sec_join"/>) contains the 'B' bit, which allows a host to indicate to its peer that this path should be treated as a backup path to use only in the event of failure of other working subflows (i.e. a subflow where the receiver has indicated B=1 SHOULD NOT be used to send data unless there are no usable subflows where B=0).</t>
          <t>In the event that the available set of paths changes, a host may wish to signal a change in priority of subflows to the peer (e.g. a subflow that was previously set as backup should now take priority over all remaining subflows). Therefore, the MP_PRIO option, shown in <xref target="tcpm_prio"/>, can be used to change the 'B' flag of the subflow on which it is sent.</t>
          <?rfc needLines='8'?>
          <figure align="center" anchor="tcpm_prio" title="MP_PRIO option">
            <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-----+-+--------------+
   |     Kind      |     Length    |Subtype|     |B| AddrID (opt) |
   +---------------+---------------+-------+-----+-+--------------+
              ]]></artwork>
          </figure>

          <t>It should be noted that the backup flag is a request from a data receiver to a data sender only, and the data sender SHOULD adhere to these requests. A host cannot assume that the data sender will do so, however, since local policies - or technical difficulties - may override MP_PRIO requests. The signal applies to a single direction: the sender of this option, however, may continue using the subflow to send data even if it has signalled B=1 to the other host.</t>

          <t>This option can also be applied to other subflows than the one on which it is sent, by setting the optional Address ID field.  This applies the given setting of B to all subflows that use the address identified by the given Address ID. The presence of this field is determined by the option length; if Length==4 then it is present, if Length==3 then it applies to the current subflow only.  The use case of this is that a host can signal to its peer that an address is temporarily unavailable (for example, if it has radio coverage issues) and the peer should therefore drop to backup state on all subflows using that Address ID.</t>

        </section>
      </section>

      <section title="Address Knowledge Exchange (Path Management)" anchor="sec_pm">
        <t>We use the term "path management" to refer to the exchange of information about additional paths between hosts, which in this design is managed by multiple addresses at hosts. For more detail of the architectural thinking behind this design, see the separate architecture document <xref target="RFC6182"/>.</t>
        <t>This design makes use of two methods of sharing such
        information, used simultaneously. The first is the direct
        setup of new subflows, already described in
        <xref target="sec_join"/>, where the initiator has an
        additional address. The second method, described in the
        following subsections, signals addresses explicitly to the
        other host to allow it to initiate new subflows. The
        two mechanisms are complementary: the first is implicit and
        simple, while the explicit is more complex but is more
        robust. Together, the mechanisms allow addresses to change in
        flight (and thus support operation through NATs, since the
        source address need not be known), and also allow the
        signaling of previously unknown addresses, and of addresses
        belonging to other address families (e.g. both IPv4 and IPv6).</t>

        <t>Here is an example of typical operation of the protocol:
          <list style="symbols">
            <t>An MPTCP connection is initially set up between address/port A1 of host A 
              and address/port B1 of host B.  If host A is multihomed and 
              multi-addressed, it can start an additional subflow from
              its address A2 to B1, by sending a SYN with a Join
              option from A2 to B1, using B's previously declared
              token for this connection.  Alternatively, if B is
              multihomed, it can try to set up a new subflow from B2 to
              A1, using A's previously declared token.  In either
              case, the SYN will be sent to the port already in use
              for the original subflow on the receiving host.</t>

            <t>Simultaneously (or after a timeout), an ADD_ADDR option 
(<xref target="sec_add_address"/>) is sent on an existing subflow, informing 
the receiver of the sender's alternative address(es). The recipient can use 
this information to open a new subflow to the sender's additional address. 
In our example, A will send ADD_ADDR option informing B of address/port A2.
The mix of using the SYN-based option and the ADD_ADDR option, including 
timeouts, is implementation-specific and can be tailored to agree with local policy.</t>

            <t>If subflow A2-B1 is succesfully setup, host B can use the Address ID in 
the Join option to correlate this with the ADD_ADDR option that will also arrive on 
an existing subflow; now B knows not to open A2-B1, ignoring the ADD_ADDR.
Otherwise, if B has not received the A2-B1 MP_JOIN SYN but received the ADD_ADDR, 
it can try to initiate a new subflow from one or more of its addresses to address 
A2. This permits new sessions to be opened if one host is behind a NAT. 
<!-- A slight security improvement can be gained if a host ensures there is a 
correlated ADD_ADDR option before responding to the SYN.--></t>
          </list>
       Other ways of using the two signaling mechanisms are possible; for instance, 
signaling addresses in other address families can only be done explicitly using the Add Address option.
        </t>

      <section title="Address Advertisement" anchor="sec_add_address">
        <t>The Add Address (ADD_ADDR) TCP Option announces additional addresses (and optionally, ports) on which a 
host can be reached (<xref target="tcpm_address"/>). 
Multiple instances of this TCP option can be added in a single message if 
there is sufficient TCP option space, otherwise multiple TCP messages containing this option 
will be sent. This option can be used at any time during a connection, depending on when the 
sender wishes to enable multiple paths and/or when paths become available. As with all MPTCP
signals, the receiver MUST understake standard TCP validity checks before acting upon it.</t>

        <t>Every address has an ID which can be used for uniquely identifying the address within a connection, for address removal. This is also 
used to identify MP_JOIN options (see <xref target="sec_join"/>) relating to 
the same address, even when address translators are in use. The ID MUST uniquely
identify the address to the sender (within the scope of the connection), but the mechanism for 
allocating such IDs is implementation-specific.</t>

        <t>All address IDs learnt via either MP_JOIN or ADD_ADDR
        SHOULD be stored by the receiver in a data structure that gathers all the Address ID 
        to address mappings for a connection (identified by a token pair). In this way there is 
        a stored mapping between Address ID, observed source address and token pair for 
        future processing of control information for a connection. Note that an implementation
        MAY discard incoming address advertisements at will, for example for avoiding the
        required mapping state, or because advertised addresses are of no use to it (for 
        example, IPv6 addresses when it has IPv4 only). Therefore, a host MUST treat address
        advertisements as soft state, and MAY choose to refresh advertisements periodically.</t>

        <t>This option is shown in <xref target="tcpm_address"/>. The illustration
is sized for IPv4 addresses (IPVer = 4). For IPv6, the IPVer field will read 6, 
and the length of the address will be 16 octets (instead of 4).</t>

        <t>The presence of the final two octets, specifying the TCP port number to use,
        are optional and can be inferred from the length of the option.
Although it is expected that the majority of 
use cases will use the same port pairs as used for the initial subflow (e.g. port 
80 remains port 80 on all subflows), as does the ephemeral port at the client, there 
may be cases (such as port-based load balancing) where the explicit specification of 
a different port is required. If no port is specified, MPTCP SHOULD attempt to 
connect to the specified address on the same port as is already in use by the signaling 
subflow, and this is discussed in more detail in <xref target="heuristics"/>.</t>

        <?rfc needLines='11'?>
        <figure align="center" anchor="tcpm_address" title="Add Address (ADD_ADDR) option (shown for IPv4)">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-------+---------------+
   |     Kind      |     Length    |Subtype| IPVer |  Address ID   |
   +---------------+---------------+-------+-------+---------------+
   |          Address (IPv4 - 4 octets / IPv6 - 16 octets)         |
   +-------------------------------+---------------+---------------+
   |   Port (2 octets, optional)   |
   +-------------------------------+
            ]]></artwork>
        </figure>

        <t>Due to the proliferation of NATs, it is reasonably likely that one host may attempt to advertise private addresses <xref target="RFC1918"/>. It is not desirable to prohibit this, since there may be cases where both hosts have additional interfaces on the same private network, and a host MAY want to advertise such addresses. Such advertisements must not, however, cause harm or security vulnerabilities. The standard mechanism to create a new subflow (<xref target="sec_join"/>) contains a 32 bit token that uniquely identifies the connection to the receiving host. If the token is unknown, the host will return with a RST. In the unlikely event that the token is known, subflow setup will continue, but the MAC exchange must occur for authentication. This will fail, and will provide sufficient protection against two unconnected hosts accidentally setting up a new subflow upon the signal of a private address.</t>

  <!-- Fix this reliability text -->
        <t>Ideally, ADD_ADDR and REMOVE_ADDR options would be sent reliably, and in order, to the other end. This would be to ensure that this address management does not unnecessarily cause an outage in the connection when remove/add addresses are processed in reverse order, and also to ensure that all possible paths are used. Note, however, that losing reliability and ordering will not
break the multipath connections, it will just reduce the opportunity to open multipath paths and to survive different patterns of path failures. </t>

        <t>Therefore, implementing reliability signals for these TCP options is not necessary. In order to minimise the impact of the loss of these options, however, it is RECOMMENDED that a sender should send these options on all available subflows.
        If these options need to be received in-order, an implementation SHOULD only send one ADD_ADDR/REMOVE_ADDR option per RTT, to minimise the risk of misordering.</t>

        <t>When receiving an ADD_ADDR message with an Address ID already in use for a live subflow within the connection, the receiver SHOULD silently ignore the ADD_ADDR. If the Address ID is not in use on a live subflow, but is stored by the receiver, a new ADD_ADDR SHOULD take precedence and replace the stored address.</t>

        <t>A host that receives an ADD_ADDR but finds a connection setup to that IP address and port number is unsuccessful SHOULD NOT perform further connection attempts to this address/port combination for this connection. A sender that wants to trigger a new incoming connection attempt on a previously advertised address/port combination can therefore refresh ADD_ADDR information by sending the option again.</t>

        <t>During normal MPTCP operation, it is unlikely that there will be sufficient TCP option space for ADD_ADDR to be included along with those for data sequence numbering (<xref target="sec_dsn"/>). Therefore, it is expected that an MPTCP implementation will send the ADD_ADDR option on separate ACKs. As discussed earlier, however, an MPTCP implementation MUST NOT treat duplicate ACKs with MPTCP options as indications of congestion <xref target="RFC2581"/>, and an MPTCP implementation SHOULD NOT send more than two duplicate ACKs in a row for signaling purposes.</t>
        
      </section>
      <section title="Remove Address" anchor="sec_remove_addr">
        <t>If, during the lifetime of an MPTCP connection, a previously-announced address becomes invalid (e.g. if the interface disappears), the affected host SHOULD announce this so that the peer can remove subflows related to this address.</t>
        <t>This is achieved through the Remove Address (REMOVE_ADDR) option (<xref target="tcpm_remove"/>), which will remove a previously-added address (or list of addresses) from a connection and terminate any subflows currently using that address.</t>
        <t>For security purposes, if a host receives a REMOVE_ADDR option, it must ensure the affected path(s) are no longer in use before it instigates closure. The receipt of REMOVE_ADDR SHOULD first trigger the sending of a TCP Keepalive <xref target="RFC1122"/> on the path, and if a response is received the path is not removed. Typical TCP validity tests on the subflow (e.g. ensuring sequence and ack numbers are correct) MUST also be undertaken.</t>
        <t>The sending and receipt (if no keepalive response was received) of this message SHOULD trigger the sending of RSTs by both hosts on the affected subflow(s) (if possible), as a courtesy to cleaning up middlebox state, before cleaning up any local state.</t>
        <t>Address removal is undertaken by ID, so as to permit the use of NATs and other middleboxes that rewrite source addresses. If there is no address at the requested ID, the receiver will silently ignore the request.</t>
        <t>A subflow that is still functioning MUST be closed with a FIN exchange as in regular TCP - for more information, see <xref target="sec_close"/>.</t>
        <?rfc needLines='8'?>
        <figure align="center" anchor="tcpm_remove" title="Remove Address (REMOVE_ADDR) option">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+-------+---------------+
   |     Kind      |  Length = 3+n |Subtype|       |   Address ID  | ...
   +---------------+---------------+-------+-------+---------------+
            ]]></artwork>
        </figure>
      </section>

      </section>


      <section title="Fallback" anchor="sec_fallback">
        <t>At the start of an MPTCP connection (i.e. the first subflow), it is important to ensure that the path is fully MPTCP-capable and the necessary TCP options can reach each host. The handshake as described in <xref target="sec_init"/> will fall back to regular TCP if either of the SYN messages do not have the MPTCP options: this is the same, and desired, behaviour in the case where a host is not MPTCP capable, or the path does not support the MPTCP options. When attempting to join an existing MPTCP connection (<xref target="sec_join"/>), if a path is not MPTCP capable, the TCP options will not get through on the SYNs and the subflow will be closed.</t>

        <t>There is, however, another corner case which should be addressed. That is one of MPTCP options getting through on the SYN, but not on regular packets. This can be resolved if the subflow is the first subflow, and thus all data in flight is contiguous, using the following rules.</t>

        <t>A sender MUST include a DSS option with Data Sequence Mapping in every segment until one of the sent segments has been acknowledged with a DSS option containing a Data ACK. Upon reception of the acknowledgement, the sender has the confirmation that the DSS option passes in both directions and may choose to send fewer DSS options than once per segment.</t>

        <t>If, however, an ACK is received for data (not just for the SYN) without a DSS option containing a Data ACK, the sender determines the path is not MPTCP capable. In the case of this occurring on an additional subflow (i.e. one started with MP_JOIN), the host MUST close the subflow with an RST. In the case of the first subflow (i.e. that started with MP_CAPABLE), it MUST drop out of an MPTCP mode back to regular TCP. The sender will send one final Data Sequence Mapping, with the length value of 0 indicating an infinite mapping (in case the path drops options in one direction only), and then revert to sending data on the single subflow without any MPTCP options.</t>

        <t>Note that this rule essentially prohibits the sending of data on the third packet of an MP_CAPABLE or MP_JOIN handshake, since both that option and a DSS cannot fit in TCP option space. If the initiator is to send first, another segment must be sent that contains the data and DSS. Note also that an additional subflow cannot be used until the initial path has been verified as MPTCP-capable.</t>

        <t>These rules should cover all cases where such a failure could happen: whether it's on the forward or reverse path, and whether the server or the client first sends data. If lost options on data packets occur on any other subflow apart from the the initial subflow, it should be treated as a standard path failure. The data would not be DATA_ACKed (since there is no mapping for the data), and the subflow can be closed with an RST. (Note that these rules do not apply if an infinite mapping is included from the start - in which case, each end will send DSS options declaring the infinite mapping.)
        </t>

        <t>The case described above is a specialised case of fallback. More generally, fallback to regular TCP can become necessary at any point during a connection if a non-MPTCP-aware middlebox changes the data stream.</t>

        <t>As described in <xref target="sec_generalop"/>, each portion of data for which there is a mapping is protected by a checksum. This mechanism is used to detect if middleboxes have made any adjustments to the payload (added, removed, or changed data). A checksum will fail if the data has been changed in any way. This will also detect if the length of data on the subflow is increased or decreased, and this means the Data Sequence Mapping is no longer valid. The sender no longer knows what subflow-level sequence number the receiver is genuinely operating at (the middlebox will be faking ACKs in return), and cannot signal any further mappings. Furthermore, in addition to the possibility of payload modifications that are valid at the application layer, there is the possibility that false-positives could be hit across MPTCP segment boundaries, corrupting the data. Therefore, all data from the start of the segment that failed the checksum onwards is not trustworthy.</t>

        <t>When multiple subflows are in use, the data in-flight on a subflow will likely involve data that is not contiguously part of the connection-level stream, since segments will be spread across the multiple subflows. Due to the problems identified above, it is not possible to determine what the adjustment has done to the data (notably, any changes to the subflow sequence numbering). Therefore, it is not possible to recover the subflow, and the affected subflow must be immediately closed with an RST, featuring an MP_FAIL option (<xref target="tcpm_fallback"/>), which defines the Data Sequence Number at the start of the segment (defined by the Data Sequence Mapping) which had the checksum failure.</t>

        <?rfc needLines='8'?>
        <figure align="center" anchor="tcpm_fallback" title="Fallback (MP_FAIL) option">
          <artwork align="left"><![CDATA[
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------+----------------------+
   |     Kind      |   Length=12   |Subtype|      (reserved)      |
   +---------------+---------------+-------+----------------------+
   |                 Data Sequence Number (8 octets)              :
   +--------------------------------------------------------------+
   :                Data Sequence Number (continued)              |
   +--------------------------------------------------------------+

            ]]></artwork>
        </figure>

        <!-- <t>TBD: In this case, is there any point in signaling Checksum Failed, or could we just RST the subflow? The signal would allow the sender to know there is something wrong with the path and not try to re-establish the subflow (if that was otherwise the policy). </t> -->

        <t>Failed data will not be DATA_ACKed and so will be re-transmitted on other subflows (<xref target="sec_retransmit"/>). </t>

        <t> A special case is when there is a single subflow and it fails with a checksum error. <!-- Here, MPTCP should be able 
to recover and continue sending data.  There are two possible mechanisms to support this. The first and simplest is to 
establish a new subflow as part of the same MPTCP connection, and then close the original one with a RST. Since it is known that 
the path may be compromised, it is not desirable to use MPTCP's segmentation on this path any longer. The 
new subflow will begin and will signal an infinite mapping (indicated by length=0 in the Data Sequence Mapping option, 
<xref target="sec_generalop"/>) from the data sequence number of the segment that failed the checksum.
This connection will then continue to appear as a regular TCP session, and a middlebox may change the 
payload without causing unintentional harm.</t>

        <t>An optimisation is possible, however. --> If it is known that all unacknowledged data in flight is 
contiguous, an infinite mapping can be applied to the subflow without the need to close it first, and 
essentially turn off all further MPTCP signaling. In this case, if a receiver identifies a checksum failure
when there is only one path, it will send back an MP_FAIL option on the subflow-level ACK. The sender will receive
this, and if all unacknowledged data in flight is contiguous, will signal an infinite mapping (if the data
is not contiguous, the sender MUST send an RST). This infinite mapping will be a DSS option (<xref target="sec_generalop"/>)
on the first new packet, containing a Data Sequence Mapping that acts retroactively, referring to the start of the subflow sequence 
number of the last segment that was known to be delivered intact. From that point onwards data can be altered 
by a middlebox without affecting MPTCP, as the data stream is equivalent to a regular, legacy TCP session.</t>

        <t>After a sender signals an infinite mapping it MUST only use subflow ACKs to clear its send buffer.
This is because Data ACKs may become misaligned with the subflow ACKs when middleboxes insert or delete data. 
The receive SHOULD stop generating Data ACKs after it receives an infinite mapping. </t>

        <t>When a connection is in fallback mode, only one subflow can send data at a time. Otherwise, the receiver would not know how to reorder the data; in practice this means that all MPTCP subflows will have to be terminated except one. Once MPTCP falls back to regular TCP, it MUST NOT revert to MPTCP later in the connection.</t>

        <t>It should be emphasised that we are not attempting to prevent the use of middleboxes that want to adjust the payload. An MPTCP-aware middlebox could provide such functionality by also rewriting checksums.</t>
      </section>
      
      <section title="Error Handling" anchor="sec_errors">
        <t>In addition to the fallback mechanism as described above, the standard classes of TCP errors may need to be handled in an MPTCP-specific way. Note that changing semantics - such as the relevance of an RST - are covered in <xref target="sec_semantics"/>. Where possible, we do not want to deviate from regular TCP behaviour.</t>
        <t>The following list covers possible errors and the appropriate MPTCP behaviour:
          <list style="symbols">
            <t>Unknown token in MP_JOIN (or MAC failure in MP_JOIN ACK, or missing MP_JOIN in SYN/ACK response): send RST (analogous to TCP's behaviour on an unknown port)</t>
            <!-- <t>(TBD: If we include DSN in MP_JOIN, and the DSN is out of the window but the token is valid, do we still send an RST?)</t> -->
            <t>DSN out of Window (during normal operation): drop the data, do not send Data ACKs.</t>
            <t>Remove request for unknown address ID: silently ignore</t>
            <!-- <t>DATA_ACK for data not yet sent: abort connection by RST on every subflow.</t> -->
          </list>
        </t>
      </section>

      <section title ="Heuristics" anchor="heuristics">

        <t>There are a number of heuristics that are needed for
        performance or deployment but which are not required for
        protocol correctness.  In this section we detail such
        heuristics. Note that discussion of buffering and certain
        sender and receiver window behaviours are presented in 
        <xref target="sec_rwin"/> and <xref target="sec_sender"/>, 
        as well as retransmission in <xref target="sec_retransmit"/>.</t>

        <section title="Port Usage">
          <t>Under typical operation an MPTCP implementation SHOULD use
          the same ports as already in use. In other words, the
          destination port of a SYN containing an MP_JOIN option SHOULD
          be the same as the remote port of the first subflow in the
          connection.  The local port for such SYNs SHOULD also be the
          same as for the first subflow (and as such, an
          implementation SHOULD reserve ephemeral ports across all
          local IP addresses), although there may be cases where this
          is infeasible.  This strategy is intended to maximize the
          probability of the SYN being permitted by a firewall or NAT
          at the recipient and to avoid confusing any network
          monitoring software.</t> 
            
          <t>There may also be cases, however, where
          the passive opener wishes to signal to the other host  
          that a specific port should be used, and this facility is
          provided in the Add Address option as documented in
          <xref target="sec_add_address"/>.  It is therefore feasible
          to allow multiple subflows between the same two addresses
          but using different port pairs, and 
          such a facility could be used to allow load balancing within
          the network based on 5-tuples (e.g. some ECMP implementations).</t>
        </section>

        <section title="Delayed Subflow Start">
          <t>Many TCP connections are short-lived and consist only of a few 
          segments, and so the overheads 
          of using MPTCP outweigh any benefits. A heuristic is required,
          therefore, to decide when to start using additional subflows in 
          an MPTCP connection. We expect that experience gathered from
          deployments will provide further guidance on this, and will be
          affected by particular application characteristics (which are
          likely to change over time). However, a suggested general-purpose
          heuristic that an implementation MAY choose to employ is as follows.
          Results from experimental deployments are needed in order to verify
          the correctness of this proposal.</t>

          <t>If a host has data buffered for its peer (which implies that the
          application has received a request for data), the host opens one
          subflow for each initial window's worth of data that is buffered.</t>
          
          <t>Consideration should also be given to limiting the rate of adding
          new subflows, as well as limiting the total number of subflows open
          for a particular connection.  A host may choose to vary these values 
          based on its load or knowledge of traffic and path characteristics.</t>

          <t>Note that this heuristic alone is probably insufficient. Traffic
          for many common applications, such as downloads, is highly asymmetric and 
          the host that is multihomed may well be the client which will never fill
          its buffers, and thus never use MPTCP. Advanced APIs that allow an 
          application to signal its traffic requirements would aid in these decisions.</t>

          <t>An additional time-based heuristic could be applied, opening additional
          subflows after a given period of time has passed. This would alleviate the
          above issue, and also provide resilience for low-bandwidth but long-lived
          applications.</t>

          <t>This section has shown some of the considerations that an implementer
          should give when developing MPTCP heuristics, but is not intended to be
          prescriptive.</t>
        </section>

        <section title="Failure Handling">
          <t>Requirements for MPTCP's handling of unexpected signals have been
          given in <xref target="sec_errors"/>. There are other failure cases, 
          however, where a hosts can choose appropriate behaviour.</t>
          
          <t>For example, <xref target="sec_init"/> suggests that a host should
          fall back to trying regular TCP SYNs after several failures of MPTCP
          SYNs. A host may keep a system-wide cache of such information, so that
          it can back off from using MPTCP, firstly for that
          particular destination host, and eventually on a whole interface, if 
          MPTCP connections continue failing. <!-- As an alternative, an approach similar
          to "Happy Eyeballs" for IPv6 <xref target="I-D.ietf-v6ops-happy-eyeballs"/>
          could be suitable, whereby a host tries simultaneous connections using
          both regular TCP and MPTCP, and chooses the one that is first successful,
          dropping the other. Again, over time, the successes or failures of MPTCP
          on various paths could be learnt. --></t>

          <t>Another failure could occur when the MP_JOIN handshake fails.
          <xref target="sec_errors"/> specifies that an incorrect handshake MUST
          lead to the subflow being closed with a RST. A host operating an active
          intrusion detection system may choose to start blocking MP_JOIN packets
          from the source host if multiple failed MP_JOIN attempts are seen. From
          the connection initiator's point of view, if an MP_JOIN fails, it SHOULD
          NOT attempt to connect to the same IP address and port during the lifetime 
          of the connection, unless the other host refreshes the information with 
          another ADD_ADDR option. Note that the ADD_ADDR option is informational 
          only, and does not guarantee the other host will attempt a connection.</t>

          <t>In addition, an implementation may learn over a number of connections 
          that certain interfaces or destination addresses consistently fail and
          may default to not trying to use MPTCP for these.  Behaviour could also 
          be learnt for particularly badly performing subflows or subflows that
          regularly fail during use, in order to temporarily choose not to use 
          these paths.</t>
        </section>

        <!-- What to do with errors? E.g. failed MP_JOIN, then what? Security - when to ignore after how many errors, etc? -->
      </section>
    </section>

    <section title="Semantic Issues" anchor="sec_semantics">
      <t>In order to support multipath operation, the semantics of some TCP components have changed. To aid clarity, this section collects these semantic changes as a reference.
        <list style="hanging">
          <t hangText="Sequence Number:"> The (in-header) TCP sequence
            number is specific to the subflow. To allow the receiver to
            reorder application data, an additional data-level
            sequence space is used. In this data-level sequence space, the initial SYN and
            the final DATA_FIN occupy one octet of sequence space. There is an explicit
            mapping of data sequence space to subflow sequence space,
            which is signalled through TCP options in data
            packets.</t>

          <t hangText="ACK:"> The ACK field in the TCP header
            acknowledges only the subflow sequence number, not the
            data-level sequence space. Implementations SHOULD NOT
            attempt to infer a data-level acknowledgement from the
            subflow ACKs.  Instead an explicit data-level ACK is
            used.  This avoids possible deadlock scenarios when a
            non-TCP-aware middlebox pro-actively ACKs at the subflow
            level, and separates subflow- and connection-level processing
            at an end host.</t>

          <t hangText="Duplicate ACK:"> A duplicate ACK that includes MPTCP signaling
            MUST NOT be treated as a signal of congestion. To avoid any non-MPTCP-aware
            entities also mistakenly seeing duplicate ACKs in such cases, MPTCP SHOULD
            NOT send more than two duplicate ACKs containing MPTCP signals in a row.</t>

          <t hangText="Receive Window:">The receive window in the TCP
            header indicates the amount of free buffer space for the
            whole data-level connection (as opposed to for this
            subflow) that is available at the receiver.  This is the
            same semantics as regular TCP, but to maintain these
            semantics the receive window must be interpreted at the
            sender as relative to the sequence number given in the
            DATA_ACK rather than the subflow ACK in the TCP header.
            In this way the original flow control role is preserved.
            Note that some middleboxes may change the receive window,
            and so a host must use the maximum value of those recently
            seen on the constituent subflows for the connection-level
            receive window, and also need to maintain a subflow-level 
            window for subflow-level processing.</t>

          <t hangText="FIN:"> The FIN flag in the TCP header applies
            only to the subflow it is sent on, not to the whole
            connection. For connection-level FIN semantics, the
            DATA_FIN option is used.</t>

          <t hangText="RST:"> The RST flag in the TCP header applies
            only to the subflow it is sent on, not to the whole
            connection. <!-- A connection is considered reset if a RST is
            received on every subflow. --></t>
<!--There is no connection-level RST, since it would be impossible to distinguish the two, i.e. if there is no state about a subflow, the host cannot know to what connection the subflow is related.-->

          <t hangText="Address List:"> Address list management (i.e. 
            knowledge of the local and remote hosts' lists of 
            available IP addresses) is handled
            on a per-connection basis (as opposed to per-subflow, per
            host, or per pair of communicating hosts).  This permits
            the application of per-connection local policy.  Adding an
            address to one connection (either explicitly through an Add
            Address message, or implicitly through a Join) has no implication 
            for other connections between the same pair of hosts.</t>

          <t hangText="5-tuple:"> The 5-tuple (protocol, local
            address, local port, remote address, remote port)
            presented by kernel APIs to the application layer in a
            non-multipath-aware application is that of the first
            subflow, even if the subflow has since been closed and
            removed from the connection. This decision, and other
            related API issues, are discussed in more detail in
            <xref target="I-D.ietf-mptcp-api"/>.</t>
        </list>
      </t>
    </section>
 
    <section title="Security Considerations" anchor="sec_security">
      <t>As identified in <xref target="RFC6181"/>, the addition of multipath capability to TCP will bring with it a number of new classes of threat. In order to prevent these, <xref target="RFC6182"/> presents a set of requirements for a security solution for MPTCP. The fundamental goal is for the security of MPTCP to be "no worse" than regular TCP today, and the key security requirements are:
        <list style="symbols">
          <t>Provide a mechanism to confirm that the parties in a subflow handshake are the same as in the original connection setup.</t>
          <t>Provide verification that the peer can receive traffic at a new address before using it as part of a connection.</t>
          <t>Provide replay protection, i.e. ensure that a request to add/remove a subflow is 'fresh'.</t>
        </list>
        In order to achieve these goals, MPTCP includes a hash-based handshake algorithm documented in <xref target="sec_init"/> and <xref target="sec_join"/>.</t>

      <t>The security of the MPTCP connection hangs on the use of keys that are shared once at the start of the first subflow, and are never sent again over the network.  To ease demultiplexing whilst not giving away any cryptographic material, future subflows use a truncated SHA-1 hash of this key as the connection identification "token".  The keys are concatenated and used as keys for creating Message Authentication Codes (MAC) used on subflow setup that verify that the parties in the handshake are the same as in the original connection setup.  It also provides verification that the peer can receive traffic at this new address.  Replay attacks would still be possible when only keys are used, and therefore the handshakes use single-use random numbers (nonces) at both ends - this ensures the MAC will never be the same on two handshakes.</t>
      <t>
      The use of crypto capability bits in the initial connection handshake to negotiate use of a particular algorithm will allow the deployment of additional crypto mechanisms in the future. Note that this would be susceptible to bid-down attacks only if the attacker was on-path (and thus would be able to modify the data anyway).
      The security mechanism presented in this draft should therefore protect against all forms of flooding and hijacking attacks discussed in <xref target="RFC6181"/>.</t>


      <!-- <t>The primary area of concern will be around the handshake to start new subflows which join existing connections. The proposal set out in <xref target="sec_init"/> and <xref target="sec_join"/> is for the initiator of the new subflow to include the token of the other endpoint in the handshake. The purpose of this is to indicate that the sender of this token was the same entity that received this token at the initial handshake.</t>
      <t>One area of concern is that the token could be simply brute-forced. The token must be hard to guess, and as such could be randomly generated. This may still not be strong enough, however, and so the use of 64 bits for the token would alleviate this somewhat.</t>
      <t>The two tokens don't need to be the same length.  Token B could be 64 bits and token A 32 bits.  If MP_JOIN always contains Token B, this would provide adequate security while saving scarce space in the initial SYN, where it is most at a premium.</t>
      <t>Use of these tokens only provide an indication that the token is the same as at the initial handshake, and does not say anything about the current sender of the token. Therefore, another approach would be to bring a new measure of freshness in to the handshake, so instead of using the initial token a sender could request a new token from the receiver to use in the next handshake. Hash chains could also be used for this purpose.</t>
      <t>Yet another alternative would be for all SYN packets to include a data sequence number. This could either be used as a passive identifier to indicate an awareness of the current data sequence number (although a reasonable window would have to be allowed for delays). Or, the SYN could form part of the data sequence space - but this would cause issues in the event of lost SYNs (if a new subflow is never established), thus causing unnecessary delays for retransmissions.</t> -->
      <!-- <t>The "Request-FIN" option (if included) is possibly vulnerable to TCP-Reset style attacks, however the presense of the subflow and data-level sequence numbers should provide some level of freshness verification.</t> -->
    </section>

    <section title="Interactions with Middleboxes" anchor="sec_middleboxes">
      
        <t>Multipath TCP was designed to be deployable in the present world. Its design takes into account "reasonable"
existing middlebox behaviour. In this section we outline a few representative middlebox-related failure scenarios and 
show how multipath TCP handles them. Next, we list the design decisions multipath has made to accomodate the different 
middleboxes.</t>

        <t>A primary concern is our use of a new TCP option. Most middleboxes should just forward packets
with new options unchanged, yet there are some that don't. These we expect will either strip options and pass the data, 
drop packets with new options, copy the same option into multiple segments (e.g. when doing segmentation) or drop 
options during segment coalescing.</t>

        <t>MPTCP uses a single new TCP option "Kind", and all message types are defined by "subtype" values (see <xref target="IANA"/>). This should reduce the chances of only some types of MPTCP options being passed, and instead the key differing characteristics are different paths, and the presence of the SYN flag.</t>

        <t>MPTCP SYN packets on the first subflow of a connection contain the MP_CAPABLE option (<xref target="sec_init"/>). If this is dropped, MPTCP SHOULD fall back to regular TCP. If packets with the MP_JOIN option (<xref target="sec_join"/>) are dropped, the paths will simply not be used.</t>

        <t>If a middlebox strips options but otherwise passes the packets unchanged, MPTCP will behave safely. If an MP_CAPABLE option is dropped on either the outgoing or the return path, the initiating host can fall back to regular TCP, as illustred in <xref target="fig_syn"/> and discussed in <xref target="sec_init"/>.</t>

          <t>Subflow SYNs contain the MP_JOIN option. If this option is stripped on the outgoing path 
the SYN will appear to be a regular SYN to host B. Depending on whether there is a listening socket on 
the target port, host B will reply either with SYN/ACK or RST (subflow connection fails). When host A 
receives the SYN/ACK it sends a RST because the SYN/ACK does not contain the MP_JOIN option and its token. 
Either way, the subflow setup fails, but otherwise does not affect the MPTCP connection as a whole.</t>

        <figure align="center" anchor="fig_syn" title="Connection Setup with Middleboxes that Strip Options from Packets">
          <artwork align="left"><![CDATA[
     Host A                             Host B 
      |              Middlebox M            |
      |                   |                 |
      |  SYN(MP_CAPABLE)  |        SYN      |
      |-------------------|---------------->|
      |                SYN/ACK              |
      |<------------------------------------|
  a) MP_CAPABLE option stripped on outgoing path

    Host A                               Host B 
      |            SYN(MP_CAPABLE)          |
      |------------------------------------>|
      |             Middlebox M             |
      |                 |                   |
      |    SYN/ACK      |SYN/ACK(MP_CAPABLE)|
      |<----------------|-------------------|
  b) MP_CAPABLE option stripped on return path
           ]]></artwork>
        </figure>

        <t>We now examine data flow with MPTCP, assuming the flow is correctly setup, which implies the options in the SYN
packets were allowed through by the relevant middleboxes. If options are allowed through and there is no resegmentation or 
coalescing to TCP segments, multipath TCP flows can proceed without problems.</t>

        <t>The case when options get stripped on data packets has been discussed in the Fallback section.
        If a fraction of options are stripped, behaviour is not deterministic. If some Data Sequence Mappings are lost, the connection can continue so long as mappings exist for the subflow-level data (e.g. if multiple maps have been sent that reinforce each other). If some subflow-level space is left unmapped, however, the subflow is treated as broken and is closed, as discussed in <xref target="sec_generalop"/>. MPTCP should survive with a loss of some Data ACKs, but performance will degrade as the fraction of stripped options increases.
We do not expect such cases to appear in practice, though: most 
middleboxes will either strip all options or let them all through.</t>

        <t>We end this section with a list of middlebox classes, their behaviour and the elements in the MPTCP design
that allow operation through such middleboxes. Issues surrounding dropping packets with options
or stripping options were discussed above, and are not included here:
 
        <list style="symbols">
          <t>NATs <xref target="RFC3022"/> (Network Address (and Port) Translators) change the source address (and often source port) of packets. This means that a host will not know its
    public-facing address for signaling in MPTCP. Therefore, MPTCP permits implicit address addition via the MP_JOIN option,
    and the handshake mechanism ensures that connection attempts to private addresses <xref target="RFC1918"/> do not cause problems.
    Explicit address removal is undertaken by an ID number to allow no knowledge of the source address.</t>
    
          <t>Performance Enhancing Proxies (PEPs) <xref target="RFC3135"/> might pro-actively ACK data to increase performance. Problems will
    occur if a PEP ACKs data and then fails before sending it on to the receiver, or if the receiver is mobile and moves away before 
    proactively ACKed data is forwarded on. If subflow ACKs were used to control send buffering, the data could be lost and never be 
    retransmitted, thus causing the subflow to permanently stall. MPTCP therefore uses the DATA_ACK to make progress when one of its 
    subflows fails in this way. This is why MPTCP does not use subflow ACKs to infer connection level ACKs.</t>

          <t>Traffic Normalizers <xref target="norm"/> may not allow holes in sequence numbers, and may cache packets and retransmit the same data.
MPTCP looks like standard TCP on the wire, and will not retransmit different data on the same subflow sequence number.</t>
          
          <t>Firewalls <xref target="RFC2979"/> might perform initial sequence number randomization on TCP connections. MPTCP uses relative 
sequence numbers in data sequence mapping to cope with this. Like NATs, firewalls will not permit many incoming connections, so
MPTCP supports address signaling (ADD_ADDR) so that a multi-addressed host can invite its peer behind the firewall/NAT to connect 
out to its additional interface.</t>

          <t>Intrusion Detection Systems look out for traffic patterns and content that could threaten a network. Multipath
will mean that such data is potentially spread, so it is more difficult for an IDS to analyse the whole traffic, and
potentially increases the risk of false positives. However, for an MPTCP-aware IDS, tokens can be read 
by such systems to correlate multiple subflows and re-assemble for analysis.</t>

          <t>Application level middleboxes such as content-aware firewalls may alter the payload within a subflow, such as re-writing URIs in HTTP traffic. MPTCP will detect these using the checksum
and close the affected subflow(s), if there are other subflows that can be used. If all subflows are affected multipath
will fallback to TCP, allowing such middleboxes to change the payload. MPTCP-aware middleboxes should be able to adjust the payload and MPTCP metadata in order not to break the connection.</t>
        </list>

        In addition, all classes of middleboxes may affect TCP traffic in the following ways:
        <list style="symbols">
          <t>TCP Options may be removed, or packets with unknown options dropped, by many classes of middleboxes. It is intended
that the initial SYN exchange, with a TCP Option, will be sufficient to identify the path capabilities. If such a packet does
not get through, MPTCP will end up falling back to regular TCP.</t>

          <t>Segmentation/Coalescing (e.g. TCP segmentation offloading) might copy options between packets and might
strip some options. MPTCP's data sequence mapping includes the relative subflow sequence number instead of using the sequence
number in the segment. In this way, the mapping is independent of the packets that carry it.</t>

          <t>The Receive Window may be shrunk by some middleboxes at the subflow level. MPTCP will use the maximum window at data-level, but will also obey
subflow specific windows.</t>
        </list>
      </t>
          
    </section>

    <!-- <section title="Interfaces" anchor="sec_interfaces">
      <t>TBD</t>
      <t>Interface with applications, interface with TCP, interface with lower layers...</t>
      <t>Discussion of interaction with applications (both in terms of how MPTCP will affect an application's assumptions of the transport layer, and what API extensions an application may wish to use with MPTCP) are discussed in <xref target="I-D.ietf-mptcp-api"/>.</t>
    </section> -->

<!--     <section title="Open Issues" anchor="sec_openissues">
        <t>This specification is a work-in-progress, and as such there are many issues that are still to be resolved. This section lists many of the key open issues within this specification; these are discussed in more detail in the appropriate sections throughout this document.</t>
        <t>
          <list style="symbols">
            <t>Issues around simultaneous opens, where both ends attempt to create a new subflow simultaneously, need to be investigated and behaviour specified.</t>
            <t>Appropriate mechanisms for controlling policy/priority of subflow usage (specifically regarding controlling incoming traffic, <xref target="sec_policy"/>). Is the 'B' flag for backup paths sufficient, or is there a need for a finer granularity of control?</t>
            <t>How much control do we want over subflows from other subflows (e.g. closing when interface has failed)? Do we want to differentiate between subflows and addresses (<xref target="sec_join"/>)?</t>
            <t>Do we want a connection identifier in every packet? E.g. would it make the implementation of an IDS easier?</t>
            <t>Instead of an Address ID in MP_JOIN, are there any cases where a Subflow ID (i.e. unique to the subflow) would be useful instead? For example, two addresses which become NATted to the same address?</t>          
          </list>
        </t>
      </section> -->

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors were supported by Trilogy (http://www.trilogy-project.org), a research project (ICT-216372) partially funded by the European Community under its Seventh Framework Program.  The views expressed here are those of the author(s) only.  The European Commission is not liable for any use that may be made of the information in this document.</t>
      <t>Alan Ford was supported by Roke Manor Research.</t>
      <t>The authors gratefully acknowledge significant input into this document from S&eacute;bastien Barr&eacute;, Christoph Paasch, and Andrew McDonald.</t>
      <t>The authors also wish to acknowledge reviews and contributions from Iljitsch van Beijnum, Lars Eggert, Marcelo Bagnulo, Robert Hancock, Pasi Sarolahti, Toby Moncaster, Philip Eardley, Sergio Lembo, Lawrence Conroy, Yoshifumi Nishida, Bob Briscoe, Stein Gjessing, Andrew McGregor, Georg Hampel, and Anumita Biswas.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This document will make a request to IANA to allocate a new TCP option value for MPTCP. This value will be the value of the "Kind" field seen in all MPTCP options in this document.</t>

      <t>This document will also request IANA operates a registry for MPTCP option subtype values. The values as defined by this specification are as follows:</t>
      <texttable anchor="table_iana" title="MPTCP Option Subtypes">
        <ttcol align="center">Symbol</ttcol>
        <ttcol align="center">Name</ttcol>
        <ttcol align="center">Ref</ttcol>
        <ttcol align="center">Value</ttcol>

        <c>MP_CAPABLE</c>
        <c>Multipath Capable</c>
        <c><xref target="sec_init"/></c>
        <c>0x0</c>
        
        <c>MP_JOIN</c>
        <c>Join Connection</c>
        <c><xref target="sec_join"/></c>
        <c>0x1</c>
        
        <c>DSS</c>
        <c>Data Sequence Signal (Data ACK and Data Sequence Mapping)</c>
        <c><xref target="sec_generalop"/></c>
        <c>0x2</c>

        <c>ADD_ADDR</c>
        <c>Add Address</c>
        <c><xref target="sec_add_address"/></c>
        <c>0x3</c>
        
        <c>REMOVE_ADDR</c>
        <c>Remove Address</c>
        <c><xref target="sec_remove_addr"/></c>
        <c>0x4</c>

        <c>MP_PRIO</c>
        <c>Change Subflow Priority</c>
        <c><xref target="sec_policy"/></c>
        <c>0x5</c>

        <c>MP_FAIL</c>
        <c>Fallback</c>
        <c><xref target="sec_fallback"/></c>
        <c>0x6</c>
      </texttable>

      <t>This document also requests that IANA keeps a registry of cryptographic handshake algorithms based on the flags in MP_CAPABLE (<xref target="sec_init"/>). This document specifies only one algorithm:</t>
      <texttable anchor="table_crypto" title="MPTCP Handshake Algorithms">
        <ttcol align="center">Flags</ttcol>
        <ttcol align="center">Algorithm</ttcol>
        <ttcol align="center">Document</ttcol>

        <c>0x1</c>
        <c>HMAC-SHA1</c>
        <c>This document, <xref target="sec_join"/></c>
      </texttable>

    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;
    </references>

    <references title="Informative References">
      &RFC0793;
      &RFC1122;
      &RFC1323;
      &RFC1918;
      &RFC2018;
      &RFC2104;
      &RFC2581;
      &RFC2979;
      &RFC3022;
      &RFC3135;
      &RFC3168;
      &RFC4086;
      &RFC4634;

      &RFC6181;
      &RFC6182;
      &RFC6356;

      &MPAPI;

      &TCPSEC;

      <!-- &EYEBALLS; -->

<reference anchor='norm' target="http://www.usenix.org/events/sec01/full_papers/handley/handley.pdf"><front><title abbrev="Network Intrusion Detection: Evasion, Traffic Normalization, and End-to-End Protocol Semantics ">Network Intrusion Detection: Evasion, Traffic Normalization, and End-to-End Protocol Semantics</title><author initials='M.' surname='Handley' fullname='Mark Handley'><organization>ACIRI</organization></author><author initials='V.' surname='Paxson' fullname='Vern Paxson'><organization>ACIRI</organization></author><author initials='C.' surname='Kreibich' fullname='Christian Kreibich'><organization>Technische Universitat Munchen</organization></author><date year="2001"/></front><seriesInfo name="Usenix Security" value="2001"/></reference>

</references>

    <section title="Notes on use of TCP Options" anchor="app_options">
      <t>The TCP option space is limited due to the length of the Data Offset field in the TCP header (4 bits), which defines the TCP header length in 32 bit words. With the standard TCP header being 20 bytes, this leaves a maximum of 40 bytes for options, and many of these may already be used by options such as timestamp and SACK.</t>

      <t>We have performed a brief study on the commonly used TCP options in SYN, data, and pure ACK packets, and found that there is enough room to fit all the options we propose using in this draft.</t>

      <t>SYN packets typically include MSS (4 bytes), window scale (3 bytes), SACK permitted (2 bytes) and timestamp (10 bytes) options. Together these sum to 19 bytes. Some operating systems appear to pad each option up to a word boundary, thus using 24 bytes (a brief survey suggests Windows XP and Mac OS X do this, whereas Linux does not).

      Optimistically, therefore, we have 21 bytes spare, or 16 if it has to be word-aligned. In either case, however, the SYN versions of Multipath Capable (12 bytes) and Join (12 or 16 bytes) options will fit in this remaining space.</t>

      <t>TCP data packets typically carry timestamp options in every packet, taking 10 bytes (or 12 with padding). That leaves 30 bytes (or 28, if word-aligned). The Data Sequence Signal (DSS) option varies in length depending on whether the Data Sequence Mapping and DATA ACK are included, and whether the sequence numbers in use are 4 or 8 octets. The maximum size of the DSS option is 28 bytes, so even that will fit in the available space. But unless a connection is both bi-directional and high-bandwidth, it is unlikely that all that option space will be required on each DSS option.</t>

      <t>It is not necessary to include the Data Sequence Mapping and DATA ACK in each packet, and in many cases it may be possible to alternate their presence (so long as the mapping covers the data being sent in the following packet). Other options include: alternating between 4 and 8 byte sequence numbers in each option; and sending the DATA_ACK on a duplicate subflow-level ACK (although note that this must not be taken as a signal of congestion).</t>

      <t>On subflow and connection setup, an MPTCP option is also set on the third packet (an ACK). These are 20 bytes (for Multipath Capable) and 24 bytes (for Join), both of which will fit in the available option space.</t>

      <t>Pure ACKs in TCP typically contain only timestamps (10B). Here, multipath TCP typically 
needs to encode only the DATA ACK (maximum of 12 octets). Occasionally ACKs will contain SACK information. Depending 
on the number of lost packets, SACK may utilize the entire option space. If a DATA ACK had to be
included, then it is probably necessary to reduce the number of SACK blocks to accomodate the 
DATA ACK. However, the presence of the DATA ACK is unlikely to be necessary in a case where SACK is
in use, since until at least some of the SACK blocks have been retransmitted, the cumulative
data-level ACK will not be moving forward (or if it does, due to retransmissions on another path, 
then that path can also be used to transmit the new DATA ACK).</t>

      <t>The ADD_ADDR option can be between 8 and 22 bytes, depending on whether IPv4 or IPv6 is used, and whether the port number is present or not. It is unlikely that such signaling would fit in a data packet (although if there is space, it is fine to include it). It is recommended to use duplicate ACKs with no other payload or options in order to transmit these rare signals. Note this is the reason for mandating that duplicate ACKs with MPTCP options are not taken as a signal of congestion.</t>

      <t>Finally, there are issues with reliable delivery of options. As options can also be sent on pure ACKs, these 
are not reliably sent. This is not an issue for DATA_ACK due to their
cumulative nature, but may be an issue for ADD_ADDR/REMOVE_ADDR options. Here, it is recommended 
to send these options redundantly (whether on multiple paths, or on the same path on a number
of ACKs - but interspersed with data in order to avoid interpretation as congestion). The cases where options are stripped by middleboxes are discussed in <xref target="sec_middleboxes"/>.</t>
    </section>

    <section title="Control Blocks" anchor="app_tcb">
<t>Conceptually, an MPTCP connection can be represented as an MPTCP control
block that contains several variables that track the progress and the
state of the MPTCP connection and a set of linked TCP control blocks
that correspond to the subflows that have been established.</t>

<t>RFC793 <xref target="RFC0793"/> specifies several state variables. Whenever possible, we reuse
the same terminology as RFC793 to describe the state variables that are
maintained by MPTCP.</t>

<section title="MPTCP Control Block">
<t>The MPTCP control block contains the following variable per-connection.</t>

<section title="Authentication and Metadata">
<t><list style="hanging">
<t hangText="Local.Token (32 bits):"> This is the token chosen by the local host on
this MPTCP connection. The token MUST be unique among all established
MPTCP connections, generated from the local key.</t>
<t hangText="Local.Key (64 bits):"> This is the key sent by the local host on this
MPTCP connection.</t>
<t hangText="Remote.Token (32 bits):"> This is the token chosen by the remote host on
this MPTCP connection, generated from the remote key.</t>
<t hangText="Remote.Key (64 bits):"> This is the key chosen by the remote host on
this MPTCP connection</t>
<t hangText="MPTCP.Checksum (flag):"> This flag is set to true if at least one of the 
hosts has set the C bit in the MP_CAPABLE options exchanged during connection establishment, 
and is set to false otherwise.  If this flag is set, the checksum must be computed in
all DSS options.</t>
</list></t>
</section>


<section title="Sending Side">
<t><list style="hanging">
<t hangText="SND.UNA (64 bits):"> This is the Data Sequence Number of the next byte to be
acknowledged, at the MPTCP connection level. This variable is updated
upon reception of a DSS option containing a DATA_ACK.</t>
<t hangText="SND.NXT (64 bits):"> This is the Data Sequence Number of the next byte to be
sent. SND.NXT is used to determine the value of the DSN in the DSS option.</t>
<t hangText="SND.WND (32 bits with RFC1323, 16 bits without):"> This is the sending window. MPTCP
maintains the sending window at the MPTCP connection level and the same
window is shared by all subflows. All subflows use the MPTCP connection
level SND.WND to compute the SEQ.WND value which is sent in each
transmitted segment.</t>
</list></t>
</section>

<section title="Receiving Side">
<t><list style="hanging">
<t hangText="RCV.NXT (64 bits):"> This is the Data Sequence Number of the next byte which
is expected on the MPTCP connection. This state variable is modified
upon reception of in-order data. The value of RCV.NXT is used to specify
the DATA_ACK which is sent in the DSS option on all subflows.</t>
<t hangText="RCV.WND (32bits with RFC1323, 16 bits otherwise):"> This is the connection-level
receive window, which is the maximum of the RCV.WND on all the subflows.</t>
</list></t>
</section>
</section>

<section title="TCP Control Blocks">
<t>The MPTCP control block also contains a list of the TCP control blocks
that are associated to the MPTCP connection.</t>

<t>Note that the TCP control block on the TCP subflows does not contain the
RCV.WND and SND.WND state variables as these are maintained at the MPTCP
connection level and not at the subflow level.</t>

<t>Inside each TCP control block, the following state variables are defined:</t>

<section title="Sending Side">
<t><list style="hanging">
<t hangText="SND.UNA (32 bits):"> This is the sequence number of the next byte to be
acknowledged on the subflow. This variable is updated upon reception of
each TCP acknowledgement on the subflow.</t>
<t hangText="SND.NXT (32 bits):"> This is the sequence number of the next byte to be
sent on the subflow. SND.NXT is used to set the value of SEG.SEQ upon
transmission of the next segment.</t>
</list></t>
</section>

<section title="Receiving Side">
<t><list style="hanging">
<t hangText="RCV.NXT (32 bits):"> This is the sequence number of the next byte which
is expected on the subflow. This state variable is modified upon
reception of in-order segments. The value of RCV.NXT is copied to the
SEG.ACK field of the next segments transmitted on the subflow.</t>
<t hangText="RCV.WND (32 bits with RFC1323, 16 bits otherwise):"> This is the 
subflow-level receive window which is updated with the window field from the 
segments received on this subflow.</t>
</list></t>
</section>
</section>

</section>

    <!-- <section title="Resync Packet" anchor="sec_resync">
      <t>In earlier versions of this draft, we proposed the use of a "re-sync" option that would be used in certain circumstances when a sender needs to instruct the receiver to skip over certain subflow sequence numbers (i.e. to treat the specified sequence space as having been received and acknowledged).</t>
      <t>The typical use of this option will be when packets are retransmitted on different subflows, after failing to be acknowledged on the original subflow. In such a case, it becomes necessary to move forward the original subflow's sequence numbering so as not to later transmit different data with a previously used sequence number (i.e. when more data comes to be transmitted on the original subflow, it would be different data, and so must not be sent with previously-used (but unacknowledged) sequence numbering).</t>
      <t>The rationale for needing to do this is two-fold: firstly, when ACKs are received they are for the subflow only, and the sender infers from this the data that was sent - if the same sequence space could be occupied by different data, the sender won't know whether the intended data was received. Secondly, certain classes of middleboxes may cache data and not send the new data on a previously-seen sequence number.</t>
      <t>This option was dropped, however, since some middleboxes may get confused when they meet a hole in the sequence space, and do not understand the resync option. It is therefore felt that the same data must continue to be retransmitted on a subflow even if it is already received after being retransmitted on another. There should not be a significant performance hit from this since the amount of data involved and needing to be retransmitted multiple times will be relatively small.</t>
    </section> -->

    <section title="Finite State Machine" anchor="app_fsm">
      <t>The diagram in <xref target="fig_fsm"/> shows the Finite State Machine for connection-level closure.  This illustrates how the DATA_FIN connection-level signal interacts with subflow-level FINs, and permits "break-before-make" handover between subflows.</t>

      <figure align="center" anchor="fig_fsm" title="Finite State Machine for Connection Closure">
        <artwork align="left"><![CDATA[
                              +---------+
                              | M_ESTAB |
                              +---------+
                     M_CLOSE    |     |    rcv DATA_FIN
                      -------   |     |    -------
 +---------+       snd DATA_FIN /       \   snd DATA_ACK    +---------+
 |  M_FIN  |<-----------------           ------------------>| M_CLOSE |
 | WAIT-1  |---------------------------                     |   WAIT  |
 +---------+               rcv DATA_FIN \                   +---------+
   | rcv DATA_ACK[DFIN]         ------- |                  M_CLOSE |
   | --------------        snd DATA_ACK |                  ------- |
   | CLOSE all subflows                 |             snd DATA_FIN |
   V                                    V                          V
 +-----------+              +-----------+                 +-----------+
 |M_FINWAIT-2|              | M_CLOSING |                 | M_LAST-ACK|
 +-----------+              +-----------+                 +-----------+
   |              rcv DATA_ACK[DFIN] |          rcv DATA_ACK[DFIN] |
   | rcv DATA_FIN     -------------- |              -------------- |
   |  -------     CLOSE all subflows |          CLOSE all subflows |
   | snd DATA_ACK[DFIN]              V                             V
   \                          +-----------+                 +---------+
     ------------------------>|M_TIME WAIT|---------------->| M_CLOSED|
                              +-----------+                 +---------+
                                         All subflows in CLOSED
                                             ------------
                                         delete MPTCP PCB
         ]]></artwork>
      </figure>
    </section>

    <section title="Changelog">
      <t>This section maintains logs of significant changes made to this document between versions.</t>
       <section title="Changes since draft-ietf-mptcp-multiaddressed-04">
         <t>
           <list style="symbols">
             <t>Reverted change to MP_CAPABLE from last revision.</t>
             <t>Clarifications in response to comments.</t>
           </list>
         </t>
       </section>
       <section title="Changes since draft-ietf-mptcp-multiaddressed-03">
         <t>
           <list style="symbols">
             <t>Removed Key from MP_CAPABLE on SYN (it is in the ACK).</t>
             <t>Added optional Address ID to MP_PRIO.</t>
             <t>Responded to review comments.</t>
           </list>
         </t>
       </section>
       <section title="Changes since draft-ietf-mptcp-multiaddressed-02">
         <t>
           <list style="symbols">
             <t>Changed to using a single TCP option with a sub-type field.</t>
             <t>Merged Data Sequence Number, DATA ACK, and DATA FIN.</t>
             <t>Changed DATA FIN behaviour (separated from subflow FIN).</t>
             <t>Added crypto agility and checksum negotiation.</t>
             <t>Redefined MP_JOIN handshake to use only three TCP options.</t>
             <t>Added pseudo-header to checksum.</t>
             <t>Many clarifications and re-structuring.</t>
             <t>Added more discussion on heuristics.</t>
           </list>
         </t>
       </section>
       <section title="Changes since draft-ietf-mptcp-multiaddressed-01">
         <t>
           <list style="symbols">
             <t>Added proposal for hash-based security mechanism.</t>
             <t>Added receiver subflow policy control (backup path flags and MP_PRIO option).</t>
             <t>Changed DSN_MAP checksum to use the TCP checksum algorithm.</t>
           </list>
         </t>
       </section>
       <section title="Changes since draft-ietf-mptcp-multiaddressed-00">
         <t>
           <list style="symbols">
             <t>Various clarifications and minor re-structuring in response to comments.</t>
           </list>
         </t>
       </section>
       <section title="Changes since draft-ford-mptcp-multiaddressed-03">
         <t>
           <list style="symbols">
             <t>Clarified handshake mechanism, especially with regard to error cases (<xref target="sec_join"/>).</t>
             <t>Added optional port to ADD_ADDR and clarified situation with private addresses (<xref target="sec_add_address"/>).</t>
             <t>Added path liveness check to REMOVE_ADDR (<xref target="sec_remove_addr"/>).</t>
             <t>Added chunk checksumming to DSN_MAP (<xref target="sec_dsn"/>) to detect payload-altering middleboxes, and defined fallback mechanism (<xref target="sec_fallback"/>).</t>
             <t>Major clarifications to receive window discussion (<xref target="sec_sender"/>).</t>
             <t>Various textual clarifications, especially in examples.</t>
           </list>
         </t>
       </section>
      <section title="Changes since draft-ford-mptcp-multiaddressed-02">
        <t>
          <list style="symbols">
            <t>Remove Version and Address ID in MP_CAPABLE in <xref target="sec_init"/>, and make ISN be 6 bytes.</t>
            <t>Data sequence numbers are now always 8 bytes.  But in some cases where it is unambiguous it is permissible to only send the lower 4 bytes if space is at a premium.</t>
            <t>Clarified behaviour of MP_JOIN in <xref target="sec_join"/>.</t>
            <t>Added DATA_ACK to <xref target="sec_generalop"/>.</t>
            <t>Clarified fallback to non-multipath once a non-MP-capable SYN is sent.</t>
          </list>
        </t>
      </section>
    </section>
 

    <!-- <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section> -->

  </back>
</rfc>

