<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3654 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3654.xml">
<!ENTITY RFC3746 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3746.xml">
<!ENTITY RFC5657 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5657.xml">
<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
<!ENTITY FORCES-OPENFLOW-LIB SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-haleplidis-forces-openflow-lib-01.xml">
<!ENTITY RFC5812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5812.xml">
<!ENTITY RFC5810 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5810.xml">
<!ENTITY RFC5811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5811.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- Start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-haleplidis-forces-model-extension-00" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="ForCES Model Extension">ForCES Model Extension</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

		<author fullname="Evangelos Haleplidis" initials="E.H." surname="Haleplidis">
			<organization>University of Patras</organization>
			<address>
				<postal>
					<street>Department of Electrical and Computer Engineering</street>
					<!-- Reorder these if your country does things differently -->
					<city>Patras</city>
					<region/>
					<code>26500</code>
					<country>Greece</country>
				</postal>
				<email>ehalep@ece.upatras.gr</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
    
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->
    <date year="2012" />

    <area>Routing</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>ForCES</keyword>
    <keyword>Model</keyword>
    <keyword>Extension</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t> Forwarding and Control Element Separation (ForCES) defines an
      architectural framework and associated protocols to standardize
      information exchange between the control plane and the forwarding
      plane in a ForCES Network Element (ForCES NE).  RFC5812 has defined
      the ForCES Model provides a formal way to represent the capabilities, 
      state, and configuration of forwarding elements within the context of 
      the ForCES protocol, so that control elements (CEs) can control the FEs 
      accordingly. More specifically, the model describes the logical functions 
      that are present in an FE, what capabilities these functions support, and 
      how these functions are or can be interconnected.</t>
      <t>RFC5812 has been around for two years and experience in its use has shown
      room for extensions without a need to alter the protocol while retaining
      backward compatibility with older xml libraries.</t>
    </abstract>
  </front>

  <middle>
    <section title="Terminology and Conventions">
      <t/>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>
      </section>
  <section title="Definitions">
	<t> This document follows the terminology defined by the ForCES
   Model in <xref target="RFC5812"></xref>.
   The required definitions are repeated below for clarity.</t>
  
      <t><list style="hanging">
      
<t>FE Model - The FE model is designed to model the logical processing
functions of an FE. The FE model proposed in this document
includes three components; the LFB modeling of individual Logical
Functional Block (LFB model), the logical interconnection between
LFBs (LFB topology), and the FE-level attributes, including FE
capabilities. The FE model provides the basis to define the
information elements exchanged between the CE and the FE in the
ForCES protocol [RFC5810].</t>
<t>LFB (Logical Functional Block) Class (or type) - A template that
represents a fine-grained, logically separable aspect of FE
processing. Most LFBs relate to packet processing in the data
path. LFB classes are the basic building blocks of the FE model.</t>
<t>LFB Instance - As a packet flows through an FE along a data path, it
flows through one or multiple LFB instances, where each LFB is an
instance of a specific LFB class. Multiple instances of the same
LFB class can be present in an FE's data path. Note that we often
refer to LFBs without distinguishing between an LFB class and LFB
instance when we believe the implied reference is obvious for the
given context.</t>
<t>LFB Model - The LFB model describes the content and structures in an
LFB, plus the associated data definition. XML is used to provide
a formal definition of the necessary structures for the modeling.
Four types of information are defined in the LFB model. The core
part of the LFB model is the LFB class definitions; the other
three types of information define constructs associated with and
used by the class definition. These are reusable data types,
supported frame (packet) formats, and metadata.</t>
<t>Element - Element is generally used in this document in accordance
with the XML usage of the term. It refers to an XML tagged part
of an XML document. For a precise definition, please see the full
set of XML specifications from the W3C. This term is included in
this list for completeness because the ForCES formal model uses
XML.</t>
<t>Attribute - Attribute is used in the ForCES formal modeling in
accordance with standard XML usage of the term, i.e., to provide
attribute information included in an XML tag.</t>
<t>LFB Metadata - Metadata is used to communicate per-packet state from
one LFB to another, but is not sent across the network. The FE
model defines how such metadata is identified, produced, and
consumed by the LFBs, but not how the per-packet state is
implemented within actual hardware. Metadata is sent between the
FE and the CE on redirect packets.</t>
<t>ForCES Component - A ForCES Component is a well-defined, uniquely
identifiable and addressable ForCES model building block. A
component has a 32-bit ID, name, type, and an optional synopsis
description. These are often referred to simply as components.
LFB Component - An LFB component is a ForCES component that defines
the Operational parameters of the LFBs that must be visible to the
CEs.</t>
<t>LFB Class Library - The LFB class library is a set of LFB classes
that has been identified as the most common functions found in
most FEs and hence should be defined first by the ForCES Working
Group.</t>
		</list></t>
    </section>

    </section>

  <section title="Introduction">
    <t>The <xref target="RFC5812">ForCES Model</xref> presents a formal way to define FEs Logical Function Blocks (LFBs) using XML. <xref target="RFC5812"></xref> has been published a litlte more than two years and current experience in its use has shown some room for adding new and changing existing modeling concepts.</t>
    <t>This document extends the ForCES Model by changing and adding new concepts. These extensions do not require any changes on the <xref target="RFC5810">ForCES protocol</xref> as they are simply changes of the schema definition. Additionally backward compatibility is ensured as xml libraries produced with the earlier schema are still valid with the new one.</t>
  </section>
  <section title="ForCES Model Extension overview">
    <t>The folowing extensions are considered:</t>
    <t><list style="numbers">
      <t>Allow complex metadata.</t>
      <t>Allow optional default values for datatypes and metadata.</t>
      <t>Change from mandatory to optional the frame produced in the output port of LFBs.</t>
      <t>Strengthen the XML validation.</t>
    </list></t>
  </section>
  <section title="Extensions">
    <t>Some of these extensions were product of the work done on the <xref target="I-D.haleplidis-forces-openflow-lib">OpenFlow library</xref> document.</t>
    <section title="Complex Metadata">
      <t>Section 4.6. (Element for Metadata Definitions) in the <xref target="RFC5812">ForCES Model</xref> limits the datatype use in metadata to only atomic types.</t>
      <t>With this extension, complex data types are also allowed, specifically structs and arrays as metadata. A simple use case can be seen in the <xref target="OpenFlowSpec1.1">OpenFlow switch</xref> where exists the Action Set metadata which is an array.</t>
    </section>
    <section title="DataType and Metadata Optional Default Value">
      <t>In the original schema, default values can be defined only in datatypes defined inside LFB components. However when it's a complex datatype or it's a refered datatype, using the default value field is difficult to be used. Additionally there is no option in a complex datatype to use the default value field for only one component in the complex datatype.</t>
      <t>This extension allows optionally to add default values to atomic and typeref types, whether they are as simple or complex datatypes. A simple use case would be to have a struct component where one of the components is a counter which the default value would be zero. The same applies to metadata.</t>
    </section>
    <section title="Optional Frame Produced">
      <t>In the original schema, frame expected in LFB inputs is optional, but frame produced in LFB outputs is mandatory. There is a case in the <xref target="OpenFlowSpec1.1">OpenFlow switch</xref> where the OpenFlow switch buffers the packet and sends only part of it to the controller with a Buffer ID as metadata. In this case the input port of the Redirect LFB will not expect any packets but only metadata. The LFB that performs the buffering will only send metadata and not the packet.</t>
    </section>
    <section title="Strengthen XML Validation">
      <t>The following validation rules have been inserted in the original schema in <xref target="RFC5812"></xref>:</t>
      <t><list style="numbers">
        <t>Each metadata ID must be unique. This validation rule checks only within the xml file.</t>
        <t>LFB Class IDs must be unique. This validataion rule checks only within the xml file.</t>
        <t>Component ID, Capability ID and Event Base ID must be unique per LFB.</t>
        <t>Event IDs must be unique per LFB.</t>
        <t>Special Values in Atomic datatypes must be unique per atomic datatype.</t>
      </list></t>
    </section>
  </section>
  <section title="XML Extension Schema for LFB Class Library Documents">
      <t>
        <figure title="OpenFlow XML Library" align="left">
          <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
xmlns:lfb="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
targetNamespace="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
elementFormDefault="qualified" attributeFormDefault="unqualified">
  <xsd:annotation>
    <xsd:documentation xml:lang="en">
        Schema for Defining LFB Classes and associated types (frames,
        data types for LFB attributes, and metadata).
        </xsd:documentation>
  </xsd:annotation>
  <xsd:element name="description" type="xsd:string"/>
  <xsd:element name="synopsis" type="xsd:string"/>
  <!-- Document root element: LFBLibrary -->
  <xsd:element name="LFBLibrary">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="description" minOccurs="0"/>
        <xsd:element name="load" type="loadType" minOccurs="0" 
        maxOccurs="unbounded"/>
        <xsd:element name="frameDefs" type="frameDefsType" 
        minOccurs="0"/>
        <xsd:element name="dataTypeDefs" type="dataTypeDefsType" 
        minOccurs="0"/>
        <xsd:element name="metadataDefs" type="metadataDefsType" 
        minOccurs="0"/>
        <xsd:element name="LFBClassDefs" type="LFBClassDefsType" 
        minOccurs="0"/>
      </xsd:sequence>
      <xsd:attribute name="provides" type="xsd:Name" use="required"/>
    </xsd:complexType>
    <!-- Uniqueness constraints -->
    <xsd:key name="frame">
      <xsd:selector xpath="lfb:frameDefs/lfb:frameDef"/>
      <xsd:field xpath="lfb:name"/>
    </xsd:key>
    <xsd:key name="dataType">
      <xsd:selector xpath="lfb:dataTypeDefs/lfb:dataTypeDef"/>
      <xsd:field xpath="lfb:name"/>
    </xsd:key>
    <xsd:key name="metadataDef">
      <xsd:selector xpath="lfb:metadataDefs/lfb:metadataDef"/>
      <xsd:field xpath="lfb:name"/>
    </xsd:key>
    <xsd:key name="metadataDefID">
      <xsd:selector xpath="lfb:metadataDefs/lfb:metadataDef"/>
      <xsd:field xpath="lfb:metadataID"/>
    </xsd:key>
    <xsd:key name="LFBClassDef">
      <xsd:selector xpath="lfb:LFBClassDefs/lfb:LFBClassDef"/>
      <xsd:field xpath="lfb:name"/>
    </xsd:key>
    <xsd:key name="LFBClassDefID">
      <xsd:selector xpath="lfb:LFBClassDefs/lfb:LFBClassDef"/>
      <xsd:field xpath="@LFBClassID"/>
    </xsd:key>
  </xsd:element>
  <xsd:complexType name="loadType">
    <xsd:attribute name="library" type="xsd:Name" use="required"/>
    <xsd:attribute name="location" type="xsd:anyURI" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="frameDefsType">
    <xsd:sequence>
      <xsd:element name="frameDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="dataTypeDefsType">
    <xsd:sequence>
      <xsd:element name="dataTypeDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element name="derivedFrom" type="xsd:NMTOKEN" 
            minOccurs="0"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <!--
         Predefined (built-in) atomic data-types are:
             char, uchar, int16, uint16, int32, uint32, int64, uint64,
             string[N], string, byte[N], boolean, octetstring[N],
             float32, float64
      -->
  <xsd:group name="typeDeclarationGroup">
    <xsd:choice>
      <!-- Extension -->
      <xsd:sequence>
        <!-- /Extension -->
        <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
        <!-- Extension -->
        <xsd:element name="DefaultValue" type="xsd:token" 
        minOccurs="0"/>
      </xsd:sequence>
      <!-- /Extension -->
      <xsd:element name="atomic" type="atomicType"/>
      <xsd:element name="array" type="arrayType">
        <!-- Extension -->
        <!--declare keys to have unique IDs -->
        <xsd:key name="contentKeyID">
          <xsd:selector xpath="lfb:contentKey"/>
          <xsd:field xpath="@contentKeyID"/>
        </xsd:key>
        <!-- /Extension -->
      </xsd:element>
      <xsd:element name="struct" type="structType">
        <!-- Extension -->
        <!-- key declaration to make componentIDs unique in a struct
            -->
        <xsd:key name="structComponentID">
          <xsd:selector xpath="lfb:component"/>
          <xsd:field xpath="@componentID"/>
        </xsd:key>
        <!-- /Extension -->
      </xsd:element>
      <xsd:element name="union" type="structType"/>
      <xsd:element name="alias" type="typeRefNMTOKEN"/>
    </xsd:choice>
  </xsd:group>
  <xsd:simpleType name="typeRefNMTOKEN">
    <xsd:restriction base="xsd:token">
      <xsd:pattern value="\c+"/>
      <xsd:pattern value="string\[\d+\]"/>
      <xsd:pattern value="byte\[\d+\]"/>
      <xsd:pattern value="octetstring\[\d+\]"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="atomicType">
    <xsd:sequence>
      <xsd:element name="baseType" type="typeRefNMTOKEN"/>
      <xsd:element name="rangeRestriction" type="rangeRestrictionType"
       minOccurs="0"/>
      <xsd:element name="specialValues" type="specialValuesType" 
      minOccurs="0">
        <!-- Extension -->
        <xsd:key name="SpecialValue">
          <xsd:selector xpath="specialValue"/>
          <xsd:field xpath="@value"/>
        </xsd:key>
        <!-- /Extension -->
      </xsd:element>
      <!-- Extension -->
      <xsd:element name="defaultValue" type="xsd:token" minOccurs="0"/>
      <!-- /Extension -->
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="rangeRestrictionType">
    <xsd:sequence>
      <xsd:element name="allowedRange" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:attribute name="min" type="xsd:integer" use="required"/>
          <xsd:attribute name="max" type="xsd:integer" use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="specialValuesType">
    <xsd:sequence>
      <xsd:element name="specialValue" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
          </xsd:sequence>
          <xsd:attribute name="value" type="xsd:token"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="arrayType">
    <xsd:sequence>
      <xsd:group ref="typeDeclarationGroup"/>
      <xsd:element name="contentKey" minOccurs="0" 
      maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="contentKeyField" type="xsd:string"
             maxOccurs="unbounded"/>
          </xsd:sequence>
          <xsd:attribute name="contentKeyID" type="xsd:integer"
           use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="type" use="optional" default="variable-size">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="fixed-size"/>
          <xsd:enumeration value="variable-size"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="length" type="xsd:integer" use="optional"/>
    <xsd:attribute name="maxLength" type="xsd:integer" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="structType">
    <xsd:sequence>
      <xsd:element name="derivedFrom" type="typeRefNMTOKEN"
       minOccurs="0"/>
      <xsd:element name="component" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
          <xsd:attribute name="componentID" type="xsd:unsignedInt"
           use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="metadataDefsType">
    <xsd:sequence>
      <xsd:element name="metadataDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="metadataID" type="xsd:integer"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:choice>
              <!-- Extension -->
              <xsd:sequence>
                <!-- /Extension -->
                <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
                <!-- Extension -->
                <xsd:element name="DefaultValue" type="xsd:token"
                 minOccurs="0"/>
              </xsd:sequence>
              <!-- /Extension -->
              <xsd:element name="atomic" type="atomicType"/>
              <xsd:element name="array" type="arrayType">
                <!-- Extension -->
                <!--declare keys to have unique IDs -->
                <xsd:key name="contentKeyID1">
                  <xsd:selector xpath="lfb:contentKey"/>
                  <xsd:field xpath="@contentKeyID"/>
                </xsd:key>
                <!-- /Extension -->
              </xsd:element>
              <xsd:element name="struct" type="structType">
                <!-- Extension -->
                <!-- key declaration to make componentIDs unique in
                 a struct -->
                <xsd:key name="structComponentID1">
                  <xsd:selector xpath="lfb:component"/>
                  <xsd:field xpath="@componentID"/>
                </xsd:key>
                <!-- /Extension -->
              </xsd:element>
            </xsd:choice>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="LFBClassDefsType">
    <xsd:sequence>
      <xsd:element name="LFBClassDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="version" type="versionType"/>
            <xsd:element name="derivedFrom" type="xsd:NMTOKEN"
             minOccurs="0"/>
            <xsd:element name="inputPorts" type="inputPortsType"
             minOccurs="0"/>
            <xsd:element name="outputPorts" type="outputPortsType"
             minOccurs="0"/>
            <xsd:element name="components" type="LFBComponentsType"
             minOccurs="0"/>
            <xsd:element name="capabilities" type="LFBCapabilitiesType"
             minOccurs="0"/>
            <xsd:element name="events" type="eventsType" minOccurs="0"/>
            <xsd:element ref="description" minOccurs="0"/>
          </xsd:sequence>
          <xsd:attribute name="LFBClassID" type="xsd:unsignedInt"
           use="required"/>
        </xsd:complexType>
        <!-- Key constraint to ensure unique attribute names within
                 a class:
            -->
        <xsd:key name="components">
          <xsd:selector xpath="lfb:components/lfb:component"/>
          <xsd:field xpath="lfb:name"/>
        </xsd:key>
        <xsd:key name="capabilities">
          <xsd:selector xpath="lfb:capabilities/lfb:capability"/>
          <xsd:field xpath="lfb:name"/>
        </xsd:key>
        <xsd:key name="events">
          <xsd:selector xpath="lfb:events/lfb:event"/>
          <xsd:field xpath="lfb:name"/>
        </xsd:key>
        <xsd:key name="eventsIDs">
          <xsd:selector xpath="lfb:events/lfb:event"/>
          <xsd:field xpath="@eventID"/>
        </xsd:key>
        <xsd:key name="componentIDs">
          <xsd:selector xpath="lfb:components/lfb:component"/>
          <xsd:field xpath="@componentID"/>
        </xsd:key>
        <xsd:key name="capabilityIDs">
          <xsd:selector xpath="lfb:capabilities/lfb:capability"/>
          <xsd:field xpath="@componentID"/>
        </xsd:key>
        <xsd:key name="ComponentCapabilityComponentIDUniqueness">
          <xsd:selector xpath="lfb:components/lfb:component|
          lfb:capabilities/lfb:capability|lfb:events"/>
          <xsd:field xpath="@componentID|@baseID"/>
        </xsd:key>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="versionType">
    <xsd:restriction base="xsd:NMTOKEN">
      <xsd:pattern value="[1-9][0-9]*\.([1-9][0-9]*|0)"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="inputPortsType">
    <xsd:sequence>
      <xsd:element name="inputPort" type="inputPortType"
       maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="inputPortType">
    <xsd:sequence>
      <xsd:element name="name" type="xsd:NMTOKEN"/>
      <xsd:element ref="synopsis"/>
      <xsd:element name="expectation" type="portExpectationType"/>
      <xsd:element ref="description" minOccurs="0"/>
    </xsd:sequence>
    <xsd:attribute name="group" type="xsd:boolean" use="optional"
     default="0"/>
  </xsd:complexType>
  <xsd:complexType name="portExpectationType">
    <xsd:sequence>
      <xsd:element name="frameExpected" minOccurs="0">
        <xsd:complexType>
          <xsd:sequence>
            <!-- ref must refer to a name of a defined frame type -->
            <xsd:element name="ref" type="xsd:string"
             maxOccurs="unbounded"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="metadataExpected" minOccurs="0">
        <xsd:complexType>
          <xsd:choice maxOccurs="unbounded">
            <!-- ref must refer to a name of a defined metadata -->
            <xsd:element name="ref" type="metadataInputRefType"/>
            <xsd:element name="one-of" type="metadataInputChoiceType"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="metadataInputChoiceType">
    <xsd:choice minOccurs="2" maxOccurs="unbounded">
      <!-- ref must refer to a name of a defined metadata -->
      <xsd:element name="ref" type="xsd:NMTOKEN"/>
      <xsd:element name="one-of" type="metadataInputChoiceType"/>
      <xsd:element name="metadataSet" type="metadataInputSetType"/>
    </xsd:choice>
  </xsd:complexType>
  <xsd:complexType name="metadataInputSetType">
    <xsd:choice minOccurs="2" maxOccurs="unbounded">
      <!-- ref must refer to a name of a defined metadata -->
      <xsd:element name="ref" type="metadataInputRefType"/>
      <xsd:element name="one-of" type="metadataInputChoiceType"/>
    </xsd:choice>
  </xsd:complexType>
  <xsd:complexType name="metadataInputRefType">
    <xsd:simpleContent>
      <xsd:extension base="xsd:NMTOKEN">
        <xsd:attribute name="dependency" use="optional"
         default="required">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:enumeration value="required"/>
              <xsd:enumeration value="optional"/>
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute name="defaultValue" type="xsd:token"
         use="optional"/>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="outputPortsType">
    <xsd:sequence>
      <xsd:element name="outputPort" type="outputPortType"
       maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="outputPortType">
    <xsd:sequence>
      <xsd:element name="name" type="xsd:NMTOKEN"/>
      <xsd:element ref="synopsis"/>
      <xsd:element name="product" type="portProductType"/>
      <xsd:element ref="description" minOccurs="0"/>
    </xsd:sequence>
    <xsd:attribute name="group" type="xsd:boolean" use="optional"
     default="0"/>
  </xsd:complexType>
  <xsd:complexType name="portProductType">
    <xsd:sequence>
      <xsd:element name="frameProduced" minOccurs="0">
        <xsd:complexType>
          <xsd:sequence>
            <!-- ref must refer to a name of a defined frame type
                   -->
            <xsd:element name="ref" type="xsd:NMTOKEN"
             maxOccurs="unbounded"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="metadataProduced" minOccurs="0">
        <xsd:complexType>
          <xsd:choice maxOccurs="unbounded">
            <!-- ref must refer to a name of a defined metadata
                -->
            <xsd:element name="ref" type="metadataOutputRefType"/>
            <xsd:element name="one-of"
             type="metadataOutputChoiceType"/>
          </xsd:choice>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="metadataOutputChoiceType">
    <xsd:choice minOccurs="2" maxOccurs="unbounded">
      <!-- ref must refer to a name of a defined metadata -->
      <xsd:element name="ref" type="xsd:NMTOKEN"/>
      <xsd:element name="one-of" type="metadataOutputChoiceType"/>
      <xsd:element name="metadataSet" type="metadataOutputSetType"/>
    </xsd:choice>
  </xsd:complexType>
  <xsd:complexType name="metadataOutputSetType">
    <xsd:choice minOccurs="2" maxOccurs="unbounded">
      <!-- ref must refer to a name of a defined metadata -->
      <xsd:element name="ref" type="metadataOutputRefType"/>
      <xsd:element name="one-of" type="metadataOutputChoiceType"/>
    </xsd:choice>
  </xsd:complexType>
  <xsd:complexType name="metadataOutputRefType">
    <xsd:simpleContent>
      <xsd:extension base="xsd:NMTOKEN">
        <xsd:attribute name="availability" use="optional"
         default="unconditional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:enumeration value="unconditional"/>
              <xsd:enumeration value="conditional"/>
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>
  <xsd:complexType name="LFBComponentsType">
    <xsd:sequence>
      <xsd:element name="component" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
            <xsd:element name="defaultValue" type="xsd:token" 
            minOccurs="0"/>
          </xsd:sequence>
          <xsd:attribute name="access" use="optional"
           default="read-write">
            <xsd:simpleType>
              <xsd:list itemType="accessModeType"/>
            </xsd:simpleType>
          </xsd:attribute>
          <xsd:attribute name="componentID" type="xsd:unsignedInt"
           use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="accessModeType">
    <xsd:restriction base="xsd:NMTOKEN">
      <xsd:enumeration value="read-only"/>
      <xsd:enumeration value="read-write"/>
      <xsd:enumeration value="write-only"/>
      <xsd:enumeration value="read-reset"/>
      <xsd:enumeration value="trigger-only"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="LFBCapabilitiesType">
    <xsd:sequence>
      <xsd:element name="capability" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
          <xsd:attribute name="componentID" type="xsd:integer"
           use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="eventsType">
    <xsd:sequence>
      <xsd:element name="event" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="eventTarget" type="eventPathType"/>
            <xsd:element ref="eventCondition"/>
            <xsd:element name="eventReports" type="eventReportsType"
             minOccurs="0"/>
            <xsd:element ref="description" minOccurs="0"/>
          </xsd:sequence>
          <xsd:attribute name="eventID" type="xsd:integer" 
          use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="baseID" type="xsd:integer" use="optional"/>
  </xsd:complexType>
  <!-- the substitution group for the event conditions -->
  <xsd:element name="eventCondition" abstract="true"/>
  <xsd:element name="eventCreated" substitutionGroup="eventCondition"/>
  <xsd:element name="eventDeleted" substitutionGroup="eventCondition"/>
  <xsd:element name="eventChanged" substitutionGroup="eventCondition"/>
  <xsd:element name="eventGreaterThan"
   substitutionGroup="eventCondition"/>
  <xsd:element name="eventLessThan"
   substitutionGroup="eventCondition"/>
  <xsd:complexType name="eventPathType">
    <xsd:sequence>
      <xsd:element ref="eventPathPart" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- the substitution group for the event path parts -->
  <xsd:element name="eventPathPart" type="xsd:string" abstract="true"/>
  <xsd:element name="eventField" type="xsd:string"
   substitutionGroup="eventPathPart"/>
  <xsd:element name="eventSubscript" type="xsd:string"
   substitutionGroup="eventPathPart"/>
  <xsd:complexType name="eventReportsType">
    <xsd:sequence>
      <xsd:element name="eventReport" type="eventPathType"
       maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="booleanType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="0"/>
      <xsd:enumeration value="1"/>
    </xsd:restriction>
  </xsd:simpleType>
</xsd:schema>
 ]]></artwork>
        </figure>
      </t>
  </section>
  <section anchor="Acknowledgements" title="Acknowledgements">
    <t>TBD</t>
  </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>

    </section>

    <section anchor="Security" title="Security Considerations">
      <t>TBD</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC5810;
      &RFC5812;
      &FORCES-OPENFLOW-LIB;

      <reference anchor="OpenFlowSpec1.1" target="http://www.OpenFlow.org/documents/OpenFlow-spec-v1.1.0.pdf">
        <front>
          <title>The OpenFlow 1.1 Specification.</title>
          <author>
            <organization>http://www.OpenFlow.org/</organization>
          </author>
          <date/>
        </front>
      </reference>

    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

    &RFC2119;
    </references>

    <!-- Change Log

v00 2009-02-17  EH   Initial version
  -->
  </back>
</rfc>
