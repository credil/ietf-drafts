<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<!-- If "yes" eliminates blank lines before main section entries. -->
<?rfc tocdepth="4"?>
<!-- Sets the number of levels of sections/subsections... in ToC -->
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<!-- These two save paper: Just setting compact to "yes" makes savings by not starting each
         main section on a new page but does not omit the blank lines between list items.
         If subcompact is also "yes" the blank lines between list items are also omitted. -->
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<!-- If "yes", causes the references to be sorted in order of tags.
This doesn't have any effect unless symrefs is "yes" also. -->
<?rfc strict="yes"?>
<?rfc rfcedstyle="no"?>
<?rfc iprnotified="yes"?>

<rfc category="std" ipr="trust200811" docName="draft-ellison-opsawg-smi-textual-conventions-xsd-00.txt">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
  <front>
    <title abbrev="Expressing SNMP SMI TCs in XSD">
      Expressing SNMP SMI Textual Conventions in XML Schema Definition Language
    </title>

    <author initials='M.' surname='Ellison'
            fullname='Mark Ellison'>
      <organization>Ellison Software Consulting</organization>
      <address>
        <postal>
          <street>38 Salem Road</street>
          <city>Atkinson</city>
          <region>NH</region>
          <code>03811</code>
          <country>USA</country>
        </postal>
        <phone>+1 603-362-9270</phone>
        <email>ietf@ellisonsoftware.com</email>
      </address>
    </author>

    <author initials='B.' surname='Natale'
            fullname='Bob Natale'>
      <organization>MITRE</organization>
      <address>
        <postal>
          <street>300 Sentinel Drive</street>
          <street>6th Floor</street>
          <city>Annapolis Junction</city>
          <region>MD</region>
          <code>20701</code>
          <country>USA</country>
        </postal>
        <phone>+1 301-617-3008</phone>
        <email>rnatale@mitre.org</email>
      </address>
    </author>

    <date year='2011'/>
    <area>Operations and Management</area>
    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>SMI</keyword>
    <keyword>Datatype</keyword>
    <keyword>Textual Convention</keyword>
    <keyword>TC</keyword>
    <keyword>XML</keyword>
    <keyword>eXtensible Markup Language</keyword>
    <keyword>XML Schema</keyword>
    <keyword>XSD</keyword>

    <abstract>
      <t>This memo defines the IETF standard expression of Structure of Management
      Information (SMI) textual conventions in Extensible Markup Language (XML) Schema
      Definition (XSD) language.  The primary objective of this memo is to enable
      the production of XML documents that are as faithful to the SMI as possible,
      using XSD as the validation mechanism.</t>
    </abstract>
  </front>

  <middle>
<!--  INTRODUCTION  -->
    <section title="Introduction">

      <t>The use of a standard mapping from SMI textual conventions to XML via XSD 
      validation enables and promotes the efficient reuse of existing and future MIB 
      modules and instrumentation by XML-based protocols and management applications.
      This standard mapping enables and facilitates improvements to the timeliness, 
      accuracy and utility of management information.</t>

      <t>This memo defines the standard expression of SMI textual conventions 
      in XML documents that is both uniform and interoperable.  This standard 
      mapping enables Internet operators, management application developers,
      and users to benefit from a wider range of management tools and to benefit 
      from a greater degree of unified management.</t>  

      <t>Numerous use cases exist for expressing the management information
      described by SMI Management Information Base (MIB) modules
      in XML <xref target="XML"/>. Potential use cases reside both outside 
      and within the traditional IETF network management community.  
      For example, developers of some XML-based management applications 
      may want to incorporate the rich set of data models provided by MIB modules.  
      Developers of other XML-based management applications may want to access MIB module 
      instrumentation via gateways to SNMP agents.  Such applications 
      benefit from the IETF standard mapping of SMI textual conventions to XML datatypes via
      XSD <xref target="XMLSchema"/>, <xref target="XSDDatatypes"/>.
      </t>

    </section>


<!--  CONVENTIONS  -->
    <section title="Conventions">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.
      </t>

    </section>


<!--  OVERVIEW  -->
    <section title="Overview">

      <t>Developers of certain XML-based management applications will find the
      specification defined in RFC 5935 <xref target="RFC5935"/>  sufficient for their purposes.  
      Developers of other XML-based management applications may need to make more complete reuse 
      of existing MIB modules, requiring standard XSD documents for TCs <xref target="RFC2579"/>
      and MIB structure <xref target="RFC2578"/>.  This memo builds upon the mappings of SMI base 
      datatypes as published in RFC 5935 by specifying mappings for SMI textual conventions.</t>

      <t>Support of RFC 5935 is prerequisite to support of the mappings defined in this memo.</t>

      <t>The SMI allows for the creation of derivative datatypes, "textual
      conventions" ("TCs") <xref target="RFC2579"/>.  A TC has a unique name, 
      has a syntax that either refines or is a base SMI datatype and has 
      relatively precise application-level semantics.  TCs facilitate correct 
      application-level handling of MIB data, improve readability of MIB 
      modules by humans and support appropriate renderings of MIB data.</t>

      <t>Textual conventions can be mapped using an algorithmic approach. This memo 
      discusses both the application of a standard algorithmic mapping for TCs
      and specifies XSD mappings for a set of widely used TCs.</t>

      <t>Note that the semantics of textual conventions are "applied" to 
      values by a management application, for example a command generator or 
      notification receiver.  Such values in varbinds "on-the-wire" are always 
      encoded as the base SMI datatype underlying the textual convention syntax.</t>

    </section>

<!--  REQUIREMENTS  -->

    <section title="Requirements">

      <!-- t>[TODO??: provide text saying the requirements are similar to and consistent
      with the requirements of RFC 5935??]</t -->

      <t>The following set of requirements is intended to produce XML documents
      which can be validated via the XSD defined in this specification to
      faithfully represent the applied semantics of textual conventions as defined
      by the SMI:
      <list style="format R%d." counter="rqmts">

        <t>SMIv2 is the normative SMI for this document.  Textual conventions were
        first introduced in SMIv2.  Any textual conventions informally defined in 
        an SMIv1 module MUST be converted (at least logically) in accordance with 
        Section 2.1, inclusive, of the "Coexistence" RFC <xref target="RFC3584"/>.</t>

        <t>The XSD base datatype of restriction facets specified for a given SMI
	textual convention MUST be defined within section 4 of the "Expressing 
	SNMP SMI Datatypes in XSD" RFC <xref target="RFC5935"/>, or be defined 
	within this memo.</t>

        <t>The XSD datatype specified for a given SMI textual convention MUST be 
	defined with the fewest necessary restriction facets on its set of values, 
	consistent with the following requirements.</t>

        <t>The XSD restriction facet(s) specified for a given SMI textual convention 
	MUST be able to represent all valid values and semantics for that SMI textual 
	convention.</t>

        <t>The XSD restriction facet(s) specified for a given SMI textual convention 
	MUST represent any special encoding rules associated with that SMI textual 
	convention.</t>

        <t>The XSD restriction facet(s) specified for a given SMI textual convention 
	MUST include any restrictions on values associated with the SMI textual convention.</t>

        <t>The XML output produced as a result of meeting the foregoing requirements SHOULD 
	be the most coherent and succinct representation (i.e., avoiding superfluous "decoration") 
	from the perspective of readability by humans.</t>

      </list>
      </t>

    </section>

<!--  ALGORITHMIC CONVERSIONS  -->
    <section title="Algorithmic Conversions">

      <t>[TODO: discuss, add text describing xs:element .vs. xs:simpleType...for this draft
         revision algorithmic conversions, MUST be simpletype.]</t>

      <t>[TODO: discuss, add text describing mapping of the units clause and the
         display hints clause]</t>

      <t>SMI textual conventions may be built upon any SMI base datatype.</t>

      <t>[TODO: call out limits of refinements for certain SMI bas datatypes?  (e.g. 
         OBJECT IDENTIFIER)]</t>

      <t>The algorithmic mapping from an SMI textual convention to an XML Schema 
         Definition (XSD) MUST provide a faithful and consistent representation
         of management information ((for which no cannonical XSD mapping is published)).</t>

      <t>For all algorithmic mappings, the following XSD facets are required:
         <list style="hanging" hangIndent="4">
            <t hangText="&nbsp; * QName">  <vspace blankLines="1" />
            The local portion of the Qname MUST be the same as the name of the SMI 
            textual convention.  For example, the local portion of the Qname for the 
            DisplayString TC defined in SNMPv2-TC <xref target="RFC2579"/> MUST be "DisplayString".</t>

            <t hangText="&nbsp; * Opening tag">  <vspace blankLines="1" />
            The opening tag MUST be &lt;xs:simpleType name="XsdName"&gt; where XsdName
            is the name of the SMI textual convention.</t>

            <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
            The mapping of the base XML datatype varies according to the SMI datatype.
            The algorithm for mapping to the proper XML datatype is discussed in the 
            following sections.</t>

            <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
            The mapping of the value constraints vary according to the SMI datatype
            and the semantics of the SMI textual convention.  The algorithm for mapping 
            value constraints is discussed in the following sections.</t>

            <t hangText="&nbsp; * Closing tag"> <vspace blankLines="1" />
            The closing tag MUST be &lt;/xs:simpleType&gt;</t>
         </list></t>  

         <t>Within the following sections, the namespace 'smi' is used to refer
         to the XML schema defined in RFC 5935.</t>

    <section title="Numeric Datatypes">

       <t>This section discusses standard algorithms for the mapping of base XML datatypes
       and XML value constraints for textual conventions that are based upon SMI 
       numeric datatypes.</t>

       <t>The SMI datatypes INTEGER, Integer32, Unsigned32 and Gauge32 may be sub-typed to 
       represent a more constrained value range by raising the lower-bounds, by reducing 
       the upper-bounds,and/or by reducing the alternative value/range choices.</t>

       <t>Thus, textual conventions based upon the SMI datatypes INTEGER, Integer32, Unsigned32
       and Gauge32 rely upon a mapping to a value range or a mapping to the union of a set of 
       value ranges.  Each value range consists of a minimum inclusive value and a maximum 
       inclusive value.</t>

       <t>In the case of a value range consisting of a single value, for example 
       "0", the value range is sufficiently described by a mapping to an enumeration with a value 
       of "0".  Such a mapping is considered an equivalent mapping to a value range with 
       a minimum inclusive value of "0" and a maximum inclusive value of "0".</t>

       <t>The SMI datatype INTEGER may be sub-typed to represent an enumeration of one or more 
       named-numbers.</t>

       <t>Thus, textual conventions based upon the SMI datatype INTEGER with a enumeration of
       named-numbers rely upon a mapping to an enumeration of values where each value is the
       label of a named-number.
       </t>

       <t>Additional detail and examples are presented in the following sections.  Note that
       the specification on sections for INTEGER, Integer32, Unsigned32 and Gauge32 are
       similar in nature.  These specifications are maintained in four separate sections
       to provide an easier reference by practitioners.</t>

    <section title="Integer32">

      <t>For the algorithmic mapping of textual conventions based upon the SMI
      Integer32 datatype, the following XSD facets are required:
         <list style="hanging" hangIndent="4">
            <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
            An XSD mapping of &lt;xs:restriction base="smi:Integer32"&gt; MUST be used.</t>

            <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
            An XSD mapping for each value range of:
<figure>
<artwork>
<![CDATA[            <xs:minInclusive value="MIN"/>
            <xs:minInclusive value="MAX"/>]]>
</artwork>
</figure>
            Where MIN is the low value of the range and MAX is the high value of the range.</t>

	    <t>A value range consisting of a single value MAY be mapped using an enumeration:
<figure>
<artwork>
<![CDATA[            <xs:enumeration value="SINGLETON"/>]]>
</artwork>
</figure>
            Where SINGLETON is the single value comprising the range.</t>

            <t>Multiple value ranges are represented by a union among the set of value ranges.</t>

            <t hangText="&nbsp; * Examples:">
            <list style="hanging" hangIndent="4">
               <t hangText="&nbsp; - SYNTAX Integer32 (-640..630)">
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:Integer32">
               <xs:minInclusive value="-640"/>
               <xs:minInclusive value="630"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Integer32 (-640..630 | 500..925)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:Integer32">
                     <xs:minInclusive value="-640"/>
                     <xs:minInclusive value="630"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:Integer32">
                     <xs:minInclusive value="500"/>
                     <xs:minInclusive value="925"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Integer32 (0|4096|8192|12288|16384)" >
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:Integer32">
               <xs:enumeration value="0"/>
               <xs:enumeration value="4096"/>
               <xs:enumeration value="8192"/>
               <xs:enumeration value="12288"/>
               <xs:enumeration value="16384"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Integer32 (0 | 128..255 | 325 | 400)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:Integer32">
                     <xs:enumeration value="0"/>
                     <xs:enumeration value="325"/>
                     <xs:enumeration value="400"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:Integer32">
                     <xs:minInclusive value="128"/>
                     <xs:minInclusive value="255"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>
               </list></t>
               </list></t>

    </section>

    <section title="INTEGER">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     INTEGER datatype when named-number enumerations are not present, the 
     following XSD facets are required:
        <list style="hanging" hangIndent="4">
            <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
               An xsd mapping of &lt;xs:restriction base="smi:INTEGER"&gt; MUST be used.</t>

            <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
            An XSD mapping for each value range of:
<figure>
<artwork>
<![CDATA[            <xs:minInclusive value="MIN"/>
            <xs:minInclusive value="MAX"/>]]>
</artwork>
</figure>
            Where MIN is the low value of the range and MAX is the high value of the range.</t>

	    <t>A value range consisting of a single value MAY be mapped using an enumeration:
<figure>
<artwork>
<![CDATA[            <xs:enumeration value="SINGLETON"/>]]>
</artwork>
</figure>
            Where SINGLETON is the single value comprising the range.</t>

            <t>Multiple value ranges are represented by a union among the set of value ranges.</t>

            <t hangText="&nbsp; * Examples:">
            <list style="hanging" hangIndent="4">
               <t hangText="&nbsp; - SYNTAX INTEGER (-640..630)">
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:INTEGER">
               <xs:minInclusive value="-640"/>
               <xs:minInclusive value="630"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX INTEGER (-640..630 | 500..925)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:INTEGER">
                     <xs:minInclusive value="-640"/>
                     <xs:minInclusive value="630"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:INTEGER">
                     <xs:minInclusive value="500"/>
                     <xs:minInclusive value="925"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX INTEGER (0|4096|8192|12288|16384)" >
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:INTEGER">
               <xs:enumeration value="0"/>
               <xs:enumeration value="4096"/>
               <xs:enumeration value="8192"/>
               <xs:enumeration value="12288"/>
               <xs:enumeration value="16384"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX INTEGER (0 | 128..255 | 325 | 400)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:INTEGER">
                     <xs:enumeration value="0"/>
                     <xs:enumeration value="325"/>
                     <xs:enumeration value="400"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:INTEGER">
                     <xs:minInclusive value="128"/>
                     <xs:minInclusive value="255"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>
               </list></t>
               </list></t>

    <section title="Named-Number Enumeration">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     INTEGER datatype when named-number enumerations are present, the following 
     XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
             An xsd mapping of &lt;xs:restriction base="tc:"&gt; MUST be used.</t>
             <t>The following XSD datatype specifies the NamedNumber simpleType:
<figure>
<artwork>
<![CDATA[        <xs:simpleType name="NamedNumber">
          <xs:restriction base="xs:string">
             <xs:pattern value="[a-z]([\w-[_]]{0,63})\(
                               (-?1?(\d{1,9})|
                                -?20(\d{8})|
                                -?21[0-3](\d{7})|
                                -?214[0-6](\d{6})|
                                -?2147[0-3](\d{5})|
                                -?21474[0-7](\d{4})|
                                -?214748[0-2](\d{3})|
                                -?2147483[0-5](\d{2})|
                                -?21474836[0-4]\d|
                                -?214748364[0-7]|
                                -2147483648
                               )\)"/>  
          </xs:restriction>
       </xs:simpleType>]]>
</artwork>
</figure></t>
          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          Exactly one named-number of an enumeration may be present as a value:
<figure>
<artwork>
<![CDATA[        <xs:enumeration value="VALUE"/>]]>
</artwork>
</figure>
            Where VALUE is the label of a named-number within the enumeration.</t>
    <t></t>

    <t>Examples of textual conventions based upon a named-number enumeration include:
    <list style="symbols">
       <t>defined in SNMPv2-TC<xref target="RFC2579"/>
           <list style="symbols">

             <t>TruthValue has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                SYNTAX INTEGER { true(1), 
                                 false(2) 
                               }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="TruthValue">
                  <xs:restriction base="NamedNumber">
                      <xs:enumeration value="true(1)"/>
                      <xs:enumeration value="false(2)"/>
                  </xs:restriction>
                </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>RowStatus has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                SYNTAX INTEGER { active(1), 
                                 notInService(2),  
                                 notReady(3),  
                                 createAndGo(4),  
                                 createAndWait(5),  
                                 destroy(6) }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="RowStatus">
                  <xs:restriction base="NamedNumber">
                      <xs:enumeration value="active(1)"/>
                      <xs:enumeration value="notInService(2)"/>
                      <xs:enumeration value="notReady(3)"/>
                      <xs:enumeration value="createAndGo(4)"/>
                      <xs:enumeration value="createAndWait(5)"/>
                      <xs:enumeration value="destroy(6)"/>
                  </xs:restriction>
                </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>StorageType has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                SYNTAX INTEGER { other(1),  
                                 volatile(2),  
                                 nonVolatile(3),  
                                 permanent(4),  
                                 readOnly(5) }

                <xs:simpleType name="StorageType">
                  <xs:restriction base="NamedNumber">
                      <xs:enumeration value="other(1)"/>
                      <xs:enumeration value="volatile(2)"/>
                      <xs:enumeration value="nonVolatile(3)"/>
                      <xs:enumeration value="permanent(4)"/>
                      <xs:enumeration value="readOnly(5)"/>
                  </xs:restriction>
                </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
       <t>defined in INET-ADDRESS-MIB<xref target="RFC4001"/>
          <list style="symbols">
             <t>InetAddressType has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                SYNTAX INTEGER { unknown(0), 
                                 ipv4(1), 
                                 ipv6(2), 
                                 ipv4z(3), 
                                 ipv6z(4), 
                                 dns(16) }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="InetAddressType">
                  <xs:restriction base="NamedNumber">
                      <xs:enumeration value="unknown(0)"/>
                      <xs:enumeration value="ipv4(1)"/>
                      <xs:enumeration value="ipv6(2)"/>
                      <xs:enumeration value="ipv4z(3)"/>
                      <xs:enumeration value="ipv6z(4)"/>
                      <xs:enumeration value="dns(16)"/>
                  </xs:restriction>
                </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>InetScopeType has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                SYNTAX INTEGER { -- reserved(0),
                                 interfaceLocal(1),
                                 linkLocal(2),
                                 subnetLocal(3),
                                 adminLocal(4),
                                 siteLocal(5), -- site-local unicast 
					       -- addresses have been
                                               -- deprecated by RFC 3879
                                 -- unassigned(6),
                                 -- unassigned(7),
                                 organizationLocal(8),
                                 -- unassigned(9),
                                 -- unassigned(10),
                                 -- unassigned(11),
                                 -- unassigned(12),
                                 -- unassigned(13),
                                 global(14)
                                 -- reserved(15) } 

             and algorithmically maps to the following XSD simpleType:


                <xs:simpleType name="InetScopeType">
                  <xs:restriction base="NamedNumber">
                      <xs:enumeration value="interfaceLocal(1)"/>
                      <xs:enumeration value="subnetLocal(2)"/>
                      <xs:enumeration value="adminLocal(3)"/>
                      <xs:enumeration value="siteLocal(4)"/>
                      <xs:enumeration value="organizationLocal(8)"/>
                      <xs:enumeration value="global(14)"/>
                  </xs:restriction>
                </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>InetVersion has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                SYNTAX INTEGER { unknown(0),
                                 ipv4(1),
                                 ipv6(2) } 

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="InetScopeType">
                  <xs:restriction base="NamedNumber">
                      <xs:enumeration value="unknown(0)"/>
                      <xs:enumeration value="ipv4(1)"/>
                      <xs:enumeration value="ipv6(2)"/>
                  </xs:restriction>
                </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
      </list></t>
      </list></t>

    </section>
    </section>

   <section title="Unsigned32">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     Unsigned32 datatype, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
          An xsd mapping of &lt;xs:restriction base="smi:Unsigned32"&gt; MUST be used.</t>

          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          An XSD mapping for each value range of:
<figure>
<artwork>
<![CDATA[            <xs:minInclusive value="MIN"/>
            <xs:minInclusive value="MAX"/>]]>
</artwork>
</figure>
            Where MIN is the low value of the range and MAX is the high value of the range.</t>

	    <t>A value range consisting of a single value MAY be mapped using an enumeration:
<figure>
<artwork>
<![CDATA[            <xs:enumeration value="SINGLETON"/>]]>
</artwork>
</figure>
            Where SINGLETON is the single value comprising the range.</t>

            <t>Multiple value ranges are represented by a union among the set of value ranges.</t>

            <t hangText="&nbsp; * Examples:">
            <list style="hanging" hangIndent="4">
               <t hangText="&nbsp; - SYNTAX Unsigned32 (40..630)">
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:Unsigned32">
               <xs:minInclusive value="40"/>
               <xs:minInclusive value="630"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Unsigned32 (40..630 | 500..925)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:Unsigned32">
                     <xs:minInclusive value="40"/>
                     <xs:minInclusive value="630"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:Unsigned32">
                     <xs:minInclusive value="500"/>
                     <xs:minInclusive value="925"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Unsigned32 (0|4096|8192|12288|16384)" >
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:Unsigned32">
               <xs:enumeration value="0"/>
               <xs:enumeration value="4096"/>
               <xs:enumeration value="8192"/>
               <xs:enumeration value="12288"/>
               <xs:enumeration value="16384"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Unsigned32 (0 | 128..255 | 325 | 400)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:Unsigned32">
                     <xs:enumeration value="0"/>
                     <xs:enumeration value="325"/>
                     <xs:enumeration value="400"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:Unsigned32">
                     <xs:minInclusive value="128"/>
                     <xs:minInclusive value="255"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>
               </list></t>
               </list></t>
   </section>

   <section title="Gauge32">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     Gauge32 datatype, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
          An xsd mapping of &lt;xs:restriction base="smi:Gauge32"&gt; MUST be used.</t>

            <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
            An XSD mapping for each value range of:
<figure>
<artwork>
<![CDATA[            <xs:minInclusive value="MIN"/>
            <xs:minInclusive value="MAX"/>]]>
</artwork>
</figure>
            Where MIN is the low value of the range and MAX is the high value of the range.</t>

	    <t>A value range consisting of a single value MAY be mapped using an enumeration:
<figure>
<artwork>
<![CDATA[            <xs:enumeration value="SINGLETON"/>]]>
</artwork>
</figure>
            Where SINGLETON is the single value comprising the range.</t>

            <t>Multiple value ranges are represented by a union among the set of value ranges.</t>

            <t hangText="&nbsp; * Examples:">
            <list style="hanging" hangIndent="4">
               <t hangText="&nbsp; - SYNTAX Gauge32 (40..630)">
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:Gauge32">
               <xs:minInclusive value="40"/>
               <xs:minInclusive value="630"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Gauge32 (40..630 | 500..925)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:Gauge32">
                     <xs:minInclusive value="40"/>
                     <xs:minInclusive value="630"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:Gauge32">
                     <xs:minInclusive value="500"/>
                     <xs:minInclusive value="925"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Gauge32 (0|4096|8192|12288|16384)" >
<figure>
<artwork>
<![CDATA[            <xs:restriction base="smi:Gauge32">
               <xs:enumeration value="0"/>
               <xs:enumeration value="4096"/>
               <xs:enumeration value="8192"/>
               <xs:enumeration value="12288"/>
               <xs:enumeration value="16384"/>
            </xs:restriction>]]>
</artwork>
</figure>
               </t>

               <t hangText="&nbsp; - SYNTAX Gauge32 (0 | 128..255 | 325 | 400)" >
<figure>
<artwork>
<![CDATA[            <xs:union>
               <xs:simpleType>
                  <xs:restriction base="smi:Gauge32">
                     <xs:enumeration value="0"/>
                     <xs:enumeration value="325"/>
                     <xs:enumeration value="400"/>
                  </xs:restriction>
               </xs:simpleType>
               <xs:simpleType>
                  <xs:restriction base="smi:Gauge32">
                     <xs:minInclusive value="128"/>
                     <xs:minInclusive value="255"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:union>]]>
</artwork>
</figure>
               </t>
               </list></t>
               </list></t>

   </section>

    <section title="Counter32">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     Gauge32 datatype, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
          An xsd mapping of &lt;xs:restriction base="smi:Counter32"&gt; MUST be used.</t>

          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          No value constraints are possible for textual conventions based upon
          the SMI Counter32 datatype.
          </t>
       </list></t>

    </section>

    <section title="TimeTicks">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     Gauge32 datatype, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
          An xsd mapping of &lt;xs:restriction base="smi:TimeTicks"&gt; MUST be used.</t>

          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          No value constraints are possible for textual conventions based upon
          the SMI TimeTicks datatype.
          </t>
       </list></t>

    </section>

    <section title="Counter64">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     Counter32 datatype, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
          An xsd mapping of &lt;xs:restriction base="smi:Counter64"&gt; MUST be used.</t>

          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          No value constraints are possible for textual conventions based upon
          the SMI Counter64 datatype.
          </t>
       </list></t>

    </section>
    </section>

    <section title="OCTET STRING">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     OCTET STRING datatype, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
          An xsd mapping of &lt;xs:restriction base="smi:OctetString"&gt; MUST be used.</t>

          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          Size constraints are possible.  pattern constraints are possible.  Character
          subsets are possible.
          </t>
       </list></t>

     <t>The SMI OCTET STRING base datatype may be used to represent information
     as a displayable text string or may be used to represent information as a binary octet string.</t>

    <t>Examples of textual conventions conveying a displayable OCTET STRING include:
    <list style="symbols">
       <t>defined in SNMPv2-TC<xref target="RFC2579"/>
            <list style="hanging" hangIndent="4">
              <t hangText="&nbsp; - DisplayString has the following SMIv2 Syntax clause:" >
<figure>
<artwork>
<![CDATA[            OCTET STRING (SIZE (0..255))

       and algorithmically maps to the following XSD simpleType:

            <xs:simpleType name="DisplayString">
              <xs:restriction base="smi:OctetString">
                <xs:minLength value="0"/>
                <xs:maxLength value="255"/>
                <xs:pattern value="((((\p{IsBasicLatin}))
                                           {0,255})){0,1}"/>
                        <!-- [TODO: is the {0,1} needed ?] -->
              </xs:restriction>
            </xs:simpleType>]]>
</artwork>
</figure>
             </t>
           </list></t>
       <t>defined in SNMP-FRAMEWORK-MIB<xref target="RFC3411"/>
          <list style="hanging" hangIndent="4">
             <t hangText="&nbsp; - SnmpAdminString has the following SMIv2 Syntax clause:" >
<figure>
<artwork>
<![CDATA[            OCTET STRING (SIZE (0..255))

       and algorithmically maps to the following XSD simpleType:
           
            <!-- [TODO: restrict characters??] -->
            <xs:simpleType name="SnmpAdminString">
              <xs:restriction base="smi:OctetString">
                <xs:minLength value="0"/>
                <xs:maxLength value="255"/>
              </xs:restriction>
            </xs:simpleType>]]>
</artwork>
</figure>
             </t>
           </list></t>
       <t>defined in SYSAPPL-MIB<xref target="RFC2287"/>
          <list style="hanging" hangIndent="4">
             <t hangText="&nbsp; - LongUtf8String has the following SMIv2 Syntax clause:" >
<figure>
<artwork>
<![CDATA[            OCTET STRING (SIZE (0..1024))

       and algorithmically maps to the following XSD simpleType:

            <xs:simpleType name="LongUtf8String">
              <xs:restriction base="smi:OctetString">
                <xs:minLength value="0"/>
                <xs:maxLength value="1024"/>
              </xs:restriction>
            </xs:simpleType>]]>
</artwork>
</figure>
             </t>
             <t hangText="&nbsp; - Utf8String has the following SMIv2 Syntax clause:" >
<figure>
<artwork>
<![CDATA[            OCTET STRING (SIZE (0..255))

       and algorithmically maps to the following XSD simpleType:

            <xs:simpleType name="Utf8String">
              <xs:restriction base="smi:OctetString">
                <xs:minLength value="0"/>
                <xs:maxLength value="255"/>
              </xs:restriction>
            </xs:simpleType>]]>
</artwork>
</figure>
             </t>
           </list></t>
    </list></t>

    <t>Examples of textual conventions conveying a binary OCTET STRING include:
    <list style="symbols">
       <t>defined in SNMPv2-TC<xref target="RFC2579"/>
            <list style="hanging" hangIndent="4">
              <t hangText="&nbsp; - MacAddress has the following SMIv2 Syntax clause:" >
<figure>
<artwork>
<![CDATA[            OCTET STRING (SIZE (6))

       and algorithmically maps to the following XSD simpleType:

            <xs:simpleType name="MacAddress">
              <xs:restriction base="smi:OctetString">
                <xs:pattern value="((([0-9A-Fa-f]{2}):){5,5})
                                     ([0-9A-Fa-f]{2})"/>
              </xs:restriction>
            </xs:simpleType>]]>
</artwork>
</figure>
             </t>
             <t hangText="&nbsp; - DateAndTime has the following SMIv2 Syntax clause:" >
<figure>
<artwork>
<![CDATA[            OCTET STRING (SIZE (8 | 11))

       and algorithmically maps to the following XSD simpleType:


            <xs:simpleType name="DateAndTime">
              <xs:restriction base="smi:OctetString">
                <xs:pattern value="(([0..65536]-[1..2]-[1..31],
                                     [0..23]:[0..59].[0-60].[0-9])
                                    (([+-][0..13]:[0..59]){0,1}))"/>
              </xs:restriction>
            </xs:simpleType>]]>
</artwork>
</figure>
             </t>
           </list></t>
    </list></t>

    </section>


    <section title="Opaque">

	<t>There are no IETF Standards Track Textual Conventions defined using an SMI base type
           of Opaque.  The OCTET STRING SMI base type provides sufficient and complete support 
	   for any TC that would otherwise be based upon Opaque.</t>

        <t>RFC 5935 includes an XML mapping for the Opaque base type for completeness and 
	   historic purposes.</t>

	<t>Thus, there is no need for a mapping for TCs based upon Opaque.</t>
           

    </section>

    <section title="IpAddress">

	<t>There are no IETF Standards Track Textual Conventions defined using an SMI base type
           of IpAddress.  The InetAddressType and InetAddress TCs defined within RFC 4001,
           provide sufficient and complete mapping for any IPv4, IPv6 or DNS internet address.</t>

        <t>RFC 5935 includes an XML mapping for the IpAddress base type for completeness and 
	   historic purposes.</t>

	<t>Thus, there is no need for a mapping for TCs based upon IpAddress.</t>


    </section>

    <section title="OBJECT IDENTIFIER">
	
	<t>For the algorithmic mapping of textual conventions based upon the SMI
           OBJECT IDENTIFIER base datatype, the following XSD facets are required:
           <list style="hanging" hangIndent="4">
             <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
                An xsd mapping of &lt;xs:restriction base="smi:ObjectIdentifier"&gt; MUST be used.</t>

                <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
                   No value constraints are possible for textual conventions based upon
                   the SMI OBJECT IDENTIFIER datatype.
                </t>
           </list>
	</t>

	<t>There are a number of IETF Standards Track Textual Conventions defined using an SMI base type
           of OBJECT IDENTIFIER.  These TCs include the following:

           <list style="symbols">
              <t>defined in SNMPv2-TC:
                 <list style="symbols">
                    <t>AutonomousType</t>
                    <t>VariablePointer</t>
                    <t>RowPointer</t>
                    <t>TDomain</t>
                 </list>
              </t>
           </list>

           <list style="symbols">
              <t>defined in ACCOUNTING-CONTROL-MIB:
                 <list style="symbols">
                    <t>DataCollectionSubtree</t>
                 </list>
              </t>
           </list>

           <list style="symbols">
              <t>defined in ALARM-MIB:
                 <list style="symbols">
                    <t>alarmModelLastChanged</t>
                 </list>
              </t>
           </list>

           <list style="symbols">
              <t>defined in APM-MIB:
                 <list style="symbols">
                    <t>DataSourceOrZero</t>
                 </list>
              </t>
           </list>

           <list style="symbols">
              <t>defined in HOST-RESOURCES-MIB:
                 <list style="symbols">
                    <t>ProductID</t>
                 </list>
              </t>
           </list>

           <list style="symbols">
              <t>defined in RMON2-MIB:
                 <list style="symbols">
                    <t>DataSource</t>
                 </list>
              </t>
           </list>

           <list style="symbols">
              <t>defined in SMON-MIB:
                 <list style="symbols">
                    <t>SmonDataSource</t>
                 </list>
              </t>

           </list>
         </t>

	<t>The algorithmic mappings of all TCs based upon the SMI OBJECT IDENTIFIER
           base datatype follow the same form.  For example, RowPointer is mapped as:
<figure>
<artwork>
<![CDATA[  <xs:simpleType name="RowPointer">
    <xs:restriction base="smi:ObjectIdentifier">
    </xs:restriction>
  </xs:simpleType>]]>
</artwork>
</figure>
        </t>



    </section>

    <section title="The BITS Construct">

     <t>For the algorithmic mapping of textual conventions based upon the SMI
     BITS construct, the following XSD facets are required:
       <list style="hanging" hangIndent="4">
          <t hangText="&nbsp; * XML datatype"> <vspace blankLines="1" />
             An xsd mapping of &lt;xs:restriction base="tc:NamedBit"&gt; MUST be used.</t>
             <t>The following XSD datatype specifies the NamedBit simpleType:
<figure>
<artwork>
<![CDATA[        <xs:simpleType name="NamedBit">
          <xs:restriction base="xs:string">
             <xs:pattern value="[a-z]([\w-[_]]{0,63})\(
                               (\d{1,5}|
                                5[0-1](\d{4})|
                                52[0-3](\d{3})|
                                524[0-1](\d{2})|
                                5242[0-7]\d
                               )\)"/>  
          </xs:restriction>
       </xs:simpleType>]]>
</artwork>
</figure></t>
          <t hangText="&nbsp; * Value constraints"> <vspace blankLines="1" />
          Zero, one or more named-bits may be present as a list value.  First, we
          map the named-bits:
<figure>
<artwork>
<![CDATA[        <xs:simpleType name="BITSENUM">
           <xs:restriction base="NamedBit">
              <xs:enumeration value="VALUE(0)"/>
                  .
                  .
                  .
              <xs:enumeration value="VALUE(N)"/>
           </xs:restriction>
        </xs:simpleType>]]>
</artwork>
</figure>
            Where BITSENUM MUST be the TC name appended with "BitNames" and VALUE MUST be the label of a 
            named-number within the enumeration.</t>

            <t>Second we create the XSD mapping the BITS TC as follows:
<figure>
<artwork>
<![CDATA[        <xs:simpleType name="BITSTC">
           <xs:list itemType="BITSENUM"/>
        </xs:simpleType>]]>
</artwork>
</figure>
            Where BITSTC is the TC name.  Note there is no maxLength facet specified because XML value sets
            are limited to the restricted list of NamedBit value choices.  In the event that an XML value
            set contains additional value choices, then each additional value choice must be a duplicate of 
            a NamedBit a previous value choice.  The effect is equivalent of specifying a specific bit to 
            be set more than once.  Thus, the maxLength facet is considered unnecessary.</t>

            <t>If, for some application specific reason, a maxLength facet is considered desirable, then the
               following schema production SHOULD be used:
<figure>
<artwork>
<![CDATA[        <xs:simpleType name="BITSTC">
           <xs:restriction>
              <xs:simpleType>
                 <xs:list itemType="BITSENUM"/>
              </xs:simpleType>
              <xs:maxLength value="LEN"/>
           </xs:restriction>
        </xs:simpleType>]]>
</artwork>
</figure>
            Where LEN is the numeric maxLength value.</t>
</list></t>

    <t>Examples of textual conventions based upon the BITS construct include:
    <list style="symbols">
       <t>defined in ADSL2-LINE-TC-MIB<xref target="RFC4706"/>
           <list style="symbols">

             <t>Adsl2TransmissionModeType has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        ansit1413(0),
                        etsi(1),
                        g9921PotsNonOverlapped(2),
                        g9921PotsOverlapped(3),
                        g9921IsdnNonOverlapped(4),
                        g9921isdnOverlapped(5),
                        g9921tcmIsdnNonOverlapped(6),
                        g9921tcmIsdnOverlapped(7),
                        g9922potsNonOverlapped(8),
                        g9922potsOverlapped(9),
                        g9922tcmIsdnNonOverlapped(10),
                        g9922tcmIsdnOverlapped(11),
                        g9921tcmIsdnSymmetric(12),
                        reserved1(13),
                        reserved2(14),
                        reserved3(15),
                        reserved4(16),
                        reserved5(17),
                        g9923PotsNonOverlapped(18),
                        g9923PotsOverlapped(19),
                        g9923IsdnNonOverlapped(20),
                        g9923isdnOverlapped(21),
                        reserved6(22),
                        reserved7(23),
                        g9924potsNonOverlapped(24),
                        g9924potsOverlapped(25),
                        reserved8(26),
                        reserved9(27),
                        g9923AnnexIAllDigNonOverlapped(28),
                        g9923AnnexIAllDigOverlapped(29),
                        g9923AnnexJAllDigNonOverlapped(30),
                        g9923AnnexJAllDigOverlapped(31),
                        g9924AnnexIAllDigNonOverlapped(32),
                        g9924AnnexIAllDigOverlapped(33),
                        g9923AnnexLMode1NonOverlapped(34),
                        g9923AnnexLMode2NonOverlapped(35),
                        g9923AnnexLMode3Overlapped(36),
                        g9923AnnexLMode4Overlapped(37),
                        g9923AnnexMPotsNonOverlapped(38),
                        g9923AnnexMPotsOverlapped(39),
                        g9925PotsNonOverlapped(40),
                        g9925PotsOverlapped(41),
                        g9925IsdnNonOverlapped(42),
                        g9925isdnOverlapped(43),
                        reserved10(44),
                        reserved11(45),
                        g9925AnnexIAllDigNonOverlapped(46),
                        g9925AnnexIAllDigOverlapped(47),
                        g9925AnnexJAllDigNonOverlapped(48),
                        g9925AnnexJAllDigOverlapped(49),
                        g9925AnnexMPotsNonOverlapped(50),
                        g9925AnnexMPotsOverlapped(51),
                        reserved12(52),
                        reserved13(53),
                        reserved14(54),
                        reserved15(55)
                 }

             and algorithmically maps to the following XSD simpleType:

               <xs:simpleType name="Adsl2TransmissionModeTypeBitNames">
                 <xs:restriction base="NamedBit">
                    <xs:enumeration value="ansit1413(0)"/>
                    <xs:enumeration value="etsi(1)"/>
                    <xs:enumeration value="g9921PotsNonOverlapped(2)"/>
                    <xs:enumeration value="g9921PotsOverlapped(3)"/>
                    <xs:enumeration value="g9921IsdnNonOverlapped(4)"/>
                    <xs:enumeration value="g9921isdnOverlapped(5)"/>
                    <xs:enumeration value=
                                    "g9921tcmIsdnNonOverlapped(6)"/>
                    <xs:enumeration value="g9921tcmIsdnOverlapped(7)"/>
                    <xs:enumeration value="g9922potsNonOverlapped(8)"/>
                    <xs:enumeration value="g9922potsOverlapped(9)"/>
                    <xs:enumeration value=
                                    "g9922tcmIsdnNonOverlapped(10)"/>
                    <xs:enumeration value=
                                    "g9922tcmIsdnOverlapped(11)"/>
                    <xs:enumeration value="g9921tcmIsdnSymmetric(12)"/>
                    <xs:enumeration value="reserved1(13)"/>
                    <xs:enumeration value="reserved2(14)"/>
                    <xs:enumeration value="reserved3(15)"/>
                    <xs:enumeration value="reserved4(16)"/>
                    <xs:enumeration value="reserved5(17)"/>
                    <xs:enumeration value=
                                    "g9923PotsNonOverlapped(18)"/>
                    <xs:enumeration value="g9923PotsOverlapped(19)"/>
                    <xs:enumeration value=
                                    "g9923IsdnNonOverlapped(20)"/>
                    <xs:enumeration value="g9923isdnOverlapped(21)"/>
                    <xs:enumeration value="reserved6(22)"/>
                    <xs:enumeration value="reserved7(23)"/>
                    <xs:enumeration value=
                                    "g9924potsNonOverlapped(24)"/>
                    <xs:enumeration value="g9924potsOverlapped(25)"/>
                    <xs:enumeration value="reserved8(26)"/>
                    <xs:enumeration value="reserved9(27)"/>
                    <xs:enumeration value=
                                 "g9923AnnexIAllDigNonOverlapped(28)"/>
                    <xs:enumeration value=
                                    "g9923AnnexIAllDigOverlapped(29)"/>
                    <xs:enumeration value=
                                 "g9923AnnexJAllDigNonOverlapped(30)"/>
                    <xs:enumeration value=
                                    "g9923AnnexJAllDigOverlapped(31)"/>
                    <xs:enumeration value=
                                 "g9924AnnexIAllDigNonOverlapped(32)"/>
                    <xs:enumeration value=
                                    "g9924AnnexIAllDigOverlapped(33)"/>
                    <xs:enumeration value=
                                  "g9923AnnexLMode1NonOverlapped(34)"/>
                    <xs:enumeration value=
                                  "g9923AnnexLMode2NonOverlapped(35)"/>
                    <xs:enumeration value=
                                    "g9923AnnexLMode3Overlapped(36)"/>
                    <xs:enumeration value=
                                    "g9923AnnexLMode4Overlapped(37)"/>
                    <xs:enumeration value=
                                   "g9923AnnexMPotsNonOverlapped(38)"/>
                    <xs:enumeration value=
                                    "g9923AnnexMPotsOverlapped(39)"/>
                    <xs:enumeration value=
                                    "g9925PotsNonOverlapped(40)"/>
                    <xs:enumeration value="g9925PotsOverlapped(41)"/>
                    <xs:enumeration value=
                                    "g9925IsdnNonOverlapped(42)"/>
                    <xs:enumeration value="g9925isdnOverlapped(43)"/>
                    <xs:enumeration value="reserved10(44)"/>
                    <xs:enumeration value="reserved11(45)"/>
                    <xs:enumeration value=
                                 "g9925AnnexIAllDigNonOverlapped(46)"/>
                    <xs:enumeration value=
                                    "g9925AnnexIAllDigOverlapped(47)"/>
                    <xs:enumeration value=
                                 "g9925AnnexJAllDigNonOverlapped(48)"/>
                    <xs:enumeration value=
                                    "g9925AnnexJAllDigOverlapped(49)"/>
                    <xs:enumeration value=
                                   "g9925AnnexMPotsNonOverlapped(50)"/>
                    <xs:enumeration value=
                                    "g9925AnnexMPotsOverlapped(51)"/>
                    <xs:enumeration value="reserved12(52)"/>
                    <xs:enumeration value="reserved13(53)"/>
                    <xs:enumeration value="reserved14(54)"/>
                    <xs:enumeration value="reserved15(55)"/>
                 </xs:restriction>
               </xs:simpleType>

               <xs:simpleType name="Adsl2TransmissionModeType">
                 <xs:list itemType=
                          "Adsl2TransmissionModeTypeBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>Adsl2LConfProfPmMode has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        allowTransitionsToIdle(0),
                        allowTransitionsToLowPower(1)
                 }

             and algorithmically maps to the following XSD simpleType:

              <xs:simpleType name="Adsl2LConfProfPmModeBitNames">
               <xs:restriction base="NamedBit">
                <xs:enumeration value="allowTransitionsToIdle(0)"/>
                <xs:enumeration value="allowTransitionsToLowPower(1)"/>
               </xs:restriction>
              </xs:simpleType>

               <xs:simpleType name="Adsl2LConfProfPmMode">
                  <xs:list itemType="Adsl2LConfProfPmModeBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>Adsl2LineStatus has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        noDefect(0),
                        lossOfFrame(1),
                        lossOfSignal(2),
                        lossOfPower(3),
                        initFailure(4)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="Adsl2LineStatusBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="noDefect(0)"/>
                     <xs:enumeration value="lossOfFrame(1)"/>
                     <xs:enumeration value="lossOfSignal(2)"/>
                     <xs:enumeration value="lossOfPower(3)"/>
                     <xs:enumeration value="initFailure(4)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="Adsl2LineStatus">
                  <xs:list itemType="Adsl2LineStatusBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>Adsl2ChAtmStatus has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        noDefect(0),
                        noCellDelineation(1),
                        lossOfCellDelineation(2)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="Adsl2ChAtmStatusBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="noDefect(0)"/>
                     <xs:enumeration value="noCellDelineation(1)"/>
                     <xs:enumeration value="lossOfCellDelineation(2)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="Adsl2ChAtmStatus">
                  <xs:list itemType="Adsl2ChAtmStatusBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>Adsl2ChPtmStatus has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        noDefect(0),
                        outOfSync(1)
                 }


             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="Adsl2ChPtmStatusBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="noDefect(0)"/>
                     <xs:enumeration value="outOfSync(1)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="Adsl2ChPtmStatus">
                  <xs:list itemType="Adsl2ChPtmStatusBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
       <t>defined in ENTITY-STATE-TC-MIB<xref target="RFC4268"/>
          <list style="symbols">
             <t>EntityAlarmStatus has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS { 
                            unknown(0),
                            underRepair(1),
                            critical(2),
                            major(3),
                            minor(4),
                            -- The following are not defined in X.733
                            warning(5),
                            indeterminate(6)
                        }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="EntityAlarmStatusBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="unknown(0)"/>
                     <xs:enumeration value="underRepair(1)"/>
                     <xs:enumeration value="critical(2)"/>
                     <xs:enumeration value="major(3)"/>
                     <xs:enumeration value="minor(4)"/>
                     <xs:enumeration value="warning(5)"/>
                     <xs:enumeration value="indeterminate(6)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="EntityAlarmStatus">
                  <xs:list itemType="EntityAlarmStatusBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
       <t>defined in FC-MGMT-MIB<xref target="RFC4044"/>
          <list style="symbols">
             <t>FcClasses has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        classF(0), 
                        class1(1), 
                        class2(2), 
                        class3(3),           
                        class4(4), 
                        class5(5), 
                        class6(6)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="FcClassesBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="classF(0)"/>
                     <xs:enumeration value="class1(1)"/>
                     <xs:enumeration value="class2(2)"/>
                     <xs:enumeration value="class3(3)"/>
                     <xs:enumeration value="class4(4)"/>
                     <xs:enumeration value="class5(5)"/>
                     <xs:enumeration value="class6(6)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="FcClasses">
                  <xs:list itemType="FcClassesBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>FcUnitFunctions has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        other(0),        -- none of the following
                        hub(1),
                        switch(2),
                        bridge(3),
                        gateway(4),
                        host(5),
                        storageSubsys(6),
                        storageAccessDev(7),
                        nas(8),
                        wdmux(9),
                        storageDevice(10)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="FcUnitFunctionsBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="other(0)"/>
                     <xs:enumeration value="hub(1)"/>
                     <xs:enumeration value="switch(2)"/>
                     <xs:enumeration value="bridge(3)"/>
                     <xs:enumeration value="gateway(4)"/>
                     <xs:enumeration value="host(5)"/>
                     <xs:enumeration value="storageSubsys(6)"/>
                     <xs:enumeration value="storageAccessDev(7)"/>
                     <xs:enumeration value="nas(8)"/>
                     <xs:enumeration value="wdmux(9)"/>
                     <xs:enumeration value="storageDevice(10)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="FcUnitFunctions">
                  <xs:list itemType="FcUnitFunctionsBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
       <t>defined in NAT-MIB<xref target="RFC4008"/>
          <list style="symbols">
             <t>NatProtocolMap has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        other(0),
                        icmp(1),
                        udp(2),
                        tcp(3)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="NatProtocolMapBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="other(0)"/>
                     <xs:enumeration value="icmp(1)"/>
                     <xs:enumeration value="udp(2)"/>
                     <xs:enumeration value="tcp(3)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="NatProtocolMap">
                  <xs:list itemType="NatProtocolMapBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>NatTranslationEntity has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        inboundSrcEndPoint(0),
                        outboundDstEndPoint(1),
                        inboundDstEndPoint(2),
                        outboundSrcEndPoint(3)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="NatTranslationEntityBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="inboundSrcEndPoint(0)"/>
                     <xs:enumeration value="outboundDstEndPoint(1)"/>
                     <xs:enumeration value="inboundDstEndPoint(0)"/>
                     <xs:enumeration value="outboundSrcEndPoint(1)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="NatTranslationEntity">
                  <xs:list itemType="NatTranslationEntityBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
       <t>defined in SIP-TC-MIB<xref target="RFC4780"/>
          <list style="symbols">
             <t>SipTCTransportProtocol has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        other(0),  -- none of the following
                        udp(1),
                        tcp(2),
                        sctp(3),   -- RFC4168
                        tlsTcp(4),
                        tlsSctp(5) -- RFC 4168
                 }


             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="SipTCTransportProtocolBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="other(0)"/>
                     <xs:enumeration value="udp(1)"/>
                     <xs:enumeration value="tcp(2)"/>
                     <xs:enumeration value="sctp(3)"/>
                     <xs:enumeration value="tlsTcp(4)"/>
                     <xs:enumeration value="tlsSctp(5)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="SipTCTransportProtocol">
                  <xs:list itemType="SipTCTransportProtocolBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>SipTCEntityRole has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                        other(0),
                        userAgent(1),
                        proxyServer(2),
                        redirectServer(3),
                        registrarServer(4)
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="SipTCEntityRoleBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="other(0)"/>
                     <xs:enumeration value="userAgent(1)"/>
                     <xs:enumeration value="proxyServer(2)"/>
                     <xs:enumeration value="redirectServer(3)"/>
                     <xs:enumeration value="registrarServer(4)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="SipTCEntityRole">
                  <xs:list itemType="SipTCEntityRoleBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
             <t>SipTCOptionTagHeaders has the following SMIv2 Syntax clause:
<figure>
<artwork><![CDATA[
                 SYNTAX BITS {
                  require(0),       -- Require header
                  proxyRequire(1),  -- Proxy-Require header
                  supported(2),     -- Supported header
                  unsupported(3)    -- Unsupported header
                 }

             and algorithmically maps to the following XSD simpleType:

                <xs:simpleType name="SipTCOptionTagHeadersBitNames">
                  <xs:restriction base="NamedBit">
                     <xs:enumeration value="require(0)"/>
                     <xs:enumeration value="proxyRequire(1)"/>
                     <xs:enumeration value="supported(2)"/>
                     <xs:enumeration value="unsupported(3)"/>
                  </xs:restriction>
                </xs:simpleType>

               <xs:simpleType name="Adsl2SipTCOptionTagHeaders">
                  <xs:list itemType="SipTCOptionTagHeadersBitNames"/>
               </xs:simpleType>]]>
</artwork>
</figure></t>
           </list></t>
    </list></t>

    </section>

    </section>

<!--  XSD FOR SMI TEXTUAL-CONVENTIONS  -->
    <section title="XSD for SMI Textual Conventions">

      <t>This document provides XSD datatype mappings for the SMIv2 Textual Conventions
      based upon "BITS" pseudo-type and the eleven "ObjectSyntax" datatypes defined in RFC 2578.
      <vspace blankLines="2"/> </t>


<figure>
<artwork>
<![CDATA[
BEGIN

<?xml version="1.0" encoding="utf-8"?>
  <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:smi="urn:ietf:params:xml:ns:smi:base:1.0"
             xmlns:tc="urn:ietf:params:xml:ns:smi:tc:1.0"
             targetNamespace="urn:ietf:params:xml:ns:smi:tc:1.0"
             elementFormDefault="qualified"
             attributeFormDefault="unqualified"
             xml:lang="en">

  <xs:import namespace="urn:ietf:params:xml:ns:smi:base:1.0" 
             schemaLocation="Smiv2.xsd" />

  <xs:annotation>
    <xs:documentation>
        Mapping of SMIv2 Textual Conventions from RFC 2579
        and other standards-track RFCs.

        Contact:      Mark Ellison
        Organization: Ellison Software Consulting
        Address:      38 Salem Road
                      Atkinson, NH 03811
                      USA
        Telephone:    +1 603-362-9270
        E-Mail:       ietf@EllisonSoftware.com

        Contact:      Bob Natale
        Organization: MITRE
        Address:      300 Sentinel Drive
                      6th Floor
                      Annapolis Junction, MD  20701
                      USA
        Telephone:    +1 301-617-3008
        E-Mail:       rnatale@mitre.org

        Last Updated: 201107150000Z

        Copyright (c) 2011 IETF Trust and the persons
        identified as the document authors.  All rights
        reserved.

        Redistribution and use in source and binary forms,
        with or without modification, is permitted pursuant
        to, and subject to the license terms contained in,
        the Simplified BSD License set forth in Section
        4.c of the IETF Trust's Legal Provisions Relating to 
        IETF Documents (http://trustee.ietf.org/license-info).

        This version of this XML Schema Definition (XSD)
        document is part of RFC XXXX; see the RFC itself for 
        full legal notices."
RFC Editor - please replace XXXX with the value allocated
for publication as an RFC.

    </xs:documentation>
  </xs:annotation>

<!-- TCs based upon smi:Integer32 -->

  <!-- from IF-MIB -->
  <xs:simpleType name="InterfaceIndex">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="2147483647"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from IF-MIB -->
  <xs:simpleType name="InterfaceIndexOrZero">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="2147483647"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ENTITY-MIB -->
  <xs:simpleType name="PhysicalIndex">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="2147483647"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ENTITY-MIB -->
  <xs:simpleType name="PhysicalIndexOrZero">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="2147483647"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from Q-BRIDGE-MIB -->
  <xs:simpleType name="VlanId">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="4094"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from Q-BRIDGE-MIB -->
  <xs:simpleType name="VlanIdOrAny">
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="smi:Integer32">
          <xs:minInclusive value="1"/>
          <xs:maxInclusive value="4094"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="smi:Integer32">
          <xs:enumeration value="4095"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="VlanIdOrNone">
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="smi:Integer32">
          <xs:enumeration value="0"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="smi:Integer32">
          <xs:minInclusive value="1"/>
          <xs:maxInclusive value="4094"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>


<!-- TCs based upon smi:INTEGER -->

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="TestAndIncr">
    <xs:restriction base="smi:INTEGER">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="2147483647"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="TimeInterval">
    <xs:restriction base="smi:INTEGER">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="2147483647"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfValidIntervals">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="96"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfInvalidIntervals">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="96"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfTimeElapsed">
    <xs:restriction base="smi:Integer32">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="86399"/>
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:INTEGER - named-number enumeration -->

<!-- NamedNumber definition...
     for use with enumerated values -->
     
  <xs:simpleType name="NamedNumber">
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-z]([\w-[_]]{0,63})\(
                         (-?1?(\d{1,9})|
                          -?20(\d{8})|
                          -?21[0-3](\d{7})|
                          -?214[0-6](\d{6})|
                          -?2147[0-3](\d{5})|
                          -?21474[0-7](\d{4})|
                          -?214748[0-2](\d{3})|
                          -?2147483[0-5](\d{2})|
                          -?21474836[0-4]\d|
                          -?214748364[0-7]|
                          -2147483648
                         )\)"/>  
    </xs:restriction>
  </xs:simpleType>

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="TruthValue">
    <xs:restriction base="smi:NamedNumber">
      <xs:enumeration value="true(1)"/>
      <xs:enumeration value="false(2)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="RowStatus">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="active(1)"/>
      <xs:enumeration value="notInService(2)"/>
      <xs:enumeration value="notReady(3)"/>
      <xs:enumeration value="createAndGo(4)"/>
      <xs:enumeration value="createAndWait(5)"/>
      <xs:enumeration value="destroy(6)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="StorageType">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="other(1)"/>
      <xs:enumeration value="volatile(2)"/>
      <xs:enumeration value="nonVolatile(3)"/>
      <xs:enumeration value="permanent(4)"/>
      <xs:enumeration value="readOnly(5)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetAddressType">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(0)"/>
      <xs:enumeration value="ipv4(1)"/>
      <xs:enumeration value="ipv6(2)"/>
      <xs:enumeration value="ipv4z(3)"/>
      <xs:enumeration value="ipv6z(4)"/>
      <xs:enumeration value="dns(16)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetScopeType">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="interfaceLocal(1)"/>
      <xs:enumeration value="linkLocal(2)"/>
      <xs:enumeration value="subnetLocal(3)"/>
      <xs:enumeration value="adminLocal(4)"/>
      <xs:enumeration value="siteLocal(5)"/>
      <xs:enumeration value="organizationLocal(8)"/>
      <xs:enumeration value="global(14)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetVersion">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(0)"/>
      <xs:enumeration value="ipv4(1)"/>
      <xs:enumeration value="ipv6(2)"/>
    </xs:restriction>
  </xs:simpleType>

 <!-- from TRANSPORT-ADDRESS-MIB -->
  <xs:simpleType name="TransportAddressType">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(0)"/>
      <xs:enumeration value="udpIpv4(1)"/>
      <xs:enumeration value="udpIpv6(2)"/>
      <xs:enumeration value="udpIpv4z(3)"/>
      <xs:enumeration value="udpIpv6z(4)"/>
      <xs:enumeration value="tcpIpv4(5)"/>
      <xs:enumeration value="tcpIpv6(6)"/>
      <xs:enumeration value="tcpIpv4z(7)"/>
      <xs:enumeration value="tcpIpv6z(8)"/>
      <xs:enumeration value="sctpIpv4(9)"/>
      <xs:enumeration value="sctpIpv6(10)"/>
      <xs:enumeration value="sctpIpv4z(11)"/>
      <xs:enumeration value="sctpIpv6z(12)"/>
      <xs:enumeration value="local(13)"/>
      <xs:enumeration value="udpDns(14)"/>
      <xs:enumeration value="tcpDns(15)"/>
      <xs:enumeration value="sctpDns(16)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ITU-ALARM-TC-MIB -->
  <xs:simpleType name="ItuPerceivedSeverity">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="cleared(1)"/>
      <xs:enumeration value="indeterminate(2)"/>
      <xs:enumeration value="critical(3)"/>
      <xs:enumeration value="major(4)"/>
      <xs:enumeration value="minor(5)"/>
      <xs:enumeration value="warning(6)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ITU-ALARM-TC-MIB -->
  <xs:simpleType name="ItuTrendIndication">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="moreSevere(1)"/>
      <xs:enumeration value="noChange(2)"/>
      <xs:enumeration value="lessSevere(3)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ENTITY-STATE-TC-MIB -->
  <xs:simpleType name="EntityAdminState">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(1)"/>
      <xs:enumeration value="locked(2)"/>
      <xs:enumeration value="shuttingDown(3)"/>
      <xs:enumeration value="unlocked(4)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ENTITY-STATE-TC-MIB -->
  <xs:simpleType name="EntityOperState">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(1)"/>
      <xs:enumeration value="disabled(2)"/>
      <xs:enumeration value="enabled(3)"/>
      <xs:enumeration value="testing(4)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ENTITY-STATE-TC-MIB -->
  <xs:simpleType name="EntityUsageState">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(1)"/>
      <xs:enumeration value="idle(2)"/>
      <xs:enumeration value="active(3)"/>
      <xs:enumeration value="busy(4)"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from ENTITY-STATE-TC-MIB -->
  <xs:simpleType name="EntityStandbyStatus">
    <xs:restriction base="tc:NamedNumber">
      <xs:enumeration value="unknown(1)"/>
      <xs:enumeration value="hotStandby(2)"/>
      <xs:enumeration value="coldStandby(3)"/>
      <xs:enumeration value="providingService(4)"/>
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:Unsigned32 -->

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetZoneIndex">
    <xs:restriction base="smi:Unsigned32">
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetAddressPrefixLength">
    <xs:restriction base="smi:Unsigned32">
      <xs:maxInclusive value="2040"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetPortNumber">
    <xs:restriction base="smi:Unsigned32">
      <xs:maxInclusive value="65535"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetAutonomousSystemNumber">
    <xs:restriction base="smi:Unsigned32">
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfIntervalThreshold">
    <xs:restriction base="smi:Unsigned32">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="900"/>
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:Gauge32 -->

  <!-- from RMON2-MIB -->
  <xs:simpleType name="ZeroBasedCounter32">
    <xs:restriction base="smi:Gauge32">
    </xs:restriction>
  </xs:simpleType>

  <!-- from PerfHist-TC-MIB -->
   <xs:simpleType name="PerfCurrentCount">
    <xs:restriction base="smi:Gauge32">
    </xs:restriction>
  </xs:simpleType>

  <!-- from PerfHist-TC-MIB -->
  <xs:simpleType name="PerfIntervalCount">
    <xs:restriction base="smi:Gauge32">
    </xs:restriction>
  </xs:simpleType>

  <!-- from PerfHist-TC-MIB -->
  <xs:simpleType name="PerfTotalCount">
    <xs:restriction base="smi:Gauge32">
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:Counter32 -->


<!-- TCs based upon smi:TimeTicks -->

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="TimeStamp">
    <xs:restriction base="smi:TimeTicks">
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:Counter64 -->

  <!-- from HCNUM-MIB -->
  <xs:simpleType name="ZeroBasedCounter64">
    <xs:restriction base="smi:Counter64">
    </xs:restriction>
  </xs:simpleType>

  <!-- from HCNUM-MIB -->
  <xs:simpleType name="CounterBasedGauge64">
    <xs:restriction base="smi:Counter64">
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfCurrentCount">
    <xs:restriction base="smi:Counter64">
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfIntervalCount">
    <xs:restriction base="smi:Counter64">
    </xs:restriction>
  </xs:simpleType>

  <!-- from HC-PerfHist-TC-MIB -->
  <xs:simpleType name="HCPerfTotalCount">
    <xs:restriction base="smi:Counter64">
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:OctetString -->

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="DisplayString">
    <xs:restriction base="smi:OctetString">
      <xs:minLength value="0"/>
      <xs:maxLength value="255"/>
      <xs:pattern value="((((\p{IsBasicLatin})){0,255})){0,1}"/>
                        <!-- [TODO: is the {0,1} needed ?] -->
    </xs:restriction>
  </xs:simpleType>

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="MacAddress">
    <xs:restriction base="smi:OctetString">
      <xs:pattern value="((([0-9A-Fa-f]{2}):){5,5})([0-9A-Fa-f]{2})"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from SNMP-FRAMEWORK-MIB -->
  <!-- [TODO: restrict characters??] -->
  <xs:simpleType name="SnmpAdminString">
    <xs:restriction base="smi:OctetString">
      <xs:minLength value="0"/>
      <xs:maxLength value="255"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from SYSAPPL-MIB -->
  <xs:simpleType name="Utf8String">
    <xs:restriction base="smi:OctetString">
      <xs:minLength value="0"/>
      <xs:maxLength value="255"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from SYSAPPL-MIB -->
  <xs:simpleType name="LongUtf8String">
    <xs:restriction base="smi:OctetString">
      <xs:minLength value="0"/>
      <xs:maxLength value="1024"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- supports tc:InetAddressUnknown 
       [TODO: add union with zero-length or
       unrestricted??]                 -->
  <xs:simpleType name="InetAddressUnkown">
    <xs:restriction base="smi:OctetString">
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetAddressIPv4">
    <xs:restriction base="smi:OctetString">
      <xs:pattern value="((0|(1[0-9]{0,2})|
                          (2(([0-4][0-9]?)|(5[0-5]?)|([6-9]?)))|
                          ([3-9][0-9]?))\.){3}
                          (0|(1[0-9]{0,2})|
                          (2(([0-4][0-9]?)|(5[0-5]?)|([6-9]?)))|
                          ([3-9][0-9]?))"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <!-- [TODO: exists in RFC 4001
              rewrite as a pattern 
              to comply with smi:OctetString ??] -->
  <xs:element name="InetAddressIPv4z">  
    <xs:complexType>
      <xs:sequence>
        <xs:element name="ipv4Address" type="tc:InetAddressIPv4"/>
        <xs:element name="zoneIndex" type="tc:InetZoneIndex"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- supports tc:InetAddressIPv6 -->
  <xs:simpleType name="InetAddressIPv6Full">
    <xs:restriction base="tc:InetAddress">
    <xs:pattern value=
      "(([0-9a-fA-F]{1,4}:){7})([0-9a-fA-F]{1,4})"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- supports tc:InetAddressIPv6 -->
  <xs:simpleType name="InetAddressIPv6Mixed">
    <xs:restriction base="tc:InetAddress">
      <xs:pattern value="(([0-9a-fA-F]{1,4}:){6})
               (([0-9a-fA-F]{1,4}:[0-9a-fA-F]{1,4})|
               ([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- supports tc:InetAddressIPv6 -->
  <xs:simpleType name="InetAddressIPv6Shortened">
    <xs:restriction base="tc:InetAddress">
      <xs:pattern value=
      "(([0-9a-fA-F]{1,4}:)*|([0-9a-fA-F]{1,4}))*(::)
                (([0-9a-fA-F]{1,4}:)*|([0-9a-fA-F]{1,4}))*"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetAddressIPv6">
    <xs:union memberTypes=
      "tc:InetAddressIPv6Full
       tc:InetAddressIPv6Mixed
       tc:InetAddressIPv6Shortened"/>
  </xs:simpleType>

  <!-- [TODO: from INET-ADDRESS-MIB exists in RFC 4001
              rewrite as a pattern 
              to comply with smi:OctetString ??] -->
  <xs:element name="InetAddressIPv6z">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="ipv6Address" type="tc:InetAddressIPv6"/>
        <xs:element name="zoneIndex" type="tc:InetZoneIndex"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- from INET-ADDRESS-MIB -->
  <!-- [TODO: check this for validity] -->
  <xs:simpleType name="InetAddressDNS">
    <xs:restriction base="smi:OctetString">
      <xs:minLength value="1"/>
      <xs:maxLength value="255"/>
      <xs:pattern value="([\p{L}\p{N}]*\.)*[\p{L}\p{N}]?"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- from INET-ADDRESS-MIB -->
  <xs:simpleType name="InetAddress">
    <xs:union memberTypes=
      "tc:InetAddressUnknown
       tc:InetAddressIPv4
       tc:InetAddressIPv6
       tc:InetAddressIPv4z
       tc:InetAddressIPv6z
       tc:InetAddressDNS"/>
  </xs:simpleType>

  <!-- from TRANSPORT-ADDRESS-MIB -->
  <!-- [TODO: need to add a pattern??] -->
  <xs:simpleType name="TransportAddress">
    <xs:restriction base="smi:OctetString">
      <xs:minLength value="0"/>
      <xs:maxLength value="255"/>
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon smi:Opaque -->

     <!-- no TCs based upon smi:Opaque - 
             use smi:OctetString instead -->


<!-- TCs based upon smi:IpAddress -->

     <!-- no TCs based upon smi:IpAddress - 
             use tc:InetAddressType, tc:InetAddress instead -->


<!-- TCs based upon smi:ObjectIdentifier -->

  <!-- from SNMPv2-TC -->
  <xs:simpleType name="RowPointer">
    <xs:restriction base="smi:ObjectIdentifier">
    </xs:restriction>
  </xs:simpleType>

  <!-- from TRANSPORT-ADDRESS-MIB -->
  <!--  [TODO: doesn't smi:ObjectIdentifier take care of 
                                      the pattern already?] -->
  <xs:simpleType name="TransportDomain">
    <xs:restriction base="smi:ObjectIdentifier">
      <xs:pattern
        value="[0-2](\.[1-3]?[0-9])(\.(0|([1-9]\d*))){0,126}"/>
    </xs:restriction>
  </xs:simpleType>


<!-- TCs based upon BITS Construct -->

  <!-- NamedBit definition...
       for use with enumerated values -->
  <xs:simpleType name="NamedBit">
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-z]([\w-[_]]{0,63})\(
                              (\d{1,5}|
                               5[0-1](\d{4})|
                               52[0-3](\d{3})|
                               524[0-1](\d{2})|
                               5242[0-7]\d
                              )\)"/>  
     </xs:restriction>
   </xs:simpleType>

  <!-- from ENTITY-STATE-TC-MIB -->
  <xs:simpleType name="EntityAlarmStatusBitNames">
    <xs:restriction base="tc:NamedBit">
      <xs:enumeration value="unknown(0)"/>
      <xs:enumeration value="underRepair(1)"/>
      <xs:enumeration value="critical(2)"/>
      <xs:enumeration value="major(3)"/>
      <xs:enumeration value="minor(4)"/>
      <xs:enumeration value="warning(5)"/>
      <xs:enumeration value="indeterminate(6)"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="EntityAlarmStatus">
    <xs:list itemType="EntityAlarmStatusBitNames"/>
  </xs:simpleType>

<!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXX -->
<!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXX -->
<!-- [TODO:  Not Clear Where the   -->
<!--  following TCs exist]         -->
<!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXX -->
<!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXX -->

<!-- [TODO: from ?????-MIB] -->
  <xs:simpleType name="MD5">
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9a-zA-Z]{32}"/>
    </xs:restriction>
  </xs:simpleType>

<!-- [TODO: from ?????-MIB] -->
  <xs:simpleType name="E164CountryCode">
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]{3}"/>
    </xs:restriction>
  </xs:simpleType>

<!-- [TODO: from ?????-MIB] -->
  <xs:simpleType name="E164SubscriberNumber">
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]{15}"/>
    </xs:restriction>
  </xs:simpleType>


</xs:schema>
END
]]>
</artwork>
</figure>

    </section>


<!--  RATIONALE  -->
    <section title="Rationale">

<!-- from SNMPv2-TC -->

  <section title="Textual Conventions defined in SNMPv2-TC">

  <section title="DisplayString">
    <t>This XSD datatype corresponds to the SMI "DisplayString" Textual Convention.</t>
    <t>A DisplayString syntax represents textual information taken from the NVT ASCII
      character set, as defined in pages 4, 10-11 of RFC 854.</t>
     <t> To summarize RFC 854, the NVT ASCII repertoire specifies:
     <list style="symbols">
       <t>the use of character codes 0-127 (decimal)</t>
       <t>the graphics characters (32-126) are interpreted as
          US ASCII</t>
       <t>NUL, LF, CR, BEL, BS, HT, VT and FF have the special
          meanings specified in RFC 854</t>
       <t>the other 25 codes have no standard interpretation</t>
       <t>the sequence 'CR LF' means newline</t>
       <t>the sequence 'CR NUL' means carriage-return</t>
       <t>an 'LF' not preceded by a 'CR' means moving to the
          same column on the next line.</t>
       <t>the sequence 'CR x' for any x other than LF or NUL is
          illegal. (Note that this also means that a string may
          end with either 'CR LF' or 'CR NUL', but not with CR.)</t>
      </list></t>
      <t>Any object defined using this syntax may not exceed 255
      characters in length.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="TruthValue">
      <t>This XSD datatype corresponds to the SMI "TruthValue" Textual Convention.</t>
      <t>A TruthValue syntax represents a boolean value.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="TestAndIncr">
    <t>This XSD datatype corresponds to the SMI "TestAndIncr" Textual Convention.</t>
    <t>A TestAndIncr syntax represents integer-valued information used for atomic
      operations.  When the management protocol is used to specify
      that an object instance having this syntax is to be
      modified, the new value supplied via the management protocol
      must precisely match the value presently held by the
      instance.  If not, the management protocol set operation
      fails with an error of `inconsistentValue'.  Otherwise, if
      the current value is the maximum value of 2^31-1 (2147483647
      decimal), then the value held by the instance is wrapped to
      zero; otherwise, the value held by the instance is
      incremented by one.  (Note that regardless of whether the
      management protocol set operation succeeds, the variable-
      binding in the request and response PDUs are identical.)</t>

    <t>The value of the ACCESS clause for objects having this
      syntax is either `read-write' or `read-create'.  When an
      instance of a columnar object having this syntax is created,
      any value may be supplied via the management protocol.
      When the network management portion of the system is re-
      initialized, the value of every object instance having this
      syntax must either be incremented from its value prior to
      the re-initialization, or (if the value prior to the re-
      initialization is unknown) be set to a pseudo-randomly
      generated value.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="RowPointer">
      <t>Represents a pointer to an element instance.  The value is an
      absolute XPath expression that points to the instance.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="RowStatus">
      <t>This XSD datatype corresponds to the SMI "RowStatus" Textual 
         Convention as defined in SNMPv2-TC [RFC 2579].</t>
      <t>A RowStatus syntax represents a set of enumerated string values as follow:
      <list style="symbols">
          <t>active</t>
          <t>notInService</t>
          <t>notReady</t>
          <t>createAndGo</t>
          <t>createAndWait</t>
          <t>destroy</t>
      </list></t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="TimeStamp">
      <t>The value of the sysUpTime object at which a specific
      occurrence happened.  The sysUpTime object is that the time
      (in hundredths of a second) since the network management
      portion of the system was last re-initialized.  The specific
      occurrence must be defined in the description of any object
      defined using this type.</t>

      <t>If sysUpTime is reset to zero as a result of a re-
      initialization of the network management (sub)system, then
      the values of all TimeStamp objects are also reset.
      However, after approximately 497 days without a re-
      initialization, the sysUpTime object will reach 2^^32-1 and
      then increment around to zero; in this case, existing values
      of TimeStamp objects do not change.  This can lead to
      ambiguities in the value of TimeStamp objects.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="TimeInterval">
      <t>A period of time, measured in units of 0.01 seconds.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="StorageType">
      <t>Describes the memory realization of a conceptual row.  A
      row which is volatile is lost upon reboot.  A row which
      is either nonVolatile, permanent or readOnly, is
      backed up by stable storage.  A row which is permanent
      can be changed but not deleted.  A row which is readOnly
      cannot be changed nor deleted.</t>

      <t>If the value of an object with this syntax is either
      permanent or readOnly, it cannot be written.
      Conversely, if the value is either other, volatile or
      nonVolatile, it cannot be modified to be permanent or
      readOnly.</t>

      <t>Every usage of this datatype is required to
      specify the columnar objects which a permanent row must
      at a minimum allow to be writable.</t>
  </section>

<!-- from SNMPv2-TC -->
  <section title="MacAddress">
      <t>Represents an 802 MAC address represented in the
      `canonical' order defined by IEEE 802.1a, i.e., as if it
      were transmitted least significant bit first, even though
      802.5 (in contrast to other 802.x protocols) requires MAC
      addresses to be transmitted most significant bit first.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in SNMP-FRAMEWORK-MIB">

<!-- from SNMP-FRAMEWORK-MIB -->
  <section title="SnmpAdminString">
      <t>An octet string containing administrative
      information, preferably in human-readable form.</t>

      <t>To facilitate internationalization, this
      information is represented using the ISO/IEC
      IS 10646-1 character set, encoded as an octet
      string using the UTF-8 transformation format
      described in RFC3629.</t>

      <t>Since additional code points are added by
      amendments to the 10646 standard from time
      to time, implementations must be prepared to
      encounter any code point from 0x00000000 to
      0x7fffffff.  Byte sequences that do not
      correspond to the valid UTF-8 encoding of a
      code point or are outside this range are
      prohibited.</t>

      <t>The use of control codes should be avoided.</t>

      <t>When it is necessary to represent a newline,
      the control code sequence CR LF should be used.</t>

      <t>The use of leading or trailing white space should
      be avoided.</t>

      <t>For code points not directly supported by user
      interface hardware or software, an alternative
      means of entry and display, such as hexadecimal,
      may be provided.</t>

      <t>For information encoded in 7-bit US-ASCII,
      the UTF-8 encoding is identical to the
      US-ASCII encoding.</t>

      <t>UTF-8 may require multiple bytes to represent a
      single character / code point; thus the length
      of this object in octets may be different from
      the number of characters encoded.  Similarly,
      size constraints refer to the number of encoded
      octets, not the number of characters represented
      by an encoding.</t>

      <t>Note that the size of an SnmpAdminString object is
      measured in octets, not characters.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in SYSAPPL-MIB">
<!-- from SYSAPPL-MIB -->
  <section title="Utf8String">
      <t>To facilitate internationalization, this datatype
      represents information taken from the ISO/IEC IS
      10646-1 character set, encoded as an octet string
      using the UTF-8 character encoding scheme described
      in RFC 2044. For strings in 7-bit US-ASCII,
      there is no impact since the UTF-8 representation
      is identical to the US-ASCII encoding.</t>
  </section>

<!-- from SYSAPPL-MIB -->
  <section title="LongUtf8String">
      <t>To facilitate internationalization, this datatype
      represents information taken from the ISO/IEC IS
      10646-1 character set, encoded as an octet string
      using the UTF-8 character encoding scheme described
      in RFC 2044.  For strings in 7-bit US-ASCII,
      there is no impact since the UTF-8 representation
      is identical to the US-ASCII encoding.</t>
  </section>
  
  </section>

  <section title="Textual Conventions defined in RMON2-MIB">

<!-- from RMON2-MIB -->
  <section title="ZeroBasedCounter32">
      <t>This datatype describes an object which counts events with the
      following semantics: objects of this type will be set to
      zero(0) on creation and will thereafter count appropriate
      events, wrapping back to zero(0) when the value 2^32 is
      reached.</t>

      <t>Provided that an application discovers the new object within
      the minimum time to wrap it can use the initial value as a
      delta since it last polled the table of which this object is
      part.  It is important for a management station to be aware of
      this minimum time and the actual time between polls, and to
      discard data if the actual time is too long or there is no
      defined minimum time.</t>

      <t>Typically this datatype is used in tables where the INDEX space is
      constantly changing and/or the TimeFilter mechanism is in use.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in HCNUM-MIB">
<!-- from HCNUM-MIB -->
  <section title="ZeroBasedCounter64">
      <t>This datatype describes an object which counts events with the
      following semantics: objects of this type will be set to
      zero(0) on creation and will thereafter count appropriate
      events, wrapping back to zero(0) when the value 2^64 is
      reached.</t>

      <t>Provided that an application discovers the new object within
      the minimum time to wrap it can use the initial value as a
      delta since it last polled the table of which this object is
      part.  It is important for a management station to be aware
      of this minimum time and the actual time between polls, and
      to discard data if the actual time is too long or there is
      no defined minimum time.</t>

      <t>Typically this datatype is used in tables where the INDEX space is
      constantly changing and/or the TimeFilter mechanism is in use.</t>

      <t>Note that this datatype does not retain all the
      semantics of the Counter64 base type. Specifically, a
      Counter64 has an arbitrary initial value, but objects
      defined with this datatype are required to start at the value
      zero.  This behavior is not likely to have any adverse
      effects on management applications which are expecting
      Counter64 semantics.</t>
  </section>

<!-- from HCNUM-MIB -->
  <section title="CounterBasedGauge64">
      <t>This datatype represents a non-negative integer, which may
      increase or decrease, but shall never exceed a maximum value,
      nor fall below a minimum value. The maximum value can not be
      greater than 2^64-1 (18446744073709551615 decimal), and the
      minimum value can not be smaller than 0.  The value of a
      CounterBasedGauge64 has its maximum value whenever the
      information being modeled is greater than or equal to its
      maximum value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases below
      (increases above) the maximum (minimum) value, the
      CounterBasedGauge64 also decreases (increases).</t>

      <t>Note that this datatype is not strictly supported in SMIv2,
      because the 'always increasing' and 'counter wrap' semantics
      associated with the Counter64 base type are not preserved.
      It is possible that management applications which rely
      solely upon the (Counter64) ASN.1 tag to determine object
      semantics will mistakenly operate upon objects of this type
      as they would for Counter64 objects.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in IF-MIB">
<!-- from IF-MIB -->
  <section title="InterfaceIndex">
      <t>A unique value, greater than zero, for each interface or
      interface sub-layer in the managed system.  It is
      recommended that values are assigned contiguously starting
      from 1.  The value for each interface sub-layer must remain
      constant at least from one re-initialization of the entity's
      network management system to the next re-initialization.</t>
  </section>

<!-- from IF-MIB -->
  <section title="InterfaceIndexOrZero">
      <t>This datatype is an extension of the
      InterfaceIndex datatype.  The latter defines a greater
      than zero value used to identify an interface or interface
      sub-layer in the managed system.  This extension permits the
      additional value of zero.  the value zero is object-specific
      and must therefore be defined as part of the description of
      any object which uses this syntax.  Examples of the usage of
      zero might include situations where interface was unknown,
      or when none or all interfaces need to be referenced.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in ENTITY-MIB">
<!-- from ENTITY-MIB -->
  <section title="PhysicalIndex">
      <t>An arbitrary value that uniquely identifies the physical
      entity.  The value should be a small, positive integer.
      Index values for different physical entities are not
      necessarily contiguous.</t>
  </section>

<!-- from ENTITY-MIB -->
  <section title="PhysicalIndexOrZero">
      <t>This datatype is an extension of the
      PhysicalIndex datatype, which defines a greater than zero
      value used to identify a physical entity.  This extension
      permits the additional value of zero.  The semantics of the
      value zero are object-specific and must, therefore, be
      defined as part of the description of any object that uses
      this syntax.  Examples of the usage of this extension are
      situations where none or all physical entities need to be
      referenced."</t>
  </section>

  </section>

  <section title="Textual Conventions defined in INET-ADDRESS-MIB">
<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressType">
      <t>A value that represents a type of Internet address.</t>

      <t>unknown  An unknown address type.  This value MUST
               be used if the value of the corresponding
               InetAddress object is a zero-length string.
               It may also be used to indicate an IP address
               that is not in one of the formats defined
               below.</t>

      <t>ipv4     An IPv4 address as defined by the
               InetAddressIPv4 datatype.</t>

      <t>ipv6     An IPv6 address as defined by the
               InetAddressIPv6 datatype.</t>

      <t>ipv4z    A non-global IPv4 address including a zone
               index as defined by the InetAddressIPv4z
               datatype.</t>

      <t>ipv6z    A non-global IPv6 address including a zone
               index as defined by the InetAddressIPv6z
               datatype.</t>

      <t>dns      A DNS domain name as defined by the
               InetAddressDNS datatype.</t>

      <t>Each definition of a concrete InetAddressType value must be
      accompanied by a definition of a datatype for use
      with that InetAddressType.</t>

      <t>To support future extensions, the InetAddressType datatype
      SHOULD NOT be sub-typed in object type definitions.
      It MAY be sub-typed in compliance statements in order to
      require only a subset of these address types for a compliant
      implementation.</t>

      <t>Implementations must ensure that InetAddressType objects
      and any dependent objects (e.g., InetAddress objects) are
      consistent.  In particular, InetAddressType/InetAddress pairs
      must be changed together if the address type changes (e.g.,
      from ipv6 to ipv4).</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddress">
      <t>Denotes a generic Internet address.
      An InetAddress value is always interpreted within the context
      of an InetAddressType value.  Every usage of the InetAddress
      datatype is required to specify the InetAddressType
      object that provides the context.  It is suggested that the
      InetAddressType object be logically registered before the
      object(s) that use the InetAddress datatype, if
      they appear in the same logical row.</t>

      <t>The value of an InetAddress object must always be
      consistent with the value of the associated InetAddressType
      object.  Attempts to set an InetAddress object to a value
      inconsistent with the associated InetAddressType
      must fail.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressIPv4">
      <t>Represents an IPv4 network address.</t>

      <t>This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair."</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetZoneIndex">
      <t>A zone index identifies an instance of a zone of a
      specific scope.</t>

      <t>The zone index MUST disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index (ifIndex as defined in the
      IF-MIB) of the interface on which the address is configured.</t>

      <t>The zone index may contain the special value 0, which refers
      to the default zone.  The default zone may be used in cases
      where the valid zone index is not known (e.g., when a
      management application has to write a link-local IPv6
      address without knowing the interface index value).  The
      default zone SHOULD NOT be used as an easy way out in
      cases where the zone index for a non-global IPv6 address
      is known.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressIPv4z">
      <!-- element -->
      <t>Represents a non-global IPv4 network address, together
      with its zone index.</t>

      <t>The corresponding InetAddressType value is 'ipv4z'.</t>

      <t>The zone index is used to disambiguate identical
      address values on nodes that have interfaces attached to
      different zones of the same scope.  The zone index may contain
      the special value 0, which refers to the default zone for each
      scope.</t>

      <t>This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressIPv6">
      <t>Represents an IPv6 network address.</t>

      <t>The corresponding InetAddressType value is 'ipv6'.</t>

      <t>This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressIPv6z">
      <!-- is an element -->
      <t>Represents a non-global IPv6 network address, together
      with its zone index.</t>

      <t>The corresponding InetAddressType value is 'ipv6z'.
      The zone index is used to disambiguate
      identical address values on nodes that have interfaces
      attached to different zones of the same scope.  The zone index
      may contain the special value 0, which refers to the default
      zone for each scope.</t>

      <t>This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressDNS">
      <t>Represents a DNS domain name.  The name SHOULD be fully
      qualified whenever possible.</t>

      <t>The corresponding InetAddressType is dns.</t>

      <t>The DESCRIPTION clause of InetAddress objects that may have
      InetAddressDNS values MUST fully describe how (and when)
      these names are to be resolved to IP addresses.</t>

      <t>The resolution of an InetAddressDNS value may require to
      query multiple DNS records (e.g., A for IPv4 and AAAA for
      IPv6).  The order of the resolution process and which DNS
      record takes precedence depends on the configuration of the
      resolver.</t>

      <t>This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAddressPrefixLength">
      <t>Denotes the length of a generic Internet network address
      prefix.  A value of n corresponds to an IP address mask
      that has n contiguous 1-bits from the most significant
      bit (MSB), with all other bits set to 0.</t>

      <t>An InetAddressPrefixLength value is always interpreted within
      the context of an InetAddressType value.  Every usage of the
      InetAddressPrefixLength datatype is required to
      specify the InetAddressType object that provides the
      context.  It is suggested that the InetAddressType object be
      logically registered before the object(s) that use the
      InetAddressPrefixLength datatype, if they appear
      in the same logical row.</t>

      <t>InetAddressPrefixLength values larger than
      the maximum length of an IP address for a specific
      InetAddressType are treated as the maximum significant
      value applicable for the InetAddressType.  The maximum
      significant value is 32 for the InetAddressType
      'ipv4' and 'ipv4z' and 128 for the InetAddressType
      'ipv6' and 'ipv6z'.  The maximum significant value
      for the InetAddressType 'dns' is 0.</t>

      <t>The value zero is object-specific and must be defined as
      part of the description of any object that uses this
      syntax.  Examples of the usage of zero might include
      situations where the Internet network address prefix
      is unknown or does not apply.</t>

      <t>The upper bound of the prefix length has been chosen to
      be consistent with the maximum size of an InetAddress.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetPortNumber">
      <t>Represents a 16 bit port number of an Internet transport
      layer protocol.  Port numbers are assigned by IANA.  A
      current list of all assignments is available from
      &lt;http://www.iana.org/&gt;.</t>

      <t>The value zero is object-specific and must be defined as
      part of the description of any object that uses this
      syntax.  Examples of the usage of zero might include
      situations where a port number is unknown, or when the
      value zero is used as a wildcard in a filter.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetAutonomousSystemNumber">
      <t>Represents an autonomous system number that identifies an
      Autonomous System (AS).  An AS is a set of routers under a
      single technical administration, using an interior gateway
      protocol and common metrics to route packets within the AS,
      and using an exterior gateway protocol to route packets to
      other ASes'.  IANA maintains the AS number space and has
      delegated large parts to the regional registries.</t>

      <t>Autonomous system numbers had been limited to 16 bits
      (0..65535).  But they have been enlarged to 32 bits in
      RFC 4893 now. Therefore, this datatype uses an unsignedInt
      value without a range restriction.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetScopeType">
      <t>Represents a scope type.  This datatype can be used
      in cases where a MIB has to represent different scope types
      and there is no context information, such as an InetAddress
      object, that implicitly defines the scope type.</t>

      <t>Note that not all possible values have been assigned yet, but
      they may be assigned in future revisions of this specification.
      Applications should therefore be able to deal with values
      not yet assigned.</t>
  </section>

<!-- from INET-ADDRESS-MIB -->
  <section title="InetVersion">
      <t>A value representing a version of the IP protocol.</t>

      <t>unknown  An unknown or unspecified version of the IP
               protocol.</t>

      <t>ipv4     The IPv4 protocol as defined in RFC 791 (STD 5).</t>

      <t>ipv6     The IPv6 protocol as defined in RFC 2460.</t>

      <t>Note that this datatype SHOULD NOT be used to
      distinguish different address types associated with IP
      protocols.  The InetAddressType has been designed for this
      purpose.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in TRANSPORT-ADDRESS-MIB">
<!-- from TRANSPORT-ADDRESS-MIB -->
  <section title="TransportDomain">
      <t>A value that represents a transport domain.</t>
  </section>

<!-- from TRANSPORT-ADDRESS-MIB -->
  <section title="TransportAddressType">
      <t>A value that represents a transport domain.  The enumerated
      values have the following meaning:

      <list style="symbols">
          <t>unknown     unknown transport address type</t>
          <t>udpIpv4     transportDomainUdpIpv4</t>
          <t>udpIpv6     transportDomainUdpIpv6</t>
          <t>udpIpv4z    transportDomainUdpIpv4z</t>
          <t>udpIpv6z    transportDomainUdpIpv6z</t>
          <t>tcpIpv4     transportDomainTcpIpv4</t>
          <t>tcpIpv6     transportDomainTcpIpv6</t>
          <t>tcpIpv4z    transportDomainTcpIpv4z</t>
          <t>tcpIpv6z    transportDomainTcpIpv6z</t>
          <t>sctpIpv4    transportDomainSctpIpv4</t>
          <t>sctpIpv6    transportDomainSctpIpv6</t>
          <t>sctpIpv4z   transportDomainSctpIpv4z</t>
          <t>sctpIpv6z   transportDomainSctpIpv6z</t>
          <t>local       transportDomainLocal</t>
          <t>udpDns      transportDomainUdpDns</t>
          <t>tcpDns      transportDomainTcpDns</t>
          <t>sctpDns     transportDomainSctpDns</t>
      </list></t>

      <t>This datatype can be used to represent transport
      domains in situations where a syntax of TransportDomain is
      unwieldy (for example, when used as an index).</t>

      <t>The usage of this datatype implies that additional
      transport domains can only be supported by updating this MIB
      module. This extensibility restriction does not apply for the
      TransportDomain datatype which allows data model authors
      to define additional transport domains independently in
      other data model modules.</t>
  </section>

<!-- from TRANSPORT-ADDRESS-MIB -->
  <section title="TransportAddress">
      <t>Denotes a generic transport address.</t>

      <t>A TransportAddress value is always interpreted within the
      context of a TransportAddressType or TransportDomain value.
      Every usage of the TransportAddress datatype MUST
      specify the TransportAddressType or TransportDomain object which
      provides the context. Furthermore, data model authors SHOULD
      define a separate TransportAddressType or TransportDomain
      object for each TransportAddress object. It is suggested that
      the TransportAddressType or TransportDomain is logically
      registered before the object(s) which use the
      TransportAddress datatype if they appear in the
      same logical row.</t>

      <t>The value of a TransportAddress object must always be
      consistent with the value of the associated
      TransportAddressType or TransportDomain object. Attempts
      to set a TransportAddress object to a value which is
      inconsistent with the associated TransportAddressType or
      TransportDomain must fail with an error.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in PerfHist-TC-MIB">
<!-- from PerfHist-TC-MIB -->
   <section title="PerfCurrentCount">
       <t>A counter associated with a performance 
       measurement in a current 15 minute 
       measurement interval.  The value of this 
       counter starts from zero and is increased 
       when associated events occur, until the end 
       of the 15 minute interval.  At that time the 
       value of the counter is stored in the first 
       15 minute history interval, and the 
       CurrentCount is restarted at zero.  In the 
       case where the agent has no valid data 
       available for the current interval the 
       corresponding object instance is not
       available and upon a retrieval request
       a corresponding error message shall be
       returned to indicate that this instance
       does not exist.</t>
  </section>

<!-- from PerfHist-TC-MIB -->
  <section title="PerfIntervalCount">
      <t>A counter associated with a
      performance measurement in a previous
      15 minute measurement interval.  In the
      case where the agent has no valid data
      available for a particular interval the
      corresponding object instance is not
      available and upon a retrieval request
      a corresponding error message shall be
      returned to indicate that this instance
      does not exist.</t>

      <t>In a system supporting
      a history of n intervals with
      most and least recent intervals
      respectively, the following applies at
      the end of a 15 minute interval:
      <list style="symbols">
          <t>discard the value of IntervalCount(n)</t>
          <t>the value of IntervalCount(i) becomes that
             of IntervalCount(i-1) for n >= i > 1</t>
          <t>the value of IntervalCount(1) becomes that
             of CurrentCount</t>
          <t>the TotalCount, if supported, is adjusted.</t>
      </list></t>
  </section>

<!-- from PerfHist-TC-MIB -->
  <section title="PerfTotalCount">
      <t>A counter associated with a
      performance measurements aggregating the
      previous valid 15 minute measurement
      intervals.  (Intervals for which no valid
      data was available are not counted)</t>
  </section>

  </section>

  <section title="Textual Conventions defined in HC-PerfHist-TC-MIB">
<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfValidIntervals">
      <t>The number of near end intervals for which data was
      collected.  The value of an object with an
      HCPerfValidIntervals syntax will be 96 unless the
      measurement was (re-)started within the last 1440 minutes,
      in which case the value will be the number of complete 15
      minute intervals for which the agent has at least some data.
      In certain cases (e.g., in the case where the agent is a
      proxy) it is possible that some intervals are unavailable.
      In this case, this interval is the maximum interval number
      for which data is available.</t>
  </section>

<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfInvalidIntervals">
      <t>The number of near end intervals for which no data is
      available.  The value of an object with an
      HCPerfInvalidIntervals syntax will typically be zero except
      in cases where the data for some intervals are not available
      (e.g., in proxy situations).</t>
  </section>

<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfTimeElapsed">
      <t>The number of seconds that have elapsed since the beginning
      of the current measurement period.  If, for some reason,
      such as an adjustment in the system's time-of-day clock or
      the addition of a leap second, the duration of the current
      interval exceeds the maximum value, the agent will return
      the maximum value.</t>

      <t>For 15 minute intervals, the range is limited to (0..899).
      For 24 hour intervals, the range is limited to (0..86399).</t>
  </section>

<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfIntervalThreshold">
      <t>This convention defines a range of values that may be set
      in a fault threshold alarm control.  As the number of
      seconds in a 15-minute interval numbers at most 900,
      objects of this type may have a range of 0...900, where the
      value of 0 disables the alarm.</t>
  </section>

<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfCurrentCount">
      <t>A gauge associated with a performance measurement in a
      current 15 minute measurement interval.  The value of an
      object with an HCPerfCurrentCount syntax starts from zero
      and is increased when associated events occur, until the
      end of the 15 minute interval.  At that time the value of
      the gauge is stored in the first 15 minute history
      interval, and the gauge is restarted at zero.  In the case
      where the agent has no valid data available for the
      current interval, the corresponding object instance is not
      available and upon a retrieval request a corresponding
      error message shall be returned to indicate that this
      instance does not exist.</t>

      <t>This count represents a non-negative integer, which
      may increase or decrease, but shall never exceed 2^64-1
      (18446744073709551615 decimal), nor fall below 0.  The
      value of an object with HCPerfCurrentCount syntax
      assumes its maximum value whenever the underlying count
      exceeds 2^64-1.  If the underlying count subsequently
      decreases below 2^64-1 (due, e.g., to a retroactive
      adjustment as a result of entering or exiting unavailable
      time), then the object's value also decreases.</t>
  </section>

<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfIntervalCount">
      <t>A gauge associated with a performance measurement in
      a previous 15 minute measurement interval.  In the case
      where the agent has no valid data available for a
      particular interval, the corresponding object instance is
      not available and upon a retrieval request a corresponding
      error message shall be returned to indicate that this
      instance does not exist.</t>

      <t>Let X be an object with HCPerfIntervalCount syntax.
      Let Y be an object with HCPerfCurrentCount syntax.
      Let Z be an object with HCPerfTotalCount syntax.
      Then, in a system supporting a history of n intervals with
      X(1) and X(n) the most and least recent intervals
      respectively, the following applies at the end of a 15
      minute interval:
          <list style="symbols">
             <t>discard the value of X(n)</t>
             <t>the value of X(i) becomes that of X(i-1)
                for n >= i > 1</t>
             <t>the value of X(1) becomes that of Y.</t>
             <t>the value of Z, if supported, is adjusted.</t>
         </list></t>

      <t>This count represents a non-negative integer, which
      may increase or decrease, but shall never exceed 2^64-1
      (18446744073709551615 decimal), nor fall below 0.  The
      value of an object with HCPerfIntervalCount syntax
      assumes its maximum value whenever the underlying count
      exceeds 2^64-1.  If the underlying count subsequently
      decreases below 2^64-1 (due, e.g., to a retroactive
      adjustment as a result of entering or exiting unavailable
      time), then the value of the object also decreases.</t>
  </section>

<!-- from HC-PerfHist-TC-MIB -->
  <section title="HCPerfTotalCount">
      <t>A gauge representing the aggregate of previous valid 15
      minute measurement intervals.  Intervals for which no
      valid data was available are not counted.</t>

      <t>This count represents a non-negative integer, which
      may increase or decrease, but shall never exceed 2^64-1
      (18446744073709551615 decimal), nor fall below 0.  The
      value of an object with HCPerfTotalCount syntax
      assumes its maximum value whenever the underlying count
      exceeds 2^64-1.  If the underlying count subsequently
      decreases below 2^64-1 (due, e.g., to a retroactive
      adjustment as a result of entering or exiting unavailable
      time), then the object's value also decreases.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in ITU-ALARM-TC-MIB">
<!-- from ITU-ALARM-TC-MIB -->
  <section title="ItuPerceivedSeverity">
      <t>ITU perceived severity values.</t>
  </section>

<!-- from ITU-ALARM-TC-MIB -->
  <section title="ItuTrendIndication">
      <t>ITU trend indication values for alarms.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in ENTITY-STATE-TC-MIB">
<!-- from ENTITY-STATE-TC-MIB -->
  <section title="EntityAdminState">
      <t>Represents the various possible administrative states.</t>

      <t>A value of 'locked' means the resource is administratively
      prohibited from use.  A value of 'shuttingDown' means that
      usage is administratively limited to current instances of
      use.  A value of 'unlocked' means the resource is not
      administratively prohibited from use.  A value of
      'unknown' means that this resource is unable to
      report administrative state.</t>
  </section>

<!-- from ENTITY-STATE-TC-MIB -->
  <section title="EntityOperState">
      <t>Represents the possible values of operational states.</t>

      <t>A value of 'disabled' means the resource is totally
      inoperable.  A value of 'enabled' means the resource
      is partially or fully operable.  A value of 'testing'
      means the resource is currently being tested
      and cannot therefore report whether it is operational
      or not.  A value of 'unknown' means that this
      resource is unable to report operational state.</t>
  </section>

<!-- from ENTITY-STATE-TC-MIB -->
  <section title="EntityUsageState">
      <t>Represents the possible values of usage states.</t>

      <t>A value of 'idle' means the resource is servicing no
      users.  A value of 'active' means the resource is
      currently in use and it has sufficient spare capacity
      to provide for additional users.  A value of 'busy'
      means the resource is currently in use, but it
      currently has no spare capacity to provide for
      additional users.  A value of 'unknown' means
      that this resource is unable to report usage state.</t>
  </section>

<!-- from ENTITY-STATE-TC-MIB -->
  <section title="EntityAlarmStatus">
      <t>Represents the possible values of alarm status.
      An Alarm , as defined in RFC3877, is a persistent indication
      of an error or warning condition.</t>

      <t>When no bits of this attribute are set, then no active
      alarms are known against this entity and it is not under
      repair.</t>

      <t>When the 'value of underRepair' is set, the resource is
      currently being repaired, which, depending on the
      implementation, may make the other values in this bit
      string not meaningful.</t>

      <t>When the value of 'critical' is set, one or more critical
      alarms are active against the resource.  When the value
      of 'major' is set, one or more major alarms are active
      against the resource.  When the value of 'minor' is set,
      one or more minor alarms are active against the resource.
      When the value of 'warning' is set, one or more warning
      alarms are active against the resource.  When the value
      of 'indeterminate' is set, one or more alarms of whose
      perceived severity cannot be determined are active
      against this resource.</t>

      <t>A value of 'unknown' means that this resource is
      unable to report alarm state.</t>
  </section>

<!-- from ENTITY-STATE-TC-MIB -->
  <section title="EntityStandbyStatus">
      <t>Represents the possible values of standby status.</t>

      <t>A value of 'hotStandby' means the resource is not
      providing service, but it will be immediately able to
      take over the role of the resource to be backed up,
      without the need for initialization activity, and will
      contain the same information as the resource to be
      backed up.  A value of 'coldStandy' means that the
      resource is to back up another resource, but will not
      be immediately able to take over the role of a resource
      to be backed up, and will require some initialization
      activity.  A value of 'providingService' means the
      resource is providing service.  A value of
      'unknown' means that this resource is unable to
      report standby state.</t>
  </section>

  </section>

  <section title="Textual Conventions defined in Q-BRIDGE-MIB">
<!-- from Q-BRIDGE-MIB -->
  <section title="VlanId">
      <t>The VLAN-ID that uniquely identifies a VLAN.  This
      is the 12-bit VLAN-ID used in the VLAN Tag header.</t>
  </section>

<!-- from Q-BRIDGE-MIB -->
  <section title="VlanIdOrAny">
      <t>The VLAN-ID that uniquely identifies a specific VLAN,
      or any VLAN.  The value of 4095 is used to
      indicate a wildcard, i.e., any VLAN.  This can be used
      in any situation where an object or table entry must
      refer either to a specific VLAN or to any VLAN.</t>

      <t>Note that a managed object that is defined using this
      datatype should clarify the meaning of 'any VLAN' (i.e.,
      the special value 4095).</t>
  </section>

<!-- from Q-BRIDGE-MIB -->
  <section title="VlanIdOrNone">
      <t>The VLAN-ID that uniquely identifies a specific VLAN,
      or no VLAN.  The value of zero is used to
      indicate that no VLAN-ID is present or used.  This can
      be used in any situation where an object or a table entry
      must refer either to a specific VLAN, or to no VLAN.</t>

      <t>Note that a managed object that is defined using this
      datatype should clarify the meaning of 'no VLAN' (i.e.,
      the special value 0).</t>
  </section>

  </section>


    </section>

<!--  SECURITY CONSIDERATIONS  -->
    <section title="Security Considerations">
      <t>Security considerations for any given SMI MIB module are likely to be
      relevant to any XSD/XML mapping of that MIB module; however, the mapping
      defined in this document does not itself introduce any new security
      considerations.</t>
      <t>If and when proxies or gateways are developed to convey SNMP management
      information from SNMP agents to XML-based management applications via
      XSD/XML mapping of MIB modules based on this specification and its planned
      siblings, special care will need to be taken to ensure that all applicable
      SNMP security mechanisms are supported in an appropriate manner yet to be
      determined.</t>
    </section>

<!--  IANA CONSIDERATIONS  -->
    <section title="IANA Considerations">
      <t>In accordance with RFC 3688 <xref target="RFC3688"/>, we request the
      following namespace and schema registrations associated with this document
      in the IANA XML Registry:
        <list style="symbols">
          <t>urn:ietf:params:xml:ns:smi:tc:[version_id]</t>
          <t>urn:ietf:params:xml:schema:smi:tc:[version_id]</t>
        </list></t>
          <section title="SMI Textual Conventions Namespace Registration">
            <t>This document registers a URI for the SMI Textual Conventions XML namespace
            in the IETF XML registry.  Following the format in RFC 3688, IANA has
            made the following registration:</t>
            <t>URI: urn:ietf:params:xml:smi:tc:1.0</t>
            <t>Registration Contact: The IESG.</t>
            <t>XML: N/A, the requested URI is an XML namespace.</t>
          </section>
          <section title="SMI Textual Conventions Schema Registration">
            <t>This document registers a URI for the SMI Textual Conventions XML schema
            in the IETF XML registry.  Following the format in RFC 3688, IANA has
            made the following registration:</t>
            <t>URI: urn:ietf:params:xml:schema:smi:tc:1.0</t>
            <t>Registration Contact: The IESG.</t>
            <t>XML: Section 4 of this document.</t>
          </section>
    </section>

<!--  ACKNOWLEDGEMENTS  -->
    <section title="Acknowledgements">
      <t>Dave Harrington provided strategic and technical leadership to the
      team which developed this particular specification.  Yan Li did much
      of the research into existing approaches that was used as a baseline for
      the recommendations in this particular specification.</t>

      <t>This document owes much to draft-romascanu-netconf-datatypes-xx,
      Dan Romascanu, Subrata Mazumdar, Sandeep Adwankar and
      many other sources (including libsmi and group discussions on the NETCONF
      mailing lists) developed by those who have researched and published candidate
      mappings of SMI textual conventions to XSD.</t>

      <!-- t>Individuals who participated in various discussions of this topic at
      IETF meetings and on IETF mailing lists include: Ray Atarashi, Yoshifumi
      Atarashi, Andy Bierman, Sharon Chisholm, Avri Doria, Rob Ennes, Eliot Lear, 
      Chris Lonvick, Faye Ly, Randy Presuhn, Juergen Schoenwaelder, Andrea Westerinen, 
      and Bert Wijnen.</t -->
    </section>

  </middle>
  <back>


    <!--  NORMATIVE REFERENCES  -->

    <references title="Normative References">
      <reference anchor="RFC1155">
        <front>
          <title abbrev="SMI">Structure and identification of management information for TCP/IP-based internets</title>
          <author initials="M." surname="Rose" fullname="Marshall T. Rose">
            <organization>Performance Systems International, Inc.</organization>
            <address>
              <postal>
                <street>P.O. Box 391776</street>
                <city>Mountain View</city>
                <region>CA</region>
                <code>94039</code>
                <country>US</country>
              </postal>
              <phone>+1 415 961 3380</phone>
              <email>mrose@PSI.COM</email>
            </address>
          </author>
          <author initials="K." surname="McCloghrie" fullname="Keith McCloghrie">
            <organization>Hughes LAN Systems, The Wollongong Group</organization>
            <address>
              <postal>
                <street>1129 San Antonio Road</street>
                <city>Palo Alto</city>
                <region>CA</region>
                <code>94303</code>
                <country>US</country>
              </postal>
              <phone>+1 415 962 7160</phone>
              <email>sytek!kzm@HPLABS.HP.COM</email>
            </address>
          </author>
          <date year="1990" day="1" month="May"/>
        </front>
        <seriesInfo name="STD" value="16"/>
        <seriesInfo name="RFC" value="1155"/>
        <format type="TXT" octets="40927" target="ftp://ftp.isi.edu/in-notes/rfc1155.txt"/>
      </reference>
      
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials="s." surname="Bradner" fullname="Scott Brander">
            <organization>Harvard University</organization>
            <address>
              <postal>
                <street>1350 Mass. Ave.</street>
                <street>Cambridge</street>
                <street>MA 02138</street>
              </postal>
              <phone>- +1 617 495 3864</phone>
              <email>sob@harvard.edu</email>
            </address>
          </author>
          <date month="March" year="1997"/>
          <area>General</area>
          <keyword>keyword</keyword>
          <abstract>
            <t>
              In many standards track documents several words are used to
              signify the requirements in the specification. These words are
              often capitalized. This document defines these words as they
              should be interpreted in IETF documents. Authors who follow these
              guidelines should incorporate this phrase near the beginning of
              their document:
              <list>
                <t>
                  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
                  "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                  "OPTIONAL" in this document are to be interpreted as described
                  in RFC 2119.
                </t>
              </list>
            </t>
            <t>
              Note that the force of these words is modified by the
              requirement level of the document in which they are used.
            </t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <format octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt" type="TXT" />
        <format octets="16553" target="http://xml.resource.org/public/rfc/html/rfc2119.html" type="HTML" />
        <format octets="5703" target="http://xml.resource.org/public/rfc/xml/rfc2119.xml" type="XML" />
      </reference>

      <reference anchor='RFC2287'>
        <front>
          <title abbrev='System-Level Managed Objects'>
            Definitions of System-Level Managed Objects for Applications
          </title>
          <author initials='C.' surname='Krupczak' fullname='Cheryl Krupczak'>
            <organization>Empire Technologies, Inc.</organization>
            <address>
              <postal>
                <street>541 Tenth Street</street>
                <street>NW Suite 169</street>
                <street>Atlanta</street>
                <street>GA 30318</street>
              </postal>
              <phone>770.384.0184</phone>
              <email>cheryl@empiretech.com</email>
            </address>
          </author>
          <author initials='J.' surname='Saperia' fullname='Jonathan Saperia'>
            <organization>BGS Systems Inc.</organization>
            <address>
              <email>saperia@networks.bgs.com</email>
            </address>
          </author>
          <date year='1998' month='February' />
          <area>Management</area>
          <keyword>Management Information Base</keyword>
          <keyword>managed object</keyword>
          <abstract>
            <t>
              This memo defines a portion of the Management Information Base (MIB)
              for use with network management protocols in the Internet community.
              In particular, it describes a basic set of managed objects for fault,
              configuration and performance management of applications from a
              systems perspective.  More specifically, the managed objects are
              restricted to information that can be determined from the system
              itself and which does not require special instrumentation within the
              applications to make the information available.
            </t>
            <t>
              This memo does not specify a standard for the Internet community.
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='2287' />
        <format type='TXT' octets='98210' target='ftp://ftp.isi.edu/in-notes/rfc2287.txt' />
        <format type='HTML' octets='107810' target='http://xml.resource.org/public/rfc/html/rfc2287.html' />
        <format type='XML' octets='94651' target='http://xml.resource.org/public/rfc/xml/rfc2287.xml' />
      </reference>

      <reference anchor="RFC2578">
        <front>
          <title abbrev="SMIv2">Structure of Management Information Version 2
                    (SMIv2)</title>
          <author initials="K." surname="McCloghrie" fullname="Keith McCloghrie"
                    role="editor">
            <organization>Cisco Systems, Inc.</organization>
            <address>
              <postal>
                <street>170 West Tasman Drive</street>
                <city>San Jose</city>
                <region>CA</region>
                <code>95134-1706</code>
                <country>USA</country>
              </postal>
              <phone>+1 408 526 5260</phone>
              <email>kzm@cisco.com</email>
            </address>
          </author>
          <author initials="D." surname="Perkins" fullname="David Perkins"
                    role="editor">
            <organization>SNMPinfo</organization>
            <address>
              <postal>
                <street>3763 Benton Street</street>
                <city>Santa Clara</city>
                <region>CA</region>
                <code>95051</code>
                <country>USA</country>
              </postal>
              <phone>+1 408 221 8702</phone>
              <email>dperkins@snmpinfo.com</email>
            </address>
          </author>
          <author initials="J." surname="Schoenwaelder" fullname="Juergen Schoenwaelder"
                    role="editor">
            <organization>TU Braunschweig</organization>
            <address>
              <postal>
                <street>Bueltenweg 74/75</street>
                <street>38106 Braunschweig</street>
                <country>Germany</country>
              </postal>
              <phone>+49 531 3913283</phone>
              <email>schoenw@ibr.cs.tu-bs.de</email>
            </address>
          </author>
          <date month="April" year="1999"/>
        </front>
        <seriesInfo name="STD" value="58"/>
        <seriesInfo name="RFC" value="2578"/>
      </reference>
      
      <reference anchor='RFC2579'>
        <front>
          <title>Textual Conventions for SMIv2</title>
          <author initials='K.' surname='McCloghrie' fullname='Keith McCloghrie' role='editor'>
            <organization>Cisco Systems, Inc.</organization>
            <address>
              <postal>
                <street>170 West Tasman Drive</street>
                <city>San Jose</city>
                <region>CA</region>
                <code>95134-1706</code>
                <country>US</country>
              </postal>
              <phone>+1 408 526 5260</phone>
              <email>kzm@cisco.com</email>
            </address>
          </author>
          <author initials='D.' surname='Perkins' fullname='David Perkins' role='editor'>
            <organization>SNMPinfo</organization>
            <address>
              <postal>
                <street>3763 Benton Street</street>
                <city>Santa Clara</city>
                <region>CA</region>
                <code>95051</code>
                <country>US</country>
              </postal>
              <phone>+1 408 221 8702</phone>
              <email>dperkins@snmpinfo.com</email>
            </address>
          </author>
          <author initials='J.' surname='Schoenwaelder' fullname='Juergen Schoenwaelder' role='editor'>
            <organization>TU Braunschweig</organization>
            <address>
              <postal>
                <street>Bueltenweg 74/75</street>
                <street>38106 Braunschweig</street>
                <country>DE</country>
              </postal>
              <phone>+49 531 3913283</phone>
              <email>schoenw@ibr.cs.tu-bs.de</email>
            </address>
          </author>
          <date year='1999' month='April' />
        </front>
      
        <seriesInfo name='STD' value='58' />
        <seriesInfo name='RFC' value='2579' />
        <format type='TXT' octets='59039' target='ftp://ftp.isi.edu/in-notes/rfc2579.txt' />
      </reference>

      <reference anchor='RFC2856'>
        <front>
          <title>Textual Conventions for Additional High Capacity Data Types</title>
          <author initials='A.' surname='Bierman' fullname='A. Bierman'>
            <organization />
          </author>
          <author initials='K.' surname='McCloghrie' fullname='K. McCloghrie'>
            <organization />
          </author>
          <author initials='R.' surname='Presuhn' fullname='R. Presuhn'>
            <organization />
          </author>
          <date year='2000' month='June' />
          <abstract>
            <t>
              This memo specifies new textual conventions for additional high capacity 
              data types, intended for SNMP implementations which already support the 
              Counter64 data type. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        
        <seriesInfo name='RFC' value='2856' />
        <format type='TXT' octets='20954' target='ftp://ftp.isi.edu/in-notes/rfc2856.txt' />
      </reference>

      <reference anchor='RFC2863'>
        <front>
          <title>The Interfaces Group MIB</title>
          <author initials='K.' surname='McCloghrie' fullname='K. McCloghrie'>
            <organization />
            </author>
          <author initials='F.' surname='Kastenholz' fullname='F. Kastenholz'>
            <organization />
          </author>
          <date year='2000' month='June' />
          <abstract>
            <t>
              This memo discusses the 'interfaces' group of MIB-II, especially the 
              experience gained from the definition of numerous media-specific MIB 
              modules for use in conjunction with the 'interfaces' group for managing 
              various sub-layers beneath the internetwork-layer.  It specifies 
              clarifications to, and extensions of, the architectural issues within 
              the MIB-II model of the 'interfaces' group. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='2863' />
        <format type='TXT' octets='155014' target='ftp://ftp.isi.edu/in-notes/rfc2863.txt' />
      </reference>

      <reference anchor='RFC3411'>
        <front>
          <title>
            An Architecture for Describing Simple Network Management Protocol (SNMP) 
            Management Frameworks
          </title>
          <author initials='D.' surname='Harrington' fullname='D. Harrington'>
            <organization />
          </author>
          <author initials='R.' surname='Presuhn' fullname='R. Presuhn'>
            <organization />
          </author>
          <author initials='B.' surname='Wijnen' fullname='B. Wijnen'>
            <organization />
          </author>
          <date year='2002' month='December' />
          <abstract>
            <t>
              This document describes an architecture for describing Simple Network 
              Management Protocol (SNMP) Management Frameworks.  The architecture is 
              designed to be modular to allow the evolution of the SNMP protocol standards 
              over time.  The major portions of the architecture are an SNMP engine 
              containing a Message Processing Subsystem, a Security Subsystem and an 
              Access Control Subsystem, and possibly multiple SNMP applications which 
              provide specific functional processing of management data.  This document 
              obsoletes RFC 2571. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='STD' value='62' />
        <seriesInfo name='RFC' value='3411' />
        <format type='TXT' octets='140096' target='ftp://ftp.isi.edu/in-notes/rfc3411.txt' />
      </reference>

      <reference anchor='RFC3419'>
        <front>
          <title>Textual Conventions for Transport Addresses</title>
          <author initials='M.' surname='Daniele' fullname='M. Daniele'>
            <organization />
          </author>
          <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
            <organization />
          </author>
          <date year='2002' month='December' />
          <abstract>
            <t>
              This document introduces a Management Information Base (MIB) module that 
              defines textual conventions to represent commonly used transport-layer 
              addressing information.  The definitions are compatible with the concept of 
              TAddress/TDomain pairs introduced by the Structure of Management Information 
              version 2 (SMIv2) and support the Internet transport protocols over IPv4 and 
              IPv6. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='3419' />
        <format type='TXT' octets='37466' target='ftp://ftp.isi.edu/in-notes/rfc3419.txt' />
      </reference>

      <reference anchor='RFC3440'>
        <front>
          <title>
            Definitions of Extension Managed Objects for Asymmetric Digital Subscriber Lines
          </title>
          <author initials='F.' surname='Ly' fullname='F. Ly'>
            <organization />
          </author>
          <author initials='G.' surname='Bathrick' fullname='G. Bathrick'>
            <organization />
          </author>
          <date year='2002' month='December' />
          <abstract>
            <t>This memo defines a portion of the Management Information Base (MIB)
            for use with network management protocols in the Internet community.
            In particular, it describes additional managed objects used for managing
            Asymmetric Digital Subscriber Line (ADSL) interfaces not covered by the
            ADSL Line MIB (RFC 2662). [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='3440' />
        <format type='TXT' octets='76058' target='ftp://ftp.rfc-editor.org/in-notes/rfc3440.txt' />
      </reference>

      <reference anchor='RFC3584'>
        <front>
          <title>
            Coexistence between Version 1, Version 2, and Version 3 of the
            Internet-standard Network Management Framework
          </title>
          <author initials='R.' surname='Frye' fullname='R. Frye'>
            <organization/>
          </author>
          <author initials='D.' surname='Levi' fullname='D. Levi'>
            <organization/>
          </author>
          <author initials='S.' surname='Routhier' fullname='S. Routhier'>
            <organization/>
          </author>
          <author initials='B.' surname='Wijnen' fullname='B. Wijnen'>
            <organization/>
          </author>
          <date year='2003' month='August' />
        </front>
        <seriesInfo name='BCP' value='74' />
        <seriesInfo name='RFC' value='3584' />
        <format type='TXT' octets='115222' target='ftp://ftp.isi.edu/in-notes/rfc3584.txt' />
      </reference>
    
      <reference anchor='RFC3593'>
        <front>
          <title>
            Textual Conventions for MIB Modules Using Performance History Based 
            on 15 Minute Intervals
          </title>
          <author initials='K.' surname='Tesink' fullname='K. Tesink'>
            <organization />
          </author>
          <date year='2003' month='September' />
          <abstract>
            <t>
              This document defines a set of Textual Conventions for MIB modules 
              that make use of performance history data based on 15 minute intervals.  
              This memo replaces RFC 2493.  Changes relative to RFC 2493 are summarized 
              in the MIB module's REVISION clause. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='3593' />
        <format type='TXT' octets='20363' target='ftp://ftp.isi.edu/in-notes/rfc3593.txt' />
      </reference>

      <reference anchor='RFC3629'>
        <front>
          <title>UTF-8, a transformation format of ISO 10646</title>
          <author initials='F.' surname='Yergeau' fullname='F. Yergeau'>
            <organization />
          </author>
          <date year='2003' month='November' />
          <abstract>
            <t>
              ISO/IEC 10646-1 defines a large character set called the Universal 
              Character Set (UCS) which encompasses most of the world's writing systems.  
              The originally proposed encodings of the UCS, however, were not 
              compatible with many current applications and protocols, and this has 
              led to the development of UTF-8, the object of this memo.  UTF-8 has 
              the characteristic of preserving the full US-ASCII range, providing 
              compatibility with file systems, parsers and other software that rely 
              on US-ASCII values but are transparent to other values.  This memo 
              obsoletes and replaces RFC 2279.
            </t>
          </abstract>
        </front>
        <seriesInfo name='STD' value='63' />
        <seriesInfo name='RFC' value='3629' />
        <format type='TXT' octets='33856' target='ftp://ftp.isi.edu/in-notes/rfc3629.txt' />
      </reference>

      <reference anchor='RFC3705'>
        <front>
          <title>
            High Capacity Textual Conventions for MIB Modules Using Performance 
            History Based on 15 Minute Intervals
          </title>
          <author initials='B.' surname='Ray' fullname='B. Ray'>
            <organization />
          </author>
          <author initials='R.' surname='Abbi' fullname='R. Abbi'>
            <organization />
          </author>
          <date year='2004' month='February' />
          <abstract>
            <t>
              This document presents a set of High Capacity Textual Conventions 
              for use in MIB modules which require performance history based 
              upon 15 minute intervals.  The Textual Conventions defined in 
              this document extend the conventions presented in RFC 3593 to 64 bit 
              resolution using the conventions presented in RFC 2856. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='3705' />
        <format type='TXT' octets='24158' target='ftp://ftp.isi.edu/in-notes/rfc3705.txt' />
      </reference>

      <reference anchor='RFC3877'>
      <front>
        <title>Alarm Management Information Base (MIB)</title>
        <author initials='S.' surname='Chisholm' fullname='S. Chisholm'>
          <organization />
        </author>
        <author initials='D.' surname='Romascanu' fullname='D. Romascanu'>
          <organization />
        </author>
        <date year='2004' month='September' />
        <abstract>
          <t>
            This memo defines a portion of the Management Information Base (MIB) 
            for use with network management protocols in the Internet community.  
            In particular, it describes management objects used for modelling and 
            storing alarms. [STANDARDS TRACK]
          </t>
        </abstract>
      </front>
      <seriesInfo name='RFC' value='3877' />
      <format type='TXT' octets='149783' target='ftp://ftp.isi.edu/in-notes/rfc3877.txt' />
      </reference>

      <reference anchor='RFC4001'>
        <front>
          <title>Textual Conventions for Internet Network Addresses</title>
          <author initials='M.' surname='Daniele' fullname='M. Daniele'>
            <organization />
          </author>
          <author initials='B.' surname='Haberman' fullname='B. Haberman'>
            <organization />
          </author>
          <author initials='S.' surname='Routhier' fullname='S. Routhier'>
            <organization />
          </author>
          <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
            <organization />
          </author>
          <date year='2005' month='February' />
          <abstract>
            <t>
              This MIB module defines textual conventions to represent commonly 
              used Internet network layer addressing information.  The intent is 
              that these textual conventions will be imported and used in MIB modules 
              that would otherwise define their own representations. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4001' />
        <format type='TXT' octets='45836' target='ftp://ftp.isi.edu/in-notes/rfc4001.txt' />
      </reference>

      <reference anchor='RFC4008'>
        <front>
          <title>
            Definitions of Managed Objects for Network Address Translators (NAT)
          </title>
          <author initials='R.' surname='Rohit' fullname='R. Rohit'>
            <organization />
          </author>
          <author initials='P.' surname='Srisuresh' fullname='P. Srisuresh'>
            <organization />
          </author>
          <author initials='R.' surname='Raghunarayan' fullname='R. Raghunarayan'>
            <organization />
          </author>
          <author initials='N.' surname='Pai' fullname='N. Pai'>
            <organization />
          </author>
          <author initials='C.' surname='Wang' fullname='C. Wang'>
            <organization />
          </author>
          <date year='2005' month='March' />
          <abstract>
            <t>This memo defines a portion of the Management Information Base (MIB)
            for devices implementing Network Address Translator (NAT) function.
            This MIB module may be used for configuration as well as monitoring of a
            device capable of NAT function. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4008' />
        <format type='TXT' octets='125696' target='ftp://ftp.rfc-editor.org/in-notes/rfc4008.txt' />
      </reference>
 

      <reference anchor='RFC4044'>
        <front>
          <title>Fibre Channel Management MIB</title>
          <author initials='K.' surname='McCloghrie' fullname='K. McCloghrie'>
            <organization />
          </author>
          <date year='2005' month='May' />
          <abstract>
            <t>This memo defines a portion of the Management Information Base (MIB) 
            for use with network management protocols in the Internet community.  
            In particular, it describes managed objects for information related 
            to the Fibre Channel. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4044' />
        <format type='TXT' octets='127148' target='ftp://ftp.rfc-editor.org/in-notes/rfc4044.txt' />
      </reference>

      <reference anchor='RFC4133'>
        <front>
          <title>Entity MIB (Version 3)</title>
          <author initials='A.' surname='Bierman' fullname='A. Bierman'>
            <organization />
          </author>
          <author initials='K.' surname='McCloghrie' fullname='K. McCloghrie'>
            <organization />
          </author>
          <date year='2005' month='August' />
          <abstract>
            <t>
              This memo defines a portion of the Management Information Base (MIB) 
              for use with network management protocols in the Internet community.  
              In particular, it describes managed objects used for managing multiple 
              logical and physical entities managed by a single SNMP agent.  This 
              document specifies version 3 of the Entity MIB, which obsoletes 
              version 2 (RFC 2737). [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4133' />
        <format type='TXT' octets='136711' target='ftp://ftp.isi.edu/in-notes/rfc4133.txt' />
      </reference>

      <reference anchor='RFC4268'>
        <front>
          <title>Entity State MIB</title>
          <author initials='S.' surname='Chisholm' fullname='S. Chisholm'>
          <organization />
            </author>
          <author initials='D.' surname='Perkins' fullname='D. Perkins'>
            <organization />
          </author>
          <date year='2005' month='November' />
          <abstract>
            <t>
              This memo defines a portion of the Management Information Base (MIB) 
              for use with network management protocols in the Internet community. 
              In particular, it describes extensions to the Entity MIB to provide 
              information about the state of physical entities.&lt;/t>&lt;t> In 
              addition, this memo defines a set of Textual Conventions to represent 
              various states of an entity. The intent is that these Textual Conventions 
              will be imported and used in MIB modules that would otherwise define 
              their own representations. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4268' />
        <format type='TXT' octets='40348' target='ftp://ftp.isi.edu/in-notes/rfc4268.txt' />
      </reference>

      <reference anchor='RFC4363'>
        <front>
          <title>
            Definitions of Managed Objects for Bridges with Traffic Classes, 
            Multicast Filtering, and Virtual LAN Extensions
          </title>
          <author initials='D.' surname='Levi' fullname='D. Levi'>
            <organization />
          </author>
          <author initials='D.' surname='Harrington' fullname='D. Harrington'>
            <organization />
          </author>
          <date year='2006' month='January' />
          <abstract>
            <t>
              This memo defines a portion of the Management Information Base (MIB) 
              for use with network management protocols in TCP/IP-based internets. 
              In particular, it defines two MIB modules for managing the capabilities 
              of MAC bridges defined by the IEEE 802.1D-1998 (TM) MAC Bridges and the 
              IEEE 802.1Q-2003 (TM) Virtual LAN (VLAN) standards for bridging between 
              Local Area Network (LAN) segments. One MIB module defines objects for 
              managing the 'Traffic Classes' and 'Enhanced Multicast Filtering' components 
              of IEEE 802.1D-1998 and P802.1t-2001 (TM). The other MIB module defines 
              objects for managing VLANs, as specified in IEEE 802.1Q-2003, P802.1u (TM), 
              and P802.1v (TM).&lt;/t>&lt;t> Provisions are made for support of transparent 
              bridging. Provisions are also made so that these objects apply to bridges 
              connected by subnetworks other than LAN segments.&lt;/t>&lt;t> This memo 
              supplements RFC 4188 and obsoletes RFC 2674. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4363' />
        <format type='TXT' octets='188981' target='ftp://ftp.isi.edu/in-notes/rfc4363.txt' />
      </reference>

      <reference anchor='RFC4502'>
        <front>
          <title>
            Remote Network Monitoring Management Information Base Version 2
          </title>
          <author initials='S.' surname='Waldbusser' fullname='S. Waldbusser'>
            <organization />
          </author>
          <date year='2006' month='May' />
          <abstract>
            <t>
              This document defines a portion of the Management Information Base (MIB) 
              for use with network management protocols in TCP/IP-based internets. 
              In particular, it defines objects for managing remote network monitoring 
              devices.&lt;/t>&lt;t> This document obsoletes RFC 2021, updates RFC 3273, 
              and contains a new version of the RMON2-MIB module. [STANDARDS TRACK]
            </t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4502' />
        <format type='TXT' octets='290816' target='ftp://ftp.isi.edu/in-notes/rfc4502.txt' />
      </reference>

      <reference anchor="XML" target="http://www.w3.org/TR/1998/REC-xml-19980210">
        <front>
          <title>Extensible Markup Language (XML) 1.0</title>
          <author>
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address>
              <postal>
                <street>MIT Laboratory for Computer Science</street>
                <street>545 Technology Square</street>
                <city>Cambridge</city>
                <region>MA</region>
                <code>02139</code>
                <country>US</country>
              </postal>
              <phone>+ 1 617 253 2613</phone>
              <facsimile>+ 1 617 258 5999</facsimile>
              <email>timbl@w3.org</email>
              <uri>http://www.w3c.org</uri>
            </address>
          </author>
          <date month="February" year="1998"/>
        </front>
        <seriesInfo name="W3C" value="XML"/>
      </reference>

      <reference anchor='RFC4706'>
      <front>
        <title>Definitions of Managed Objects for Asymmetric Digital Subscriber Line 2 (ADSL2)</title>
          <author initials='M.' surname='Morgenstern' fullname='M. Morgenstern'>
            <organization />
          </author>
          <author initials='M.' surname='Dodge' fullname='M. Dodge'>
            <organization />
          </author>
          <author initials='S.' surname='Baillie' fullname='S. Baillie'>
            <organization />
          </author>
          <author initials='U.' surname='Bonollo' fullname='U. Bonollo'>
            <organization />
          </author>
          <date year='2006' month='November' />
          <abstract>
            <t>This document defines a Management Information Base (MIB) module for use 
            with network management protocols in the Internet community.  In particular, 
            it describes objects used for managing parameters of the "Asymmetric Digital 
            Subscriber Line" family of interface types: ADSL, ADSL2, ADSL2+, and their 
            variants. [STANDARDS-TRACK]</t>
          </abstract>
      </front>
      <seriesInfo name='RFC' value='4706' />
      <format type='TXT' octets='347648' target='ftp://ftp.rfc-editor.org/in-notes/rfc4706.txt' />
      </reference>

      <reference anchor='RFC4780'>
        <front>
          <title>Management Information Base for the Session Initiation Protocol (SIP)</title>
          <author initials='K.' surname='Lingle' fullname='K. Lingle'>
            <organization />
          </author>
          <author initials='J-F.' surname='Mule' fullname='J-F. Mule'>
            <organization />
          </author>
          <author initials='J.' surname='Maeng' fullname='J. Maeng'>
            <organization />
          </author>
          <author initials='D.' surname='Walker' fullname='D. Walker'>
            <organization />
          </author>
          <date year='2007' month='April' />
          <abstract>
            <t>This memo defines a portion of the Management Information Base (MIB) 
            for use with network management protocols in the Internet community.  
            In particular, it describes a set of managed objects that are used to 
            manage Session Initiation Protocol (SIP) entities, which include User 
            Agents, and Proxy, Redirect and Registrar servers. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='4780' />
        <format type='TXT' octets='160460' target='ftp://ftp.rfc-editor.org/in-notes/rfc4780.txt' />
      </reference>


      <reference anchor='RFC5935'>
        <front>
          <title>Expressing SNMP SMI Datatypes in XML Schema Definition Language</title>
          <author initials='M.' surname='Ellison' fullname='M. Ellison'>
            <organization />
          </author>
          <author initials='B.' surname='Natale' fullname='B. Natale'>
            <organization />
          </author>
          <date year='2010' month='August' />
          <abstract>
            <t>This memo defines the IETF standard expression of Structure of 
            Management Information (SMI) base datatypes in XML Schema Definition 
            (XSD) language.  The primary objective of this memo is to enable the 
            production of XML documents that are as faithful to the SMI as possible, 
            using XSD as the validation mechanism. [STANDARDS TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name='RFC' value='5935' />
        <format type='TXT' octets='28164' target='http://www.rfc-editor.org/rfc/rfc5935.txt' />
      </reference>

      <reference anchor="XMLSchema" target="http://www.w3.org/TR/xmlschema-1/">
        <front>
          <title>XML Schema Part 1: Structures Second Edition</title>
          <author>
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address>
              <postal>
                <street>MIT Laboratory for Computer Science</street>
                <street>545 Technology Square</street>
                <city>Cambridge</city>
                <region>MA</region>
                <code>02139</code>
                <country>US</country>
              </postal>
              <phone>+ 1 617 253 2613</phone>
              <facsimile>+ 1 617 258 5999</facsimile>
              <email>timbl@w3.org</email>
              <uri>http://www.w3c.org</uri>
            </address>
          </author>
          <date month="October" year="2004"/>
        </front>
        <seriesInfo name="W3C" value="XML Schema"/>
      </reference>

      <reference anchor="XSDDatatypes" target="http://www.w3.org/TR/xmlschema-2/">
        <front>
          <title>XML Schema Part 2: Datatypes Second Edition</title>
          <author>
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address>
              <postal>
                <street>MIT Laboratory for Computer Science</street>
                <street>545 Technology Square</street>
                <city>Cambridge</city>
                <region>MA</region>
                <code>02139</code>
                <country>US</country>
              </postal>
              <phone>+ 1 617 253 2613</phone>
              <facsimile>+ 1 617 258 5999</facsimile>
              <email>timbl@w3.org</email>
              <uri>http://www.w3c.org</uri>
            </address>
          </author>
          <date month="October" year="2004"/>
        </front>
        <seriesInfo name="W3C" value="XML Schema"/>
      </reference>
    </references>


    <!--  INFORMATIVE REFERENCES  -->
    <references title="Informative References">
       <reference anchor='RFC3688'>
        <front>
        <title>The IETF XML Registry</title>
        <author initials='M.' surname='Mealling' fullname='M. Mealling'>
        <organization/></author>
        <date year='2004' month='January' />
        <abstract>
          <t>This document describes an IANA maintained registry for IETF standards
          which use Extensible Markup Language (XML) related items such as Namespaces,
          Document Type Declarations (DTDs), Schemas, and Resource Description Framework
          (RDF) Schemas.</t>
        </abstract>
        </front>
        <seriesInfo name='BCP' value='81' />
        <seriesInfo name='RFC' value='3688' />
        <format type='TXT' octets='17325' target='ftp://ftp.isi.edu/in-notes/rfc3688.txt' />
      </reference>

      
      <reference anchor="ASN.1">
        <front>
          <title>Information processing systems - Open Systems Interconnection -
                 Specification of Basic Encoding Rules for Abstract Syntax Notation
                 One (ASN.1)
          </title>
          <author>
            <organization>International Organization for Standardization</organization>
            <address/>
          </author>
          <date month="December" year="1987"/>
        </front>
        <seriesInfo name="International Standard" value="8825"/>
      </reference>
    </references>

  <section title="Open Issues">
  </section>

  <section title="Change Log">
    <t>-00 Initial version</t>
  </section>

  </back>
</rfc>

