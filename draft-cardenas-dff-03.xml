<?xml version="1.0" encoding="US-ASCII"?>
    
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->



<rfc category="exp" docName="draft-cardenas-dff-03" ipr="trust200902">
	<!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes ups="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->
	<!-- ***** FRONT MATTER ***** -->
	<front>
		<!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
		<title abbrev="DFF">Depth-First Forwarding in Unreliable Networks</title>
		<!-- add 'role="editor"' below for the editors if appropriate -->
		<!-- Another author who claims to be an editor -->
		
		<author fullname="Ulrich Herberg" initials="U.H." surname="Herberg">
			<organization>Fujitsu</organization>
			<address>
				<postal>
					<street>1240 E. Arques Avenue, M/S 345</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94085</code>
					<country>US</country>
				</postal>
				<phone>+1 408 530-4528</phone>
				<email>ulrich.herberg@us.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Alvaro A. Cardenas" initials="A.C." surname="Cardenas">
			<organization>Fujitsu</organization>
			<address>
				<postal>
					<street>1240 E. Arques Avenue, M/S 345</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94085</code>
					<country>US</country>
				</postal>
				<phone>+1 408 530-4516</phone>
				<email>alvaro.cardenas-mora@us.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Tadashige Iwao" initials="T.I." surname="Iwao">
			<organization>Fujitsu</organization>
			<address>
				<postal>
					<street>Shiodome City Center, 5-2, Higashi-shimbashi 1-chome, Minato-ku</street>
					<city>Tokyo</city>
					<region/>
					<code/>
					<country>JP</country>
				</postal>
				<phone>+81-44-754-3343</phone>
				<email>smartnetpro-iwao_std@ml.css.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Michael L. Dow" initials="M.L." surname="Dow">
			<organization>Freescale</organization>
			<address>
				<postal>
					<street>6501 William Cannon Drive West</street>
					<city>Austin</city>
					<region>TX</region>
					<code>78735</code>
					<country>USA</country>
				</postal>
				<phone>+1 512 895 4944</phone>
				<email>m.dow@freescale.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Sandra L. Cespedes" initials="S.C." surname="Cespedes">
			<organization>U. Icesi/U. of Waterloo</organization>
			<address>
				<postal>
					<street>Calle 18 No. 122-135 Pance</street>
					<city>Cali</city>
					<region>Valle</region>
					<code/>
					<country>Colombia</country>
				</postal>
				<phone/>
				<email>slcesped@bbcr.uwaterloo.ca</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		

		

		
		<date year="2011"/>

		<!-- Meta-data Declarations -->
		<area>General</area>
		
		<workgroup>Internet Engineering Task Force</workgroup>
		<!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->
        
		<keyword>DFF</keyword>
		<!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->
        
		<abstract>
			<t>This document describes the Depth-First Forwarding (DFF) protocol for IPv6 networks based on the LoWPAN adaptation layer. The protocol is a mesh-under data forwarding mechanism that increases reliability of data delivery.</t>
			
			<t>
			DFF forwards data packets using a network-wide "depth-first search" for the Final Destination of the packet. DFF may be used in conjunction with a mesh-under routing protocol, which provides "hints" for DFF in which order to try to send the packet to the neighbors discovered by the neighborhood discovery mechanism. In that case, DFF can be used as local repair mechanism.
			</t>
		</abstract>
	</front>
	
	
	<middle>
		<section title="Introduction">			
			<t>This document describes the Depth-First Forwarding (DFF) protocol for IPv6 networks based on the LoWPAN adaptation layer, as specified in <xref target="RFC4944"/>. The protocol is a mesh-under data forwarding mechanism that increases reliability of data delivery in networks with dynamic topologies.</t>
			
			<t>DFF forwards data packets using a network-wide "depth-first search" for the final destination of the packet. DFF relies on a neighborhood discovery mechanism which lists neighbors of a node for the next hop of a data packet. In addition, DFF may be used in conjunction with a mesh-under routing protocol, which provides "hints" for DFF in which order to try to send the packet to the neighbors discovered by the neighborhood discovery mechanism.</t>
			
			<t>If the packet makes no forward progress using the selected next hop, DFF will successively try all neighbors of the node (as determined by an additional mechanism, e.g. a mesh-under routing protocol, ND, HELLO message exchange). If none of the next hops successfully receives the packet, DFF returns the packet to the previous hop, which in turn tries to send it to alternate neighbors.</t>
			
			<t>As network topologies do not necessarily form a tree, loops can occur. Therefore, DFF contains a loop detection and avoidance mechanism.</t>
			
			<t>If DFF is used in conjunction with a mesh-under routing protocol,  the cost of routes provided by that routing protocol may be updated while rerouting the packet through alternative next hops. Thus, DFF provides an optional local route repair mechanism.</t>
			
			
			<section title="Motivation">
				<t>In networks with dynamic topologies, even frequent exchanges of control messages between nodes for updating the routing tables cannot guarantee freshness of routes: packets may not be delivered to their destination because the topology has changed since the last routing protocol update.</t> 
				
				<t>While more frequent routing protocol updates could mitigate that problem to a certain extent, that requires network bandwidth (e.g. when flooding control messages through the network for route discovery). This is an issue in networks with lossy links, where further control traffic exchange can worsen the network stability because of collisions (e.g. in the case of a network-wide flood of Route Request messages or Link State Advertisements). Moreover, additional control traffic exchange drains energy from battery-driven nodes.</t>
				
				<t>The data-forwarding mechanism specified in this document allows for forwarding data packets along alternate paths for increasing reliability of data delivery, using a depth-first search. The objective is to decrease the necessary control traffic overhead in the network, and in the same time to increase delivery success rates. If a mesh-under routing protocol is used in conjunction to DFF, that protocol can be informed about the updated topology, and routes can then be repaired.</t>
			</section>
			
			<section title="Protocol Dependencies">
				<t>DFF can be used as stand-alone forwarding mechanism, but may be used in conjunction with a mesh-under routing protocol which allows for providing an order of preference to which next hops a packet should be forwarded (e.g. the packet may be forwarded first to neighbors that are listed as next hops to the final destination, preferring those with the lowest route cost).</t>
			
				<t>DFF requires a list of bidirectional neighbors for each node, which must be provided by an external mechanism, such as specified in <xref target="RFC4861"/>. This specification assumes there is such a neighborhood discovery protocol in place and outlines the requirements for that protocol, as well as the interaction between DFF and a mesh-under routing protocol if such is used in conjunction to DFF.</t>
			</section>
    	</section>
    	
			
		<section title="Notation and Terminology">
			<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.
       		</t>
       		
       		<t>Additionally, this document uses the notation in <xref target="notation"/> and the terminology in <xref target="terminology"/>.</t>
       		
       		<section anchor="notation" title="Notation">
       			<t>The following notations are used in this document:
       				<list style="hanging">
       					<t hangText="List"> - A list of elements is defined as [] for an empty list, [element] for a list with one element, and [element1, element2, ...] for a list with multiple elements.</t>
       					
       					<t hangText="Concatenation of lists:">If L1 and L2 are lists, then L1@L2 is a new list with all elements of L2 concatenated to L1. 
       					</t>
       				</list>
       			
       			</t>
       		</section>
       		
       		<section anchor="terminology" title="Terminology">
				<t>All terms introduced in <xref target="RFC4944"/> are to be interpreted as described therein, in particular Originator Address, Final Destination Address, Source Address, and Destination Address.</t>
				
				<t>Additionally, this document uses the following terminology:
				
					<list style="hanging">
						<t hangText="Address"> - An address is either a 16-bit short or a EUI-64 link layer address, as specified in <xref target="RFC4944"/>.</t>
					
						<t hangText="Packet"> - An IPv6 packet encapsulated in a IEEE 802.15.4 frame, using the LoWPAN adaption layer as specified in <xref target="RFC4944"/>.</t>

					</list>
				</t>
			</section>
		</section>
		
		
		<section anchor="applicability" title="Applicability Statement">
			<t>This protocol:
			
				<list style="symbols">
					<t>Is applicable for use in LoWPAN based networks, using the frame format for transmission of IPv6 packets defined in <xref target="RFC4944"/>.</t>
					
					<t>Assumes addresses used in the network are either 16-bit short or EUI-64 link layer address, as specified in <xref target="RFC4944"/>.</t>
					
					<t>Operates as "mesh-under" forwarding protocol, i.e. on the link layer. While the proposed mechanism could also be used as "route-over", this is not specified in this document and thus out of scope.</t>
					
					<t>Is designed to work in networks with lossy links or with a dynamic topology.</t>
					
					<t>Relies on an external neighborhood discovery mechanism, which MUST provide a list of bidirectional neighbors of a node. In addition, DFF MAY use information from a mesh-under routing protocol used in conjunction to DFF. Such a protocol provide provides "hints" to DFF in which order the neighbors should be successively tried as next hop for a packet.</t>
					
					<t>Increases reliability of data delivery by trying alternative paths, using a "depth-first forwarding" approach.</t>
					
					<t>Provides a loop detection mechanism, and an optional local route repair mechanism if a mesh-under routing protocol is used in conjunction to DFF.</t>	
					
					<t>Is designed to work in a completely distributed manner, and does not depend on any central entity.</t>
				</list>
			</t>
		</section>
		
		
		<section anchor="overview" title="Protocol Overview and Functioning">
			<t>DFF is a mesh-under data forwarding mechanism responsible for finding a path to a Final Destination of a packet, using a "depth-first search" in the network. DFF operates on LoWPAN based networks (using the frame format and the transmission of IPv6 packets defined in <xref target="RFC4944"/>).</t>
			
			<t>DFF requires an external mechanism to discover the bidirectional neighborhood of a node. The specification of such a mechanism is out of scope of this document. The list of neighbors is required because DFF successively tries to forward a packet to all neighbors of a node during the depth-first search, and eventually returns it to the previous hop if the packet was not successfully received by any of the neighbors.</t>
			
			<t>In addition to the mandatory neighborhood information, DFF may use information from a mesh-under routing protocol that runs in conjunction to DFF. Such protocol can increase the efficiency of the depth-first search, as it allows for providing an order of preference which next hops to try first (e.g. by preferring neighbors that are listed in the mesh-under routing protocol as next hops along the path to the final destination, and by preferring next hops with a lower route cost). If the topology as reflected by that mesh-under routing protocol represents the effective topology of the network, then DFF will forward the data packet along the path provided by the protocol. However, if the topology has changed and the routing protocol has not yet converged, then DFF will try alternate paths. Compared to the typical forwarding mechanism in LoWPAN networks, a mesh-under routing protocol thus only serves DFF to give recommendations (or "hints") where to forward a packet. That also implies that if the mesh-under routing protocol does not provide a route to a final destination, the data packet would not be dropped but forwarded by DFF, trying to find a path to that final destination.</t>
			
			<t>In order to avoid loops when forwarding a data packet towards its Final Destination, DFF stores a data packet identifier (i.e. a sequence number) to detect loops. DFF lists for each recently forwarded packet  which neighbors that packet has already been sent to, allowing for trying to forward the packet to all candidates for the next hop.</t>
			
			<t>DFF requires additional header information for each data packet, provided by a LoWPAN dispatch byte specified in this document. This header contains a sequence number used for identifying a packet uniquely, and two flags: RET and DUP. 
			If none of the transmissions of a data packet to the neighbors of a node has succeeded, the packet is returned to the previous hop, indicated by setting the return (RET) flag. The previous hop then continues to try other neighbors in turn, resulting in a depth-first search in the network.</t>
			
			<t>Whenever a packet has been sent to a neighbor and no link layer acknowledgment (ACK) has been received, the duplicate (DUP) flag is set in the packet header for the following transmissions. The rationale is that the packet may have been successfully received by the neighbor and only the ACK has been lost, resulting in duplicates of the packet in the network. The DUP flag tags such a possible duplicate.</t>
			
			<t>Whenever a node receives a packet that it has already forwarded (as identified by the sequence number of the packet), and which is not a duplicate (i.e. DUP = 0), it will assume a loop and return the packet to the previous hop (with the RET flag set). Optionally, if a mesh-under routing protocol is used in conjunction to DFF, the route using the next hop which resulted in the loop may be "poisoned" (i.e. the route cost may be increased).</t>
		</section>
		
		
		<section title="Information Sets">
			<t>This section specifies the information sets used by DFF. In addition, DFF requires access to a list of bidirectional neighbors of the node, provided by an external neighborhood discovery mechanism, which is not specified within this document.</t>


			<section title="Processed Set" anchor="processed_set">
				<t>Each node MUST maintain a Processed Set in order to support the loop detection functionality. The Processed Set lists sequence numbers of previously received packets, as well as a list of next hops to which the packet has been sent successively as part of the depth-first search mechanism. The set consists of Processed Tuples:
			
				<list style="hanging">
					<t hangText="">(P_orig_address, P_seq_number, P_prev_hop, P_next_hop_neighbor_list, P_time)</t>
				</list>
			
				where
			
				<list style="hanging">
					<t hangText="">P_orig_address is is the Originator Address of the received packet;</t>
				
					<t hangText="">P_seq_number is the Sequence Number of the received packet;</t>
				
					<t hangText="">P_prev_hop is the Source Address (i.e. the previous hop) of the packet;</t>
				
					<t hangText="">P_next_hop_neighbor_list is a list of addresses of next hops to which the packet has been sent previously, as part of the depth-first search mechanism, as explained in <xref target="packet_processing"/>;</t>
				
					<t hangText="">P_time specifies when this Tuple expires and MUST be removed.</t>
				</list>
				</t>
			</section>
		</section>
		
		
		<section anchor="packet_format" title="Packet Format">
			<t>This document assumes that the data forwarding is based on the LoWPAN adaptation layer ("mesh-under"), and that data packets are conform with the packet format specified in <xref target="RFC4944"/>. In particular, <xref target="RFC4944"/> states that
			<list style="hanging">
				<t>Additional mesh routing capabilities, such as specifying the mesh routing protocol, source routing, and so on may be expressed by defining additional routing headers that precede the fragmentation or addressing header in the header stack.
				</t>
			</list>
			
			Hence, all data packets to be forwarded using DFF MUST be preceded by the Mesh Addressing header defined in <xref target="RFC4944"/>, and SHOULD be preceded by a header that identifies the DFF data forwarding mechanism, which is defined in the following.</t>
			
			<t>After these two headers, any other LoWPAN header, e.g. hop-by-hop options, header compression or fragmentation, MAY also be added before the actual payload. <xref target="mesh-header"/> depicts the Mesh Addressing header defined in <xref target="RFC4944"/>, and <xref target="DFF-header"/> depicts the DFF header.</t>

			<figure anchor="mesh-header" title="Mesh Addressing Header">
				<artwork align="center"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 0|V|F|HopsLft| DeepHopsLeft  |orig. address, final address... 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
			</figure>


			<figure anchor="DFF-header" title="Header for DFF data frames">
				<artwork align="center"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 1| Mesh Forw |D|R|x|    Sequence Number      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
			</figure>
			
			<t>Field definitions of the Mesh Addressing header are as specified in <xref target="RFC4944"/>.</t>

			<t>Field definitions of the DFF header are as follows: 
				<list style="hanging">            		
            		<t hangText="Mesh Forw"> - A 6-bit identifier that allows for the use of different mesh forwarding mechanisms. As specified in <xref target="RFC4944"/>, additional mesh forwarding mechanisms should use the reserved dispatch byte values following LOWPAN_BCO; therefore, 0 1 MUST precede Mesh Forw. The value of Mesh Forw is LOWPAN_DFF.</t>
            		
            		<t hangText="Duplicate packet flag (D)"> - This flag is included in the DFF mesh header to indicate that the packet has been re-sent as a duplicate. The flag MUST be set to 1 by the node that re-sends the packet after detecting link-layer failure to deliver through the last attempted next-hop, as specified in <xref target="packet_processing"/>. Once the flag is set to 1, it MUST not be modified by nodes forwarding the packet.</t>
            
          			<t hangText="Return packet flag (R)"> - This flag is included in the DFF mesh header to indicate that the packet has been returned to the previous hop after failure to deliver to all the available next-hops. The flag MUST be set to 1 prior to forwarding the packet back to the previous hop and MUST be set to 0 prior to forwarding the packet to the selected next-hop, as specified in <xref target="packet_processing"/>. This flag is modified in a hop-by-hop basis.</t>
            
           			<t hangText="Reserved flag (x)"> - This bit is reserved for future flag definitions.</t>
           			
            
            		<t hangText="Sequence Number"> - This is a sequence number generated by the originator, unique on a node for each new generated packet, as specified in <xref target="seqno"/>. The Originator Address concatenated with the Sequence Number represent an identifier of previously seen data packets. </t>
      		  </list>
   		 </t>
		</section>
		
				
		<section anchor="parameters" title="Protocol Parameters and Constants">
			<t>
				The parameters and constants used in this specification are described in this section.
				
				<list style="hanging">
					<t hangText="P_HOLD_TIME"> - is the time period after which a newly created Processed Tuple expires and MUST be deleted.</t>
					
					<t hangText="MAX_HOPS_LEFT"> - is the initial value of Deep Hops Left in the mesh header specified in <xref target="RFC4944"/>.</t>
				</list>
			</t>
		</section>
		
		
		
		<section title="Data Packet Generation and Processing">
			<t>The following sections describe the process of handling a new packet, generated on a node (<xref target="packet_generation"/>), as well as forwarding a packet from another node (<xref target="packet_processing"/>). When DFF is used, the following specification MUST be used instead of the default frame delivery, specified in Section 11 of <xref target="RFC4944"/>.</t>
			
			<t>In the following, it is assumed that all data packets are preceded by the Mesh Addressing header and the DFF header, as specified in <xref target="packet_format"/>. In order to allow for interoperability with nodes not using DFF as forwarding mechanism, packets that are preceded by the Mesh Addressing header but not the DFF header are treated as specified in Section 11 of <xref target="RFC4944"/>.</t>
			
			<section title="Data Packet Generation" anchor="packet_generation">
				<t>Before a new packet (denoted the "current packet") is transmitted on a node, the following steps MUST be performed:
				
					<list style="numbers">
						<t>
							Add the Mesh Addressing header to the current packet, as specified in <xref target="RFC4944"/> and described in <xref target="packet_format"/>, with:
							
							<list style="symbols">
      							<t>V and F are set according to the used address length;</t>
      							<t>Hops Left := 0xF (i.e. reserved value indicating that the Deep Hops Left field is following);</t>
      							<t>Deep Hops Left := MAX_HOPS_LEFT;</t>
      							<t>Originator Address := address of this node;</t>
      							<t>Final Destination Address := address of the final destination node.</t>
       						</list>
       					</t>
       					
       					<t>
							Add the DFF header to the current packet, as specified in <xref target="packet_format"/>, with:
							<list style="symbols">
      							<t>Duplicate packet flag (D) := 0;</t>
      							<t>Return packet flag (R) := 0;</t>
      							<t>Sequence Number := a new Sequence Number of the packet (as defined in <xref target="seqno"/>).</t>
       						</list>
						
						</t>
					
						<t>
							Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
						</t>
					
					
						<t>
							Add a Processed Tuple to the Processed Set with:
					
							<list style="symbols">
      							<t>P_orig_address := the Originator Address of the current packet;</t>
      							<t>P_seq_number := the Sequence Number of the current packet;</t>
      							<t>P_prev_hop := the Originator Address of the current packet;</t>
      							<t>P_next_hop_neighbor_list := [next_hop];</t>
      							<t>P_time := current time + P_HOLD_TIME.</t>
       						</list>
       					</t>
       					
       					<t>
       						Set the Source Address in the 802.15.4 header to the node's own address and the Destination Address to next_hop.
       					</t>
       					
       					<t>
       						Transmit the current packet. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       					</t>
       				
					</list>
				</t>
			</section>
		
		
		
		
			<section anchor="packet_processing" title="Data Packet Processing">
				<t>
					If a packet (denoted the "current packet") is received on the node, then the following tasks MUST be performed:

					<list style="numbers">
						<t>
							If the Final Destination Address from the Mesh Addressing header matches the address of this node, consume the packet as per normal delivery.
						</t>
						
						<t>
							Otherwise, decrement the value of the Deep Hops Left field in the mesh header. Drop the packet if Deep Hops Left is decremented to zero.
						</t>
					
					
						<t>
							If no Processed Tuple (denoted the "current tuple") exists in the Processed Set, with:

							<list style="hanging">
            					<t hangText="+">P_orig_address = the Originator Address of the current packet, AND;</t>

            					<t hangText="+">P_seq_number = the Sequence Number of the current packet,</t>
            				</list>

          					then:
          					
          					<list style="format %d." counter="my_count1">
          						<t>
          							add a Processed Tuple (denoted the "current tuple") with:
					
									<list style="symbols">

      									<t>P_orig_address := the Originator Address of the current packet;</t>
      					
      									<t>P_seq_number := the Sequence Number of the current packet;</t>
      					
      									<t>P_prev_hop := the Source Address (i.e. the previous hop) of the current packet;</t>
      					
      									<t>P_next_hop_neighbor_list := 	[];</t>
      					
      									<t>P_time := current time + P_HOLD_TIME.</t>
      					
       								</list>
       							</t>
       			
       							<t>
       								Set RET to 0 in the packet DFF header.
       							</t>
       							
       							
       							<t>
       								Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
       							</t>
       							
       							<t>
       								P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];
       							</t>
       							
       							<t>
       								Set the Source Address in the 802.15.4 header to the node's own address and the Destination Address field to next_hop.
       							</t>
       					
       					
       							<t>
       								Transmit the current packet. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       							</t>
       							
       						</list>
          				</t>
          					
          				<t>
          					Otherwise, if a tuple exists:
					
							<list style="numbers">
								<t>If the return flag of the current packet is not set (RET=0) (i.e. a loop has been detected):
									<list style="numbers">
										<t>Set RET := 1</t>
										
										<t>Set the Source Address in the 802.15.4 header to the node's own address and the Destination Address field to the Source Address of the current packet (i.e. the previous hop).
       									</t>
       					
       					
       									<t>
       									Transmit the current packet.
       									</t>
       								</list>
       							</t>
								
								<t>Otherwise, if the return flag of the current packet is set (RET = 1):
								
									<list style="numbers">
										<t>Set RET := 0</t>
      						
      									<t>Execute the "poisoning" procedure specified in <xref target="poison"/>.</t>
      							
      									<t>Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
      									</t>
      							
      									<t>Modify the current tuple:
      								
      										<list style="symbols">
      											<t>P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];</t>
      					
      											<t>P_time := current time + P_HOLD_TIME.</t>
       										</list>
      									</t>
      							
      									<t>
      										If the selected next hop is equal to P_prev_hop of the current tuple (i.e. all neighbors have been unsuccessfully tried), set the RET flag (RET := 1). If this node has the same address as the Originator Address of the current packet, drop the packet.
      									</t>
      							
      							
      									<t>
       										Set the Source Address in the 802.15.4 header to the node's own address and the Destination Address field to next_hop.
       									</t>
       					
       					
       									<t>
       										Transmit the current packet. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       									</t>
      								</list>
       							</t>
          					</list>
          				</t>
          			</list>
				</t>
				
			</section>
		</section>
		


		<section anchor="missed_ACK" title="Missed Link Layer Acknowledgment when Sending a Packet">
			<t>
				If a packet (the "current packet") has been sent to the next hop, as specified in <xref target="packet_generation"/> and <xref target="packet_processing"/>, and no link layer acknowledgment has been received after several retries (as specified in <xref target="ieee802.15.4"/>), then:
				
				<list style="numbers">
      				<t>
      					Set the duplicate flag (DUP) of the DFF header of the current packet to 1.
      				</t>      				
      							
      				<t>
      					Select the next hop (denoted "next_hop") for the current packet, as specified in <xref target="getnexthop"/>.
      				</t>
      				
      				<t>Find the Processed Tuple (the "current tuple") in the Processed Set, with:

						<list style="hanging">
            				<t hangText="+">P_orig_address = the Originator Address of the current packet, AND;</t>

            				<t hangText="+">P_seq_number = the Sequence Number of the current packet,</t>
            			</list>
      		
      				and modify the current tuple:
      								
      					<list style="symbols">
  
      						<t>P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];</t>
      					
      						<t>P_time := current time + P_HOLD_TIME.</t>
      					
       					</list>	
      				</t>
      				
      							
      				<t>
      					If the selected next hop is equal to P_prev_hop of the current tuple, set the RET flag (RET := 1), otherwise reset it (RET := 0).
      				</t>
      							
      				<t>
       					Set the Source Address in the 802.15.4 header to the node's own address and the Destination Address field to next_hop.
    				</t>
       						
    				<t>
    					Transmit the current packet. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       				</t>
      			
       			</list>
			</t>
		</section>
		
		
		<section anchor="getnexthop" title="Getting the Next Hop for a Packet">
			<t>
				Before a packet (the "current packet") is sent from a node towards the packet destination, a valid next hop along the path has to be selected. This section describes how to select the next hop (denoted "next_hop"). As a Processed Tuple was either existing when receiving the packet, or otherwise was created, it can be assumed the a Processed Tuple for that packet (the "current tuple") is available. 
			</t>
			
			<t>
				The next hop is chosen from a list of neighbors in order of decreasing preference of the following conditions. This list is only a suggestion, any other order of priority MAY be used, however, P_prev_hop of the current tuple SHOULD be the last entry. The list SHOULD NOT contain addresses which are listed in P_next_hop_neighbor_list of the current tuple, and an address SHOULD NOT appear more than once in the list. 
				
				<list style="numbers">
					<t>If a mesh-under routing protocol is used, then a next hop along the path to the Final Destination Address of the packet may be added, where next hops with lower route costs have a higher priority.</t>
					
					<t>All other neighbors from an external neighborhood discovery process can be added.</t>
					
					<t>P_prev_hop of the current tuple SHOULD be added last; this case is only used for returning the packet to the previous hop, in which case the RET flag MUST be set to 1.</t>
				</list>
			</t>
		</section>
		

		<section anchor="poison" title="Poisoning">
			<t>When a packet is returned (i.e. a packet with RET = 1 is received by a node) or a link layer acknowledgment (ACK) has not been received for a forwarded packet, and if a mesh-under routing protocol is used in conjunction to DFF, the cost for the route MAY be increased in that routing protocol. Thus, future transmissions prefer other routes. For the case of a missing link layer ACK, in addition to increasing the route cost, the link cost to the neighbor may also be increased if such is supported by the neighborhood discovery process.
			</t>
			
			<t>It is up to the implementation to decide by how much the route and link cost should be increased and out of scope of this document.</t>
		</section>
		
		<section anchor="route_repair" title="Route Repair Mechanism">
			<t>If DFF is used in conjunction with a mesh-under routing protocol, route repair mechanisms of that mesh-under routing protocol MAY be disabled in order to avoid unnecessary flooding of the network. As DFF finds alternate paths for the data traffic, and in addition may "poison" unused routes of the mesh-under routing protocol, route repair mechanisms may be unnecessary and even reduce the stability of the network (e.g. because of collisions when Route Requests or Link State Advertisements are flooded in the network).
			</t>
		</section>
		
		<section anchor="seqno" title="Sequence Numbers">
			<t>Whenever a node generates a packet, a sequence number is required in the DFF header. This sequence number needs to be unique only locally on each node. For example, a sequence number may start at 0 for the first generated packet, and then increase in steps of 1 for each new packet. The sequence number MUST not be greater than 65535 and SHOULD wrap around to 0.</t>
		</section>
		
		
		<section anchor="proposed_values" title="Proposed Values for Parameters and Constants">
			<t>
				This section lists the parameters and constants used in the   specification of the protocol, and proposed values of each that MAY be used.
				
				<list style="symbols">
					<t>P_HOLD_TIME := 5 seconds</t>
					<t>MAX_HOPS_LEFT := 255</t>
				</list>
   			</t>
		</section>
		
		
		
		<section anchor="Security" title="Security Considerations">
			<t>The security mechanisms for protecting the network can be provided by link-layer technologies. Further details are presented in the Security Considerations section of <xref target="RFC4944"/>.</t>
		</section>
		

		<section anchor="IANA" title="IANA Considerations">
			<t>IANA is requested to allocate a value from the Dispatch Type Field registry for LOWPAN_DFF.
			</t>
		</section>
		

		<section anchor="Acknowledgements" title="Acknowledgements">
			<t>Yuichi Igarashi (Hitachi), Kazuya Monden (Hitachi), Geoff Mulligan (IPSO), Hiroki Satoh (Hitachi), Ganesh Venkatesh (UC San Diego), and Jiazi Yi (Ecole Polytechnique) provided useful discussions which helped to improve this document.</t>
		</section>	
		
		
	</middle>
	

	<back>
	
		<references title="Normative References">
			<reference anchor='RFC2119'>
				<front>
					<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
						<organization>Harvard University</organization>
					</author>
					<date year='1997' month='March' />
				</front>
				<seriesInfo name='BCP' value='14' />
				<seriesInfo name='RFC' value='2119' />
				<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
				<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
				<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
			</reference>

			<reference anchor='RFC4944'>
				<front>
					<title>Transmission of IPv6 Packets over IEEE 802.15.4 Networks</title>
					<author initials='G.' surname='Montenegro' fullname='G. Montenegro'>
						<organization /></author>
					<author initials='N.' surname='Kushalnagar' fullname='N. Kushalnagar'>
						<organization /></author>
					<author initials='J.' surname='Hui' fullname='J. Hui'>
						<organization /></author>
					<author initials='D.' surname='Culler' fullname='D. Culler'>
						<organization /></author>
					<date year='2007' month='September' />
				</front>

				<seriesInfo name='RFC' value='4944' />
				<format type='TXT' octets='67232' target='http://www.rfc-editor.org/rfc/rfc4944.txt' />
			</reference>

			<reference anchor='ieee802.15.4'>
				<front>
					<title>IEEE Std. 802.15.4-2003</title>
					<author initials = 'IEEE' surname='Computer Society' fullname='IEEE Computer Society'>
						<organization/>
					</author>
					<date year='2003' month='October'/>
				</front>
			</reference>

		</references>
		
		<references title="Informative References">
			<reference anchor='RFC4861'>
				<front>
					<title>Neighbor Discovery for IP version 6 (IPv6)</title>
					<author initials='T.' surname='Narten' fullname='T. Narten'>
						<organization /></author>
					<author initials='E.' surname='Nordmark' fullname='E. Nordmark'>
						<organization /></author>
					<author initials='W.' surname='Simpson' fullname='W. Simpson'>
						<organization /></author>
					<author initials='H.' surname='Soliman' fullname='H. Soliman'>
						<organization /></author>
					<date year='2007' month='September' />
				</front>

				<seriesInfo name='RFC' value='4861' />
				<format type='TXT' octets='1234' target='http://www.rfc-editor.org/rfc/rfc4861.txt' />
			</reference>
		</references>
	
		
		<section anchor="Appendix1" title="Examples">
			<t>In this section, some example network topologies are depicted, using the DFF mechanism for data forwarding. In these examples, it is assumed that DFF is used in conjunction to a mesh-under routing protocol. This protocol provides a list of neighbors of each node, and a routing table with one or more next hops to a destination, if the topology provides a path from the node to the destination.
			</t>
			
			<section anchor="example1" title="Example 1: Normal Delivery">
				<t>
					<xref target="example1_fig"/> depicts a network topology with seven nodes A to G, with links between them as indicated by lines. It is assumed that node A sends a packet to G, through B and D, according to the mesh-under routing protocol.
					
					<figure anchor="example1_fig" title="Example 1: normal delivery">
						<artwork align="center"><![CDATA[
                  +---+
              +---+ D +-----+
              |   +---+     |
      +---+   |             |
  +---+ B +---+             |
  |   +---+   |             |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					If no link fails in this topology, and no loop occurs, then DFF will not modify the usual data forwarding mechanism. Each node adds a Processed Tuple for the incoming packet, and selects the next hop according to <xref target="getnexthop"/>, i.e. it will first select the next hop for node G as determined by the mesh-under routing protocol.
				</t>
			</section>
			
			<section anchor="example2" title="Example 2: Forwarding with Link Failure">
				<t>
					<xref target="example2_fig"/> depicts the same topology as the Example 1, but both links between B and D and between B and E are unavailable (e.g. because of wireless link characteristics). 
					
					<figure anchor="example2_fig" title="Example 2: link failure">
						<artwork align="center"><![CDATA[
                  +---+
              XXX-+ D +-----+
              X   +---+     |
      +---+   X             |
  +---+ B +---+             |
  |   +---+   X             |
+-+-+         X   +---+   +-+-+
| A |         XXXX+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					When B receives the packet from node a, it adds a Processed Tuple, and then tries to forward the packet to D. Once B detects that the packet cannot be successfully delivered to D because it does not receive link layer ACKs, it will follow the procedures listed in <xref target="missed_ACK"/>, by setting the DUP flag to 1, selecting E as new next hop, adding E to the list of next hops in the Processed Tuple, and then forwarding the packet to E.
				</t>
					
				<t>
					As the link to E also fails, B will again follow the procedure in <xref target="missed_ACK"/>. As all possible next hops (D and E) are listed in the Processed Tuple, B will set the RET flag in the packet and return it to A.
				</t>
					
				<t>
					A determines that it already has a Processed Tuple for the returned packet, reset the RET flag of the packet and select a new next hop for the packet. As B is already in the list of next hops in the Processed Tuple, it will select C as next hop and forward the packet to it. C will then forward the packet to F, and F delivers the packet to its destination G.
				</t>
			</section>
			
			
			<section anchor="example3" title="Example 3: Forwarding with Missed Link Layer Acknowledgment">
				<t>
					<xref target="example3_fig"/> depicts the same topology as the Example 1, but the link layer acknowledgments from C to A are lost (e.g. because the link is uni-directional). It is assumed that A prefers a path to G through C and F.
					
					<figure anchor="example3_fig" title="Example 3: missed link layer acknowledgment">
						<artwork align="center"><![CDATA[
                  +---+
              +---+ D +-----+
              |   +---+     |
      +---+   |             |
  +---+ B +---+             |
  |   +---+   |             |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  .   +---+                 |
  +...+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					While C successfully receives the packet from A, A does not receive the ACK and assumes the packet has not been delivered to C. Therefore, it sets the DUP flag of the packet to 1, in order to indicate that this packet is a duplicate. Then, it forwards the packet to B.
				</t>

			</section>
			
			
			
			<section anchor="example4" title="Example 4: Forwarding with a Loop">
				<t>
					<xref target="example4_fig"/> depicts the same topology as the Example 1, but there is a loop from D to A, and A sends the packet through B and D.
					
					<figure anchor="example4_fig" title="Example 4: loop">
						<artwork align="center"><![CDATA[
  +-----------------+
  |                 |
  |               +-+-+
  |           +---+ D +
  |           |   +---+
 \|/  +---+   |
  +---+ B +---+
  |   +---+   |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					When A receives the packet through the loop from D, it will find a Processed Tuple for the packet. Node A will set the RET flag and return the packet to D, which in turn will return it to B. B will then select E as next hop, which will then forward it to G.
				</t>
			</section>
			
		</section>
		
	
	
	</back>
</rfc>
