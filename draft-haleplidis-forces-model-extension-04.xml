<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC3654 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3654.xml">
  <!ENTITY RFC3746 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3746.xml">
  <!ENTITY RFC5657 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5657.xml">
  <!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
  <!ENTITY FORCES-CEHA SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-forces-ceha-07.xml">
  <!ENTITY RFC5812 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5812.xml">
  <!ENTITY RFC5810 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5810.xml">
  <!ENTITY RFC5811 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5811.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="no" ?>
<!-- Start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-haleplidis-forces-model-extension-04" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->
  <!-- ***** FRONT MATTER ***** -->
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->
    <title abbrev="ForCES Model Extension">ForCES Model Extension</title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Evangelos Haleplidis" initials="E.H." surname="Haleplidis">
      <organization>University of Patras</organization>
      <address>
        <postal>
          <street>Department of Electrical and Computer Engineering</street>
          <!-- Reorder these if your country does things differently -->
          <city>Patras</city>
          <region/>
          <code>26500</code>
          <country>Greece</country>
        </postal>
        <email>ehalep@ece.upatras.gr</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->
    <!-- Meta-data Declarations -->
    <date year="2013"/>
    <area>Routing</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->
    <keyword>ForCES</keyword>
    <keyword>Model</keyword>
    <keyword>Extension</keyword>
    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->
    <abstract>
      <t> Forwarding and Control Element Separation (ForCES) defines an
      architectural framework and associated protocols to standardize
      information exchange between the control plane and the forwarding
      plane in a ForCES Network Element (ForCES NE).  RFC5812 has defined
      the ForCES Model provides a formal way to represent the capabilities, 
      state, and configuration of forwarding elements within the context of 
      the ForCES protocol, so that control elements (CEs) can control the FEs 
      accordingly. More specifically, the model describes the logical functions 
      that are present in an FE, what capabilities these functions support, and 
      how these functions are or can be interconnected.</t>
      <t>RFC5812 has been around for two years and experience in its use has shown
      room for small extensions without a need to alter the protocol while retaining
      backward compatibility with older xml libraries. This document extends the model
      to allow complex datatypes for metadata, optional default values for datatypes 
      and optional access types for structures. The document also introduces three new features,
      bitmap as a new datatype, a new event condition BecomesEqualTo and LFB properties.</t>
    </abstract>
  </front>
  <middle>
    <section title="Terminology and Conventions">
      <t/>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119"/>.</t>
      </section>
      <section title="Definitions">
        <t> This document follows the terminology defined by the ForCES
   Model in <xref target="RFC5812"/>.
   The required definitions are repeated below for clarity.</t>
        <t>
          <list style="hanging">
            <t>FE Model - The FE model is designed to model the logical processing
functions of an FE. The FE model proposed in this document
includes three components; the LFB modeling of individual Logical
Functional Block (LFB model), the logical interconnection between
LFBs (LFB topology), and the FE-level attributes, including FE
capabilities. The FE model provides the basis to define the
information elements exchanged between the CE and the FE in the
ForCES protocol [RFC5810].</t>
            <t>LFB (Logical Functional Block) Class (or type) - A template that
represents a fine-grained, logically separable aspect of FE
processing. Most LFBs relate to packet processing in the data
path. LFB classes are the basic building blocks of the FE model.</t>
            <t>LFB Instance - As a packet flows through an FE along a data path, it
flows through one or multiple LFB instances, where each LFB is an
instance of a specific LFB class. Multiple instances of the same
LFB class can be present in an FE's data path. Note that we often
refer to LFBs without distinguishing between an LFB class and LFB
instance when we believe the implied reference is obvious for the
given context.</t>
            <t>LFB Model - The LFB model describes the content and structures in an
LFB, plus the associated data definition. XML is used to provide
a formal definition of the necessary structures for the modeling.
Four types of information are defined in the LFB model. The core
part of the LFB model is the LFB class definitions; the other
three types of information define constructs associated with and
used by the class definition. These are reusable data types,
supported frame (packet) formats, and metadata.</t>
            <t>Element - Element is generally used in this document in accordance
with the XML usage of the term. It refers to an XML tagged part
of an XML document. For a precise definition, please see the full
set of XML specifications from the W3C. This term is included in
this list for completeness because the ForCES formal model uses
XML.</t>
            <t>Attribute - Attribute is used in the ForCES formal modeling in
accordance with standard XML usage of the term, i.e., to provide
attribute information included in an XML tag.</t>
            <t>LFB Metadata - Metadata is used to communicate per-packet state from
one LFB to another, but is not sent across the network. The FE
model defines how such metadata is identified, produced, and
consumed by the LFBs, but not how the per-packet state is
implemented within actual hardware. Metadata is sent between the
FE and the CE on redirect packets.</t>
            <t>ForCES Component - A ForCES Component is a well-defined, uniquely
identifiable and addressable ForCES model building block. A
component has a 32-bit ID, name, type, and an optional synopsis
description. These are often referred to simply as components.
LFB Component - An LFB component is a ForCES component that defines
the Operational parameters of the LFBs that must be visible to the
CEs.</t>
            <t>LFB Class Library - The LFB class library is a set of LFB classes
that has been identified as the most common functions found in
most FEs and hence should be defined first by the ForCES Working
Group.</t>
          </list>
        </t>
      </section>
    </section>
    <section title="Introduction">
      <t>The <xref target="RFC5812">ForCES Model</xref> presents a formal way to define FEs Logical Function Blocks (LFBs) using XML. <xref target="RFC5812"/> has been published a more than two years and current experience in its use has demonstrated need for adding new and changing existing modeling concepts. </t>
      <t>Specifically this document extends the ForCES Model to allow complex datatypes for metadata, optional default values for datatypes and optional access types for structures. Additionally the document introduces three new features, bitmap as a new datatype, a new event condition BecomesEqualTo and LFB properties.</t> 
      <t>These extensions are an addendum to the <xref target="RFC5812">ForCES model</xref> and do not require any changes on the <xref target="RFC5810">ForCES protocol</xref> as they are simply changes of the schema definition. Additionally backward compatibility is ensured as xml libraries produced with the earlier schema are still valid with the new one.</t>
      <t>XXX: Discussion is needed to specify whether bitmap required protocol definition of how bitmap is sent through the wire.</t>
    </section>
  <section title="ForCES Model Extension proposal">
    <section title="Complex datatypes for Metadata">
      <t>Section 4.6. (Element for Metadata Definitions) in the <xref target="RFC5812">ForCES Model</xref> limits the datatype use in metadata to only atomic types. <xref target="InitMetaDef"></xref> shows the xml schema excerpt where ony typeRef and atomic are allowed for a metadata definition.</t>
      <t>However there are cases where complex metadata are used in the datapath, for example two simple use cases can be seen in the <xref target="OpenFlowSpec1.1">OpenFlow switch 1.1</xref> and beyond:</t>
      <t><list style="numbers">
        <t>The Action Set metadata follows a packet inside the Flow Tables. The Action Set metadata is an array of actions to be performed at the end of the pipeline.</t>
        <t>When a packet is received from a controller it may be accompanied by a list of actions to be performed on it prior to be sent on the flow table pipeline which is also an array.</t>
        </list></t>
      <t><xref target="NewMetaDef">With this extension</xref>, complex data types are also allowed, specifically structs and arrays as metadata. The key declarations are required to check for validity of content keys in arrays and componentIDs in structs.</t>
        <figure title="Initial MetadataDefType Defintion in the schema" anchor="InitMetaDef">
          <artwork align="center"><![CDATA[
  <xsd:complexType name="metadataDefsType">
    <xsd:sequence>
      <xsd:element name="metadataDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="metadataID" type="xsd:integer"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:choice>
              <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
              <xsd:element name="atomic" type="atomicType"/>
            </xsd:choice>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
				]]></artwork>
        </figure>
        <figure title="New MetadataDefType Defintion for the schema" anchor="NewMetaDef">
          <artwork align="center"><![CDATA[
    <xsd:complexType name="metadataDefsType">
    <xsd:sequence>
      <xsd:element name="metadataDef" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element name="metadataID" type="xsd:integer"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:choice>
              <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
              <xsd:element name="atomic" type="atomicType"/>
              <xsd:element name="array" type="arrayType">
                <xsd:key name="contentKeyID1">
                  <xsd:selector xpath="lfb:contentKey"/>
                  <xsd:field xpath="@contentKeyID"/>
                </xsd:key>
              </xsd:element>
              <xsd:element name="struct" type="structType">
                <xsd:key name="structComponentID1">
                  <xsd:selector xpath="lfb:component"/>
                  <xsd:field xpath="@componentID"/>
                </xsd:key>
              </xsd:element>
            </xsd:choice>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
				]]></artwork>
        </figure>
    </section>
    <section title="Optional Default Value for Datatypes">
        <t>In the original schema, default values can only be defined for datatypes defined inside LFB components and not inside structures or arrays. Therefore default values of datatypes that are constantly being reused, e.g. counters with default value of 0, have to be constantly respecified. Additionally, datatypes inside complex datatypes cannot be defined with a default value, e.g. a counter inside a struct that has a default value of 0.</t>
      <t>This extension allows optionally to add default values to atomic and typeref types, whether they are as simple or complex datatypes. A simple use case would be to have a struct component where one of the components is a counter which the default value would be zero.</t>
      <t>This extension alters the definition of the typeDeclarationGroup in the xml schema from <xref target="InitTypeDecl"></xref> to <xref target="NewTypeDecl"></xref> to allow default values to TypeRef.</t>
        <figure title="Initial Excerpt of typeDeclarationGroup Defintion in the schema" anchor="InitTypeDecl">
          <artwork align="center"><![CDATA[
  <xsd:element name="typeRef" type="typeRefNMTOKEN"/>
				]]></artwork>
        </figure>
        <figure title="New Excerpt of typeDeclarationGroup Defintion in the schema" anchor="NewTypeDecl">
          <artwork align="center"><![CDATA[
      <xsd:sequence>
  <xsd:element name="typeRef" type="typeRefNMTOKEN"/> 
    <xsd:element name="DefaultValue" type="xsd:token" 
          minOccurs="0"/>
      </xsd:sequence>
				]]></artwork>
        </figure>
      <t>Additionally it appends to the declaration of the AtomicType <xref target="NewAtomicDecl">this xml</xref> to allow default values to Atomic datatypes.</t>
        <figure title="Appending xml in of AtomicType Defintion in the schema" anchor="NewAtomicDecl">
          <artwork align="center"><![CDATA[
  <xsd:element name="defaultValue" type="xsd:token" minOccurs="0"/>
				]]></artwork>
        </figure>
    </section>
    <section title="Optional Access Type for Structs">
      <t>In the original schema, the access type can be only be defined on components of LFB and not on components in structs or arrays. However when it's a struct datatype it is not possible to fine-tune access type per component in the struct. A simple use case would be to have a read-write struct component where one of the components is a counter where the access-type could be read-reset or read-only, e.g. a read-reset or a read-only counter inside a struct.</t>
      <t>With this extension is it allowed to define the access type for a struct component either in the datatype definitions or in the LFB component definitions.</t>
      <t>When the optional access type for a struct component is defined it MUST override the access type of the struct. If by accident an access type for a component in a capability is defined, the access type MUST NOT be taken into account and MUST always be considered as read-only.</t>
      <t>This extension alters the definition of the struct in the xml schema from <xref target="StructInitial"></xref> to <xref target="StructNew"></xref>.</t>
        <figure title="Initial xml for the struct definition in the schema" anchor="StructInitial">
          <artwork align="center"><![CDATA[
   <xsd:complexType name="structType">
    <xsd:sequence>
      <xsd:element name="derivedFrom" type="typeRefNMTOKEN" 
        minOccurs="0"/>
      <xsd:element name="component" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
          <xsd:attribute name="componentID" type="xsd:unsignedInt"
           use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
			]]></artwork>
        </figure>
        <figure title="New xml for the struct definition in the schema" anchor="StructNew">
          <artwork align="center"><![CDATA[
   <xsd:complexType name="structType">
    <xsd:sequence>
      <xsd:element name="derivedFrom" type="typeRefNMTOKEN" 
        minOccurs="0"/>
      <xsd:element name="component" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:NMTOKEN"/>
            <xsd:element ref="synopsis"/>
            <xsd:element ref="description" minOccurs="0"/>
            <xsd:element name="optional" minOccurs="0"/>
            <xsd:group ref="typeDeclarationGroup"/>
          </xsd:sequence>
          <xsd:attribute name="access" use="optional" 
            default="read-write">
            <xsd:simpleType>
              <xsd:list itemType="accessModeType"/>
            </xsd:simpleType>
          </xsd:attribute>
          <xsd:attribute name="componentID" type="xsd:unsignedInt" 
            use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
			]]></artwork>
        </figure>
      </section>
    <section title="New datatype: Bitmap">
      <t>With the current schema it is valid to create a struct of booleans in order to simulate a bitmap value. However each boolean is sent as 4bytes. This extension adds the bitmap, a set of sequential named bits.</t>
      <t>Bitmaps may be useful in describing capabilities, e.g. Link speed capabilities as multiple boolean values.</t>
      <t>XXX Discussion may be required as to whether there is a need for protocol description of how the bitmap is sent through the wire.</t>
      <t>In the new schema, bits are named followed an optional bit value. An example:</t>
        <figure title="Example of bitmap Defintion" anchor="BitmapExample">
          <artwork align="center"><![CDATA[
    <dataTypeDef>
      <name>Bitmap example</name>
      <synopsis>A bitmap field example</synopsis>
      <bitmap>
        <bit name="Bit0" defaultValue="0"/>
        <bit name="Bit1"/>
      </bitmap>
    </dataTypeDef>
				]]></artwork>
        </figure>
      <t>The ordering of the bits MUST be implemented in the order that are defined in the xml library.</t>
      <t>The bitmap is defined in the model extension schema is as follows:</t>
        <figure title="New Excerpt of bitmap Defintion in the schema" anchor="NewBitmapDecl">
          <artwork align="center"><![CDATA[
  <xsd:complexType name="bitmapType">
    <xsd:sequence>
      <xsd:element name="bit" maxOccurs="unbounded">
        <xsd:complexType>
         <xsd:attribute name="name" type="xsd:NMTOKEN" use="required"/>
         <xsd:attribute name="defaultValue" type="booleanValues" 
         use="optional"></xsd:attribute>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="booleanValues">
    <xsd:restriction base="xsd:integer">
      <xsd:minInclusive value="0"></xsd:minInclusive>
      <xsd:maxInclusive value="1"></xsd:maxInclusive>
    </xsd:restriction>
  </xsd:simpleType>
				]]></artwork>
        </figure>
        <t>Along with the needed addition to the typeDeclarationGroup Definition:</t>
        <figure title="New Excerpt of typeDeclarationGroup Defintion in the schema" anchor="NewTypeDeclBitmap">
          <artwork align="center"><![CDATA[
      <xsd:element name="bitmap" type="bitmapType"/>
				]]></artwork>
        </figure>
    </section>
    <section title="New Event Condition: BecomesEqualTo">
      <t>This extensions adds one more event condition in the model schema, that of BecomesEqualTo. The difference between Greater Than and Less Than, is that when the value is exactly that of the BecomesEqualTo, the event is triggered. This event condition is particular useful when there is a need to monitor one or more states of an LFB or the FE. For example in the <xref target="I-D.ietf-forces-ceha">CEHA</xref> document it may be useful for the master CE to know which backup CEs have just become associated in order to connect to them and begin synchronizing the state of the FE. The master CE could always poll for such information but getting such an event will speed up the process and the event may be useful in other cases as well for monitoring state.</t>
      <t>The event MUST be triggered only when the value of the targeted component becomes equal to the event condition value and MUST NOT generate events while the targeted component's value remains equal to the event condition's value.</t>
      <t>The BecomesEqualTo is appended to the schema as follows:</t>
        <figure title="New Excerpt of BecomesEqualTo event condition definition in the schema" anchor="EqualToDecl">
          <artwork align="center"><![CDATA[
          <xsd:element name="eventBecomesEqualTo"
     substitutionGroup="eventCondition"/>
				]]></artwork>
        </figure>
    </section>
    <section title="LFB Properties">
    <t>The current model definition specifies properties for components of LFBs. Experience however has proven valuable at least for debug reasons, to have statistics per LFB instance to monitor sent/received messages and errors for communication between CE and FE. These properties are read-only.</t>
    <t>XXX: Discussion for addressing LFB properties. Possibly in the protocol extension?</t>
    <t>The following datatype definitions are to be used as properties for LFB instances.</t>
    <t>
      <figure title="Properties for LFB instances">
        <artwork><![CDATA[
      <dataTypeDef>
         <name>LFBProperties</name>
         <synopsis>LFB Properties definition</synopsis>
         <struct>
            <component componentID="1">
               <name>SentToCE</name>
               <synopsis>Messages sent to CE</synopsis>
               <typeRef>uint32</typeRef>
            </component>
            <component componentID="2">
               <name>SentErrorsToCE</name>
               <synopsis>Error messages sent to CE</synopsis>
               <typeRef>uint32</typeRef>
            </component>
            <component componentID="3">
               <name>ReceivedFromCE</name>
               <synopsis>Messages received from CE</synopsis>
               <typeRef>uint32</typeRef>
            </component>
            <component componentID="4">
               <name>ReceivedErrorsFromCE</name>
               <synopsis>Error messages received from CE</synopsis>
               <typeRef>uint32</typeRef>
            </component>
         </struct>
      </dataTypeDef>
        ]]>
        </artwork>
      </figure>
    </t>    
    </section> 
    <section title="Enhancing XML Validation">
      <t>As specified earlier this is not an extension but an enhancement of the schema to provide additional validation rules. This includes adding new key declarations to provide uniqueness as deinfed by the <xref target="RFC5812">ForCES Model</xref>. Such validations work only on within the same xml file.</t>
      <t>The following validation rules have been appended in the original schema in <xref target="RFC5812"></xref>:</t>
      <t><list style="numbers">
        <t>Each metadata ID must be unique.</t>
        <t>LFB Class IDs must be unique.</t>
        <t>Component ID, Capability ID and Event Base ID must be unique per LFB.</t>
        <t>Event IDs must be unique per LFB.</t>
        <t>Special Values in Atomic datatypes must be unique per atomic datatype.</t>
      </list></t>
    </section>
  </section>
  <section title="XML Extension Schema for LFB Class Library Documents">
      <t>
        <figure title="OpenFlow XML Library" align="left">
          <artwork><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   xmlns="urn:ietf:params:xml:ns:forces:lfbmodel:1.0" 
   xmlns:lfb="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
   targetNamespace="urn:ietf:params:xml:ns:forces:lfbmodel:1.0"
   elementFormDefault="qualified" attributeFormDefault="unqualified">
   <xsd:annotation>
      <xsd:documentation xml:lang="en">
         Schema for Defining LFB Classes and associated types (
         frames, data types for LFB attributes, and metadata).
      </xsd:documentation>
   </xsd:annotation>
   <xsd:element name="description" type="xsd:string" />
   <xsd:element name="synopsis" type="xsd:string" />
   <!-- Document root element: LFBLibrary -->
   <xsd:element name="LFBLibrary">
      <xsd:complexType>
         <xsd:sequence>
            <xsd:element ref="description" minOccurs="0" />
            <xsd:element name="load" type="loadType"
               minOccurs="0" maxOccurs="unbounded" />
            <xsd:element name="frameDefs" type="frameDefsType"
               minOccurs="0" />
            <xsd:element name="dataTypeDefs" type="dataTypeDefsType"
               minOccurs="0" />
            <xsd:element name="metadataDefs" type="metadataDefsType"
               minOccurs="0" />
            <xsd:element name="LFBClassDefs" type="LFBClassDefsType"
               minOccurs="0" />
         </xsd:sequence>
         <xsd:attribute name="provides" type="xsd:Name"
            use="required" />
      </xsd:complexType>
      <!-- Uniqueness constraints -->
      <xsd:key name="frame">
         <xsd:selector xpath="lfb:frameDefs/lfb:frameDef" />
         <xsd:field xpath="lfb:name" />
      </xsd:key>
      <xsd:key name="dataType">
         <xsd:selector xpath="lfb:dataTypeDefs/lfb:dataTypeDef" />
         <xsd:field xpath="lfb:name" />
      </xsd:key>
      <xsd:key name="metadataDef">
         <xsd:selector xpath="lfb:metadataDefs/lfb:metadataDef" />
         <xsd:field xpath="lfb:name" />
      </xsd:key>
      <xsd:key name="metadataDefID">
         <xsd:selector xpath="lfb:metadataDefs/lfb:metadataDef" />
         <xsd:field xpath="lfb:metadataID" />
      </xsd:key>
      <xsd:key name="LFBClassDef">
         <xsd:selector xpath="lfb:LFBClassDefs/lfb:LFBClassDef" />
         <xsd:field xpath="lfb:name" />
      </xsd:key>
      <xsd:key name="LFBClassDefID">
         <xsd:selector xpath="lfb:LFBClassDefs/lfb:LFBClassDef" />
         <xsd:field xpath="@LFBClassID" />
      </xsd:key>
   </xsd:element>
   <xsd:complexType name="loadType">
      <xsd:attribute name="library" type="xsd:Name" use="required" />
      <xsd:attribute name="location" type="xsd:anyURI"
         use="optional" />
   </xsd:complexType>
   <xsd:complexType name="frameDefsType">
      <xsd:sequence>
         <xsd:element name="frameDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element ref="description"
                     minOccurs="0" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="dataTypeDefsType">
      <xsd:sequence>
         <xsd:element name="dataTypeDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element name="derivedFrom" type="xsd:NMTOKEN"
                     minOccurs="0" />
                  <xsd:element ref="synopsis" />
                  <xsd:element ref="description"
                     minOccurs="0" />
                  <xsd:group ref="typeDeclarationGroup" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <!-- Predefined (built-in) atomic data-types are: char, uchar, 
     int16, uint16, int32, uint32, int64, uint64, string[N], string, 
      byte[N], boolean, octetstring[N], float32, float64 -->
   <xsd:group name="typeDeclarationGroup">
      <xsd:choice>
         <!-- Extension -->
         <xsd:sequence>
            <!-- /Extension -->
            <xsd:element name="typeRef" type="typeRefNMTOKEN" />
            <!-- Extension -->
            <xsd:element name="DefaultValue" type="xsd:token"
               minOccurs="0" />
         </xsd:sequence>
         <xsd:element name="bitmap" type="bitmapType"/>
         <!-- /Extension -->
         <xsd:element name="atomic" type="atomicType" />
         <xsd:element name="array" type="arrayType">
            <!-- Extension -->
            <!--declare keys to have unique IDs -->
            <xsd:key name="contentKeyID">
               <xsd:selector xpath="lfb:contentKey" />
               <xsd:field xpath="@contentKeyID" />
            </xsd:key>
            <!-- /Extension -->
         </xsd:element>
         <xsd:element name="struct" type="structType">
            <!-- Extension -->
            <!-- key for componentIDs uniqueness in a struct -->
            <xsd:key name="structComponentID">
               <xsd:selector xpath="lfb:component" />
               <xsd:field xpath="@componentID" />
            </xsd:key>
            <!-- /Extension -->
         </xsd:element>
         <xsd:element name="union" type="structType" />
         <xsd:element name="alias" type="typeRefNMTOKEN" />
      </xsd:choice>
   </xsd:group>
   <xsd:simpleType name="typeRefNMTOKEN">
      <xsd:restriction base="xsd:token">
         <xsd:pattern value="\c+" />
         <xsd:pattern value="string\[\d+\]" />
         <xsd:pattern value="byte\[\d+\]" />
         <xsd:pattern value="octetstring\[\d+\]" />
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="atomicType">
      <xsd:sequence>
         <xsd:element name="baseType" type="typeRefNMTOKEN" />
         <xsd:element name="rangeRestriction" 
           type="rangeRestrictionType" minOccurs="0" />
         <xsd:element name="specialValues" type="specialValuesType"
            minOccurs="0">
            <!-- Extension -->
            <xsd:key name="SpecialValue">
               <xsd:selector xpath="specialValue" />
               <xsd:field xpath="@value" />
            </xsd:key>
            <!-- /Extension -->
         </xsd:element>
         <!-- Extension -->
         <xsd:element name="defaultValue" type="xsd:token"
            minOccurs="0" />
         <!-- /Extension -->
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="rangeRestrictionType">
      <xsd:sequence>
         <xsd:element name="allowedRange" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:attribute name="min" type="xsd:integer"
                  use="required" />
               <xsd:attribute name="max" type="xsd:integer"
                  use="required" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="specialValuesType">
      <xsd:sequence>
         <xsd:element name="specialValue" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
               </xsd:sequence>
               <xsd:attribute name="value" type="xsd:token" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
  <!-- Extension -->
  <xsd:complexType name="bitmapType">
    <xsd:sequence>
      <xsd:element name="bit" maxOccurs="unbounded">
        <xsd:complexType>
         <xsd:attribute name="name" type="xsd:NMTOKEN" 
         use="required"/>
         <xsd:attribute name="defaultValue" type="booleanValues" 
         use="optional"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:simpleType name="booleanValues">
    <xsd:restriction base="xsd:integer">
      <xsd:minInclusive value="0"></xsd:minInclusive>
      <xsd:maxInclusive value="1"></xsd:maxInclusive>
    </xsd:restriction>
  </xsd:simpleType>
  <!-- /Extension -->
   <xsd:complexType name="arrayType">
      <xsd:sequence>
         <xsd:group ref="typeDeclarationGroup" />
         <xsd:element name="contentKey" minOccurs="0"
            maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="contentKeyField"
                     type="xsd:string" maxOccurs="unbounded" />
               </xsd:sequence>
               <xsd:attribute name="contentKeyID" type="xsd:integer"
                  use="required" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="type" use="optional" 
        default="variable-size">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="fixed-size" />
               <xsd:enumeration value="variable-size" />
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <xsd:attribute name="length" type="xsd:integer"
         use="optional" />
      <xsd:attribute name="maxLength" type="xsd:integer"
         use="optional" />
   </xsd:complexType>
   <xsd:complexType name="structType">
      <xsd:sequence>
         <xsd:element name="derivedFrom" type="typeRefNMTOKEN"
            minOccurs="0" />
         <xsd:element name="component" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element ref="description"
                     minOccurs="0" />
                  <xsd:element name="optional" minOccurs="0" />
                  <xsd:group ref="typeDeclarationGroup" />
               </xsd:sequence>
                <!-- Extension -->
                <xsd:attribute name="access" use="optional"
                 default="read-write">
                  <xsd:simpleType>
                    <xsd:list itemType="accessModeType"/>
                  </xsd:simpleType>
                </xsd:attribute>
                <!-- /Extension -->
               <xsd:attribute name="componentID" 
                 type="xsd:unsignedInt" use="required" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="metadataDefsType">
      <xsd:sequence>
         <xsd:element name="metadataDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element name="metadataID" type="xsd:integer"/>
                  <xsd:element ref="description"
                     minOccurs="0" />
                  <xsd:choice>
                     <xsd:element name="typeRef" 
                       type="typeRefNMTOKEN" />
                     <xsd:element name="atomic" type="atomicType" />
                     <!-- Extension -->
                     <xsd:element name="array" type="arrayType">
                        <!--declare keys to have unique IDs -->
                        <xsd:key name="contentKeyID1">
                           <xsd:selector xpath="lfb:contentKey" />
                           <xsd:field xpath="@contentKeyID" />
                        </xsd:key>
                        <!-- /Extension -->
                     </xsd:element>
                     <xsd:element name="struct" type="structType">
                        <!-- Extension -->
                        <!-- key declaration to make componentIDs 
                          unique in a struct -->
                        <xsd:key name="structComponentID1">
                           <xsd:selector xpath="lfb:component" />
                           <xsd:field xpath="@componentID" />
                        </xsd:key>
                        <!-- /Extension -->
                     </xsd:element>
                  </xsd:choice>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="LFBClassDefsType">
      <xsd:sequence>
         <xsd:element name="LFBClassDef" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element name="version" type="versionType" />
                  <xsd:element name="derivedFrom" type="xsd:NMTOKEN"
                     minOccurs="0" />
                  <xsd:element name="inputPorts"
                   type="inputPortsType"
                     minOccurs="0" />
                  <xsd:element name="outputPorts"
                   type="outputPortsType"
                     minOccurs="0" />
                  <xsd:element name="components"
                   type="LFBComponentsType"
                     minOccurs="0" />
                  <xsd:element name="capabilities"
                   type="LFBCapabilitiesType"
                     minOccurs="0" />
                  <xsd:element name="events" type="eventsType"
                     minOccurs="0" />
                  <xsd:element ref="description"
                     minOccurs="0" />
               </xsd:sequence>
               <xsd:attribute name="LFBClassID" 
                 type="xsd:unsignedInt" use="required" />
            </xsd:complexType>
            <!-- Key constraint to ensure unique attribute names 
              within a class: -->
            <xsd:key name="components">
               <xsd:selector xpath="lfb:components/lfb:component" />
               <xsd:field xpath="lfb:name" />
            </xsd:key>
            <xsd:key name="capabilities">
              <xsd:selector xpath="lfb:capabilities/lfb:capability"/>
              <xsd:field xpath="lfb:name" />
            </xsd:key>
            <xsd:key name="events">
               <xsd:selector xpath="lfb:events/lfb:event" />
               <xsd:field xpath="lfb:name" />
            </xsd:key>
            <xsd:key name="eventsIDs">
               <xsd:selector xpath="lfb:events/lfb:event" />
               <xsd:field xpath="@eventID" />
            </xsd:key>
            <xsd:key name="componentIDs">
               <xsd:selector xpath="lfb:components/lfb:component" />
               <xsd:field xpath="@componentID" />
            </xsd:key>
            <xsd:key name="capabilityIDs">
              <xsd:selector xpath="lfb:capabilities/lfb:capability"/>
               <xsd:field xpath="@componentID" />
            </xsd:key>
            <xsd:key name="ComponentCapabilityComponentIDUniqueness">
               <xsd:selector
                  xpath="lfb:components/lfb:component|
                  lfb:capabilities/lfb:capability|lfb:events" />
               <xsd:field xpath="@componentID|@baseID" />
            </xsd:key>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:simpleType name="versionType">
      <xsd:restriction base="xsd:NMTOKEN">
         <xsd:pattern value="[1-9][0-9]*\.([1-9][0-9]*|0)" />
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="inputPortsType">
      <xsd:sequence>
         <xsd:element name="inputPort" type="inputPortType"
            maxOccurs="unbounded" />
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="inputPortType">
      <xsd:sequence>
         <xsd:element name="name" type="xsd:NMTOKEN" />
         <xsd:element ref="synopsis" />
         <xsd:element name="expectation" type="portExpectationType"/>
         <xsd:element ref="description" minOccurs="0" />
      </xsd:sequence>
      <xsd:attribute name="group" type="xsd:boolean"
         use="optional" default="0" />
   </xsd:complexType>
   <xsd:complexType name="portExpectationType">
      <xsd:sequence>
         <xsd:element name="frameExpected" minOccurs="0">
            <xsd:complexType>
               <xsd:sequence>
                  <!-- ref must refer to a name of a defined 
                    frame type -->
                  <xsd:element name="ref" type="xsd:string"
                     maxOccurs="unbounded" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="metadataExpected" minOccurs="0">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded">
                  <!-- ref must refer to a name of a defined
                   metadata -->
                  <xsd:element name="ref" 
                    type="metadataInputRefType" />
                  <xsd:element name="one-of"
                     type="metadataInputChoiceType" />
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="metadataInputChoiceType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="xsd:NMTOKEN" />
         <xsd:element name="one-of" type="metadataInputChoiceType" />
         <xsd:element name="metadataSet"
          type="metadataInputSetType"/>
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataInputSetType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="metadataInputRefType" />
         <xsd:element name="one-of" type="metadataInputChoiceType"/>
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataInputRefType">
      <xsd:simpleContent>
         <xsd:extension base="xsd:NMTOKEN">
            <xsd:attribute name="dependency" use="optional"
               default="required">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="required" />
                     <xsd:enumeration value="optional" />
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <xsd:attribute name="defaultValue" type="xsd:token"
               use="optional" />
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:complexType name="outputPortsType">
      <xsd:sequence>
         <xsd:element name="outputPort" type="outputPortType"
            maxOccurs="unbounded" />
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="outputPortType">
      <xsd:sequence>
         <xsd:element name="name" type="xsd:NMTOKEN" />
         <xsd:element ref="synopsis" />
         <xsd:element name="product" type="portProductType" />
         <xsd:element ref="description" minOccurs="0" />
      </xsd:sequence>
      <xsd:attribute name="group" type="xsd:boolean"
         use="optional" default="0" />
   </xsd:complexType>
   <xsd:complexType name="portProductType">
      <xsd:sequence>
         <xsd:element name="frameProduced" minOccurs="0">
            <xsd:complexType>
               <xsd:sequence>
                  <!-- ref must refer to a name of a defined 
                    frame type -->
                  <xsd:element name="ref" type="xsd:NMTOKEN"
                     maxOccurs="unbounded" />
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="metadataProduced" minOccurs="0">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded">
                  <!-- ref must refer to a name of a defined 
                    metadata -->
                  <xsd:element name="ref"
                     type="metadataOutputRefType" />
                  <xsd:element name="one-of"
                     type="metadataOutputChoiceType" />
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="metadataOutputChoiceType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="xsd:NMTOKEN" />
         <xsd:element name="one-of" type="metadataOutputChoiceType"/>
         <xsd:element name="metadataSet"
           type="metadataOutputSetType" />
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataOutputSetType">
      <xsd:choice minOccurs="2" maxOccurs="unbounded">
         <!-- ref must refer to a name of a defined metadata -->
         <xsd:element name="ref" type="metadataOutputRefType" />
         <xsd:element name="one-of" 
           type="metadataOutputChoiceType" />
      </xsd:choice>
   </xsd:complexType>
   <xsd:complexType name="metadataOutputRefType">
      <xsd:simpleContent>
         <xsd:extension base="xsd:NMTOKEN">
            <xsd:attribute name="availability" use="optional"
               default="unconditional">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="unconditional" />
                     <xsd:enumeration value="conditional" />
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <xsd:complexType name="LFBComponentsType">
      <xsd:sequence>
         <xsd:element name="component" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element ref="description"
                     minOccurs="0" />
                  <xsd:element name="optional" minOccurs="0" />
                  <xsd:group ref="typeDeclarationGroup" />
                  <xsd:element name="defaultValue" type="xsd:token"
                     minOccurs="0" />
               </xsd:sequence>
               <xsd:attribute name="access" use="optional"
                  default="read-write">
                  <xsd:simpleType>
                     <xsd:list itemType="accessModeType" />
                  </xsd:simpleType>
               </xsd:attribute>
               <xsd:attribute name="componentID" 
                 type="xsd:unsignedInt" use="required" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:simpleType name="accessModeType">
      <xsd:restriction base="xsd:NMTOKEN">
         <xsd:enumeration value="read-only" />
         <xsd:enumeration value="read-write" />
         <xsd:enumeration value="write-only" />
         <xsd:enumeration value="read-reset" />
         <xsd:enumeration value="trigger-only" />
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:complexType name="LFBCapabilitiesType">
      <xsd:sequence>
         <xsd:element name="capability" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element ref="description"
                     minOccurs="0" />
                  <xsd:element name="optional" minOccurs="0" />
                  <xsd:group ref="typeDeclarationGroup" />
               </xsd:sequence>
               <xsd:attribute name="componentID" type="xsd:integer"
                  use="required" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
   <xsd:complexType name="eventsType">
      <xsd:sequence>
         <xsd:element name="event" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="name" type="xsd:NMTOKEN" />
                  <xsd:element ref="synopsis" />
                  <xsd:element name="eventTarget"
                   type="eventPathType" />
                  <xsd:element ref="eventCondition" />
                  <xsd:element name="eventReports" 
                   type="eventReportsType" minOccurs="0" />
                  <xsd:element ref="description"
                     minOccurs="0" />
               </xsd:sequence>
               <xsd:attribute name="eventID" type="xsd:integer"
                  use="required" />
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="baseID" type="xsd:integer"
         use="optional" />
   </xsd:complexType>
   <!-- the substitution group for the event conditions -->
   <xsd:element name="eventCondition" abstract="true" />
   <xsd:element name="eventCreated"
     substitutionGroup="eventCondition" />
   <xsd:element name="eventDeleted" 
     substitutionGroup="eventCondition" />
   <xsd:element name="eventChanged" 
     substitutionGroup="eventCondition" />
   <xsd:element name="eventGreaterThan" 
     substitutionGroup="eventCondition" />
   <xsd:element name="eventLessThan"
    substitutionGroup="eventCondition" />
  <!-- Extension -->
    <xsd:element name="eventBecomesEqualTo"
     substitutionGroup="eventCondition"/>
  <!-- /Extension -->
   <xsd:complexType name="eventPathType">
      <xsd:sequence>
         <xsd:element ref="eventPathPart" maxOccurs="unbounded" />
      </xsd:sequence>
   </xsd:complexType>
   <!-- the substitution group for the event path parts -->
   <xsd:element name="eventPathPart" type="xsd:string"
      abstract="true" />
   <xsd:element name="eventField" type="xsd:string"
      substitutionGroup="eventPathPart" />
   <xsd:element name="eventSubscript" type="xsd:string"
      substitutionGroup="eventPathPart" />
   <xsd:complexType name="eventReportsType">
      <xsd:sequence>
         <xsd:element name="eventReport" type="eventPathType"
            maxOccurs="unbounded" />
      </xsd:sequence>
   </xsd:complexType>
   <xsd:simpleType name="booleanType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="0" />
         <xsd:enumeration value="1" />
      </xsd:restriction>
   </xsd:simpleType>
</xsd:schema>
 ]]></artwork>
        </figure>
      </t>
  </section>
  <section anchor="Acknowledgements" title="Acknowledgements">
    <t>The author would like to acknowledge Joel Halpern, Jamal Hadi and Dave Hood for their comments and discussion that helped shape this document in a better way.</t>
  </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The security considerations that have been described in the <xref target="RFC5812">ForCES Model RFC</xref> apply to this document as well.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC5810;
      &RFC5812;
      &FORCES-CEHA;
      <reference anchor="OpenFlowSpec1.1" target="http://www.OpenFlow.org/documents/OpenFlow-spec-v1.1.0.pdf">
        <front>
          <title>The OpenFlow 1.1 Specification.</title>
          <author>
            <organization>http://www.OpenFlow.org/</organization>
          </author>
          <date/>
        </front>
      </reference>

    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

    &RFC2119;
    </references>

    <!-- Change Log

v00 2009-02-17  EH   Initial version
  -->
  </back>
</rfc>
