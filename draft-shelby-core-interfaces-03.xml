<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0792 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2046 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4288 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml">
<!ENTITY RFC4346 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4346.xml">
<!ENTITY RFC4347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4347.xml">
<!ENTITY RFC4944 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4944.xml">
<!ENTITY RFC5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY RFC5785 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5785.xml">
<!ENTITY RFC5988 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml">
<!ENTITY I-D.ietf-core-coap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-coap.xml">
<!ENTITY I-D.ietf-core-link-format SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-link-format.xml">
<!ENTITY I-D.ietf-core-observe SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-observe.xml">
<!ENTITY I-D.shelby-core-resource-directory SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.shelby-core-resource-directory.xml">
<!ENTITY I-D.cheshire-dnsext-dns-sd SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.cheshire-dnsext-dns-sd.xml">

]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" ipr="trust200902" docName="draft-shelby-core-interfaces-03">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

    <front>
        <title>CoRE Interfaces</title>

        <author initials="Z" surname="Shelby" fullname="Zach Shelby">
          <organization>
             Sensinode
          </organization>
          <address>
            <postal>
             <street>Kidekuja 2</street>
             <city>Vuokatti</city>
             <code>88600</code>
             <country>FINLAND</country>
            </postal>
            <phone>+358407796297</phone>
            <email>zach@sensinode.com</email>
          </address>
        </author>
        
        <author fullname="Matthieu Vial" initials="M.V."
                surname="Vial">
          <organization>Schneider-Electric</organization>
          <address>
            <postal>
              <street></street>
              <city>Grenoble</city>
              <region></region>
              <code></code>
              <country>FRANCE</country>
            </postal>
            <phone>+33 (0)47657 6522</phone>
            <email>matthieu.vial@schneider-electric.com</email>
          </address>
        </author>

  <date year="2012"/>

  <area>Internet</area>

  <workgroup>CoRE</workgroup>
  <keyword>CoRE, Web Linking, Resource Discovery</keyword>

    <abstract>
    <t>
  This document defines well-known REST interface descriptions for Batch, Sensor, Parameter and Actuator types for use in contrained web servers using the CoRE Link Format. A short reference is provided for each type that can be efficiently included in the interface description attribute of the CoRE Link Format. These descriptions are intended to be for general use in resource designs or for inclusion in more specific interface profiles. In addition, this document defines the concepts of Function Set and Binding. The former is the basis element to create RESTful profiles and the latter helps the configuration of links between resources located on one or more endpoints.
  </t> 
    
    </abstract>
    </front>

    <middle>


  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <section anchor="introduction" title="Introduction">

  <t>
  The Constrained RESTful Environments (CoRE) working group aims at realizing the REST architecture in a suitable form for the most constrained nodes (e.g. 8-bit microcontrollers with limited RAM and ROM) and networks (e.g. 6LoWPAN). CoRE is aimed at machine-to-machine (M2M) applications such as smart energy and building automation.
  </t>
  <t>
  The discovery of resources offered by a constrained server is very important in machine-to-machine applications where there are no humans in the loop and static interfaces result in fragility. The discovery of resources provided by an HTTP Web Server is typically called Web Linking <xref target="RFC5988"/>. The use of Web Linking for the description and discovery of resources hosted by constrained web servers is specified by the CoRE Link Format <xref target="I-D.ietf-core-link-format"/> and can be used by CoAP <xref target="I-D.ietf-core-coap"/> or HTTP servers. The CoRE Link Format defines an attribute that can be used to describe the REST interface of a resource, and may include a link to a description document. This memo describes how other specifications can combine resources with a well-known interface to create new CoRE RESTful profiles. A CoRE profile is based on the concept of Function Set, which is a group of REST resources providing a service in a distributed system. In addition, the notion of Binding is introduced in order to create a synchronization link between two resources. This document also defines well-known interface descriptions for Batch, Sensor, Parameter and Actuator types to compose new Function Sets or for standalone use in a constrained web server. A short reference is provided for each type that can be efficiently included in the interface description (if=) attribute of the CoRE Link Format.
  </t>

  </section>
  
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** --> 
  <section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref
  target="RFC2119"/>.</t>

  <t>This specification requires readers to be familiar with all the terms
  and concepts that are discussed in <xref target="RFC5988"/> and <xref target="I-D.ietf-core-link-format"/>. This specification makes use of the following additional terminology:</t>
  
  <t>
    <list style="hanging">
      <t hangText="Function Set:">A group of well-known REST resources that provides a particular service. </t>
      <t hangText="Profile:">A group of well-known Function Sets defined by a specification. </t>
      <t hangText="Device:">An IP smart object running a web server that hosts a group of Function Set instances from a profile. </t>
      <t hangText="Service Discovery:">The process making it possible for a web client to automatically detect devices and Function Sets offered by these devices on a CoRE network. </t>
      <t hangText="Resource Discovery:">The process allowing a web client to identify resources being hosted on a web server. </t>
      <t hangText="Gradual Reveal:">A REST design where resources are discovered progressively using Web Linking. </t>
      <t hangText="Binding:">A unidirectional logical link between a source resource and a destination resource. </t>
    </list>
  </t> 

  </section>
  

  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section anchor="function-set" title="Function Set">
    
    <t>This section defines how a specification can organize REST resources to create a new profile. A profile is structured into groups of resource types called Function Sets. A Function Set is similar to a function block in the sense that it consists of input, output and parameter resources and contains internal logic. A Function Set MAY have a subset of mandatory inputs, outputs and parameters to provide minimum interoperability. It MAY also be extended with manufacturer/user-specific resources. Other specifications defines the list of function sets available within a given profile. A device is composed of one or more Function Set instances. A profile specification MAY specify device profiles with mandatory function sets.
    </t>

    <section anchor="definition" title="Defining a Function Set">
    
      <t>In a Function Set, types of resources are defined. Each type includes a human readable name, a path template, a Resource Type for discovery, the Interface Definition and the data type and allowed values. A Function Set definition may also include a field indicating if a sub-resource is mandatory or optional.
      </t>
      
      <section anchor="path-template" title="Path template">
      
        <t>A Function Set is a container resource under which its sub-resources are organized. The profile defines the path to each resource of a Function Set in a path template. The template can contain either relative paths or absolute paths depending on the profile needs. An absolute Function Set SHOULD be located at its recommended root path on a web server, however it MAY be located under an alternative path if necessary (for example multi-purpose devices, gateways etc.). A relative Function Set can be instantiated as many times as needed on a web server with an arbitrary root path. However some Function Sets (e.g. device description) only make sense as singletons.
        </t>
        
        <t>The path template includes a possible index {#} parameter, and possible fixed path segments.  The index {#} allows for multiple instances of this type of resource, and can be any string. The root path and the indexes are the only variable elements in a path template. All other path segments MUST be fixed.
        </t>
        
      </section>

      <section anchor="resource-type" title="Resource Type">
      
        <t>Each root resource of a Function Set is assigned a Resource Type parameter, therefore making it possible to discover it. Each sub-resource of a Function Set is also assigned a Resource Type parameter. This Resource Type is used for resource discovery and is usually necessary to discover optional resources supported on a specific device. The Resource Type of a Function Set may also be used for service discovery and MAY be exported to DNS-SD <xref target="I-D.cheshire-dnsext-dns-sd"/> for example.
        </t>
        
        <t>The Resource Type parameter defines the value that MUST be included in the rt= field of the CoRE Link Format when describing a link to this resource. The value SHOULD be in the form &quot;namespace.type&quot; for root resources and &quot;namespace.type.subtype&quot; for sub-resources. This naming convention facilitates resource type filtering with the /.well-known/core resource. However a profile MAY allow mixing in foreign namespace references within a Function Set to import external references from other object models (e.g. SenML and UCUM).
        </t>
        
      </section>

      <section anchor="interface-description" title="Interface Description">
      
        <t>The Interface Description parameter defines the REST interface for that type of resource. Several base interfaces are defined in <xref target="interfaces"/> of this document. For a given profile, the Interface Description may be inferred from the Resource Type. In that case the Interface Description MAY be elided from link descriptions of resource types defined in the profile, but SHOULD be included for custom extensions to the profile.
        </t>
        
        <t>The root resource of a Function Set should provide a list of links to its sub-resources in order to offer gradual reveal of resources. The CoRE Link List interface defined in <xref target="link-list"/> offers this functionality so a root resource SHOULD support this interface or a derived interface like CoRE Batch (See <xref target="batch"/>).
        </t>
        
      </section>

      <section anchor="data-type" title="Data type">
      
        <t>The Data Type field defines the type of value (and possible range) that is returned in response to a GET for that resource or accepted with a PUT. The interfaces defined in <xref target="interfaces"/> make use of plain text and SenML Media types for the actual format of this data. A profile may restrict the list of supported content types for the CoRE interfaces or define new interfaces with new content types.
        </t>
        
      </section>
      
    </section>
    
    <section anchor="discovery" title="Discovery">
    
      <t>A device conforming to a profile SHOULD make its resources discoverable by providing links to the resources on the path /.well-known/core as defined in <xref target="I-D.ietf-core-link-format"/>. All resources hosted on a device SHOULD be discoverable either with a direct link in /.well-known/core or by following successive links starting from /.well-known/core.
      </t>
      
      <t>The root path of a Function Set instance SHOULD be directly referenced in /.well-known/core in order to offer discovery at the first discovery stage. A device with more than 10 individual resources SHOULD only expose Function Set instances in /.well-known/core to limit the size of this resource.
      </t>
      
      <t>In addition, a device MAY register its resources to a Resource Directory using the registration interface defined in <xref target="I-D.shelby-core-resource-directory"/> if such a directory is available.
      </t>
      
    </section>

    <section anchor="versioning" title="Versioning">

      <t>A profile should track Function Set changes to avoid incompatibility issues. Evolutions in a Function Set SHOULD be backward compatible.
      </t>
    
    </section>
    
  </section>

  <section anchor="bindings" title="Bindings">
    <t>In a M2M RESTful environment, endpoints exchange the content of their resources to operate the distributed system. Beforehand, a configuration phase is necessary to determine how the resources of the different endpoints are related to each other. This can be done either automatically using discovery mechanisms or by means of human intervention and a so-called commissioning tool. In this document the abstract relationship between two resources is called a Binding. The configuration phase necessitates the exchange of binding information so a format recognized by all CoRE endpoints is essential. This document defines a format based on the CoRE Link-Format to represent binding information along with the rules to define a binding method which is a specialized relationship between two resources. The purpose of a binding is to synchronize the content between a source resource and a destination resource. The destination resource MAY be a group resource if the authority component of the destination URI contains a group address (either a multicast address or a name that resolves to a multicast address). Since a binding is unidirectional, the binding entry defining a relationship is present only on one endpoint. The binding entry may be located either on the source or the destination endpoint depending on the binding method. The following table gives a summary of the binding methods described in more detail in <xref target="binding_methods"/>.
    </t>

    <texttable>
      <ttcol align="left">Name</ttcol>
      <ttcol align="left">Identifier</ttcol>
      <ttcol align="left">Location</ttcol>
      <ttcol align="left">Method</ttcol>

      <c>Polling</c> <c>poll</c> <c>Destination</c> <c>GET</c>
      <c>Observe</c> <c>obs</c> <c>Destination</c> <c>GET + Observe</c>
      <c>Push</c> <c>push</c> <c>Source</c> <c>PUT</c>
    </texttable>  
  
    <section anchor="binding_format" title="Format">
      <t>Since Binding lies in the creation of a link between two resources, Web Linking and the CoRE Link-Format are a natural way to represent binding information. This involves the creation of a new relation type, purposely named &quot;boundto&quot;. In a Web link with this relation type, the target URI contains the location of the source resource and the context URI points to the destination resource. The Web link attributes allow a fine-grained control of the type of synchronization exchange along with the conditions that trigger an update. This specification defines the attributes below:
      </t>
        
      <texttable>
        <ttcol align="left">Attribute</ttcol>
        <ttcol align="left">Parameter</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Binding method</c> <c>bind</c> <c>xsd:string</c>
        <c>Minimum Period (s)</c> <c>pmin</c> <c>xsd:integer (>0)</c>
        <c>Maximum Period (s)</c> <c>pmax</c> <c>xsd:integer (>0)</c>
        <c>Change Step</c> <c>st</c> <c>xsd:decimal (>0)</c>    
      </texttable>  
    
      <t>
        <list style="hanging">
          <t hangText="Bind Method:">This is the identifier of a binding method which defines the rules to synchronize the destination resource. This attribute is mandatory.</t>
          <t hangText="Minimum Period:">When present, the minimum period indicates the minimum time to wait (in seconds) before sending a new synchronization message (even if it has changed). In the absence of this parameter, the minimum period is up to the notifier.</t>
          <t hangText="Maximum Period:">When present, the maximum period indicates the maximum time in seconds between two consecutive syncronization messages (regardless if it has changed). In the absence of this parameter, the maximum period is up to the notifier. The maximum period MUST be greater than the minimum period parameter (if present).</t>
          <t hangText="Change Step:">When present, the change step indicates how much the value of a resource SHOULD change before sending a new notification (compared to the value of the last notification). This parameter has lower priority than the period parameters, thus even if the change step has been fulfilled, the time since the last notification SHOULD be between pmin and pmax. </t>
        </list>
      </t>
    </section>

    <section anchor="binding_methods" title="Binding methods">
    
      <t>A binding method defines the rules to generate the web-transfer exchanges that will effectively send content from the source resource to the destination resource. The description of a binding method must define the following aspects:
      </t>
        
      <t>
        <list style="hanging">
          <t hangText="Identifier:">This is value of the &quot;bind&quot; attribute used to identify the method.</t>
          <t hangText="Location:">This information indicates whether the binding entry is stored on the source or on the destination endpoint.</t>
          <t hangText="REST Method:">This is the REST method used in the Request/Response exchanges.</t>
          <t hangText="Conditions:">A binding method definition must state how the condition attributes of the abstract binding definition are actually used in this specialized binding.</t>
        </list>               
      </t>
            
      <t>This specification supports 3 binding methods described below.
      </t>
      
      <t>
        <list style="hanging">
          <t hangText="Polling:">The Polling method consists of sending periodic GET requests from the destination endpoint to the source resource and copying the content to the destination resource. The binding entry for this method MUST be stored on the destination endpoint. The destination endpoint MUST ensure that the polling frequency does not exceed the limits defined by the pmin and pmax attributes of the binding entry. The copying process MAY filter out content from the GET requests using value-based conditions (e.g Change Step).</t>
          
          <t hangText="Observe:">The Observe method relies on the Publish/Subscribe pattern thus an observation relationship is created between the destination endpoint and the source resource. On each notification the content from the source resource is copied to the destination resource. The creation of the observation relationship requires the CoAP Observation mechanism <xref target="I-D.ietf-core-observe"/> hence this method is only permitted when the resources are made available over CoAP. The binding entry for this method MUST be stored on the destination endpoint. The binding conditions are mapped as query string parameters (see <xref target="observation"/>).</t>

          <t hangText="Push:">When the Push method is assigned to a binding, the source endpoint sends PUT requests to the destination resource upon change of the source resource. The source endpoint MUST only send a notification request if the binding conditions are met. The binding entry for this method MUST be stored on the source endpoint.</t>
        </list>               
      </t>
    </section>

    <section anchor="binding_table" title="Binding table">
      <t>The binding table is a special resource that gives access to the bindings on a endpoint. A binding table resource MUST support the Binding interface defined in <xref target="binding_interface"/>. A profile SHOULD allow only one resource table per endpoint.
      </t>
    </section>

  </section>
  
  <section anchor="interfaces" title="Interface Descriptions">

  <t>This section defines REST interfaces for Link List, Batch, Sensor, Parameter, Actuator and Binding table resources. Variants such as Linked Batch or Read-Only Parameter are also presented. Each type is described along with its Interface Description attribute value and valid methods. These are defined for each interface in the table below. These interfaces can support plain text and/or SenML Media types. </t>
  
  <t>The if= column defines the Interface Description (if=) attribute value to be used in the CoRE Link Format for a resource conforming to that interface. When this value appears in the if= attribute of a link, the resource MUST support the corresponding REST interface described in this section. The resource MAY support additional functionality, which is out of scope for this specification. Although these interface descriptions are intended to be used with the CoRE Link Format, they are applicable for use in any REST interface definition. </t>
  
  <t>The Methods column defines the methods supported by that interface, which are described in more detail below. 
  </t>

    <texttable>
      <ttcol align="right">Interface</ttcol>
      <ttcol align="left">if=</ttcol>
      <ttcol align="left">Methods</ttcol>
      
      <c>Link List</c> <c>core.ll</c> <c>GET</c>
      <c>Batch</c> <c>core.b</c> <c>GET, PUT, POST (where applicable)</c>
      <c>Linked Batch</c> <c>core.lb</c> <c>GET, PUT, POST, DELETE (where applicable)</c>
      <c>Sensor</c> <c>core.s</c> <c>GET</c>
      <c>Parameter</c> <c>core.p</c> <c>GET, PUT</c>
      <c>Read-only Parameter</c> <c>core.rp</c> <c>GET</c>
      <c>Actuator</c> <c>core.a</c> <c>GET, PUT, POST</c>     
      <c>Binding</c> <c>core.bnd</c> <c>GET, POST, DELETE</c>     
    </texttable>
  
  <t>The following is an example of links in the CoRE Link Format using these interface descriptions. The resource hierarchy is based on a simple profile defined in <xref target="simple-profile"/>. These links are used in the subsequent examples below.</t>
  
   <figure>
    <artwork align="left"><![CDATA[

Req: GET /.well-known/core
Res: 2.05 Content (application/link-format)
</s>;rt="simple.sen";if="core.b",
</s/lt>;rt="simple.sen.lt";if="core.s",
</s/tmp>;rt="simple.sen.tmp";if="core.s";obs,
</s/hum>;rt="simple.sen.hum";if="core.s",
</a>;rt="simple.act";if="core.b",
</a/1/led>;rt="simple.act.led";if="core.a",
</a/2/led>;rt="simple.act.led";if="core.a",
</d>;rt="simple.dev";if="core.ll",
</l>;if="core.lb",
    ]]></artwork>
    </figure>
 
    <section anchor="link-list" title="Link List">
      
      <t>The Link List interface is used to retrieve (GET) a list of resources on a web server. The GET request SHOULD contain an Accept option with the application/link-format content type, however if the resource does not support any other form of GET methods the Accept option MAY be elided. The Accept option SHOULD only include the application/link-format content type.

<!-- This use of Accept is not very clear, should probably explain this is due to this interface type being extended by Batch and Linked Batch later -->

	  The request returns a list of URI references with absolute paths to the resources as defined in CoRE Link Format. This interface is typically used with a parent resource to enumerate sub-resources but may be used to reference any resource on a web server.
      </t>

      <t>Link List is the base interface to provide gradual reveal of resources on a CoRE web server, hence the root resource of a Function Set SHOULD implement this interface or an extension of this interface.
      </t>
      
      <t>The following example interacts with a Link List /d containing Parameter sub-resources /d/name, /d/model. </t>
      
  <figure>
    <artwork align="left"><![CDATA[

Req: GET /d (Accept:application/link-format)
Res: 2.05 Content (application/link-format)
</d/name>;rt="simple.dev.n";if="core.p",
</d/model>;rt="simple.dev.mdl";if="core.rp"

    ]]></artwork>
    </figure>  
    
    </section>
 
    <section anchor="batch" title="Batch">
    
    <t>The Batch interface is used to manipulate a collection of sub-resources at the same time. The Batch interface type supports the same methods as its sub-resources, and can be used to read (GET), set (PUT) or toggle (POST) the values of those sub-resource with a single resource representation. The sub-resources of a Batch MAY be heterogeneous, a method used on the Batch only applies to sub-resources that support it. For example Sensor interfaces do not support PUT, and thus a PUT request to a Sensor member of that Batch would be ignored. A batch requires the use of SenML Media types in order to support multiple sub-resources. </t>
    
    <t>In addition, The Batch interface is an extension of the Link List interface and in consequence MUST support the same methods.
    </t>

<!-- Should probably explain that this means doing a GET with an Accept:application/link-format will return the sub-resource links -->    
    
    <t>The following example interacts with a Batch /s with Sensor sub-resources /s/light, /s/temp and /s/humidity. </t>
    
  <figure>
    <artwork align="left"><![CDATA[

Req: GET /s
Res: 2.05 Content (application/senml+json)
{"e":[
    { "n": "light", "v": 123, "u": "lx" },
    { "n": "temp", "v": 27.2, "u": "degC" },
    { "n": "humidity", "v": 80, "u": "%RH" }],
}

    ]]></artwork>
    </figure>  
    
    </section>

    <section anchor="linked-batch" title="Linked Batch">
    
    <t>The Linked Batch interface is an extension of the Batch interface. Contrary to the basic Batch which is a collection statically defined by the web server, a Linked Batch is dynamically controlled by a web client. A Linked Batch resource has no sub-resources. Instead the resources forming the batch are referenced using Web Linking <xref target="RFC5988"/> and the CoRE Link Format <xref target="I-D.ietf-core-link-format"/>. A request with a POST method and a content type of application/link-format simply appends new resources to the collection. The links in the payload MUST reference a resource on the web server with an absolute path. A DELETE request empties the current collection of links. All other requests available for a basic Batch are still valid for a Linked Batch.</t>
    
    <t>The following example interacts with a Linked Batch /l and creates a collection containing /s/light, /s/temp and /s/humidity in 2 steps. </t>
    
  <figure>
    <artwork align="left"><![CDATA[

Req: POST /l (Content-type: application/link-format)
</s/light>,</s/temp>
Res: 2.04 Changed 

Req: GET /l
Res: 2.05 Content (application/senml+json)
{"e":[
   { "n": "/s/light", "v": 123, "u": "lx" },
   { "n": "/s/temp", "v": 27.2, "u": "degC" },
}

Req: POST /l (Content-type: application/link-format)
</s/humidity>
Res: 2.04 Changed 

Req: GET /l (Accept: application/link-format)
Res: 2.05 Content (application/link-format)
</s/light>,</s/temp>,</s/humidity>

Req: GET /l
Res: 2.05 Content (application/senml+json)
{"e":[
   { "n": "/s/light", "v": 123, "u": "lx" },
   { "n": "/s/temp", "v": 27.2, "u": "degC" },
   { "n": "/s/humidity", "v": 80, "u": "%RH" }],
}

Req: DELETE /l
Res: 2.04 Changed

    ]]></artwork>
    </figure>  
    
    </section>

    <section anchor="sensor" title="Sensor">
    
    <t>The Sensor interface allows the value of a sensor resource to be read (GET). The Media type of the resource can be either plain text or SenML. Plain text MAY be used for a single measurement that does not require meta-data. For a measurement with meta-data such as a unit or time stamp, SenML SHOULD be used. A resource with this interface MAY use SenML to return multiple measurements in the same representation, for example a list of recent measurements.</t>

    <t>The following are examples of Sensor interface requests in both text/plain and application/senml+json.</t>
    
  <figure>
    <artwork align="left"><![CDATA[

Req: GET /s/humidity (Accept: text/plain)
Res: 2.05 Content (text/plain)
80

Req: GET /s/humidity (Accept: application/senml+json)
Res: 2.05 Content (application/senml+json)
{"e":[
    { "n": "humidity", "v": 80, "u": "%RH" }],
}

    ]]></artwork>
    </figure>      
    
    </section>  

    <section anchor="parameter" title="Parameter">
    
    <t>The Parameter interface allows configurable parameters and other information to be modeled as a resource. The value of the parameter can be read (GET) or set (PUT). Plain text or SenML Media types MAY be returned from this type of interface.</t>

    <t>The following example shows request for reading and setting a parameter.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET /d/name
Res: 2.05 Content (text/plain)
node5

Req: PUT /d/name (text/plain)
outdoor
Res: 2.04 Changed 

    ]]></artwork>
    </figure> 
    
    </section>

    <section anchor="readonly-parameter" title="Read-only Parameter">
    
    <t>The Read-only Parameter interface allows configuration parameters to be read (GET) but not set. Plain text or SenML Media types MAY be returned from this type of interface.</t>

    <t>The following example shows request for reading such a parameter.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET /d/model
Res: 2.05 Content (text/plain)
SuperNode200

    ]]></artwork>
    </figure> 
    
    </section>


    <section anchor="actuator" title="Actuator">
    
    <t>The Actuator interface is used by resources that model different kinds of actuators (changing its value has an effect on its environment). Examples of actuators include for example LEDs, relays, motor controllers and light dimmers. The current value of the actuator can be read (GET) or a new actuator value set (PUT). In addition, this interface defines the use of POST (with no body) to toggle an actuator between its possible values. Plain text or SenML Media types MAY be returned from this type of interface. A resource with this interface MAY use SenML to include multiple measurements in the same representation, for example a list of recent actuator values or a list of values to set.</t>
 
    <t>The following example shows requests for reading, setting and toggling an actuator (turning on a led).</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET /a/1/led
Res: 2.05 Content (text/plain)
0

Req: PUT /a/1/led (text/plain)
1
Res: 2.04 Changed 

Req: POST /a/1/led (text/plain)
Res: 2.04 Changed 

Req: GET /a/1/led
Res: 2.05 Content (text/plain)
0

    ]]></artwork>
    </figure>
 
    </section>

    <section anchor="binding_interface" title="Binding">
    
    <t>The Binding interface is used to manipulate a binding table. A request with a POST method and a content type of application/link-format simply appends new bindings to the table. All links in the payload MUST have a relation type &quot;boundTo&quot;. A GET request simply returns the current state of a binding table whereas a DELETE request empties the table.</t>
 
    <t>The following example shows requests for adding, retrieving and deleting bindings in a binding table.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: POST /bnd (Content-type: application/link-format)
<coap://sensor.example.com/s/light>;
  rel="boundto";anchor="/a/light";bind="obs";pmin="10";pmax="60"
Res: 2.04 Changed 

Req: GET /bnd
Res: 2.05 Content (application/senml+json)
<coap://sensor.example.com/s/light>;
  rel="boundto";anchor="/a/light";bind="obs";pmin="10";pmax="60"

Req: DELETE /bnd
Res: 2.04 Changed

    ]]></artwork>
    </figure>
 
    </section>
    
    <section anchor="observation" title="Resource Observation">
    
      <t>When resource interfaces following this specification are made available over CoAP, the CoAP Observation mechanism <xref target="I-D.ietf-core-observe"/> MAY be used to observe any changes in a resource, and receive asynchronous notifications as a result. In addition, a set of query string parameters are defined here to allow a client to request how often a client is interested in receiving notifications and how much a resource should change for the new representation to be interesting. These query parameters are described in the following table. A resource using an interface description defined in this specification and marked as Observable in its link description SHOULD support these observation parameters. The Change Step parameter can only be supported on resources with an atomic numeric value.
      </t>
      
    <texttable>
      <ttcol align="left">Query</ttcol>
      <ttcol align="left">Parameter</ttcol>
      <ttcol align="left">Value</ttcol>

      <c>Minimum Period (s)</c> <c>pmin</c> <c>xsd:integer (>0)</c>
      <c>Maximum Period (s)</c> <c>pmax</c> <c>xsd:integer (>0)</c>
      <c>Change Step</c> <c>st</c> <c>xsd:decimal (>0)</c>
    
    </texttable>  
    
  <t>
    <list style="hanging">
      <t hangText="Minimum Period:">When present, the minimum period indicates the minimum time in seconds the server SHOULD wait between sending notifications. In the absence of this parameter, the minimum period is up to the server.</t>
      <t hangText="Maximum Period:">When present, the maximum period indicated the maximum time in seconds the server SHOULD wait between sending notifications (regardless if it has changed). In the absence of this parameter, the maximum period is up to the server. The maximum period MUST be greater than the minimum period parameter (if present). </t>
      <t hangText="Change Step:">When present, the change step indicates how much the value of a resource SHOULD change before sending a new notification (compared to the value of the last notification). This parameter has lower priority than the period parameters, thus even if the change step has been fulfilled, the time since the last notification SHOULD be between pmin and pmax. </t>
    </list>
  </t> 
    
    <t>The following example shows an Observation request using these query parameters. Here the value of Observe indicates the number of seconds since the observation was made to show the time.</t>

  <figure>
    <artwork align="left"><![CDATA[

Req: GET Observe /s/temp?pmin=10&pmax=60&st=1
Res: 2.05 Content Observe:0 (text/plain)
23.2

Res: 2.05 Content Observe:60 (text/plain)
23.0

Res: 2.05 Content Observe:80 (text/plain)
22.0

Res: 2.05 Content Observe:140 (text/plain)
21.8

    ]]></artwork>
    </figure>     
    
    </section>
    
    <section anchor="future" title="Future Interfaces">
  
    <t>It is expected that further interface descriptions will be defined in this and other specifications. Potential interfaces to be considered for this specifications include:
    
    <list style="hanging">
      
      <t hangText="Collection:">This resource would be a container that allows sub-resources to be added or removed.</t>
    </list>
    </t>
    
    </section>
   
    <section anchor="wadl" title="WADL Description">
    
    <t>This section defines the formal Web Application Description Langauge (WADL) definition of these CoRE interface descriptions.</t>
    
  <figure>
    <artwork align="left"><![CDATA[

<?xml version="1.0" standalone="yes"?>

<application xmlns="http://research.sun.com/wadl/2006/10"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns:senml="urn:ietf:params:xml:ns:senml">

  <grammars>
    <include href="http://tools.ietf.org/html/draft-jennings-senml"/>
  </grammars>

  <doc title="CoRE Interfaces"/>

  <resource_type id="s">
    <doc title="Sensor resource type"/>
    <method href="#read"/>
    <method href="#observe"/>
  </resource_type>

  <resource_type id="p">
    <doc title="Parameter resource type"/>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#update"/>
  </resource_type>

  <resource_type id="rp">
    <doc title="Read-only Parameter resource type"/>
    <method href="#read"/>
    <method href="#observe"/>
  </resource_type> 

  <resource_type id="a">
    <doc title="Actuator resource type"/>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#update"/>
    <method href="#toggle"/>
  </resource_type>

  <resource_type id="ll">
    <doc title="Link List type"/></doc>
    <method href="#listLinks"/>
  </resource_type>

  <resource_type id="b">
    <doc title="Batch of sub-resources type">The methods read, 
     observe, update and toggle are applied to each sub-
     resource of the requested resource that supports it. Mixed 
     sub-resource types can be supported.</doc>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#update"/>
    <method href="#toggle"/>
    <method href="#listLinks"/>
  </resource_type>

  <resource_type id="lb">
    <doc title="Linked Batch resource type">. The methods read, 
     obervableRead, update and toggle are applied to each linked 
     resource of the requested resource that supports it. Mixed 
     linked resource types can be supported.</doc>
    <method href="#read"/>
    <method href="#observe"/>
    <method href="#update"/>
    <method href="#listLinks"/>
    <method href="#appendLinks"/>
    <method href="#clearLinks"/>
  </resource_type>

  <resource_type id="bnd">
    <doc title="Binding table resource type">A modifiable list of links.
    Each link MUST have the relation type "boundTo".</doc>
    <method href="#listLinks"/>
    <method href="#appendLinks"/>
    <method href="#clearLinks"/>
  </resource_type>
  
  <method id="read" name="GET">
    <doc>Retrieve the value of a sensor, an actuator or a parameter.
     Both HTTP and CoAP support this method.</doc>
    <request>
    </request>
    <response status="200">
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
    <response status="2.05">
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
  </method>

  <method id="observe" name="GET">
    <doc>Observe the value of a sensor, an actuator or a parameter. 
     Only CoAP supports this method since it requires the CoRE 
     Observe mechanism.</doc>
    <request>
      <param name="pmin" style="query" type="xsd:integer"/>
      <param name="pmax" style="query" type="xsd:integer"/>
      <param name="st" style="query" type="xsd:decimal"/>
    </request>
    <response status="2.05">
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </response>
  </method>

  <method id="update" name="PUT">
    <doc>Control the actuator or update a parameter with a new value 
    or command. Both HTTP and CoAP support this method.</doc>
    <request>
      <representation mediaType="text/plain"/>
      <representation mediaType="application/senml+exi"/>
      <representation mediaType="application/senml+xml"/>
      <representation mediaType="application/senml+json"/>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>
  
  <method id="toggle" name="POST">
    <doc>Toggle the values of actuator resources. Both HTTP and CoAP 
    support this method.</doc>
    <request>
      <doc>The toggle function is only applicable if the request 
      is empty.</doc>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>

  <method id="listLinks" name="GET">
    <doc>Retrieve the list of Web links associated to a resource.
     Both HTTP and CoAP support this method.</doc>
    <request>
    <doc>This request MUST contain an Accept option with 
    application/link-format when the resource supports
    other GET methods.</doc>
    </request>
    <response status="200">
      <representation mediaType="application/link-format"/>
    </response>
    <response status="2.05">
      <representation mediaType="application/link-format"/>
    </response>
  </method>

  <method id="appendLinks" name="POST">
    <doc>Append new Web links to a resource which is a collection 
    of links. Both HTTP and CoAP support this method.</doc>
    <request>
      <representation mediaType="application/link-format"/>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>

  <method id="clearLinks" name="DELETE">
    <doc>Clear all Web Links in a resource which is a collection 
    of links. Both HTTP and CoAP support this method.</doc>
    <request>
    </request>
    <response status="200"/>
    <response status="2.04"/>
  </method>
  
</application>

  ]]></artwork>
    </figure>
    
    </section>   
   
   
  </section>


  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section anchor="security" title="Security Considerations">
  <t> 
  An implementation of a client needs to be prepared to deal with responses to a request that differ from what is specified in this document. A server implementing what the client thinks is a resource with one of these interface descriptions could return malformed representations and response codes either by accident or maliciously. A server sending maliciously malformed responses could attempt to take advantage of a poorly implemented client for example to crash the node or perform denial of service.  
    </t>

  </section>

  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section title="IANA Considerations">

  <t>
  The interface description types defined require registration.
  </t>

  <t>
  The new link relation type "boundto" requires registration.
  </t>
  
  <!-- We need a registry for binding methods? -->
     
  </section>

<!-- **************************************************************** -->
<!--  SECTION: ACKNOWLEDGMENTS          -->
<!-- **************************************************************** -->

<section title="Acknowledgments">

<t>Acknowledgement is given to colleagues from the SENSEI project who were critical in the initial development of the well-known REST interface concept, to members of the IPSO Alliance where further requirements for interface types have been discussed, and to Szymon Sasin, Cedric Chauvenet, Daniel Gavelle and Carsten Bormann who have provided useful discussion and input to the concepts in this document. </t>

</section>

  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->
  <!-- **************************************************************** -->

  <section title="Changelog">

  <t>Changes from -02 to -03
  <list style="symbols">
  	<t>Added Bindings</t>
  	<t>Updated all rt= and if= for the new Link Format IANA rules</t>
  </list>
  </t>

  <t>Changes from -01 to -02
  <list style="symbols">
  	<t>Defined a Function Set and its guidelines.</t>
  	<t>Added the Link List interface.</t>
  	<t>Added the Linked Batch interface.</t>
  	<t>Improved the WADL interface definition.</t>
  	<t>Added a simple profile example.</t>
  </list>
  </t>

  </section>
  
    </middle>

    <back>
    <references title='Normative References'>
       &I-D.ietf-core-link-format;
       &RFC2119;
       &RFC5988;
       
    </references>

    <references title='Informative References'>
    &I-D.ietf-core-coap;
    &I-D.ietf-core-observe;
    &I-D.shelby-core-resource-directory;
    &I-D.cheshire-dnsext-dns-sd;
       
    </references>
  
  <section anchor="simple-profile" title="Profile example">

  <t>The following is a short definition of simple profile. This simplistic profile is for use in the examples of this document.</t>

    <texttable title="List of Function Sets">
      <ttcol align="right">Function Set</ttcol>
      <ttcol align="left">Root Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      
      <c>Device Description</c> <c>/d</c> <c>simple.dev</c> <c>core.ll</c>
      <c>Sensors</c> <c>/s</c> <c>simple.sen</c> <c>core.b</c>
      <c>Actuators</c> <c>/a</c> <c>simple.act</c> <c>core.b</c>
    </texttable>

    <texttable title="Device Description Function Set">
      <ttcol align="right">Type</ttcol>
      <ttcol align="left">Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      <ttcol align="left">Data Type</ttcol>
      
      <c>Name</c> <c>/d/name</c> <c>simple.dev.n</c> <c>core.p</c> <c>xsd:string</c>
      <c>Model</c> <c>/d/model</c> <c>simple.dev.mdl</c> <c>core.rp</c> <c>xsd:string</c>
    </texttable>

    <texttable title="Sensors Function Set">
      <ttcol align="right">Type</ttcol>
      <ttcol align="left">Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      <ttcol align="left">Data Type</ttcol>
      
      <c>Light</c> <c>/s/light</c> <c>simple.sen.lt</c> <c>core.s</c> <c>xsd:decimal (lux)</c>
      <c>Humidity</c> <c>/s/humidity</c> <c>simple.sen.hum</c> <c>core.s</c> <c>xsd:decimal (%RH)</c>
      <c>Temperature</c> <c>/s/temp</c> <c>simple.sen.tmp</c> <c>core.s</c> <c>xsd:decimal (degC)</c>
    </texttable>

    <texttable title="Actuators Function Set">
      <ttcol align="right">Type</ttcol>
      <ttcol align="left">Path</ttcol>
      <ttcol align="left">RT</ttcol>
      <ttcol align="left">IF</ttcol>
      <ttcol align="left">Data Type</ttcol>
      
      <c>LED</c> <c>/a/{#}/led</c> <c>simple.act.led</c> <c>core.a</c> <c>xsd:boolean</c>
    </texttable>

  </section>

    </back>

</rfc>
