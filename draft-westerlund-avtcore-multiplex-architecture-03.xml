<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY rfc2198 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2198.xml">
<!ENTITY rfc2205 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2205.xml">
<!ENTITY rfc2326 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2326.xml">
<!ENTITY rfc2474 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2474.xml">
<!ENTITY rfc2974 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2974.xml">
<!ENTITY rfc3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY rfc3264 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY rfc3389 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3389.xml">
<!ENTITY rfc3551 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3551.xml">
<!ENTITY rfc3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY rfc3830 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml">
<!ENTITY rfc4103 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4103.xml">
<!ENTITY rfc4566 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY rfc4568 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml">
<!ENTITY rfc4588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4588.xml">
<!ENTITY rfc4607 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4607.xml">
<!ENTITY rfc5104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5104.xml">
<!ENTITY rfc5117 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5117.xml">
<!ENTITY rfc5576 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5576.xml">
<!ENTITY rfc5583 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5583.xml">
<!ENTITY rfc5760 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5760.xml">
<!ENTITY rfc5761 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5761.xml">
<!ENTITY rfc5764 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5764.xml">
<!ENTITY rfc5888 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5888.xml">
<!ENTITY rfc6190 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6190.xml">
<!ENTITY rfc6222 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6222.xml">
<!ENTITY rfc6285 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6285.xml">
<!ENTITY rfc6465 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6465.xml">
<!ENTITY draft-ietf-avtext-multiple-clock-rates SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-avtext-multiple-clock-rates.xml">
<!ENTITY draft-ietf-payload-rtp-howto SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-payload-rtp-howto.xml">
<!ENTITY draft-ietf-avt-srtp-ekt SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-avt-srtp-ekt.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="info"
     docName="draft-westerlund-avtcore-multiplex-architecture-03"
     ipr="trust200902">
  <front>
    <title abbrev="Guidelines for Multiplexing in RTP">Guidelines for using
    the Multiplexing Features of RTP</title>

    <author fullname="Magnus Westerlund" initials="M." surname="Westerlund">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Farogatan 6</street>

          <city>SE-164 80 Kista</city>

          <country>Sweden</country>
        </postal>

        <phone>+46 10 714 82 87</phone>

        <email>magnus.westerlund@ericsson.com</email>
      </address>
    </author>

    <author fullname="Bo Burman" initials="B." surname="Burman">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Farogatan 6</street>

          <city>SE-164 80 Kista</city>

          <country>Sweden</country>
        </postal>

        <phone>+46 10 714 13 11</phone>

        <email>bo.burman@ericsson.com</email>
      </address>
    </author>

    <author fullname="Colin Perkins" initials="C. " surname="Perkins">
      <organization>University of Glasgow</organization>

      <address>
        <postal>
          <street>School of Computing Science</street>

          <city>Glasgow</city>

          <code>G12 8QQ</code>

          <country>United Kingdom</country>
        </postal>

        <email>csp@csperkins.org</email>
      </address>
    </author>

    <author fullname="Harald Tveit Alvestrand" initials="H."
            surname="Alvestrand">
      <organization>Google</organization>

      <address>
        <postal>
          <street>Kungsbron 2</street>

          <city>Stockholm</city>

          <region/>

          <code>11122</code>

          <country>Sweden</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>harald@alvestrand.no</email>

        <uri/>
      </address>
    </author>

    <date day="25" month="February" year="2013"/>

    <abstract>
      <t>Real-time Transport Protocol (RTP) is a flexible protocol possible to
      use in a wide range of applications and network and system topologies.
      This flexibility and the implications of different choices should be
      understood by any application developer using RTP. To facilitate that
      understanding, this document contains an in-depth discussion of the
      usage of RTP's multiplexing points; the RTP session and the
      Synchronisation Source Identifier (SSRC). The document tries to give
      guidance and source material for an analysis on the most suitable
      choices for the application being designed.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t><xref target="RFC3550">Real-time Transport Protocol (RTP)</xref> is a
      commonly used protocol for real-time media transport. It is a protocol
      that provides great flexibility and can support a large set of different
      applications. RTP has several multiplexing points designed for different
      purposes. These enable support of multiple media streams and switching
      between different encoding or packetization of the media. By using
      multiple RTP sessions, sets of media streams can be structured for
      efficient processing or identification. Thus the question for any RTP
      application designer is how to best use the RTP session, the SSRC and
      the payload type to meet the application's needs.</t>

      <t>The purpose of this document is to provide clear information about
      the possibilities of RTP when it comes to multiplexing. The RTP
      application designer should understand the implications that come from a
      particular usage of the RTP multiplexing points. The document will
      recommend against some usages as being unsuitable, in general or for
      particular purposes.</t>

      <t>RTP was from the beginning designed for multiple participants in a
      communication session. This is not restricted to multicast, as some may
      believe, but also provides functionality over unicast, using either
      multiple transport flows below RTP or a network node that re-distributes
      the RTP packets. The re-distributing node can for example be a transport
      translator (relay) that forwards the packets unchanged, a translator
      performing media or protocol translation in addition to forwarding, or
      an RTP mixer that creates new conceptual sources from the received
      streams. In addition, multiple streams may occur when a single endpoint
      have multiple media sources, like multiple cameras or microphones that
      need to be sent simultaneously.</t>

      <t>This document has been written due to increased interest in more
      advanced usage of RTP, resulting in questions regarding the most
      appropriate RTP usage. The limitations in some implementations, RTP/RTCP
      extensions, and signalling has also been exposed. It is expected that
      some limitations will be addressed by updates or new extensions
      resolving the shortcomings. The authors also hope that clarification on
      the usefulness of some functionalities in RTP will result in more
      complete implementations in the future.</t>

      <t>The document starts with some definitions and then goes into the
      existing RTP functionalities around multiplexing. Both the desired
      behaviour and the implications of a particular behaviour depend on which
      topologies are used, which requires some consideration. This is followed
      by a discussion of some choices in multiplexing behaviour and their
      impacts. Some arch-types of RTP usage are discussed. Finally, some
      recommendations and examples are provided.</t>

      <t>This document is currently an individual contribution, but it is the
      intention of the authors that this should become a WG document that
      objectively describes and provides suitable recommendations for which
      there is WG consensus. Currently this document only represents the views
      of the authors. The authors gladly accept any feedback on the document
      and will be happy to discuss suitable recommendations.</t>
    </section>

    <section title="Definitions">
      <t/>

      <section title="Terminology">
        <t>The following terms and abbreviations are used in this
        document:</t>

        <t><list style="hanging">
            <t hangText="Endpoint:">A single entity sending or receiving RTP
            packets. It may be decomposed into several functional blocks, but
            as long as it behaves a single RTP stack entity it is classified
            as a single endpoint.</t>

            <t hangText="Multiparty:">A communication situation including
            multiple end-points. In this document it will be used to refer to
            situations where more than two end-points communicate.</t>

            <t hangText="Media Source:">The source of a stream of data of one
            Media Type, It can either be a single media capturing device such
            as a video camera, a microphone, or a specific output of a media
            production function, such as an audio mixer, or some video editing
            function. Sending data from a Media Source may cause multiple RTP
            sources to send multiple Media Streams.</t>

            <t hangText="Media Stream:">A sequence of RTP packets using a
            single SSRC that together carries part or all of the content of a
            specific Media Type from a specific sender source within a given
            RTP session.</t>

            <t hangText="RTP Source:">The originator or source of a particular
            Media Stream. Identified using an SSRC in a particular RTP
            session. An RTP source is the source of a single media stream, and
            is associated with a single endpoint and a single Media Source. An
            RTP Source is just called a Source in RFC 3550.</t>

            <t hangText="Media Sink:">A recipient of a Media Stream. The
            endpoint sinking media are Identified using one or more SSRCs.
            There may be more than one Media Sink for one RTP source.</t>

            <t hangText="CNAME:">"Canonical name" - identifier associated with
            one or more RTP sources from a single endpoint. Defined in <xref
            target="RFC3550">the RTP specification</xref>. A CNAME identifies
            a synchronisation context. A CNAME is associated with a single
            endpoint, although some RTP nodes will use an end-points CNAME on
            that end-points behalf. An endpoint may use multiple CNAMEs. A
            CNAME is intended to be globally unique and stable for the full
            duration of a communication session. <xref target="RFC6222"/><xref
            target="I-D.ietf-avtcore-6222bis"/> gives updated guidelines for
            choosing CNAMEs.</t>

            <t hangText="Media Type:">Audio, video, text or data whose form
            and meaning are defined by a specific real-time application.</t>

            <t hangText="Multiplex:">The operation of taking multiple entities
            as input, aggregating them onto some common resource while keeping
            the individual entities addressable such that they can later be
            fully and unambiguously separated (de-multiplexed) again.</t>

            <t hangText="RTP Session:">As defined by <xref target="RFC3550"/>,
            the endpoints belonging to the same RTP Session are those that
            share a single SSRC space. That is, those endpoints can see an
            SSRC identifier transmitted by any one of the other endpoints. An
            endpoint can receive an SSRC either as SSRC or as CSRC in RTP and
            RTCP packets. Thus, the RTP Session scope is decided by the
            endpoints' network interconnection topology, in combination with
            RTP and RTCP forwarding strategies deployed by endpoints and any
            interconnecting middle nodes.</t>

            <t hangText="RTP Session Group:">One or more RTP sessions that are
            used together to perform some function. Examples are multiple RTP
            sessions used to carry different layers of a layered encoding. In
            an RTP Session Group, CNAMEs are assumed to be valid across all
            RTP sessions, and designate synchronisation contexts that can
            cross RTP sessions.</t>

            <t hangText="Source:">Term that should not be used alone. An RTP
            Source, as identified by its SSRC, is the source of a single Media
            Stream; a Media Source can be the source of mutiple Media
            Streams.</t>

            <t hangText="SSRC:">An RTP 32-bit unsigned integer used as
            identifier for a RTP Source.</t>

            <t hangText="CSRC:">Contributing Source, A SSRC identifier used in
            a context, like the RTP headers CSRC list, where it is clear that
            the Media Source is not the source of the media stream, instead
            only a contributor to the Media Stream.</t>

            <t hangText="Signalling:">The process of configuring endpoints to
            participate in one or more RTP sessions.</t>

            <t/>
          </list></t>
      </section>

      <section title="Subjects Out of Scope">
        <t>This document is focused on issues that affect RTP. Thus, issues
        that involve signalling protocols, such as whether SIP, Jingle or some
        other protocol is in use for session configuration, the particular
        syntaxes used to define RTP session properties, or the constraints
        imposed by particular choices in the signalling protocols, are
        mentioned only as examples in order to describe the RTP issues more
        precisely.</t>

        <t>This document assumes the applications will use RTCP. While there
        are such applications that don't send RTCP, they do not conform to the
        RTP specification, and thus should be regarded as reusing the RTP
        packet format, not as implementing the RTP protocol.</t>
      </section>
    </section>

    <section anchor="sec-mux-points" title="RTP Concepts">
      <t>This section describes the existing RTP tools that are particularly
      important when discussing multiplexing of different media streams.</t>

      <section title="Session">
        <t>The RTP Session is the highest semantic level in RTP and contains
        all of the RTP functionality. RTP itself has no normative statements
        about the relationship between different RTP sessions.<list
            style="hanging">
            <t hangText="Identifier:">RTP in itself does not contain any
            Session identifier, but relies either on the underlying transport
            or on the used signalling protocol, depending on in which context
            the identifier is used (e.g. transport or signalling). Due to
            this, a single RTP Session may have multiple associated
            identifiers belonging to different contexts.<list style="hanging">
                <t hangText="Position:">Depending on underlying transport and
                signalling protocol. For example, when running RTP on top of
                UDP, an RTP endpoint can identify and delimit an RTP Session
                from other RTP Sessions through the UDP source and destination
                transport address, consisting of network address and port
                number(s). Commonly, RTP and RTCP use separate ports and the
                destination transport address is in fact an address pair, but
                in the case of <xref target="RFC5761">RTP/RTCP
                multiplex</xref> there is only a single port. Another example
                is <xref target="RFC4566">SDP signalling</xref>, where the
                <xref target="RFC5888">grouping framework</xref> uses an
                identifier per "m="-line. If there is a one-to-one mapping
                between "m="-line and RTP Session, that grouping framework
                identifier can identify a single RTP Session.</t>

                <t hangText="Usage:">Identify separate RTP Sessions.</t>

                <t hangText="Uniqueness:">Globally unique, but identity can
                only be detected by the general communication context for the
                specific endpoint.</t>

                <t hangText="Inter-relation:">Depending on the underlying
                transport and signalling protocol.</t>
              </list></t>

            <t hangText="Special Restrictions:">None.</t>
          </list></t>

        <t>A RTP source in an RTP session that changes its source transport
        address during a session must also choose a new SSRC identifier to
        avoid being interpreted as a looped source.</t>

        <t>The set of participants considered part of the same RTP Session is
        defined by <xref target="RFC3550">the RTP specification</xref> as
        those that share a single SSRC space. That is, those participants that
        can see an SSRC identifier transmitted by any one of the other
        participants. A participant can receive an SSRC either as SSRC or CSRC
        in RTP and RTCP packets. Thus, the RTP Session scope is decided by the
        participants' network interconnection topology, in combination with
        RTP and RTCP forwarding strategies deployed by endpoints and any
        interconnecting middle nodes.</t>
      </section>

      <section title="SSRC">
        <t>An SSRC identifies a RTP source or a media sink. For end-points
        that both source and sink media streams its SSRCs are used in both
        roles. At any given time, a RTP source has one and only one SSRC -
        although that may change over the lifetime of the RTP source or sink.
        An RTP Session serves one or more RTP sources.<!----><list
            style="hanging">
            <t hangText="Identifier:">Synchronisation Source (SSRC), 32-bit
            unsigned number.<list style="hanging">
                <t hangText="Position:">In every RTP and RTCP packet header.
                May be present in RTCP payload. May be present in SDP
                signalling.</t>

                <t hangText="Usage:">Identify individual RTP sources and media
                sinks within an RTP Session. Refer to individual RTP sources
                and media sinks in RTCP messages and SDP signalling.</t>

                <t hangText="Uniqueness:">Randomly chosen, intended to be
                globally unique within an RTP Session and not dependent on
                network address. SSRC value collisions may occur and must be
                handled as specified in <xref target="RFC3550">RTP</xref>.</t>

                <t hangText="Inter-relation:">SSRC belonging to the same
                synchronisation context (originating from the same endpoint),
                within or between RTP Sessions, are indicated through use of
                identical SDES CNAME items in RTCP compound packets with those
                SSRC as originating source. SDP signalling can provide
                explicit <xref target="RFC5576">SSRC grouping </xref>. When
                CNAME is inappropriate or insufficient, there exist a few
                other methods to relate different SSRC. One such case is
                session-based <xref target="RFC4588">RTP
                retransmission</xref>. In some cases, the same SSRC Identifier
                value is used to relate streams in two different RTP Sessions,
                such as in Multi-Session Transmission of <xref
                target="RFC6190">scalable video</xref>.</t>
              </list></t>

            <t hangText="Special Restrictions:">All RTP implementations must
            be prepared to use procedures for SSRC collision handling, which
            results in an SSRC number change. A RTP source that changes its
            RTP Session identifier (e.g. source transport address) during a
            session must also choose a new SSRC identifier to avoid being
            interpreted as looped source.</t>

            <t hangText="">Note that RTP sequence number and RTP timestamp are
            scoped by SSRC and thus independent between different SSRCs.</t>
          </list></t>

        <t>An SSRC identifier is used by different type of sources as well as
        sinks:<list style="hanging">
            <t hangText="Real Media Source:">Connected to a "physical" media
            source, for example a camera or microphone.</t>

            <t hangText="Conceptual Media Source:">A source with some
            attributed property generated by some network node, for example a
            filtering function in an RTP mixer that provides the most active
            speaker based on some criteria, or a mix representing a set of
            other sources.</t>

            <t hangText="Media Sink:">A source that does not generate any RTP
            media stream in itself (e.g. an endpoint or middlebox only
            receiving in an RTP session), but anyway need a sender SSRC for
            use as source in RTCP reports.</t>
          </list></t>

        <t>Note that a endpoint that generates more than one media type, e.g.
        a conference participant sending both audio and video, need not (and
        commonly should not) use the same SSRC value across RTP sessions. RTCP
        Compound packets containing the CNAME SDES item is the designated
        method to bind an SSRC to a CNAME, effectively cross-correlating SSRCs
        within and between RTP Sessions as coming from the same endpoint. The
        main property attributed to SSRCs associated with the same CNAME is
        that they are from a particular synchronisation context and may be
        synchronised at playback.</t>

        <t>An RTP receiver receiving a previously unseen SSRC value must
        interpret it as a new source. It may in fact be a previously existing
        source that had to change SSRC number due to an SSRC conflict.
        However, the originator of the previous SSRC should have ended the
        conflicting source by sending an RTCP BYE for it prior to starting to
        send with the new SSRC, so the new SSRC is anyway effectively a new
        source.</t>
      </section>

      <section title="CSRC">
        <t>The Contributing Source (CSRC) is not a separate identifier, but an
        usage of the SSRC identifier. It is optionally included in the RTP
        header as list of up to 15 contributing RTP sources. CSRC shares the
        SSRC number space and specifies which set of SSRCs that has
        contributed to the RTP payload. However, even though each RTP packet
        and SSRC can be tagged with the contained CSRCs, the media
        representation of an individual CSRC is in general not possible to
        extract from the RTP payload since it is typically the result of a
        media mixing (merge) operation (by an RTP mixer) on the individual
        media streams corresponding to the CSRC identifiers. The exception is
        the case when only a single CSRC is indicated as this represent
        forwarding of a media stream, possibly modified. The RTP header
        extension for <xref target="RFC6465">Mixer-to-Client Audio Level
        Indication</xref> expands on the receivers information about a packet
        with a CSRC list. Due to these restrictions, CSRC will not be
        considered a fully qualified multiplex point and will be disregarded
        in the rest of this document.</t>
      </section>

      <section title="Payload Type">
        <t>Each Media Stream utilises one or more encoding formats, identified
        by the Payload Type.</t>

        <t>The Payload Type is not a multiplexing point. <xref
        target="sec-pt-mux"/> gives some of the many reasons why attempting to
        use it as a multiplexing point will have bad results.</t>

        <t><list style="hanging">
            <t hangText="Identifier:">Payload Type number.<list
                style="hanging">
                <t hangText="Position:">In every RTP header and in
                signalling.</t>

                <t hangText="Usage:">Identify a specific Media Stream encoding
                format. The format definition may be taken from <xref
                target="RFC3551"/> for statically allocated Payload Types, but
                should be explicitly defined in signalling, such as SDP, both
                for static and dynamic Payload Types. The term "format" here
                includes whatever can be described by out-of-band signalling
                means. In SDP, the term "format" includes media type, RTP
                timestamp sampling rate, codec, codec configuration, payload
                format configurations, and various robustness mechanisms such
                as <xref target="RFC2198">redundant encodings</xref>.</t>

                <t hangText="Uniqueness:">Scoped by sending endpoint within an
                RTP Session. To avoid any potential for ambiguity, it is
                desirable that payload types are unique across all sending
                endpoints within an RTP session, but this is often not true in
                practice. All SSRC in an RTP session sent from an single
                endpoint share the same Payload Types definitions. The RTP
                Payload Type is designed such that only a single Payload Type
                is valid at any time instant in the SSRC's RTP timestamp time
                line, effectively time-multiplexing different Payload Types if
                any change occurs. Used Payload Type may change on a
                per-packet basis for an SSRC, for example a speech codec
                making use of <xref target="RFC3389">generic Comfort
                Noise</xref>.</t>

                <t hangText="Inter-relation:">There are some uses where
                Payload Type numbers need to be unique across RTP Sessions.
                This is for example the case in <xref target="RFC5583">Media
                Decoding Dependency</xref> where Payload Types are used to
                describe media dependency across RTP Sessions. Another example
                is session-based <xref target="RFC4588">RTP
                retransmission</xref>.</t>
              </list></t>

            <t hangText="Special Restrictions:">Using different RTP timestamp
            clock rates for the RTP Payload Types in use in the same RTP
            Session have issues such as potential for loss of synchronisation.
            Payload Type clock rate switching requires some special
            consideration that is described in the <xref
            target="I-D.ietf-avtext-multiple-clock-rates">multiple clock rates
            specification</xref>.</t>
          </list></t>

        <t>If there is a true need to send multiple Payload Types for the same
        SSRC that are valid for the same RTP Timestamps, then <xref
        target="RFC2198">redundant encodings</xref> can be used. Several
        additional constraints than the ones mentioned above need to be met to
        enable this use, one of which is that the combined payload sizes of
        the different Payload Types must not exceed the transport MTU.</t>

        <t>Other aspects of RTP payload format use are described in <xref
        target="I-D.ietf-payload-rtp-howto">RTP Payload HowTo </xref>.</t>
      </section>
    </section>

    <section title="Multiple Streams Alternatives">
      <t>The reasons why an endpoint may choose to send multiple media streams
      are widespread. In the below discussion, please keep in mind that the
      reasons for having multiple media streams vary and include but are not
      limited to the following:<list style="symbols">
          <t>Multiple Media Sources</t>

          <t>Multiple Media Streams may be needed to represent one Media
          Source (for instance when using layered encodings)</t>

          <t>A Retransmission stream may repeat the content of another Media
          Stream</t>

          <t>An FEC stream may provide material that can be used to repair
          another Media Stream</t>

          <t>Alternative Encodings, for instance different codecs for the same
          audio stream</t>

          <t>Alternative formats, for instance multiple resolutions of the
          same video stream</t>
        </list></t>

      <t>Thus the choice made due to one reason may not be the choice suitable
      for another reason. In the above list, the different items have
      different levels of maturity in the discussion on how to solve them. The
      clearest understanding is associated with multiple media sources of the
      same media type. However, all warrant discussion and clarification on
      how to deal with them.</t>

      <t>This section reviews the alternatives to enable multi-stream
      handling. Let's start with describing mechanisms that could enable
      multiple media streams, independent of the purpose for having multiple
      streams.</t>

      <t><list style="hanging">
          <t hangText="Additional SSRC:">Each additional Media Stream gets its
          own SSRC within a RTP Session.</t>

          <t hangText="Multiple RTP Sessions:">Using additional RTP Sessions
          to handle additional Media Streams.</t>
        </list>As the below discussion will show, in reality we cannot choose
      a single one of the two solutions. To utilise RTP well and as
      efficiently as possible, both are needed. The real issue is finding the
      right guidance on when to create RTP sessions and when additional SSRCs
      in an RTP session is the right choice.</t>
    </section>

    <section anchor="sec-topologies" title="RTP Topologies and Issues">
      <t>The impact of how RTP Multiplex is performed will in general vary
      with how the RTP Session participants are interconnected, described by
      <xref target="RFC5117">RTP Topology</xref> and its <xref
      target="I-D.westerlund-avtcore-rtp-topologies-update">intended
      successor</xref>.</t>

      <!--BoB: Only the remaining sub-sections of section 5 contain any text in addition to
rtp-topologies-update. Does that mean that those are the only ones that has any specific
usage considerations, or is it rather that it is unclear what "issues" should be described
in this draft? Seriously consider to focus on recommendations, specific to topologies.
Another option would be to just guide and recommend, without using per-topology division.
-->

      <section title="Point to Point">
        <t>Even the most basic use case, denoted Topo-Point-to-Point in <xref
        target="I-D.westerlund-avtcore-rtp-topologies-update"/>, raises a
        number of considerations that are discussed in detail <xref
        target="sec-discussion">below</xref>. They range over such aspects
        as:<list style="symbols">
            <t>Does my communication peer support RTP as defined with multiple
            SSRCs?</t>

            <t>Do I need network differentiation in form of QoS?</t>

            <t>Can the application more easily process and handle the media
            streams if they are in different RTP sessions?</t>

            <t>Do I need to use additional media streams for RTP
            retransmission or FEC.</t>

            <t>etc.</t>
          </list></t>

        <t>The application designer will have to make choices here. The point
        to point topology can contain one to many RTP sessions with one to
        many media sources per session, resulting in one or more RTP source
        (SSRC) per media source. </t>
      </section>

      <section title="Translators &amp; Gateways">
        <t>A point to point communication can end up in a situation when the
        peer it is communicating with is not compatible with the other peer
        for various reasons:<list style="symbols">
            <t>No common media codec for a media type thus requiring
            transcoding</t>

            <t>Different support for multiple RTP sources and RTP sessions</t>

            <t>Usage of different media transport protocols, i.e RTP or
            other.</t>

            <t>Usage of different transport protocols, e.g. UDP, DCCP, TCP</t>

            <t>Different security solutions, e.g. IPsec, TLS, DTLS, SRTP with
            different keying mechanisms.</t>
          </list></t>

        <t>This is in many situations resolved by the inclusion of a
        translator in-between the two peers, as described by
        Topo-PtP-Translator in <xref
        target="I-D.westerlund-avtcore-rtp-topologies-update"/>. The
        translator's main purpose is to make the peer look to the other peer
        like something it is compatible with. There may also be other reasons
        than compatibility to insert a translator in the form of a middlebox
        or gateway, for example a need to monitor the media streams. If the
        stream transport characteristics are changed by the translator,
        appropriate media handling can require thorough understanding of the
        application logic, specifically any congestion control or media
        adaptation.</t>
      </section>

      <section title="Point to Multipoint Using Multicast">
        <t>This section discusses the Point to Multi-point using Multicast to
        interconnect the session participants. This includes both Topo-ASM and
        Topo-SSM in <xref
        target="I-D.westerlund-avtcore-rtp-topologies-update"/>.</t>

        <t>Special considerations must be made as multicast is a one to many
        distribution system. For example, the only practical method for
        adapting the bit-rate sent towards a given receiver for large groups
        is to use a set of multicast groups, where each multicast group
        represents a particular bit-rate. Otherwise the whole group gets media
        adapted to the participant with the worst conditions. The media
        encoding is either scalable, where multiple layers can be combined, or
        simulcast where a single version is selected. By either selecting or
        combing multicast groups, the receiver can control the bit-rate sent
        on the path to itself. It is also common that streams that improve
        transport robustness are sent in their own multicast group to allow
        for interworking with legacy or to support different levels of
        protection.</t>

        <t>The result of this is some common behaviours for RTP
        multicast:<list style="numbers">
            <t>Multicast applications use a group of RTP sessions, not one.
            Each endpoint will need to be a member of a number of RTP sessions
            in order to perform well.</t>

            <t>Within each RTP session, the number of media sinks is likely to
            be much larger than the number of RTP sources.</t>

            <t>Multicast applications need signalling functions to identify
            the relationships between RTP sessions.</t>

            <t>Multicast applications need signalling functions to identify
            the relationships between SSRCs in different RTP sessions.</t>
          </list></t>

        <t>All multicast configurations share a signalling requirement; all of
        the participants will need to have the same RTP and payload type
        configuration. Otherwise, A could for example be using payload type 97
        as the video codec H.264 while B thinks it is MPEG-2. It should be
        noted that <xref target="RFC3264">SDP offer/answer</xref> has issues
        with ensuring this property. The signalling aspects of multicast are
        not explored further in this memo.</t>

        <t>Security solutions for this type of group communications are also
        challenging. First of all the key-management and the security protocol
        must support group communication. Source authentication becomes more
        difficult and requires special solutions. For more discussion on this
        please review <xref
        target="I-D.ietf-avtcore-rtp-security-options">Options for Securing
        RTP Sessions</xref>.</t>
      </section>

      <section anchor="sec-translator"
               title="Point to Multipoint Using an RTP Transport Translator">
        <t>This mode is described as Topo-Translator in <xref
        target="I-D.westerlund-avtcore-rtp-topologies-update"/>.</t>

        <t>Transport Translators (Relays) result in an RTP session situation
        that is very similar to how an ASM group RTP session would behave.</t>

        <t>One of the most important aspects with the simple relay is that it
        is only rewriting transport headers, no RTP modifications nor media
        transcoding occur. The most obvious downside of this basic relaying is
        that the translator has no control over how many streams need to be
        delivered to a receiver. Nor can it simply select to deliver only
        certain streams, as this creates session inconsistencies: If the
        translator temporarily stops a stream, this prevents some receivers
        from reporting on it. From the sender's perspective it will look like
        a transport failure. Applications having needs to stop or switch
        streams in the central node should consider using an RTP mixer to
        avoid this issue.</t>

        <t>The Transport Translator has the same signalling requirement as
        multicast: All participants must have the same payload type
        configuration. Most of the ASM security issues also arise here. Some
        alternative when it comes to solution do exist as there after all
        exist a central node to communicate with. One that also can enforce
        some security policies depending on the level of trust placed in the
        node.</t>
      </section>

      <section anchor="sec-mixer"
               title="Point to Multipoint Using an RTP Mixer">
        <t>A mixer, described by Topo-Mixer in <xref
        target="I-D.westerlund-avtcore-rtp-topologies-update"/>, is a
        centralised node that selects or mixes content in a conference to
        optimise the RTP session so that each endpoint only needs connect to
        one entity, the mixer. The media sent from the mixer to the end-point
        can be optimised in different ways. These optimisations include
        methods like only choosing media from the currently most active
        speaker or mixing together audio so that only one audio stream is
        required.</t>

        <t>Mixers have some downsides, the first is that the mixer must be a
        trusted node as they either perform media operations or at least
        repacketize the media. When using SRTP, both media operations and
        repacketization requires that the mixer verifies integrity, decrypts
        the content, performs the operation and forms new RTP packets,
        encrypts and integrity-protects them. This applies to all types of
        mixers. The second downside is that all these operations and
        optimisations of the session requires processing. How much depends on
        the implementation, as will become evident below.</t>

        <t>A mixer, unlike a pure transport translator, is always application
        specific: the application logic for stream mixing or stream selection
        has to be embedded within the mixer, and controlled using application
        specific signalling. The implementation of a mixer can take several
        different forms and we will discuss the main themes available that
        doesn't break RTP.</t>

        <t>Please note that a Mixer could also contain translator
        functionalities, like a media transcoder to adjust the media bit-rate
        or codec used for a particular RTP media stream.</t>
      </section>
    </section>

    <section anchor="sec-discussion" title="Multiple Streams Discussion">
      <section title="Introduction">
        <t>Using multiple media streams is a well supported feature of RTP.
        However, it can be unclear for most implementers or people writing
        RTP/RTCP applications or extensions attempting to apply multiple
        streams when it is most appropriate to add an additional SSRC in an
        existing RTP session and when it is better to use multiple RTP
        sessions. This section tries to discuss the various considerations
        needed. The next section then concludes with some guidelines.</t>
      </section>

      <section title="RTP/RTCP Aspects">
        <t>This section discusses RTP and RTCP aspects worth considering when
        selecting between using an additional SSRC and Multiple RTP
        sessions.</t>

        <section anchor="sec-rtp-spec" title="The RTP Specification">
          <t>RFC 3550 contains some recommendations and a bullet list with 5
          arguments for different aspects of RTP multiplexing. Let's review
          Section 5.2 of <xref target="RFC3550"/>, reproduced below:</t>

          <t>"For efficient protocol processing, the number of multiplexing
          points should be minimised, as described in the <xref
          target="ALF">integrated layer processing design principle</xref>. In
          RTP, multiplexing is provided by the destination transport address
          (network address and port number) which is different for each RTP
          session. For example, in a teleconference composed of audio and
          video media encoded separately, each medium SHOULD be carried in a
          separate RTP session with its own destination transport address.</t>

          <t>Separate audio and video streams SHOULD NOT be carried in a
          single RTP session and demultiplexed based on the payload type or
          SSRC fields. Interleaving packets with different RTP media types but
          using the same SSRC would introduce several problems: <list
              style="numbers">
              <t>If, say, two audio streams shared the same RTP session and
              the same SSRC value, and one were to change encodings and thus
              acquire a different RTP payload type, there would be no general
              way of identifying which stream had changed encodings.</t>

              <t>An SSRC is defined to identify a single timing and sequence
              number space. Interleaving multiple payload types would require
              different timing spaces if the media clock rates differ and
              would require different sequence number spaces to tell which
              payload type suffered packet loss.</t>

              <t>The RTCP sender and receiver reports (see Section 6.4) can
              only describe one timing and sequence number space per SSRC and
              do not carry a payload type field.</t>

              <t>An RTP mixer would not be able to combine interleaved streams
              of incompatible media into one stream.</t>

              <t>Carrying multiple media in one RTP session precludes: the use
              of different network paths or network resource allocations if
              appropriate; reception of a subset of the media if desired, for
              example just audio if video would exceed the available
              bandwidth; and receiver implementations that use separate
              processes for the different media, whereas using separate RTP
              sessions permits either single- or multiple-process
              implementations.</t>
            </list></t>

          <t>Using a different SSRC for each medium but sending them in the
          same RTP session would avoid the first three problems but not the
          last two.</t>

          <t>On the other hand, multiplexing multiple related sources of the
          same medium in one RTP session using different SSRC values is the
          norm for multicast sessions. The problems listed above don't apply:
          an RTP mixer can combine multiple audio sources, for example, and
          the same treatment is applicable for all of them. It may also be
          appropriate to multiplex streams of the same medium using different
          SSRC values in other scenarios where the last two problems do not
          apply."</t>

          <t>Let's consider one argument at a time. The first is an argument
          for using different SSRC for each individual media stream, which is
          very applicable.</t>

          <t>The second argument is advocating against using payload type
          multiplexing, which still stands as can been seen by the extensive
          list of issues found in <xref target="sec-pt-mux"/>.</t>

          <t>The third argument is yet another argument against payload type
          multiplexing.</t>

          <t>The fourth is an argument against multiplexing media streams that
          require different handling into the same session. As we saw in the
          discussion of RTP mixers, the RTP mixer has to embed application
          logic in order to handle streams anyway; the separation of streams
          according to stream type is just another piece of application logic,
          which may or may not be appropriate for a particular application. A
          type of application that can mix different media sources "blindly"
          is the audio only "telephone" bridge; most other type of application
          needs application-specific logic to perform the mix correctly.</t>

          <t>The fifth argument discusses network aspects that we will discuss
          more below in <xref target="sec-network-aspects"/>. It also goes
          into aspects of implementation, like decomposed endpoints where
          different processes or inter-connected devices handle different
          aspects of the whole multi-media session.</t>

          <t>A summary of RFC 3550's view on multiplexing is to use unique
          SSRCs for anything that is its own media/packet stream, and to use
          different RTP sessions for media streams that don't share media
          type. The first this document support as very valid. The later is
          one thing which is further discussed in this document as something
          the application developer needs to make a conscious choice for.</t>

          <section anchor="sec-multi-media-rec"
                   title="Different Media Types Recommendations">
            <t>The above quote from <xref target="RFC3550">RTP</xref> includes
            a strong recommendation:<list style="empty">
                <t>"For example, in a teleconference composed of audio and
                video media encoded separately, each medium SHOULD be carried
                in a separate RTP session with its own destination transport
                address."</t>
              </list></t>

            <t>It was identified in <xref
            target="I-D.alvestrand-rtp-sess-neutral">"Why RTP Sessions Should
            Be Content Neutral"</xref> that the above statement is poorly
            supported by any of the motivations provided in the RTP
            specification. This has resulted in the creation of a
            specification <xref
            target="I-D.ietf-avtcore-multi-media-rtp-session">Multiple Media
            Types in an RTP Session specification</xref> which intend to
            update this recommendation. That document has a detailed analysis
            of the potential issues in having multiple media types in the same
            RTP session. This document tries to provide an more over arching
            consideration regarding the usage of RTP session and considers
            multiple media types in one RTP session as possible choice for the
            RTP application designer.</t>
          </section>
        </section>

        <section anchor="sec-self-reporting"
                 title="Multiple SSRCs in a Session">
          <t>Using multiple SSRCs in an RTP session at one endpoint has some
          unclarities in the RTP specification. These could potentially lead
          to some interoperability issues as well as some potential
          significant inefficencies. These are further discussed in <xref
          target="I-D.lennox-avtcore-rtp-multi-stream">"RTP Considerations for
          Endpoints Sending Multiple Media Streams"</xref>. A application
          designer may need to consider these issues and the impact
          availability or lack of the optimization in the endpoints has on
          their application.</t>

          <t>If an application will become affected by the issues described,
          using Multiple RTP sessions can mitigate these issues.</t>
        </section>

        <section title="Handling Varying Sets of Senders">
          <t>In some applications, the set of simultaneously active sources
          varies within a larger set of session members. A receiver can then
          possibly try to use a set of decoding chains that is smaller than
          the number of senders, switching the decoding chains between
          different senders. As each media decoding chain may contain state,
          either the receiver must either be able to save the state of
          swapped-out senders, or the sender must be able to send data that
          permits the receiver to reinitialise when it resumes activity.</t>

          <t>This behaviour will cause similar issues independent of
          Additional SSRC or Multiple RTP session.</t>
        </section>

        <section title="Cross Session RTCP Requests">
          <t>There currently exists no functionality to make truly
          synchronised and atomic RTCP messages with some type of request
          semantics across multiple RTP Sessions. Instead, separate RTCP
          messages will have to be sent in each session. This gives streams in
          the same RTP session a slight advantage as RTCP messages for
          different streams in the same session can be sent in a compound RTCP
          packet. Thus providing an atomic operation if different
          modifications of different streams are requested at the same
          time.</t>

          <t>When using multiple RTP sessions, the RTCP timing rules in the
          sessions and the transport aspects, such as packet loss and jitter,
          prevents a receiver from relying on atomic operations, forcing it to
          use more robust and forgiving mechanisms.</t>
        </section>

        <section anchor="sec-binding-related" title="Binding Related Sources">
          <t>A common problem in a number of various RTP extensions has been
          how to bind related RTP sources and their media streams together.
          This issue is common to both using additional SSRCs and Multiple RTP
          sessions.</t>

          <t>The solutions can be divided into some groups, RTP/RTCP based,
          Signalling based (SDP), grouping related RTP sessions, and grouping
          SSRCs within an RTP session. Most solutions are explicit, but some
          implicit methods have also been applied to the problem.</t>

          <t>The SDP-based signalling solutions are:<list style="hanging">
              <t hangText="SDP Media Description Grouping:">The <xref
              target="RFC5888">SDP Grouping Framework</xref> uses various
              semantics to group any number of media descriptions. These has
              previously been considered primarily as grouping RTP sessions,
              but this may change.</t>

              <t hangText="SDP SSRC grouping:"><xref
              target="RFC5576">Source-Specific Media Attributes in SDP</xref>
              includes a solution for grouping SSRCs the same way as the
              Grouping framework groupes Media Descriptions.</t>
            </list></t>

          <t>This supports a lot of use cases. Both solutions have
          shortcomings in cases where the session's dynamic properties are
          such that it is difficult or resource consuming to keep the list of
          related SSRCs up to date. As they are two related but still
          separated solutions it is not well specified to group SSRCs across
          multiple RTP sessions and SDP media descriptions.</t>

          <t>Within RTP/RTCP based solutions when binding to a endpoint or
          synchronization context, i.e. the CNAME has not be sufficient and
          one has multiple RTP sessions has been to using the same SSRC value
          across all the RTP sessions. <xref target="RFC4588">RTP
          Retransmission</xref> is multiple RTP session mode, <xref
          target="RFC5109">Generic FEC</xref>, as well as the <xref
          target="RFC6190">RTP payload format for Scalable Video Coding</xref>
          in Multi Session Transmission (MST) mode uses this method. This
          method clearly works but might have some downside in RTP sessions
          with many participating SSRCs. The birthday paradox ensures that if
          you populate a single session with 9292 SSRCs at random, the chances
          are approximately 1% that at least one collision will occur. When a
          collision occur this will force one to change SSRC in all RTP
          sessions and thus resynchronizing all of them instead of only the
          single media stream having the collision.</t>

          <t>It can be noted that Section 8.3 of the <xref
          target="RFC3550">RTP Specification</xref> recommends using a single
          SSRC space across all RTP sessions for layered coding.</t>

          <t>Another solution that has been applied to binding SSRCs have been
          an implicit method used by <xref target="RFC4588">RTP
          Retransmission</xref> when doing retransmissions in the same RTP
          session as the source RTP media stream. This issues an RTP
          retransmission request, and then await a new SSRC carrying the RTP
          retransmission payload and where that SSRC is from the same CNAME.
          This limits a requestor to having only one outstanding request on
          any new source SSRCs per endpoint.</t>

          <t>There exist no RTP/RTCP based mechanism capable of supporting
          explicit association accross multiple RTP sessions as well within an
          RTP session. A proposed solution for handling this issue is <xref
          target="I-D.westerlund-avtext-rtcp-sdes-srcname"/>. This can
          potentially be part of an SDP based solution also by reusing the
          same identifiers and name space. </t>

          <!---->
        </section>

        <section title="Forward Error Correction">
          <t>There exist a number of Forward Error Correction (FEC) based
          schemes for how to reduce the packet loss of the original streams.
          Most of the FEC schemes will protect a single source flow. The
          protection is achieved by transmitting a certain amount of redundant
          information that is encoded such that it can repair one or more
          packet loss over the set of packets they protect. This sequence of
          redundant information also needs to be transmitted as its own media
          stream, or in some cases instead of the original media stream. Thus
          many of these schemes create a need for binding the related flows as
          discussed above. They also create additional flows that need to be
          transported. Looking at the history of these schemes, there is both
          schemes using multiple SSRCs and multiple RTP sessions, and some
          schemes that support both modes of operation.</t>

          <t>Using multiple RTP sessions supports the case where some set of
          receivers may not be able to utilise the FEC information. By placing
          it in a separate RTP session, it can easily be ignored.</t>

          <t>In usages involving multicast, having the FEC information on its
          own multicast group, and therefore in its own RTP session, allows
          for flexibility, for example when using <xref target="RFC6285">Rapid
          Acquisition of Multicast Groups (RAMS)</xref>. During the RAMS burst
          where data is received over unicast and where it is possible to
          combine with unicast based <xref
          target="RFC4588">retransmission</xref>, there is no need to burst
          the FEC data related to the burst of the source media streams needed
          to catch up with the multicast group. This saves bandwidth to the
          receiver during the burst, enabling quicker catch up. When the
          receiver has caught up and joins the multicast group(s) for the
          source, it can at the same time join the multicast group with the
          FEC information. Having the source stream and the FEC in separate
          groups allows for easy separation in the Burst/Retransmission Source
          (BRS) without having to individually classify packets.</t>
        </section>

        <section title="Transport Translator Sessions">
          <t>A basic Transport Translator relays any incoming RTP and RTCP
          packets to the other participants. The main difference between
          Additional SSRCs and Multiple RTP Sessions resulting from this use
          case is that with Additional SSRCs it is not possible for a
          particular session participant to decide to receive a subset of
          media streams. When using separate RTP sessions for the different
          sets of media streams, a single participant can choose to leave one
          of the sessions but not the other.</t>
        </section>
      </section>

      <section title="Interworking">
        <t>There are several different kinds of interworking, and this section
        discusses two related ones. The interworking between different
        applications and the implications of potentially different choices of
        usage of RTP's multiplexing points. The second topic relates to what
        limitations may have to be considered working with some legacy
        applications.</t>

        <section title="Types of Interworking">
          <t>It is not uncommon that applications or services of similar
          usage, especially the ones intended for interactive communication,
          ends up in a situation where one want to interconnect two or more of
          these applications.</t>

          <t>In these cases one ends up in a situation where one might use a
          gateway to interconnect applications. This gateway then needs to
          change the multiplexing structure or adhere to limitations in each
          application.</t>

          <t>There are two fundamental approaches to gatewaying: RTP bridging,
          where the gateway acts as an RTP Translator, and the two
          applications are members of the same RTP session, and RTP
          termination, where there are independent RTP sessions running from
          each interconnected application to the gateway.</t>
        </section>

        <section title="RTP Translator Interworking">
          <t>From an RTP perspective the RTP Translator approach could work if
          all the applications are using the same codecs with the same payload
          types, have made the same multiplexing choices, have the same
          capabilities in number of simultaneous media streams combined with
          the same set of RTP/RTCP extensions being supported. Unfortunately
          this may not always be true.</t>

          <t>When one is gatewaying via an RTP Translator, a natural
          requirement is that the two applications being interconnected must
          use the same approach to multiplexing. Furthermore, if one of the
          applications is capable of working in several modes (such as being
          able to use Additional SSRCs or Multiple RTP sessions at will), and
          the other one is not, successful interconnection depends on locking
          the more flexible application into the operating mode where
          interconnection can be successful, even if no participants using the
          less flexible application are present when the RTP sessions are
          being created.</t>
        </section>

        <section title="Gateway Interworking">
          <t>When one terminates RTP sessions at the gateway, there are
          certain tasks that the gateway must carry out:</t>

          <t><list style="symbols">
              <t>Generating appropriate RTCP reports for all media streams
              (possibly based on incoming RTCP reports), originating from
              SSRCs controlled by the gateway.</t>

              <t>Handling SSRC collision resolution in each application's RTP
              sessions.</t>

              <t>Signalling, choosing and policing appropriate bit-rates for
              each session.</t>
            </list>If either of the applications has any security applied,
          e.g. in the form of SRTP, the gateway must be able to decrypt
          incoming packets and re-encrypt them in the other application's
          security context. This is necessary even if all that's required is a
          simple remapping of SSRC numbers. If this is done, the gateway also
          needs to be a member of the security contexts of both sides, of
          course.</t>

          <t>Other tasks a gateway may need to apply include transcoding (for
          incompatible codec types), rescaling (for incompatible video size
          requirements), suppression of content that is known not to be
          handled in the destination application, or the addition or removal
          of redundancy coding or scalability layers to fit the need of the
          destination domain.</t>

          <t>From the above, we can see that the gateway needs to have an
          intimate knowledge of the application requirements; a gateway is by
          its nature application specific, not a commodity product.</t>

          <t>This fact reveals the potential for these gateways to block
          evolution of the applications by blocking unknown RTP and RTCP
          extensions that the regular application has been extended with.</t>

          <t>If one uses security functions, like SRTP, they can as seen above
          incur both additional risk due to the gateway needing to be in
          security association between the endpoints, unless the gateway is on
          the transport level, and additional complexities in form of the
          decrypt-encrypt cycles needed for each forwarded packet. SRTP, due
          to its keying structure, also requires that each RTP session must
          have different master keys, as use of the same key in two RTP
          sessions can result in two-time pads that completely breaks the
          confidentiality of the packets.</t>
        </section>

        <section title="Multiple SSRC Legacy Considerations">
          <t>Historically, the most common RTP use cases have been point to
          point Voice over IP (VoIP) or streaming applications, commonly with
          no more than one media source per endpoint and media type (typically
          audio and video). Even in conferencing applications, especially
          voice only, the conference focus or bridge has provided a single
          stream with a mix of the other participants to each participant. It
          is also common to have individual RTP sessions between each endpoint
          and the RTP mixer, meaning that the mixer functions as an
          RTP-terminating gateway.</t>

          <t>When establishing RTP sessions that may contain endpoints that
          aren't updated to handle multiple streams following these
          recommendations, a particular application can have issues with
          multiple SSRCs within a single session. These issues include:</t>

          <t><list style="numbers">
              <t>Need to handle more than one stream simultaneously rather
              than replacing an already existing stream with a new one.</t>

              <t>Be capable of decoding multiple streams simultaneously.</t>

              <t>Be capable of rendering multiple streams simultaneously.</t>
            </list></t>

          <t>This indicates that gateways attempting to interconnect to this
          class of devices must make sure that only one media stream of each
          type gets delivered to the endpoint if it's expecting only one, and
          that the multiplexing format is what the device expects. It is
          highly unlikely that RTP translator-based interworking can be made
          to function successfully in such a context.</t>
        </section>
      </section>

      <section anchor="sec-network-aspects" title="Network Aspects">
        <t>The multiplexing choice has impact on network level mechanisms that
        need to be considered by the implementor.</t>

        <section title="Quality of Service">
          <t>When it comes to Quality of Service mechanisms, they are either
          flow based or marking based. <xref target="RFC2205">RSVP</xref> is
          an example of a flow based mechanism, while <xref
          target="RFC2474">Diff-Serv</xref> is an example of a Marking based
          one. For a marking based scheme, the method of multiplexing will not
          affect the possibility to use QoS.</t>

          <t>However, for a flow based scheme there is a clear difference
          between the methods. Additional SSRC will result in all media
          streams being part of the same 5-tuple (protocol, source address,
          destination address, source port, destination port) which is the
          most common selector for flow based QoS. Thus, separation of the
          level of QoS between media streams is not possible. That is however
          possible when using multiple RTP sessions, where each media stream
          for which a separate QoS handling is desired can be in a different
          RTP session that can be sent over different 5-tuples.</t>
        </section>

        <section title="NAT and Firewall Traversal">
          <t>In today's network there exist a large number of middleboxes. The
          ones that normally have most impact on RTP are Network Address
          Translators (NAT) and Firewalls (FW).</t>

          <t>Below we analyze and comment on the impact of requiring more
          underlying transport flows in the presence of NATs and
          Firewalls:</t>

          <t><list style="hanging">
              <t hangText="End-Point Port Consumption:">A given IP address
              only has 65536 available local ports per transport protocol for
              all consumers of ports that exist on the machine. This is
              normally never an issue for an end-user machine. It can become
              an issue for servers that handle large number of simultaneous
              streams. However, if the application uses ICE to authenticate
              STUN requests, a server can serve multiple endpoints from the
              same local port, and use the whole 5-tuple (source and
              destination address, source and destination port, protocol) as
              identifier of flows after having securely bound them to the
              remote endpoint address using the STUN request. In theory the
              minimum number of media server ports needed are the maximum
              number of simultaneous RTP Sessions a single endpoint may use.
              In practice, implementation will probably benefit from using
              more server ports to simplify implementation or avoid
              performance bottlenecks.</t>

              <t hangText="NAT State:">If an endpoint sits behind a NAT, each
              flow it generates to an external address will result in a state
              that has to be kept in the NAT. That state is a limited
              resource. In home or Small Office/Home Office (SOHO) NATs,
              memory or processing are usually the most limited resources. For
              large scale NATs serving many internal endpoints, available
              external ports are likely the scarce resource. Port limitations
              is primarily a problem for larger centralised NATs where
              endpoint independent mapping requires each flow to use one port
              for the external IP address. This affects the maximum number of
              internal users per external IP address. However, it is worth
              pointing out that a real-time video conference session with
              audio and video is likely using less than 10 UDP flows, compared
              to certain web applications that can use 100+ TCP flows to
              various servers from a single browser instance.</t>

              <t hangText="NAT Traversal Excess Time:">Making the NAT/FW
              traversal takes a certain amount of time for each flow. It also
              takes time in a phase of communication between accepting to
              communicate and the media path being established which is fairly
              critical. The best case scenario for how much extra time it
              takes after finding the first valid candidate pair following the
              specified ICE procedures are: 1.5*RTT + Ta*(Additional_Flows-1),
              where Ta is the pacing timer, which ICE specifies to be no
              smaller than 20 ms. That assumes a message in one direction, and
              then an immediate triggered check back. The reason it isn't
              more, is that ICE first finds one candidate pair that works
              prior to attempting to establish multiple flows. Thus, there is
              no extra time until one has found a working candidate pair.
              Based on that working pair the needed extra time is to in
              parallel establish the, in most cases 2-3, additional flows.
              However, packet loss causes extra delays, at least 100 ms, which
              is the minimal retransmission timer for ICE.</t>

              <t hangText="NAT Traversal Failure Rate:">Due to the need to
              establish more than a single flow through the NAT, there is some
              risk that establishing the first flow succeeds but that one or
              more of the additional flows fail. The risk that this happens is
              hard to quantify, but it should be fairly low as one flow from
              the same interfaces has just been successfully established. Thus
              only rare events such as NAT resource overload, or selecting
              particular port numbers that are filtered etc, should be reasons
              for failure.</t>

              <t
              hangText="Deep Packet Inspection and Multiple Streams:">Firewalls
              differ in how deeply they inspect packets. There exist some
              potential that deeply inspecting firewalls will have similar
              legacy issues with multiple SSRCs as some stack
              implementations.</t>
            </list></t>

          <t>Additional SSRC keeps the additional media streams within one RTP
          Session and transport flow and does not introduce any additional NAT
          traversal complexities per media stream. This can be compared with
          normally one or two additional transport flows per RTP session when
          using multiple RTP sessions. Additional lower layer transport flows
          will be required, unless an explicit de-multiplexing layer is added
          between RTP and the transport protocol. A proposal for how to
          multiplex multiple RTP sessions over the same single lower layer
          transport exist in <xref
          target="I-D.westerlund-avtcore-transport-multiplexing"/>.</t>
        </section>

        <section title="Multicast">
          <t>Multicast groups provides a powerful semantics for a number of
          real-time applications, especially the ones that desire
          broadcast-like behaviours with one endpoint transmitting to a large
          number of receivers, like in IPTV. But that same semantics do result
          in a certain number of limitations.</t>

          <t>One limitation is that for any group, sender side adaptation to
          the actual receiver properties causes degradation for all
          participants to what is supported by the receiver with the worst
          conditions among the group participants. In most cases this is not
          acceptable. Instead various receiver based solutions are employed to
          ensure that the receivers achieve best possible performance. By
          using scalable encoding and placing each scalability layer in a
          different multicast group, the receiver can control the amount of
          traffic it receives. To have each scalability layer on a different
          multicast group, one RTP session per multicast group is used.</t>

          <t>RTP can't function correctly if media streams sent over different
          multicast groups where considered part of the same RTP session.
          First of all the different layers needs different SSRCs or the
          sequence number space seen for a receiver of any sub set of the
          layers would have sender side holes. Thus triggering packet loss
          reactions. Also any RTCP reporting of such a session would be non
          consistent and making it difficult for the sender to determine the
          sessions actual state.</t>

          <t>Thus it appears easiest and most straightforward to use multiple
          RTP sessions. In addition, the transport flow considerations in
          multicast are a bit different from unicast. First of all there is no
          shortage of port space, as each multicast group has its own port
          space.</t>
        </section>

        <section title="Multiplexing multiple RTP Session on a Single Transport">
          <t>For applications that doesn't need flow based QoS and like to
          save ports and NAT/FW traversal costs and where usage of multiple
          media types in one RTP session is not suitable, there is a proposal
          for how to achieve <xref
          target="I-D.westerlund-avtcore-transport-multiplexing">multiplexing
          of multiple RTP sessions over the same lower layer transport</xref>.
          Using such a solution would allow Multiple RTP session without most
          of the perceived downsides of Multiple RTP sessions creating a need
          for additional transport flows.</t>
        </section>
      </section>

      <section anchor="sec-security-aspects" title="Security Aspects">
        <t>When dealing with point-to-point, 2-member RTP sessions only, there
        are few security issues that are relevant to the choice of having one
        RTP session or multiple RTP sessions. However, there are a few aspects
        of multiparty sessions that might warrant consideration. For general
        information of possible methods of securing RTP, please review <xref
        target="I-D.ietf-avtcore-rtp-security-options">RTP Security
        Options</xref>.</t>

        <section title="Security Context Scope">
          <t>When using <xref target="RFC3711">SRTP</xref> the security
          context scope is important and can be a necessary differentiation in
          some applications. As SRTP's crypto suites (so far) is built around
          symmetric keys, the receiver will need to have the same key as the
          sender. This results in that no one in a multi-party session can be
          certain that a received packet really was sent by the claimed sender
          or by another party having access to the key. In most cases this is
          a sufficient security property, but there are a few cases where this
          does create situations.</t>

          <t>The first case is when someone leaves a multi-party session and
          one wants to ensure that the party that left can no longer access
          the media streams. This requires that everyone re-keys without
          disclosing the keys to the excluded party.</t>

          <t>A second case is when using security as an enforcing mechanism
          for differentiation. Take for example a scalable layer or a high
          quality simulcast version which only premium users are allowed to
          access. The mechanism preventing a receiver from getting the high
          quality stream can be based on the stream being encrypted with a key
          that user can't access without paying premium, having the
          key-management limit access to the key.</t>

          <t><xref target="RFC3711">SRTP</xref> has not special functions for
          dealing with different sets of master keys for different SSRCs. The
          key-management functions has different capabilities to establish
          different set of keys, normally on a per end-point basis. <xref
          target="RFC5764">DTLS-SRTP</xref> and <xref
          target="RFC4568">Security Descriptions</xref> for example establish
          different keys for outgoing and incoming traffic from an end-point.
          This key usage must be written into the cryptographic context,
          possibly associated with different SSRCs.</t>
        </section>

        <section title="Key Management for Multi-party session">
          <t>Performing key-management for multi-party session can be a
          challenge. This section considers some of the issues.</t>

          <t>Multi-party sessions, such as transport translator based sessions
          and multicast sessions, cannot use <xref target="RFC4568">Security
          Description</xref> nor <xref target="RFC5764">DTLS-SRTP</xref>
          without an extension as each endpoint provides its set of keys. In
          centralised conference, the signalling counterpart is a conference
          server and the media plane unicast counterpart (to which DTLS
          messages would be sent) is the transport translator. Thus an
          extension like <xref target="I-D.ietf-avt-srtp-ekt">Encrypted Key
          Transport</xref> is needed or a <xref target="RFC3830">MIKEY</xref>
          based solution that allows for keying all session participants with
          the same master key.</t>
        </section>

        <section title="Complexity Implications">
          <t>The usage of security functions can surface complexity
          implications of the choice of multiplexing and topology. This
          becomes especially evident in RTP topologies having any type of
          middlebox that processes or modifies RTP/RTCP packets. Where there
          is very small overhead for an RTP translator or mixer to rewrite an
          SSRC value in the RTP packet of an unencrypted session, the cost of
          doing it when using cryptographic security functions is higher. For
          example if using <xref target="RFC3711">SRTP</xref>, the actual
          security context and exact crypto key are determined by the SSRC
          field value. If one changes it, the encryption and authentication
          tag must be performed using another key. Thus changing the SSRC
          value implies a decryption using the old SSRC and its security
          context followed by an encryption using the new one.</t>
        </section>
      </section>
    </section>

    <section title="Arch-Types">
      <t>This section discusses some arch-types of how RTP multiplexing can be
      used in applications to achieve certain goals and a summary of their
      implications. For each arch-type there is discussion of benefits and
      downsides.</t>

      <section title="Single SSRC per Session">
        <t>In this arch-type each endpoint in a point-to-point session has
        only a single SSRC, thus the RTP session contains only two SSRCs, one
        local and one remote. This session can be used both unidirectional,
        i.e. only a single media stream or bi-directional, i.e. both endpoints
        have one media stream each. If the application needs additional media
        flows between the endpoints, they will have to establish additional
        RTP sessions.</t>

        <t>The Pros:<list style="numbers">
            <t>This arch-type has great legacy interoperability potential as
            it will not tax any RTP stack implementations.</t>

            <t>The signalling has good possibilities to negotiate and describe
            the exact formats and bit-rates for each media stream, especially
            using today's tools in SDP.</t>

            <t>It does not matter if usage or purpose of the media stream is
            signalled on media stream level or session level as there is no
            difference.</t>

            <t>It is possible to control security association per RTP session
            with current key-management.</t>
          </list></t>

        <t>The Cons:<list style="letters">
            <t>The number of required RTP sessions grows directly in
            proportion with the number of media streams, which has the
            implications:<list style="symbols">
                <t>Linear growth of the amount of NAT/FW state with number of
                media streams.</t>

                <t>Increased delay and resource consumption from NAT/FW
                traversal.</t>

                <t>Likely larger signalling message and signalling processing
                requirement due to the amount of session related
                information.</t>

                <t>Higher potential for a single media stream to fail during
                transport between the endpoints.</t>
              </list></t>

            <t>When the number of RTP sessions grows, the amount of explicit
            state for relating media stream also grows, linearly or possibly
            exponentially, depending on how the application needs to relate
            media streams.</t>

            <t>The port consumption may become a problem for centralised
            services, where the central node's port consumption grows rapidly
            with the number of sessions.</t>

            <t>For applications where the media streams are highly dynamic in
            their usage, i.e. entering and leaving, the amount of signalling
            can grow high. Issues arising from the timely establishment of
            additional RTP sessions can also arise.</t>

            <t>Cross session RTCP requests needs is likely to exist and may
            cause issues.</t>

            <t>If the same SSRC value is reused in multiple RTP sessions
            rather than being randomly chosen, interworking with applications
            that uses another multiplexing structure than this application
            will have issues and require SSRC translation.</t>

            <t>Cannot be used with Any Source Multicast (ASM) as one cannot
            guarantee that only two endpoints participate as packet senders.
            Using SSM, it is possible to restrict to these requirements if no
            RTCP feedback is injected back into the SSM group.</t>

            <t>For most security mechanisms, each RTP session or transport
            flow requires individual key-management and security association
            establishment thus increasing the overhead.</t>
          </list></t>

        <t>RTP applications that need to inter-work with legacy RTP
        applications, like VoIP and video conferencing, can potentially
        benefit from this structure. However, a large number of media
        descriptions in SDP can also run into issues with existing
        implementations. For any application needing a larger number of media
        flows, the overhead can become very significant. This structure is
        also not suitable for multi-party sessions, as any given media stream
        from each participant, although having same usage in the application,
        must have its own RTP session. In addition, the dynamic behaviour that
        can arise in multi-party applications can tax the signalling system
        and make timely media establishment more difficult.</t>
      </section>

      <section anchor="sec-multiple-ssrc-single-session"
               title="Multiple SSRCs of the Same Media Type">
        <t>In this arch-type, each RTP session serves only a single media
        type. The RTP session can contain multiple media streams, either from
        a single endpoint or due to multiple endpoints. This commonly creates
        a low number of RTP sessions, typically only two one for audio and one
        for video with a corresponding need for two listening ports when using
        RTP and RTCP multiplexing.</t>

        <t>The Pros:<list style="numbers">
            <t>Low number of RTP sessions needed compared to single SSRC case.
            This implies:<list style="symbols">
                <t>Reduced NAT/FW state</t>

                <t>Lower NAT/FW Traversal Cost in both processing and
                delay.</t>
              </list></t>

            <t>Allows for early de-multiplexing in the processing chain in RTP
            applications where all media streams of the same type have the
            same usage in the application.</t>

            <t>Works well with media type de-composite endpoints.</t>

            <t>Enables Flow-based QoS with different prioritisation between
            media types.</t>

            <t>For applications with dynamic usage of media streams, i.e. they
            come and go frequently, having much of the state associated with
            the RTP session rather than an individual SSRC can avoid the need
            for in-session signalling of meta-information about each SSRC.</t>

            <t>Low overhead for security association establishment.</t>
          </list></t>

        <t>The Cons:<list style="letters">
            <t>May have some need for cross session RTCP requests for things
            that affect both media types in an asynchronous way.</t>

            <t>Some potential for concern with legacy implementations that
            does not support the RTP specification fully when it comes to
            handling multiple SSRC per endpoint.</t>

            <t>Will not be able to control security association for sets of
            media streams within the same media type with today's
            key-management mechanisms, only between SDP media
            descriptions.</t>
          </list></t>

        <t>For RTP applications where all media streams of the same media type
        share same usage, this structure provides efficiency gains in amount
        of network state used and provides more faith sharing with other media
        flows of the same type. At the same time, it is still maintaining
        almost all functionalities when it comes to negotiation in the
        signalling of the properties for the individual media type and also
        enabling flow based QoS prioritisation between media types. It handles
        multi-party session well, independently of multicast or centralised
        transport distribution, as additional sources can dynamically enter
        and leave the session.</t>
      </section>

      <section title="Multiple Sessions for one Media type">
        <t>In this arch-type one goes one step further than in the <xref
        target="sec-multiple-ssrc-single-session">above</xref> by using
        multiple RTP sessions also for a single media type. The main reason
        for going in this direction is that the RTP application needs
        separation of the media streams due to their usage. Some typical
        reasons for going to this arch-type are scalability over multicast,
        simulcast, need for extended QoS prioritisation of media streams due
        to their usage in the application, or the need for fine granular
        signalling using today's tools.</t>

        <t>The Pros:<list style="numbers">
            <t>More suitable for Multicast usage where receivers can
            individually select which RTP sessions they want to participate
            in, assuming each RTP session has its own multicast group.</t>

            <t>Detailed indication of the application's usage of the media
            stream, where multiple different usages exist.</t>

            <t>Less need for SSRC specific explicit signalling for each media
            stream and thus reduced need for explicit and timely
            signalling.</t>

            <t>Enables detailed QoS prioritisation for flow based
            mechanisms.</t>

            <t>Works well with de-composite endpoints.</t>

            <t>Handles dynamic usage of media streams well.</t>

            <t>For transport translator based multi-party sessions, this
            structure allows for improved control of which type of media
            streams an endpoint receives.</t>

            <t>The scope for who is included in a security association can be
            structured around the different RTP sessions, thus enabling such
            functionality with existing key-management.</t>
          </list></t>

        <t>The Cons:<list style="letters">
            <t>Increases the amount of RTP sessions compared to Multiple SSRCs
            of the Same Media Type.</t>

            <t>Increased amount of session configuration state.</t>

            <t>May need synchronised cross-session RTCP requests and require
            some consideration due to this.</t>

            <t>For media streams that are part of scalability, simulcast or
            transport robustness it will be needed to bind sources, which must
            support multiple RTP sessions.</t>

            <t>Some potential for concern with legacy implementations that
            does not support the RTP specification fully when it comes to
            handling multiple SSRC per endpoint.</t>

            <t>Higher overhead for security association establishment.</t>

            <t>If the applications need finer control than on media type level
            over which session participants that are included in different
            sets of security associations, most of today's key-management will
            have difficulties establishing such a session.</t>
          </list></t>

        <t>For more complex RTP applications that have several different
        usages for media streams of the same media type and / or uses
        scalability or simulcast, this solution can enable those functions at
        the cost of increased overhead associated with the additional
        sessions. This type of structure is suitable for more advanced
        applications as well as multicast based applications requiring
        differentiation to different participants.</t>
      </section>

      <section title="Multiple Media Types in one Session">
        <t>This arch-type is to use a single RTP session for multiple
        different media types, like audio and video, and possibly also
        transport robustness mechanisms like FEC or Retransmission. Each media
        stream will use its own SSRC and a given SSRC value from a particular
        endpoint will never use the SSRC for more than a single media
        type.</t>

        <t>The Pros:<list style="numbers">
            <t>Single RTP session which implies:<list style="symbols">
                <t>Minimal NAT/FW state.</t>

                <t>Minimal NAT/FW Traversal Cost.</t>

                <t>Fate-sharing for all media flows.</t>
              </list></t>

            <t>Enables separation of the different media types based on the
            payload types so media type specific endpoint or central
            processing can still be supported despite single session.</t>

            <t>Can handle dynamic allocations of media streams well on an RTP
            level. Depends on the application's needs for explicit indication
            of the stream usage and how timely that can be signalled.</t>

            <t>Minimal overhead for security association establishment.</t>
          </list></t>

        <t>The Cons:<list style="letters">
            <t>Less suitable for interworking with other applications that
            uses individual RTP sessions per media type or multiple sessions
            for a single media type, due to need of SSRC translation.</t>

            <t>Negotiation of bandwidth for the different media types is
            currently not possible in SDP. This requires SDP extensions to
            enable payload or source specific bandwidth. Likely to be a
            problem due to media type asymmetry in required bandwidth.</t>

            <t>Not suitable for de-composite end-points as it requires higher
            bandwidth and processing.</t>

            <t>Flow based QoS cannot provide separate treatment to some media
            streams compared to other in the single RTP session.</t>

            <t>If there is significant asymmetry between the media streams
            RTCP reporting needs, there are some challenges in configuration
            and usage to avoid wasting RTCP reporting on the media stream that
            does not need that frequent reporting.</t>

            <t>Not suitable for applications where some receivers like to
            receive only a subset of the media streams, especially if
            multicast or transport translator is being used.</t>

            <t>Additional concern with legacy implementations that does not
            support the RTP specification fully when it comes to handling
            multiple SSRC per endpoint, as also multiple simultaneous media
            types needs to be handled.</t>

            <t>If the applications need finer control over which session
            participants that are included in different sets of security
            associations, most key-management will have difficulties
            establishing such a session.</t>
          </list></t>

        <t/>

        <!--MW: Add new summary for this arch-type.
MW: One arch-type that we should consider adding is the one with multiple RTP sessions over
a single transport.-->
      </section>

      <section title="Summary">
        <t>There are some clear relations between these arch-types. Both the
        "single SSRC per RTP session" and the "multiple media types in one
        session" are cases which require full explicit signalling of the media
        stream relations. However, they operate on two different levels where
        the first primarily enables session level binding, and the second
        needs to do it all on SSRC level. From another perspective, the two
        solutions are the two extreme points when it comes to number of RTP
        sessions required.</t>

        <t>The two other arch-types "Multiple SSRCs of the Same Media Type"
        and "Multiple Sessions for one Media Type" are examples of two other
        cases that first of all allows for some implicit mapping of the role
        or usage of the media streams based on which RTP session they appear
        in. It thus potentially allows for less signalling and in particular
        reduced need for real-time signalling in dynamic sessions. They also
        represent points in between the first two when it comes to amount of
        RTP sessions established, i.e. representing an attempt to reduce the
        amount of sessions as much as possible without compromising the
        functionality the session provides both on network level and on
        signalling level.</t>
      </section>
    </section>

    <section title="Summary considerations and guidelines">
      <t/>

      <section title="Guidelines">
        <t>This section contains a number of recommendations for implementors
        or specification writers when it comes to handling multi-stream.<list
            style="hanging">
            <t hangText="Do not Require the same SSRC across Sessions:">As
            discussed in <xref target="sec-binding-related"/> there exist
            drawbacks in using the same SSRC in multiple RTP sessions as a
            mechanism to bind related media streams together. It is instead
            recommended that a mechanism to explicitly signal the relation is
            used, either in RTP/RTCP or in the used signalling mechanism that
            establishes the RTP session(s).</t>

            <t hangText="Use additional SSRCs additional Media Sources:">In
            the cases an RTP endpoint needs to transmit additional media
            streams of the same media type in the application, with the same
            processing requirements at the network and RTP layers, it is
            recommended to send them as additional SSRCs in the same RTP
            session. For example a telepresence room where there are three
            cameras, and each camera captures 2 persons sitting at the table,
            sending each camera as its own SSRC within a single RTP session is
            recommended.</t>

            <t
            hangText="Use additional RTP sessions for streams with different requirements:">When
            media streams have different processing requirements from the
            network or the RTP layer at the endpoints, it is recommended that
            the different types of streams are put in different RTP
            sessions.<vspace blankLines="0"/>This includes the case where
            different participants want different subsets of the set of RTP
            streams.</t>

            <t hangText="When using multiple RTP Sessions use grouping:">When
            using Multiple RTP session solutions, it is recommended to be
            explicitly group the involved RTP sessions when needed using the
            signalling mechanism, for example <xref target="RFC5888">The
            Session Description Protocol (SDP) Grouping Framework.</xref>,
            using some appropriate grouping semantics.</t>

            <t
            hangText="RTP/RTCP Extensions May Support Additional SSRCs as well as Multiple RTP sessions:">When
            defining an RTP or RTCP extension, the creator needs to consider
            if this extension is applicable to usage with additional SSRCs and
            Multiple RTP sessions. Any extension intended to be generic is
            recommended to support both. Applications that are not as
            generally applicable will have to consider if interoperability is
            better served by defining a single solution or providing both
            options.</t>

            <t hangText="Transport Support Extensions:">When defining new
            RTP/RTCP extensions intended for transport support, like the
            retransmission or FEC mechanisms, they are recommended to include
            support for both additional SSRCs and multiple RTP sessions so
            that application developers can choose freely from the set of
            mechanisms without concerning themselves with which of the
            multiplexing choices a particular solution supports.</t>
          </list></t>

        <t/>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document makes no request of IANA.</t>

      <t>Note to RFC Editor: this section may be removed on publication as an
      RFC.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>There is discussion of the security implications of choosing SSRC vs
      Multiple RTP session in <xref target="sec-security-aspects"/>.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &rfc3550;
    </references>

    <references title="Informative References">
      &rfc2198;

      &rfc2205;

      &rfc2326;

      &rfc2474;

      &rfc2974;

      &rfc3261;

      &rfc3264;

      &rfc3389;

      &rfc3551;

      &rfc3711;

      &rfc3830;

      &rfc4103;

      &rfc4566;

      &rfc4568;

      &rfc4588;

      &rfc4607;

      &rfc5104;

      &rfc5117;

      &rfc5583;

      &rfc5576;

      &rfc5760;

      &rfc5761;

      &rfc5764;

      &rfc5888;

      &rfc6190;

      &rfc6285;

      &rfc6465;

      &rfc6222;

      &draft-ietf-avtext-multiple-clock-rates;

      &draft-ietf-payload-rtp-howto;

      &draft-ietf-avt-srtp-ekt;

      <reference anchor="ALF">
        <front>
          <title>Architectural Considerations for a New Generation of
          Protocols</title>

          <author initials="D." surname="Clark">
            <organization>IEEE Computer Communications Review, Vol.
            20(4)</organization>
          </author>

          <author initials="D." surname="Tennenhouse">
            <organization/>

            <address>
              <postal>
                <street/>

                <city/>

                <region/>

                <code/>

                <country/>
              </postal>

              <phone/>

              <facsimile/>

              <email/>

              <uri/>
            </address>
          </author>

          <date month="September" year="1990"/>
        </front>

        <seriesInfo name="SIGCOMM Symposium on         Communications Architectures and Protocols"
                    value="(Philadelphia, Pennsylvania), pp. 200--208, IEEE Computer Communications Review, Vol. 20(4)"/>
      </reference>

      <?rfc include='reference.I-D.ietf-mmusic-sdp-bundle-negotiation'?>

      <?rfc include='reference.I-D.alvestrand-rtp-sess-neutral'?>

      <?rfc include='reference.I-D.lennox-mmusic-sdp-source-selection'?>

      <?rfc include='reference.I-D.westerlund-avtext-rtcp-sdes-srcname'?>

      <?rfc include='reference.I-D.westerlund-avtcore-max-ssrc'?>

      <?rfc include='reference.I-D.westerlund-avtcore-transport-multiplexing'?>

      <?rfc include='reference.I-D.ietf-avtcore-rtp-security-options'?>

      <?rfc include='reference.I-D.ietf-avtcore-multi-media-rtp-session'?>

      <?rfc include='reference.I-D.lennox-avtcore-rtp-multi-stream'?>

      <?rfc include='reference.I-D.westerlund-avtcore-rtp-topologies-update'?>

      <?rfc include='reference.I-D.ietf-avtcore-6222bis'?>

      <?rfc include='reference.RFC.5109'?>
    </references>

    <section anchor="sec-pt-mux" title="Dismissing Payload Type Multiplexing">
      <t>This section documents a number of reasons why using the payload type
      as a multiplexing point for most things related to multiple streams is
      unsuitable. If one attempts to use Payload type multiplexing beyond it's
      defined usage, that has well known negative effects on RTP. To use
      Payload type as the single discriminator for multiple streams implies
      that all the different media streams are being sent with the same SSRC,
      thus using the same timestamp and sequence number space. This has many
      effects:</t>

      <t><list style="numbers">
          <t>Putting restraint on RTP timestamp rate for the multiplexed
          media. For example, media streams that use different RTP timestamp
          rates cannot be combined, as the timestamp values need to be
          consistent across all multiplexed media frames. Thus streams are
          forced to use the same rate. When this is not possible, Payload Type
          multiplexing cannot be used.</t>

          <t>Many RTP payload formats may fragment a media object over
          multiple packets, like parts of a video frame. These payload formats
          need to determine the order of the fragments to correctly decode
          them. Thus it is important to ensure that all fragments related to a
          frame or a similar media object are transmitted in sequence and
          without interruptions within the object. This can relatively simple
          be solved on the sender side by ensuring that the fragments of each
          media stream are sent in sequence.</t>

          <t>Some media formats require uninterrupted sequence number space
          between media parts. These are media formats where any missing RTP
          sequence number will result in decoding failure or invoking of a
          repair mechanism within a single media context. The <xref
          target="RFC4103">text/T140 payload format</xref> is an example of
          such a format. These formats will need a sequence numbering
          abstraction function between RTP and the individual media stream
          before being used with Payload Type multiplexing.</t>

          <t>Sending multiple streams in the same sequence number space makes
          it impossible to determine which Payload Type and thus which stream
          a packet loss relates to.</t>

          <t>If <xref target="RFC4588">RTP Retransmission</xref> is used and
          there is a loss, it is possible to ask for the missing packet(s) by
          SSRC and sequence number, not by Payload Type. If only some of the
          Payload Type multiplexed streams are of interest, there is no way of
          telling which missing packet(s) belong to the interesting stream(s)
          and all lost packets must be requested, wasting bandwidth.</t>

          <t>The current RTCP feedback mechanisms are built around providing
          feedback on media streams based on stream ID (SSRC), packet
          (sequence numbers) and time interval (RTP Timestamps). There is
          almost never a field to indicate which Payload Type is reported, so
          sending feedback for a specific media stream is difficult without
          extending existing RTCP reporting.</t>

          <t>The current <xref target="RFC5104">RTCP media control
          messages</xref> specification is oriented around controlling
          particular media flows, i.e. requests are done addressing a
          particular SSRC. Such mechanisms would need to be redefined to
          support Payload Type multiplexing.</t>

          <t>The number of payload types are inherently limited. Accordingly,
          using Payload Type multiplexing limits the number of streams that
          can be multiplexed and does not scale. This limitation is
          exacerbated if one uses solutions like <xref target="RFC5761">RTP
          and RTCP multiplexing</xref> where a number of payload types are
          blocked due to the overlap between RTP and RTCP.</t>

          <t>At times, there is a need to group multiplexed streams and this
          is currently possible for RTP Sessions and for SSRC, but there is no
          defined way to group Payload Types.</t>

          <t>It is currently not possible to signal bandwidth requirements per
          media stream when using Payload Type Multiplexing.</t>

          <t>Most existing SDP media level attributes cannot be applied on a
          per Payload Type level and would require re-definition in that
          context.</t>

          <t>A legacy endpoint that doesn't understand the indication that
          different RTP payload types are different media streams may be
          slightly confused by the large amount of possibly overlapping or
          identically defined RTP Payload Types.</t>
        </list></t>
    </section>

    <section title="Proposals for Future Work">
      <t>The above discussion and guidelines indicates that a small set of
      extension mechanisms could greatly improve the situation when it comes
      to using multiple streams independently of Multiple RTP session or
      Additional SSRC. These extensions are:<list style="hanging">
          <t hangText="Media Source Identification:">A Media source
          identification that can be used to bind together media streams that
          are related to the same media source. A <xref
          target="I-D.westerlund-avtext-rtcp-sdes-srcname">proposal</xref>
          exist for a new SDES item SRCNAME that also can be used with the
          a=ssrc SDP attribute to provide signalling layer binding
          information.</t>

          <t hangText="SSRC limitations within RTP sessions:">By providing a
          signalling solution that allows the signalling peers to explicitly
          express both support and limitations on how many simultaneous media
          streams an endpoint can handle within a given RTP Session. That
          ensures that usage of Additional SSRC occurs when supported and
          without overloading an endpoint. This extension is proposed in <xref
          target="I-D.westerlund-avtcore-max-ssrc"/>.</t>
        </list></t>
    </section>

    <section anchor="sec-rtp-clarifications"
             title="RTP Specification Clarifications">
      <t>This section describes a number of clarifications to the RTP
      specifications that are likely necessary for aligned behaviour when RTP
      sessions contain more SSRCs than one local and one remote.</t>

      <t>All of the below proposals are under consideration in <xref
      target="I-D.lennox-avtcore-rtp-multi-stream"/>.</t>

      <section title="RTCP Reporting from all SSRCs">
        <t>When one has multiple SSRC in an RTP node, all these SSRC must send
        some RTP or RTCP packet as long as the SSRC exist. It is not
        sufficient that only one SSRC in the node sends report blocks on the
        incoming RTP streams; any SSRC that intends to remain in the session
        must send some packets to avoid timing out according to the rules in
        RFC 3550 section 6.3.5.</t>

        <t>It has been hypothesised that a third party monitor may be confused
        by not necessarily being able to determine that all these SSRC are in
        fact co-located and originate from the same stack instance; if this
        hypothesis is true, this may argue for having all the sources send
        full reception reports, even though they are reporting the same packet
        delivery.</t>

        <t>The contrary argument is that such double reporting may confuse the
        third party monitor even more by making it seem that utilisation of
        the last-hop link to the recipient is (number of SSRCs) times higher
        than what it actually is.</t>
      </section>

      <section title="RTCP Self-reporting">
        <t>For any RTP node that sends more than one SSRC, there is the
        question if SSRC1 needs to report its reception of SSRC2 and vice
        versa. The reason that they in fact need to report on all other local
        streams as being received is report consistency. The hypothetical
        third party monitor that considers the full matrix of media streams
        and all known SSRC reports on these media streams would detect a gap
        in the reports which could be a transport issue unless identified as
        in fact being sources from the same node.</t>

        <!--MW: Moved the proposal out of the text. I am not certain this is fly and 
don't have time to consider it well enough. 

Our proposal is that RFC3550 is updated to clarify that one needs to report 
on all SSRCs one knows exist with the sole exception of the local SSRCs 
that has the same CNAME as the SSRC providing the report. That way a third 
party monitor can use the CNAME data from the various SSRCs to determine 
that the gap in reporting is not valid.

Note: There is nothing preventing a node to send an SSRC with the same 
CNAME as one or more other SSRCs originating from another node. In fact 
an obvious case for this to occur is when the creation of Forward Error 
Correction data is performed at a boundary to another transport domain. Thus 
any node in this case would need to report on both the actual arrived 
stream and send sender reports on the stream it creates.

The result of the above exception is that a 3rd party monitor can't 
detect if there is an fault in the transport from the original source and 
the secondary node generating the new source with shared CNAME.-->
      </section>

      <section title="Combined RTCP Packets">
        <t>When a node contains multiple SSRCs, it is questionable if an RTCP
        compound packet can only contain RTCP packets from a single SSRC or if
        multiple SSRCs can include their packets in a joint compound packet.
        The high level question is a matter for any receiver processing on
        what to expect. In addition to that question there is the issue of how
        to use the RTCP timer rules in these cases, as the existing rules are
        focused on determining when a single SSRC can send.</t>
      </section>
    </section>

    <section title="Signalling considerations">
      <t>Signalling is not an architectural consideration for RTP itself, so
      this discussion has been moved to an appendix. However, it is hugely
      important for anyone building complete applications, so it is deserving
      of discussion.</t>

      <t>The issues raised here need to be addressed in the WGs that deal with
      signalling; they cannot be addressed by tweaking, extending or profiling
      RTP.</t>

      <section title="Signalling Aspects">
        <t>There exist various signalling solutions for establishing RTP
        sessions. Many are <xref target="RFC4566">SDP</xref> based, however
        SDP functionality is also dependent on the signalling protocols
        carrying the SDP. Where <xref target="RFC2326">RTSP</xref> and <xref
        target="RFC2974">SAP</xref> both use SDP in a declarative fashion,
        while <xref target="RFC3261">SIP</xref> uses SDP with the additional
        definition of <xref target="RFC3264">Offer/Answer</xref>. The impact
        on signalling and especially SDP needs to be considered as it can
        greatly affect how to deploy a certain multiplexing point choice.</t>

        <section title="Session Oriented Properties">
          <t>One aspect of the existing signalling is that it is focused
          around sessions, or at least in the case of SDP the media
          description. There are a number of things that are signalled on a
          session level/media description but those are not necessarily
          strictly bound to an RTP session and could be of interest to signal
          specifically for a particular media stream (SSRC) within the
          session. The following properties have been identified as being
          potentially useful to signal not only on RTP session level:<list
              style="symbols">
              <t>Bitrate/Bandwidth exist today only at aggregate or a common
              any media stream limit, unless either codec-specific bandwidth
              limiting or RTCP signalling using TMMBR is used.</t>

              <t>Which SSRC that will use which RTP Payload Types (this will
              be visible from the first media packet, but is sometimes useful
              to know before packet arrival).</t>
            </list></t>

          <t>Some of these issues are clearly SDP's problem rather than RTP
          limitations. However, if the aim is to deploy an solution using
          additional SSRCs that contains several sets of media streams with
          different properties (encoding/packetization parameter, bit-rate,
          etc), putting each set in a different RTP session would directly
          enable negotiation of the parameters for each set. If insisting on
          Additional SSRC only, a number of signalling extensions are needed
          to clarify that there are multiple sets of media streams with
          different properties and that they shall in fact be kept different,
          since a single set will not satisfy the application's
          requirements.</t>

          <t>For some parameters, such as resolution and framerate, a
          SSRC-linked mechanism has been proposed: <xref
          target="I-D.lennox-mmusic-sdp-source-selection"/>.</t>
        </section>

        <section title="SDP Prevents Multiple Media Types">
          <t>SDP chose to use the m= line both to delineate an RTP session and
          to specify the top level of the MIME media type; audio, video, text,
          image, application. This media type is used as the top-level media
          type for identifying the actual payload format bound to a particular
          payload type using the rtpmap attribute. This binding has to be
          loosened in order to use SDP to describe RTP sessions containing
          multiple MIME top level types.</t>

          <t>There is an accepted WG item in the MMUSIC WG to define how <xref
          target="I-D.ietf-mmusic-sdp-bundle-negotiation">multiple media lines
          describe a single underlying transport</xref> and thus it becomes
          possible in SDP to define one RTP session with media types having
          different MIME top level types.</t>
        </section>

        <section title="Signalling Media Stream Usage">
          <t>Media streams being transported in RTP has some particular usage
          in an RTP application. This usage of the media stream is in many
          applications so far implicitly signalled. For example, an
          application may choose to take all incoming audio RTP streams, mix
          them and play them out. However, in more advanced applications that
          use multiple media streams there will be more than a single usage or
          purpose among the set of media streams being sent or received. RTP
          applications will need to signal this usage somehow. The signalling
          used will have to identify the media streams affected by their
          RTP-level identifiers, which means that they have to be identified
          either by their session or by their SSRC + session.</t>

          <t>In some applications, the receiver cannot utilise the media
          stream at all before it has received the signalling message
          describing the media stream and its usage. In other applications,
          there exists a default handling that is appropriate.</t>

          <t>If all media streams in an RTP session are to be treated in the
          same way, identifying the session is enough. If SSRCs in a session
          are to be treated differently, signalling must identify both the
          session and the SSRC.</t>

          <t>If this signalling affects how any RTP central node, like an RTP
          mixer or translator that selects, mixes or processes streams, treats
          the streams, the node will also need to receive the same signalling
          to know how to treat media streams with different usage in the right
          fashion.</t>
        </section>
      </section>
    </section>

    <section title="Changes from -01 to -02">
      <t><list style="symbols">
          <t>Added Harald Alvestrand as co-author.</t>

          <t>Removed unused term "Media aggregate".</t>

          <t>Added term "RTP session group", noted that CNAMEs are assumed to
          bind across the sessions of an RTP session group, and used it when
          appropriate (TODO)</t>

          <t>Moved discussion of signalling aspects to appendix</t>

          <t>Removed all suggestion that PT can be a multiplexing point</t>

          <t>Normalised spelling of "endpoint" to follow RFC 3550 and not use
          a hyphen.</t>

          <t>Added CNAME to definition list.</t>

          <t>Added term "Media Sink" for the thing that is identified by a
          listen-only SSRC.</t>

          <t>Added term "RTP source" for the thing that transmits one media
          stream, separating it from "Media Source". [[OUTSTANDING: Whether to
          use "RTP Source" or "Media Sender" here]]</t>

          <t>Rewrote section on distributed endpoint, noting that this, like
          any endpoint that wants a subset of a set of RTP streams, needs
          multiple RTP sessions.</t>

          <t>Removed all substantive references to the undefined term
          "purpose" from the main body of the document when it referred to the
          purpose of an RTP stream.</t>

          <t>Moved the summary section of section 6 to the guidelines section
          that it most closely supports.</t>

          <t/>
        </list></t>
    </section>
  </back>
</rfc>
