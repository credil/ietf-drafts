<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="lib/rfc2629.xslt"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc ipr="trust200902"
     category="exp"
     docName="draft-thierry-bulk-02"
     xmlns:x="http://purl.org/net/xml2rfc/ext">
  <x:feedback template="mailto:pierre@nothos.net"/>
  <front>
    <title abbrev="BULK1">Binary Uniform Language Kit 1.0</title>

    <author initials="P." surname="Thierry" fullname="Pierre Thierry">
      <organization>Thierry Technologies</organization>
      <address>
        <email>pierre@nothos.net</email>
      </address>
    </author>

    <date day="7" month="August" year="2013" />
    <keyword>binary</keyword>

    <abstract>
      <t>
        This specification describes a uniform, decentrally extensible and efficient format for data
        serialization.
      </t>
    </abstract>

  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <section title="Rationale">
        <t>
          This specification aims at finding an original trade-off between uniformity, generality,
          extensibility, decentralization, compactness and processing speed for a data format. It is
          our opinion that every widely used existing format occupy a different position in the
          solution space for formats, hence this new design. It is also our opinion that most of
          those existing formats constitute an optimal solution for their specific use case, either
          in a absolute sense, or at least at the time of their design. But the ever-changing field
          of IT now faces new challenges that call for a new approach.
        </t>
	<t>
	  In particular, whereas the previous trend for Internet and Web standards and programming
	  tools has been to create human-readable syntaxes for data and protocols, the advent of
	  technologies like <xref target="protobuf">protocol buffers</xref>, <xref
	  target="Thrift">Thrift</xref>, the various binary serializations for JSON like <xref
	  target="Avro">Avro</xref> or <xref target="Smile">Smile</xref>, or the binary <xref
	  target="HTTP2">HTTP/2.0</xref> currently in development seem to indicate that the time is
	  ripe for a generalized use of binary, reserved until now for the low-level protocols. The
	  lessons about flexibility learnt in the previous switch from binary to plain text can now
	  be applied to efficient binary syntaxes.
	</t>
	<section title="Definitions">
	  <t>
	    By uniformity, we mean the property of a syntax that can be parsed even by an
	    application that doesn't understand the semantics of every part of the processed
	    data. Of course, almost all syntaxes that feature uniformity contain a limited number of
	    non uniform elements. Also, uniformity really only has value in the face of extension,
	    as a fixed syntax doesn't need uniformity (it only makes the implementation simpler).
	  </t>
	  <t>
	    Almost all extensible syntaxes have their extensible part uniform to a great degree. In
	    this specification, uniformity is hence evaluated on two criteria: first, the number of
	    non uniform elements (and, incidentally, their diversity), second, the fact that the
	    uniformity of the extensible part is not a limitation to the users (i.e. that the
	    temptation to extend the language in a non-uniform way is as absent as possible).
	  </t>
	  <t>
	    A good counter-example is found in most programming languages. Adding a new branching
	    construct cannot be done in a terse way without modifying the underlying
	    implementation. Such a construct either cannot be defined by user code (because of
	    evaluation rules) or can in a terribly verbose and inconvenient way (with lots of
	    boilerplate code). Notable exceptions to this limitation of programming languages are
	    Lisp, Haskell and stack programming languages.
	  </t>
	  <t>
	    On the other hand, a stack programming language is the canonical example of a
	    non-uniform language. Each operator takes a number of operands from the stack. Not
	    knowing the arity of an operator makes it impossible to continue parsing, even when its
	    evaluation was optional to the final processing. In the design space, stack programming
	    languages completely sacrifice uniformity to achieve one of the highest combination of
	    extensibility, compactness and speed of processing.
	  </t>
	  <t>
	    By generality, we mean the ability of a syntax to lend itself to describe any kind of
	    data with a reasonable (or better yet, high) level of compactness and simplicity. For
	    example, although both arrays and linked lists could be considered very general as they
	    are both able to store any kind of data, they actually are at the respective cost of
	    complexity (arrays need the embedding of data structure in the data or in the processing
	    logic) and size (in-memory linked lists can waste as much as half or two third of the
	    space for the overhead of the data structure).
	  </t>
	  <t>
	    By decentralization, we mean the ability to extend the syntax in a way that avoid naming
	    collisions without the use of a central registry. Note that the DNS, as we use it, is
	    NOT decentralized in this sense, but distributed, as it cannot work without its root
	    servers and not even without prior knowledge of their location.
	  </t>
	</section>
	<section title="State of the art">
	  <t>
	    Uniformity, generality and extensibility are usually highly-valued traits in formats
	    design. Programming languages obviouly feature them foremost, although their generality
	    usually stops at what they are supposed to express: procedures. Most of them are
	    ill-suited to represent arbitrary data, but notable exceptions include Lisp (where "code
	    is data") and Javascript, from which a subset has been extracted to exchange data, JSON,
	    which has seen a tremendous success for this purpose. JSON may lack in generality and
	    compactness, but its design makes its parsing really straightforward and fast. All of
	    them, though, lack decentralization. Some of them make it possible to extend them in a
	    relatively decentralized way if some discipline is followed (for example, by naming
	    modules after domaine names), but the discipline is not mandatory.
	  </t>
	  <t>
	    The SGML/XML family of formats also feature these traits and actually fare much better
	    than programming languages on the three fronts. XML namespaces also make it relatively
	    decentralized and there have been attempts at making it compact (e.g. EXI from W3C, Fast
	    Infoset from ISO/ITU or EBML).
	  </t>
	  <t>
	    All the previously cited formats clearly lack compactness, although just applying
	    standard compression techniques would sacrifice only very little processing time to gain
	    huge size reductions on most of their intended use cases.
	  </t>
	  <t>
	    So-called binary formats pretty much exhibit the opposite trade-offs. Most of them are
	    not uniform to achieve better compactness. Some are specifically designed for a great
	    generality, but many lack extensibility. When they are extensible, it's never in a
	    decentralized way, again for reasons that have to do with compactness. They are usually
	    extremely fast to parse.
	  </t>
	  <t>
	    Actually, many binary formats are not so much formats but formats frameworks, and
	    exclude extensibility by design. For each use case, an IDL compiler creates a brand new
	    format that is essentially incompatible with all other formats created by the same
	    compiler (EBML specifically cites this property among its own disadvantages). If the IDL
	    compiler and framework are correctly designed, such a format usually represent an
	    optimum in compactness and speed of processing, as the compiler can also automatically
	    generate an ad-hoc optimized parser.
	  </t>
	</section>
      </section>
      <section title="Format overview">
	<t>
	  A BULK stream is a stream of 8-bit bytes, in big-endian order. Parsing a BULK stream
	  yields a sequence of expressions, which can be either atoms or forms, which are sequences
	  of expressions. The syntax of forms is entirely uniform, without a single exception: a
	  starting byte marker, a sequence of expressions and an ending byte marker. Among atoms,
	  only nil (the null byte), arrays and fixed-sized binary words have a special syntax, for
	  efficiency purposes. Even booleans and floating-point numbers follow the uniform syntax
	  that every other expression follow.
	</t>
	<t>
	  Non uniform atoms start with a marker byte, followed by a static or dynamic number of
	  bytes, depending on the type (none for nil, static for fixed-size binary words, dynamic
	  for arrays).
	</t>
	<t>
	  Any other atom is a reference, which consists of a namespace marker (in most of the cases,
	  a single byte) followed by a identifier within this namespace (a single byte). All in all,
	  a very little sacrifice is made in compactness for the benefit of a very simple syntax:
	  apart from nil, nothing is smaller than 2 bytes, and as most forms involve a reference
	  followed by some content, a form is 4 bytes + its content.
	</t>
	<t>
	  A namespace marker in a BULK stream is associated by either one of two simple forms to a
	  namespace identified by a UUID, thus ensuring decentralized extensibility. One of the two
	  forms declares that the stream can be processed even if the application doesn't recognize
	  the namespace. Parsing remains possible thanks to the uniform syntax.
	</t>
	<t>
	  Combination of BULK namespaces, BULK streams and even other formats doesn't need any
	  content transformation to work. Here are some examples:
	  <list style="symbols">
	    <t>
	      The content of a BULK stream, enclosed in 0x1 and 0x2 bytes markers, constitute a
	      valid BULK expression. Thus BULK streams can be packed or annotated within a BULK
	      stream without modification. Annotation use cases include adding metadata and
	      cryptographic signature.
	    </t>
	    <t>
	      A BULK format could specify in its syntax the place for an expression holding
	      metadata. Whether the specification provides its own metadata forms or not, an
	      application could use a BULK serialization for MARC, TEI Header, XML or RDF for this
	      metadata expression. The vocabulary selected would be univocally expressed by the
	      namespace and every vocabulary would be parsed by the same mechanisms.
	    </t>
	    <t>
	      Whether a content must be stored as-is instead of serialized or a highly-optimized ad
	      hoc serialization exists for some data, anything can always be stored within an
	      array. They can contain arbitray bytes and there is no limit to their size.
	    </t>
	  </list>
	</t>
	<t>
	  Furthermore, BULK expressions can be evaluated. Most expressions evaluate to themselves,
	  but some evaluate by default to the result of a function call, making it possible to
	  serialize data in an even more compact form, by eliminating boilerplate data and repeated
	  patterns.
	</t>
      </section>
      <section title="Conventions and Terminology">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
        <t>
          Literal numerical values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with <spanx style="verb">0x</spanx> to distinguish them
          from decimal literals.
        </t>
	<t>
	   The text notation of the BULK stream uses mnemonics for some bytes sequences. Mnemonics
	   are series of characters, excluding all capital letters and white space, like <spanx
	   style="verb">this-is-one-mnemonic</spanx> or <spanx
	   style="verb">what-the-%§!?#-is-that?</spanx>. They are always separated by white
	   space. Outside the use of mnemonics, a sequence of bytes (of one or more bytes) can be
	   represented by its hexadecimal value as an unsigned integer (e.g. <spanx
	   style="verb">0x3F</spanx> or <spanx style="verb">0x3A0B770F</spanx>). Some types in this
	   specification define a special syntax for their representation in the text notation.
	</t>
	<t>
	  In the grammar, a shape is a pattern of bytes, following the rules of the text notation
	  for a BULK stream. Apart from mnemonics and fixed sequences of bytes, a shape can contain:
	  <list style="symbols">
	    <t>an arbitrary sequence of a fixed number of bytes, represented by its size, i.e. a
	    number of bytes in decimal immediately followed by a B uppercase letter (e.g. <spanx
	    style="verb">4B</spanx>)</t>
	    <t>a typed sequence of bytes, represented by the name of its type, a capitalized word
	    (e.g.  <spanx style="verb">Foo</spanx>); this means a sequence of bytes whose specific
	    yield (cf. <xref target="parsing"/>) has this type</t>
	    <t>a named sequence of bytes (of zero or more bytes), represented by a series of any
	    character excluding '{}' between '{' and '}' (e.g. <spanx style="verb">{quux}</spanx>);
	    a named sequence can be typed or sized, in which case it is immediately followed by ':'
	    and a type or size (e.g. <spanx style="verb">{quux}:Bar</spanx> or <spanx
	    style="verb">{quux}:12B</spanx>)</t>
	  </list>
	</t>
	<t>
	  When an entire shape describes the byte sequence of an atom, it is the normative
	  specification for parsing it, but shapes of forms are only normative with respect to their
	  evaluation. A reference defined with a form shape can be used in different shapes, albeit
	  with different semantics and value.
	</t>
      </section>
    </section>

    <section title="BULK syntax">
      <t>
	A BULK stream is a sequence of 8-bit bytes. Bits and bytes are in big-endian order. The
	result of parsing a BULK stream is a sequence of abstract data, called the abstract
	yield. BULK parsing is injective: a BULK stream has only one abstract yield, but different
	BULK streams can have the same abstract yield.
      </t>
      <t>
	A processing application is not expected to actually produce the abstract yield, but an
	adaptation of the abstract yield to its own implementation, called the concrete yield. Also,
	some expressions in a BULK stream may have the semantics of a transformation of the abstract
	yield. A processing application may thus not produce or retain the concrete yield but the
	result of its transformation. This specification deals mainly with the byte sequence and the
	abstract yield and occasionnally provide guidelines about the concrete yield.
      </t>
      <t>
	The abstract yield is a sequence of expressions. Expressions can be atoms or forms. Forms
	are sequences of expressions. If a byte sequence is parsed as an expression, this byte
	sequence is said to denote this expression.
      </t>

      <section anchor="parsing" title="Parsing algorithm">
	<t>
	  The parser operates with a context, which is a sequence of expressions. Each time an
	  expression is parsed, it is appended at the end of the context. The initial context is the
	  abstract yield.
	</t>
	<t>
	  At the beginning of a BULK stream and after having consumed the byte sequence denoting a
	  complete expression, the parser is at the dispatch stage. At this stage, the next byte is
	  a marker byte, which tells the parser what kind of expression comes next (the marker byte
	  is the first byte of the sequence that denotes an expression). The expression appended to
	  the context after reading a byte sequence is called the specific yield of the byte
	  sequence.
	</t>
	<t>
	  The <spanx style="verb">0x1</spanx> and <spanx style="verb">0x2</spanx> marker bytes are
	  special cases. When the parser reads <spanx style="verb">0x1</spanx>, it immediately
	  appends an empty sequence to the current context. This sequence becomes the new
	  context. This new context has the previous context as parent. Then the parser returns to
	  its dispatch stage. When the parser reads <spanx style="verb">0x2</spanx>, it appends
	  nothing to the context, but instead the parent of the current context becomes the new
	  context and the parser returns to the dispatch stage. Thus it is a parsing error to read
	  <spanx style="verb">0x2</spanx> when the context is the abstract yield.
	</t>
	<t>
	  The scope of an expression is the part of its context that follows the expression.
	</t>
	<t>
	  Whenever a parsing error is encountered, parsing of the BULK stream MUST stop.
	</t>
	<section title="Evaluation">
	  <t>
	    A processing application MAY implement evaluation of BULK expressions and streams. When
	    evaluating a BULK stream, when the parser gets to the dispatch stage and the context is
	    the abstract yield, the last expression in the context is replaced by what it evaluates
	    to.
	  </t>
	  <t>
	    The default evaluation rule is that an expression evaluates to itself. A name within a
	    namespace can have a value, which is what a reference associated to this name evaluates
	    to. A reference whose marker value is associated to no namespace or whose name has no
	    value evaluates to itself. How self-evaluating BULK expressions are represented in the
	    concrete yield is application-dependent, but future specifications may define a standard
	    API to access it, similar to the Document Object Model for XML.
	  </t>
	  <t>
	    The evaluation of a sequence obeys a special rule, though: if the first expression of
	    the sequence has type <spanx style="verb">Function</spanx>, that function is called with
	    an argument list and the sequence evaluates to the return value. If the function has
	    type <spanx style="verb">LazyFunction</spanx>, the argument list is the rest of the
	    sequence. If the function has type <spanx style="verb">EagerFunction</spanx>, the
	    argument list is the rest of the sequence, where each expression is replaced by what it
	    evaluates to. Any expression that has type <spanx style="verb">LazyFunction</spanx> or
	    <spanx style="verb">EagerFunction</spanx> also has type <spanx
	    style="verb">Function</spanx>.
	  </t>
	</section>
      </section>

      <section title="Forms">
	<section title="starting marker byte">
	  <t>
	    <list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x1</spanx></t>
	      <t hangText="mnemonic"><spanx style="verb">(</spanx></t>
	    </list>
	  </t>
	</section>
	<section title="ending marker byte">
	  <t>
	    <list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x2</spanx></t>
	      <t hangText="mnemonic"><spanx style="verb">)</spanx></t>
	    </list>
	  </t>
	</section>

	<section title="Difference between sequence and form">
	  <t>
	    Beware that although the specific yield of a form is a sequence of expressions, it is
	    not the same thing as a byte sequence described as a sequence of expressions. Let's
	    examine several forms of the shape <spanx style="verb">( foo {seq} )</spanx>.
	  </t>
	  <t>
	    In the first form, {seq} is a sequence of 3 expressions: <spanx style="verb">( foo nil
	    nil nil )</spanx>. In the second form, {seq} is a single expression, and that expression
	    is an atom: <spanx style="verb">( foo nil )</spanx>. But in the third form, {seq} is
	    also a single expression, and that expression is a form: <spanx style="verb">( foo ( nil
	    nil nil ) )</spanx>.
	  </t>
	</section>
      </section>

      <section title="Atoms">
	<section title="nil">
	  <t>
	    <list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x0</spanx> (mnemonic: <spanx style="verb">nil</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">nil</spanx></t>
	    </list>
	  </t>
	  <t>
	    Apart from being a possible short marker value, the fact that the <spanx
	    style="verb">0x0</spanx> byte represents a valid atom means that a sequence of null bytes
	    is a valid part of a BULK stream, thus making the format less fragile. In a network
	    communication, nil atoms can also be sent to keep the channel open. They can also be
	    used as padding at the end of a form.
	  </t>
	</section>

	<section title="Array">
	  <t>
	    <list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x3</spanx> (mnemonic: <spanx style="verb">#</spanx>)</t>
	      <t hangText="shape"><spanx style="verb"># Int {content}</spanx></t>
	    </list>
	  </t>
	  <t>
	    Arrays have a special parsing rule. After consuming the marker byte, the parser returns
	    to the dispatch stage. It is a parser error if the parsed expression is not of type Int
	    or if its value cannot be recognized. This integer is not added to any context, but the
	    parser consumes as many bytes as this integer and they constitute the content of this
	    array.
	  </t>
	  <t>
	    If two arrays have the shapes <spanx style="verb"># {s1} {c1}</spanx> and <spanx
	    style="verb"># {s2} {c2}</spanx> and if <spanx style="verb">{s1+s2}</spanx> denotes the sum
	    of <spanx style="verb">{s1} </spanx>and <spanx style="verb">{s2}</spanx>, then their
	    concatenation is <spanx style="verb"># {s1+s2} {c1} {c2}</spanx>.
	  </t>
	  <t>
	    In the text notation, a quoted string represent an array containing the encoding of that
	    string in the current encoding.
	  </t>
	  <t>Type: <spanx style="verb">Array</spanx></t>
	</section>

	<section title="Binary words">
	  <t>
	    A word can be interpreted either as a bits sequence or as an unsigned integer in binary
	    notation. The choice depends on the context and the application. Actually, many
	    processing applications may not need make any choice, as most programming language
	    implementations actually also confuse unsigned integers and bits sequences to some
	    extent.
	  </t>
	  <section title="8 bits word">
	    <t>
	      <list style="hanging">
		<t hangText="marker"><spanx style="verb">0x4</spanx> (mnemonic: <spanx style="verb">w8</spanx>)</t>
		<t hangText="shape"><spanx style="verb">w8 1B</spanx></t>
	      </list>
	    </t>
	    <t>Types: <spanx style="verb">Int</spanx>, <spanx style="verb">Word</spanx>, <spanx style="verb">Word8</spanx></t>
	  </section>

	  <section title="16 bits word">
	    <t>
	      <list style="hanging">
		<t hangText="marker"><spanx style="verb">0x5</spanx> (mnemonic: <spanx style="verb">w16</spanx>)</t>
		<t hangText="shape"><spanx style="verb">w16 2B</spanx></t>
	      </list>
	    </t>
	    <t>Types: <spanx style="verb">Int</spanx>, <spanx style="verb">Word</spanx>, <spanx style="verb">Word16</spanx></t>
	  </section>

	  <section title="32 bits word">
	    <t>
	      <list style="hanging">
		<t hangText="marker"><spanx style="verb">0x6</spanx> (mnemonic: <spanx style="verb">w32</spanx>)</t>
		<t hangText="shape"><spanx style="verb">w32 4B</spanx></t>
	      </list>
	    </t>
	    <t>Types: <spanx style="verb">Int</spanx>, <spanx style="verb">Word</spanx>, <spanx style="verb">Word32</spanx></t>
	  </section>

	  <section title="64 bits word">
	    <t>
	      <list style="hanging">
		<t hangText="marker"><spanx style="verb">0x7</spanx> (mnemonic: <spanx style="verb">w64</spanx>)</t>
		<t hangText="shape"><spanx style="verb">w64 8B</spanx></t>
	      </list>
	    </t>
	    <t>Types: <spanx style="verb">Int</spanx>, <spanx style="verb">Word</spanx>, <spanx style="verb">Word64</spanx></t>
	  </section>

	  <section title="128 bits word">
	    <t>
	      <list style="hanging">
		<t hangText="marker"><spanx style="verb">0x8</spanx> (mnemonic: <spanx style="verb">w128</spanx>)</t>
		<t hangText="shape"><spanx style="verb">w128 16B</spanx></t>
	      </list>
	    </t>
	    <t>Types: <spanx style="verb">Int</spanx>, <spanx style="verb">Word</spanx>, <spanx style="verb">Word128</spanx></t>
	  </section>
	</section>

	<section title="Signed fixed-size integer">
	  <t>
	    <list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x9</spanx> (mnemonic: <spanx style="verb">sint</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">sint Word</spanx></t>
	    </list>
	  </t>
	  <t>
	    The value of its contained word is the value of this integer in two's-complement
	    notation.
	  </t>
	  <t>Type: <spanx style="verb">Number</spanx>, <spanx style="verb">Int</spanx></t>
	</section>

	<section title="Reserved marker bytes">
	  <t>
	    Marker bytes <spanx style="verb">0xA−0xF</spanx> are reserved for future major versions of
	    BULK. It is a parser error if a BULK stream with major version 1 contains such a marker
	    byte.
	  </t>
	</section>

	<section title="Reference">
	  <t><list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x10−0xFF</spanx></t>
	      <t hangText="shape"><spanx style="verb">{ns}:1B {name}:1B</spanx></t>
	    </list>
	  </t>
	  <t>
	    The <spanx style="verb">{ns}</spanx> byte is a value associated with a namespace. Values
	    <spanx style="verb">0x10−0x1F</spanx> are reserved for namespaces defined by BULK
	    specifications. Greater values can be associated with namespaces identified by a UUID.
	  </t>
	  <t>
	    The <spanx style="verb">{name}</spanx> byte is the name within the namespace. Vocabularies
	    with more than 256 names thus need to be spread accross several namespaces.
	  </t>
	  <t>
	    The specification of a namespace SHOULD include a mnemonic for the namespace and for
	    each defined name. When descriptions use several namespaces, the mnemonic of a reference
	    SHOULD be the concatenation of the namespace mnemonic, ":" and the name mnemonic if
	    there can be an ambiguity. For example, the <spanx style="verb">fp</spanx> name in
	    namespace <spanx style="verb">math</spanx> becomes <spanx style="verb">math:fp</spanx>.
	  </t>
	  <t>Type: <spanx style="verb">Ref</spanx></t>
	  <section title="Speciale case">
	    <t>
	      References have a special parsing rule. In case a BULK stream needs an important
	      number of namespaces, if the marker byte is <spanx style="verb">0xFF</spanx>, the parser
	      continues to read bytes until it finds a byte different than 0xFF. The value of this
	      sequence of bytes is the value associated with a namespace. For example, the reference
	      denoted by the bytes <spanx style="verb">0xFF 0xFF 0x8C 0x1A</spanx> is the name 26 in
	      the namespace associated with 16777100.
	    </t>
	  </section>
	</section>

      </section>
    </section>

    <section title="Standard namespaces">
      <t>
	Standard namespaces have a fixed namespace value and are not identified by a UUID.
      </t>

      <section title="BULK core namespace">
	<t>
	  <list style="hanging">
	      <t hangText="marker"><spanx style="verb">0x10</spanx> (mnemonic: <spanx style="verb">bulk</spanx>)</t>
	  </list>
	</t>

	<section title="Version">
	  <t>
	    <list style="hanging">
	      <t hangText="name"><spanx style="verb">0x1</spanx> (mnemonic: <spanx style="verb">version</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">( version {major}:Int {minor}:Int )</spanx></t>
	    </list>
	  </t>
	  <t>
	    When parsing a BULK stream, a processing application MUST determine explicitely the
	    major and minor version of the BULK specification that the stream obeys. This
	    information MAY be exchanged out-of-band, if BULK is used to exchange a number a very
	    small messages, where repeated headers of 8 bytes might become too big a overhead. A
	    processing application MUST NOT assume a default version.
	  </t>
	  <t>
	    If the version is expressed within a BULK stream, this form MUST be the first in the
	    stream. In any other place, this form has no semantics attached to it. This
	    specification defines BULK 1.0. When writing a BULK stream, an application MUST denote
	    {major} and {minor} by the smallest byte sequence possible.
	  </t>
	  <t>
	    An application writing a BULK stream to long-term storage (e.g. in a file or a database
	    record) SHOULD include a <spanx style="verb">version</spanx> form.
	  </t>
	  <t>
	    Two BULK versions with the same major version MUST share the same parsing rules and the
	    same definitions of marker bytes. Changing the syntax or semantics of existing marker
	    bytes and using marker bytes in the reserved interval warrants a new major
	    version. Changing the syntax or semantics of existing names in standard namespaces also.
	  </t>
	  <t>
	    Adding standard namespaces or adding names in existing standard namespaces warrants a
	    new minor version.
	  </t>
	</section>


	<section title="true">
	  <t>
	    <list style="hanging">
	      <t hangText="name"><spanx style="verb">0x2</spanx> (mnemonic: <spanx style="verb">true</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">true</spanx></t>
	    </list>
	  </t>
	  <t>
	    Type: <spanx style="verb">Boolean</spanx>.
	  </t>
	</section>

	<section title="false">
	  <t>
	    <list style="hanging">
	      <t hangText="name"><spanx style="verb">0x3</spanx> (mnemonic: <spanx style="verb">false</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">false</spanx></t>
	    </list>
	  </t>
	  <t>
	    Type: <spanx style="verb">Boolean</spanx>.
	  </t>
	</section>

	<section title="Strings encoding">
	  <t>
	    <list style="hanging">
	      <t hangText="name"><spanx style="verb">0x4</spanx> (mnemonic: <spanx style="verb">stringenc</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">( stringenc {enc}:Encoding )</spanx></t>
	    </list>
	  </t>
	  <t>
	    This tells the processing application that, in the scope of this expression, all
	    expressions that are understood by the application as character strings will be encoded
	    with the encoding designated by {enc}.
	  </t>
	  <t>
	    As the abstract yield doesn't contains strings but expressions that will be used as
	    strings by the application, it is not a parsing error if the application doesn't
	    recognize {enc}. In this situation, it is a parsing error when the application actually
	    needs to decode a byte sequence as a string. It is not a parsing error when a processing
	    application only transmits a byte sequence encoding a string, if it can accurately
	    convey the encoding to the receiving application.
	  </t>
	</section>

	<section title="IANA registered character set">
	  <t>
	    <list style="hanging">
	      <t hangText="name"><spanx style="verb">0x5</spanx> (mnemonic: <spanx style="verb">iana-charset</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">( iana-charset {id}:Int )</spanx></t>
	    </list>
	  </t>
	  <t>
	    This designates the string encoding registered among the <xref
	    target="IANA-Charsets">IANA Character Sets</xref> whose MIBenum is {id}.
	  </t>
	  <t>
	    Type: <spanx style="verb">Encoding</spanx>.
	  </t>
	</section>

	<section title="Windows code page">
	  <t>
	    <list style="hanging">
	      <t hangText="name"><spanx style="verb">0x6</spanx> (mnemonic: <spanx style="verb">code-page</spanx>)</t>
	      <t hangText="shape"><spanx style="verb">( code-page {id}:Int )</spanx></t>
	    </list>
	  </t>
	  <t>
	    This designates the string encoding among Windows code pages whose identifier is {id}.
	  </t>
	  <t>
	    Type: <spanx style="verb">Encoding</spanx>.
	  </t>
	</section>

	<section title="Namespaces">
	  <t>
	    The semantic of some expressions is to make a namespace required. It is a parsing error
	    if a processing application doesn't recognise this namespace.
	  </t>

	  <section title="Required namespace">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x7</spanx> (mnemonic: <spanx style="verb">ns</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( ns {mark}:Int {uuid}:Word128 )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This associates the namespace identified by {uuid} to the value {mark}. It makes this
	      namespace required.
	    </t>
	  </section>

	  <section title="Optional namespace">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x8</spanx> (mnemonic: <spanx style="verb">ns*</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( ns* {mark}:Int {uuid}:Word128 )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This associates the namespace identified by {uuid} to the value {mark}.
	    </t>
	  </section>

	  <section title="Package">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x9</spanx> (mnemonic: <spanx style="verb">package</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( package {uuid}:Word128 {namespaces} )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This creates a package identified by {uuid}. Packages are immutable, {uuid} MUST be a
	      v5 UUID generated with the BULK UUID and the byte sequence {namespaces}. <spanx
	      style="verb">{namespaces}</spanx> must be a sequence of expressions. They can be
	      either expressions of type Word128 or have the shape <spanx style="verb">( ns* Word128
	      )</spanx>, which means that the designated namespace is optional to this package.
	    </t>
	  </section>

	  <section title="Import">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0xA</spanx> (mnemonic: <spanx style="verb">import</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( import {base}:Int {uuid}:Word128 )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This associates the namespaces in the package identified by {uuid} with a continuous
	      range of values starting at {base}. If the namespace is not optional to this package,
	      it make the namespace required. It is a parsing error if a processing application
	      doesn't recognize the package.
	    </t>
	  </section>
	</section>

	<section title="Definitions">
	  <t>
	    To define a reference is to change the the value of its name in its namespace (as
	    identified by its UUID, not the marker value) within a certain scope.
	  </t>
	  <t>
	    If a BULK stream is not evaluated, the semantics of an definition are entirely
	    application-dependent.
	  </t>
	  <t>
	    When a BULK stream containing definitions for a namespace comes from a trusted source
	    (i.e. in configuration files of the application, or in the communication with an agent
	    that has been granted the relevant authority), an application MAY give those definitions
	    long-lasting semantics (i.e. keep the values of the names at the end of parsing). This
	    is the preferred mechanism for bulk namespace definition when the semantics of the
	    defined expressions can be expressed completely by BULK forms.
	  </t>

	  <section title="Simple definition">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0xB</spanx> (mnemonic: <spanx style="verb">define</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( define {ref}:Ref Expr )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This defines the reference {ref} in the scope of this expression.
	    </t>
	  </section>
	</section>

	<section title="Substituton">
	  <section title="Substitution function">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0xC</spanx> (mnemonic: <spanx style="verb">subst</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( subst {code} )</spanx></t>
	      </list>
	    </t>
	    <t>
	      <list style="hanging">
		<t hangText="Name's type">LazyFunction</t>
		<t hangText="Form's type">EagerFunction</t>
		<t hangText="Form's value">A substitution function whose return value is the value
		of {code}. Within {code}'s specific yield, the names <spanx style="verb">arg</spanx>
		and <spanx style="verb">rest</spanx> are defined:</t>
	      </list>
	    </t>
	    <section title="Argument">
	      <t>
		<list style="hanging">
		  <t hangText="name"><spanx style="verb">0xD</spanx> (mnemonic: <spanx style="verb">arg</spanx>)</t>
		  <t hangText="shape"><spanx style="verb">( arg {n}:Int )</spanx></t>
		</list>
	      </t>
	      <t>
		<list style="hanging">
		  <t hangText="Name's type">EagerFunction</t>
		  <t hangText="Form's type">Expr</t>
		  <t hangText="Form's value">the element number {n} (starting at zero) of the
		  substitution function's arguments list</t>
		</list>
	      </t>
	    </section>
	    <section title="Rest of arguments list">
	      <t>
		<list style="hanging">
		  <t hangText="name"><spanx style="verb">0xE</spanx> (mnemonic: <spanx style="verb">rest</spanx>)</t>
		  <t hangText="shape"><spanx style="verb">( rest {n}:Int )</spanx></t>
		</list>
	      </t>
	      <t>
		<list style="hanging">
		  <t hangText="Name's type">EagerFunction</t>
		  <t hangText="Form's type">Expr</t>
		  <t hangText="Form's value">the substitution function's arguments list without its
		  first {n} elements.</t>
		</list>
	      </t>
	    </section>
	  </section>

	  <section title="Named expression">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0xF</spanx> (mnemonic: <spanx style="verb">named</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( named {ref}:Ref {expr}:Expr )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This form defines {ref} as {expr} in its scope. This form evaluates to {expr}.
	    </t>
	  </section>
	</section>

	<section title="arithmetic">
	  <t>
	    A processing application must recognize the type of all expressions defined in this
	    specification that have the type Number, but an application MAY consider a number as
	    having an unknown value if it has no adequate data type to store it.
	  </t>
	  <t>
	    In the text notation of a BULK stream, a decimal integer represent the smallest byte
	    sequence that is represented by this integer. For example, <spanx style="verb">( 31 256
	    )</spanx> is a notation for the bytes <spanx style="verb">0x1 0x7 0x1F 0x8 0x0 0x0 0x1 0x0
	    0x2</spanx>.
	  </t>

	  <section title="fraction">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x20</spanx> (mnemonic: <spanx style="verb">frac</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( frac {num}:Int {div}:Int )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This is the number {num}/{div}.
	    </t>
	    <t>
	      Type: <spanx style="verb">Number</spanx>.
	    </t>
	  </section>

	  <section title="Arbitrary precision signed integer">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x21</spanx> (mnemonic: <spanx style="verb">bigint</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( bigint {bits}:Array )</spanx></t>
	      </list>
	    </t>
	    <t>
	      The bits contained in {bits} is the value of this integer in two's-complement notation.
	    </t>
	    <t>
	      Type: <spanx style="verb">Number</spanx>, <spanx style="verb">Int</spanx>.
	    </t>
	  </section>

	  <section title="Binary floating-point number">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x22</spanx> (mnemonic: <spanx style="verb">binary</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( binary {bits}:Word )</spanx></t>
		<t hangText="shape"><spanx style="verb">( binary {bits}:Array )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This is a floating-point number expressed in IEEE 754-2008 binary interchange format. If
	      {bits} is an Array, the size of its contents must be a multiple of 32 bits, as per IEEE
	      754-2008 rules. {bits} MUST NOT have type Word8.
	    </t>
	    <t>
	      Types: <spanx style="verb">Number</spanx>, <spanx style="verb">Float</spanx>.
	    </t>
	  </section>

	  <section title="Decimal floating-point number">
	    <t>
	      <list style="hanging">
		<t hangText="name"><spanx style="verb">0x23</spanx> (mnemonic: <spanx style="verb">decimal</spanx>)</t>
		<t hangText="shape"><spanx style="verb">( decimal {bits}:Word )</spanx></t>
		<t hangText="shape"><spanx style="verb">( decimal {bits}:Array )</spanx></t>
	      </list>
	    </t>
	    <t>
	      This is a floating-point number expressed in IEEE 754-2008 decimal interchange
	      format. If {bits} is an Array, the size of its contents must be a multiple of 32 bits,
	      as per IEEE 754-2008 rules. {bits} MUST NOT have type Word8.
	    </t>
	    <t>
	      Types: <spanx style="verb">Number</spanx>, <spanx style="verb">Float</spanx>.
	    </t>
	  </section>

	</section>
      </section>
    </section>

    <section title="Extension namespaces">
      <t>
	Extension namespaces are defined with an identifier UUID, to be associated to a marker
	value.
      </t>

      <section title="Official namespaces">
	<t>
	  Extension namespaces defined as part of the official BULK suite MUST be identified by a v5
	  UUID. The namespace UUID used to generate it MUST be <eref
	  target="urn:uuid:abaddeed-face-11e2-9605-74de2b4102f1"/>. The name used to generate it
	  SHOULD be a URI designating the described vocabulary when one exists.
	</t>
      </section>

      <section title="User-defined namespaces">
	<t>
	  User-defined namespaces are actually no different than official namespaces, apart from the
	  choice of UUID.
	</t>
      </section>
    </section>

    <section title="Profiles">
      <t>
	A profile is a byte sequence parsed by a processing application just after the <spanx
	style="verb">version</spanx> form or before the first expression if there is no <spanx
	style="verb">version</spanx> form. Thus a parser SHOULD look ahead at the beginning of a
	stream to see if the first three bytes are <spanx style="verb">( bulk:version</spanx>. With
	respect to the BULK stream, the profile is an out-of-band information, usually implicit.
      </t>
      <t>
	A processing application doesn't need to include the profile in the concrete yield, as long
	as the semantics of the abstract yield are maintained.
      </t>
      <t>
	The same BULK stream might be processed with different profiles.
      </t>
      <t>
	A processing application MUST NOT deduce the profile from the content of a BULK stream.
      </t>

      <section title="Profile redundancy">
	<t>
	  A processing application should only rely on the use of a profile when it is a safe
	  assumption that the profile is known, for example within a communication where the
	  protocol dictates the profile.
	</t>
	<t>
	  In particular, long-term storage of a BULK stream should preserve profile information, for
	  example with a media type that dictates the profile.
	</t>
	<t>
	  Otherwise, an application writing a BULK stream in a long-term storage SHOULD include the
	  profile after the version form. For this reason, the expressions in a profile SHOULD have
	  idempotent semantics.
	</t>
      </section>

      <section title="Standard profile">
	<t>
	  This specification defines the default profile that a processing application MUST use when
	  it is not using a specific profile:
	</t>
	<t>
	  <spanx style="verb">( bulk:stringenc 106 )</spanx>
	</t>
	<t>
	  This means that the default string encoding in a BULK stream is UTF-8.
	</t>
      </section>
    </section>

    <section title="Security Considerations" anchor="sec">
      <section title="Parsing">
	<t>
	  Parsing a BULK stream is designed to be free of side-effects for the processing application,
	  apart from storing the parsed results.
	</t>
	<t>
	  Arrays in BULK carry their size, so as for the application to know in advance the size of
	  the data to read and store, thus making it easier to build robust code. A malicious
	  software, however, may announce an array with a size choosen to get an application to
	  exhaust its available memory. When a BULK stream has been completely received, an array
	  bigger than the remaining data SHOULD trigger an error. When a BULK stream's size is not
	  known in advance, the application SHOULD use a growable data structure.
	</t>
      </section>
      <section title="Forwarding">
	<t>
	  When a processing application forwards all or part of the data in a BULK stream to another
	  application, care must be taken if part of the forwarded data was not entirely recognized,
	  as it could be used by an attacker to benefit from the authority the forwarding
	  application has on the recipient of the data.
	</t>
      </section>
      <section title="Definitions">
	<t>
	  The architecture of a processing application SHOULD ensure that a malicious agent cannot
	  abuse authority given to it to define a namespace in order to modify associations in other
	  namespaces. Depending on the use of data structures storing BULK expressions, this could
	  amount to giving an attacker a way to manipulate the application's state. See <xref
	  target="robustNS"/> for an example of architecture that is resistant to that kind of
	  attack.
	</t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>
	This specification defines a new media type, application/bulk. Here are the informations for
	its registration to IANA:
      </t>
      <t>
	<list style="hanging">
	  <t hangText="Type name">application</t>
	  <t hangText="Subtype name">bulk</t>
	  <t hangText="Required parameters">none</t>
	  <t hangText="Optional parameters">none</t>
	  <t hangText="Encoding considerations">none, content is self-describing</t>
	  <t hangText="Security considerations">cf. <xref target="sec"/></t>
	  <t hangText="Interoperability considerations">the constraint to start any BULK stream with
	  a version form has the side-effect that classes of BULK streams can be identified by a
	  sequence of bytes acting as "magic number":
	  <list style="hanging">
	    <t hangText="0x011001">any BULK stream</t>
	    <t hangText="0x01100104">a BULK stream of any major version beneath 256</t>
	    <t hangText="0x0110010401">a BULK stream of major version 1</t>
	    <t hangText="0x0110010401040202">a BULK stream of version 1.2</t>
	  </list>
	  </t>
	  <t hangText="Published specification">this document</t>
	  <t hangText="Applications that use this media type">none so far</t>
	  <t hangText="Fragment identifier considerations">this specification defines no semantics for
	  addressing the data with a fragment identifier; a future specification could define fragment
	  identifier syntaxes to address the content by byte offset or the parsed results by their
	  number in the yielded sequence</t>
	  <t hangText="Additional information">a future specification may define a naming convention
	  for media types based on bulk with a +bulk suffix, as for XML with +xml</t>
	</list>
      </t>
    </section>

    <section title="Acknowledgements">
      <t>
	The original author of this specification read <eref
	target="http://www.schnada.de/grapt/eriknaggum-xmlrant.html">Erik Naggum's famous rant about
	XML</eref> several years before, and it may well have unconsciouly influenced this
	design. He happened to stumble upon it again while writing the earliest draft of this
	specification and it struck him how much it embodies Erik's ideas. In any case, this format
	is dedicated to Erik.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address><email>sob@harvard.edu</email></address>
          </author>
          <date month="March" year="1997"/>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
      </reference>

      <reference anchor="IANA-Charsets" target="http://www.iana.org/assignments/character-sets">
        <front>
          <title>
	    IANA Charset Registry (archived at):
          </title>
	  <date/>
        </front>
      </reference>

    </references>


    <references title="Informative references">

      <reference anchor="HTTP2">
	<front>
	  <title>Hypertext Transfer Protocol version 2.0</title>
	  <author initials="M." surname="Belshe" fullname="Mike Belshe">
	    <organization>Twist</organization>
	    <address>
	      <email>mbelshe@chromium.org</email>
	    </address>
	  </author>

	  <author initials="R." surname="Peon" fullname="Roberto Peon">
	    <organization>Google, Inc</organization>
	    <address>
	      <email>fenix@google.com</email>
	    </address>
	  </author>

	  <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
	    <organization>Microsoft</organization>
	    <address>
	      <postal>
		<street>3210 Porter Drive</street>
		<city>Palo Alto</city>
		<code>94304</code>
		<country>US</country>
	      </postal>
	      <email>martin.thomson@skype.net</email>
	    </address>
	  </author>

	  <author initials="A." surname="Melnikov" fullname="Alexey Melnikov" role="editor">
	    <organization>Isode Ltd</organization>
	    <address>
	      <postal>
		<street>5 Castle Business Village</street>
		<street>36 Station Road</street>
		<city>Hampton</city>
		<region>Middlesex</region>

		<code>TW12 2BX</code>
		<country>UK</country>
	      </postal>
	      <email>Alexey.Melnikov@isode.com</email>
	    </address>
	  </author>
	  <date month="July" year="2013"/>
	</front>
	<seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-http2-04"/>
      </reference>
      <reference anchor="Avro" target="http://avro.apache.org/docs/1.7.4/spec.html">
	<front>
	  <title>Apache Avro™ 1.7.4 Specification</title>
	  <author initials="D." surname ="Cutting" fullname="Doug Cutting">
            <organization>Cloudera</organization>
	  </author>
	  <date month="February" year="2013"/>
	</front>
      </reference>

      <reference anchor="protobuf" target="https://developers.google.com/protocol-buffers/">
	<front>
	  <title>Protocol Buffers</title>
	  <date month="July" year="2008"/>
	</front>
      </reference>

      <reference anchor="Smile" target="http://wiki.fasterxml.com/SmileFormat">
	<front>
	  <title>Smile Data Format</title>
	  <author initials="T." surname ="Saloranta" fullname="Tatu Saloranta">
	    <address><email>tsaloranta@gmail.com</email></address>
	  </author>
	  <date month="September" year="2010"/>
	</front>
      </reference>

      <reference anchor="Thrift" target="http://thrift.apache.org/static/files/thrift-20070401.pdf">
	<front>
	  <title>Thrift: Scalable Cross-Language Services Implementation</title>
	  <author initials="M." surname ="Slee" fullname="Mark Slee">
	    <organization>Facebook</organization>
	    <address><email>mcslee@facebook.com</email></address>
	  </author>
	  <author initials="A." surname ="Agarwal" fullname="Aditya Agarwal">
	    <organization>Facebook</organization>
	    <address><email>aditya@facebook.com</email></address>
	  </author>
	  <author initials="M." surname ="Kwiatkowski" fullname="Marc Kwiatkowski">
	    <organization>Facebook</organization>
	    <address><email>marc@facebook.com</email></address>
	  </author>
	  <date month="April" year="2007"/>
	</front>
      </reference>

    </references>

    <section anchor="robustNS" title="Robust namespace definition">
      <t>
	This constitutes a suggestion of architecture for a BULK processing application. It has the
	advantage that an agent cannot modify the values of names to which it has not specifically
	be given authority. This architecture doesn't ensure this property by checking the validity
	of definitions but by adhering to the Principle Of Least Authority, thus ensuring no false
	positives or TOCTOU race conditions.
      </t>
      <t>
	For each new context (including the abstract yield when parsing starts), the parser creates
	a new copy of each known namespace. These copies are available in this context to retrieve
	and define values. It implements the lexical scoping of definitions on top of providing the
	robustness properties discussed here.
      </t>
      <t>
	By default, all namespaces created in a context are discarded at the end of this context.
      </t>
      <t>
	Of course, an implementation of the architecture presented here can be optimized compared to
	the abstract algorithm, for example by using copy-on-demand.
      </t>
      <t>
	Any namespace that is not a copy for its context but the object retained by the application
	afterwards, gives authority to make long-lasting definitions. Such a namespace is called
	lasting here.
      </t>
      <section title="Selective authority">
	<t>
	  A number of lasting namespaces are included for the abstract yield. Their UUIDs are agreed
	  out-of-band. The disadvantage of this solution is that it needs prior agreement on the
	  definable namespaces.
	</t>
      </section>
      <section title="Open authority">
	<t>
	  Any <spanx style="verb">ns*</spanx> form for a UUID unknown to the processing application
	  triggers the creation a lasting namespace.
	</t>
	<t>
	  The disadvantage of this solution is that it opens a denial of service vulnerability. If
	  Bob is a processing application and Carol and Dave are agents communicating with Bob with
	  an open authority, Dave can prevent Carol from defining a namespace if it manages to know
	  the UUID and starting a communication with Bob before Carol.
	</t>
	<t>
	  If an agent uses a secure way to create UUIDs and protects their secrecy, this solution is
	  both flexible and safe.
	</t>
      </section>
    </section>

    <section title="Semantic leeway">
      <t>
	Atoms and forms have semantics and sometimes evaluation rules defined by this specification,
	but as long as parsing rules are maintained, a processing application MAY use any form and
	atom with different semantics and evaluation rules, as long as it is within the confines of
	a form that makes this semantics change explicit.
      </t>
      <t>
	For example, if an application needs to store a big number of unsigned integers and the
	overhead of the two marker bytes is too big, the application SHOULD bypass the default
	semantics of words and define a form in which they are taken as two's-complement
	notation. The following form could be interpreted as the sequence of integers (-1358102763
	35467 -100237):
	<figure>
	  <artwork>
( foo:sints w32 0xAF0CFF15 w16 0x8A8B w32 0xFFFE7873 )
	  </artwork>
	</figure>
      </t>
      <t>
	If an overhead of one byte per integer is still too big and the integers all have the same
	size, an application MAY pack them into an array. The sequence of integers (-14376 -235 4567
	-31299 42) could be serialized as:
	<figure>
	  <artwork>
( foo:array16 # w8 0xA 0xC7D8FF1511D785BD002A )
	  </artwork>
	</figure>
      </t>
      <t>
	BULK's syntax also enables hybrid solutions, for example by packing together into an array
	the sequences of same-size integers, among a sequence of words. So the sequence of integers
	(-1358102763 35467 -100237 -14376 -235 4567 -31299 42 -8449839282860229000) could be
	serialized as:
	<figure>
	  <artwork>
( foo:flatten w32 0xAF0CFF15 w16 0x8A8B w32 0xFFFE7873 ( foo:array16 # w8 0xA 0xC7D8FF1511D785BD002A
) w64 0x8ABC23F0FFF98283 )
	  </artwork>
	</figure>
      </t>
    </section>

  </back>
</rfc>

