<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-jose-json-web-signature-18">

  <front>
    <title>JSON Web Signature (JWS)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
	<uri>http://www.thread-safe.com/</uri>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization abbrev="NRI">Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
	<uri>http://nat.sakimura.org/</uri>
      </address>
    </author>

    <date day="12" month="November" year="2013" />

    <area>Security</area>
    <workgroup>JOSE Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Object Signing and Encryption</keyword>
    <keyword>JOSE</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>
    <keyword>JSON Web Algorithms</keyword>
    <keyword>JWA</keyword>

    <abstract>
      <t>
	JSON Web Signature (JWS) represents
	content secured with digital signatures or
	Message Authentication Codes (MACs)
	using JavaScript Object Notation (JSON) based data structures.
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) specification
	and an IANA registry defined by that specification.
	Related encryption capabilities are described in the separate
	JSON Web Encryption (JWE) specification.
      </t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction" anchor="Introduction">
      <t>
	JSON Web Signature (JWS) represents
	content secured with digital signatures or
	Message Authentication Codes (MACs)
	using JavaScript Object Notation (JSON) <xref target="RFC4627"/>
	based data structures.
	The JWS cryptographic mechanisms provide integrity protection for
	an arbitrary sequence of octets.
      </t>
      <t>
	Two closely related serializations for JWS objects are defined.
	The JWS Compact Serialization is a compact, URL-safe representation
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.
	The JWS JSON Serialization represents JWS objects as JSON objects and
	enables multiple signatures and/or MACs to be applied to the same content.
	Both share the same cryptographic underpinnings.
      </t>
      <t>
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) <xref target="JWA" /> specification
	and an IANA registry defined by that specification.
	Related encryption capabilities are described in the separate
	JSON Web Encryption (JWE) <xref target="JWE" /> specification.
      </t>
      <t>
	Names defined by this specification are short because a core goal is
	for the resulting representations to be compact.
      </t>

      <section title="Notational Conventions" anchor="NotationalConventions">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in
	  Key words for use in RFCs to Indicate Requirement Levels <xref target='RFC2119' />.
	  If these words are used without being spelled in uppercase then
	  they are to be interpreted with their normal natural language meanings.
        </t>
	<t>
	  BASE64URL(OCTETS) denotes the base64url encoding of OCTETS,
	  per <xref target="Terminology"/>.
	</t>
	<t>
	  UTF8(STRING) denotes the octets of the
	  UTF-8 <xref target="RFC3629"/> representation of STRING.
	</t>
	<t>
	  ASCII(STRING) denotes the octets of the
	  ASCII <xref target="USASCII"/> representation of STRING.
	</t>
	<t>
	  The concatenation of two values A and B
	  is denoted as A&nbsp;||&nbsp;B.
	</t>
      </section>

    </section>

    <section title="Terminology" anchor="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Signature (JWS)">
	    A data structure representing a digitally signed or MACed message.
	  </t>

          <t hangText="JWS Header">
	    A JSON object
	    (or JSON objects, when using the JWS JSON Serialization)
	    that describes the
	    digital signature or MAC operation applied to
	    create the JWS Signature value.
	    The members of the JWS Header object(s) are Header Parameters.
	  </t>
          <t hangText="JWS Payload">
	    The sequence of octets to be secured -- a.k.a., the message.
	    The payload can contain an arbitrary sequence of octets.
	  </t>
          <t hangText="JWS Signature">
	    A sequence of octets containing the cryptographic material that
	    ensures the integrity of
	    the JWS Protected Header
	    and the JWS Payload.
	    The JWS Signature value is a digital signature or MAC value
	    calculated over the JWS Signing Input using the parameters
	    specified in the JWS Header.
	  </t>

          <t hangText="JWS Protected Header">
	    A JSON object that contains the portion of the
	    JWS Header that is integrity protected.
	    For the JWS Compact Serialization, this comprises the entire JWS Header.
	    For the JWS JSON Serialization, this is one component of the JWS Header.
	  </t>

	  <t hangText="Header Parameter">
	    A name/value pair that is member of the JWS Header.
	  </t>

          <t hangText="Base64url Encoding">
	    Base64 encoding using the URL- and filename-safe
	    character set defined in Section 5 of <xref target="RFC4648">RFC 4648</xref>,
	    with all trailing '=' characters omitted (as permitted by Section 3.2).
	    (See <xref target="base64urlnotes" /> for notes on
	    implementing base64url encoding without padding.)
	  </t>

	  <t hangText="JWS Signing Input">
	    The input to the digital signature or MAC computation.
	    Its value is
	    ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)).
	  </t>

	  <t hangText="JWS Compact Serialization">
	    A representation of the JWS as a compact, URL-safe string.
	  </t>

	  <t hangText="JWS JSON Serialization">
	    A representation of the JWS as a JSON object.
	    Unlike the JWS Compact Serialization,
	    the JWS JSON Serialization
	    enables multiple digital signatures and/or MACs to
	    be applied to the same content.
	    This representation is neither compact nor URL-safe.
	  </t>

	  <t hangText="Collision-Resistant Name">
	    A name in a namespace that enables names to be allocated in a manner
	    such that they are highly unlikely to collide with other names.
	    Examples of collision-resistant namespaces include:
	    Domain Names,
	    Object Identifiers (OIDs) as defined in the ITU-T X.660
	    and X.670 Recommendation series, and
	    Universally Unique IDentifiers (UUIDs)
	    <xref target="RFC4122"/>.
	    When using an administratively delegated namespace,
	    the definer of a name needs to take
	    reasonable precautions to ensure they are in control of
	    the portion of the namespace they use to define the name.
	  </t>

	  <t hangText="StringOrURI">
	    A JSON string value, with the additional requirement that
	    while arbitrary string values MAY be used, any value
	    containing a ":" character MUST be a URI
	    <xref target="RFC3986"/>.
	    StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied.
	  </t>

        </list>
      </t>
    </section>

    <section title="JSON Web Signature (JWS) Overview" anchor="Overview">

      <t>
	JWS represents digitally signed or MACed content using JSON data
	structures and base64url encoding.
	A JWS represents these logical values:
	<list style="hanging">
	  <t hangText="JWS Header">
	    JSON object containing the parameters
	    describing the cryptographic operations and parameters employed.
	    The JWE Header members are the union of the members of
	    the JWS Protected Header
	    and the JWS Unprotected Header, as described below.
	  </t>
	  <t hangText="JWS Payload">
	    Message content to be secured.
	  </t>
	  <t hangText="JWS Signature">
	    Digital signature or MAC over
	    the JWS Protected Header and the JWS Payload.
	  </t>
	</list>
	The JWS Header represents the combination of these logical values:
	<list style="hanging">
	  <t hangText="JWS Protected Header">
	    JSON object containing some of the parameters
	    describing the cryptographic operations and parameters employed.
	    This value is integrity protected in
	    the digital signature or MAC calculation of the JWS Signature.
	  </t>
	  <t hangText="JWS Unprotected Header">
	    JSON object containing some of the parameters
	    describing the cryptographic operations and parameters employed.
	    This value is not integrity protected in
	    the digital signature or MAC calculation of the JWS Signature.
	  </t>
	</list>
      </t>
      <t>
	This document defines two serializations for JWS objects:
	a compact, URL-safe serialization called the JWS Compact Serialization
	and a JSON serialization called the JWS JSON Serialization.
	In both serializations, the
	JWS Protected Header,
	JWS Payload, and
	JWS Signature
	are base64url encoded for transmission,
	since JSON lacks a way to directly represent octet sequences.
      </t>
      <t>
	In the JWS Compact Serialization, no JWS Unprotected Header is used.
	In this case, the JWS Header and the JWS Protected Header are the same.
      </t>
      <t>
	In the JWS Compact Serialization, a JWS object is represented as the
	combination of these three string values,
	<?rfc subcompact="yes"?>
	<list style="empty">
	  <t>BASE64URL(UTF8(JWS Protected Header)),</t>
	  <t>BASE64URL(JWS Payload), and</t>
	  <t>BASE64URL(JWS Signature),</t>
	</list>
	<?rfc subcompact="no"?>
	concatenated in that order,
	with the three strings being separated by two period ('.') characters.
      </t>
      <t>
	In the JWS JSON Serialization, one or both of the JWS Protected Header
	and JWS Unprotected Header MUST be present.
	In this case, the members of the JWS Header are the combination of
	the members of the JWS Protected Header and the JWS Unprotected Header
	values that are present.
      </t>
      <t>
	In the JWS JSON Serialization, a JWS object is represented as the
	combination of these four values,
	<?rfc subcompact="yes"?>
	<list style="empty">
	  <t>BASE64URL(UTF8(JWS Protected Header)),</t>
	  <t>JWS Unprotected Header,</t>
	  <t>BASE64URL(JWS Payload), and</t>
	  <t>BASE64URL(JWS Signature),</t>
	</list>
	with the three base64url encoding result strings
	and the JWS Unprotected Header value
	being represented as members within a JSON object.
	The inclusion of some of these values is OPTIONAL.
	The JWS JSON Serialization can also represent
	multiple signature and/or MAC values, rather than just one.
	See <xref target="JSONSerialization"/> for more information
	about the JWS JSON Serialization.
      </t>

      <section title="Example JWS" anchor="ExampleJWS">

	<t>
	  This section provides an example of a JWS.
	  Its computation is described in more detail in <xref target="HS256Example"/>,
	  including specifying the exact octet sequences representing the JSON values used
	  and the key value used.
	</t>
	<t>
	  The following example JWS Protected Header declares that the
	  encoded object is a JSON Web Token (JWT) <xref target="JWT" />
	  and the JWS Protected Header and the JWS Payload are
	  secured using the HMAC SHA-256 algorithm:
	</t>

	<figure><artwork><![CDATA[
  {"typ":"JWT",
   "alg":"HS256"}
]]></artwork></figure>

	<t>
	  Encoding this JWS Protected Header as
	  BASE64URL(UTF8(JWS Protected Header)) gives this value:
	</t>

	<figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
]]></artwork></figure>

	<t>
	  The UTF-8 representation of following JSON object is used as the JWS Payload.
	  (Note that the payload can be any
	  content, and need not be a representation of a JSON object.)
	</t>

	<figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	<t>
	  Encoding this JWS Payload as
	  BASE64URL(JWS Payload) gives this value
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	<t>
	  Computing the HMAC of the JWS Signing Input
	  ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload))
	  with the HMAC SHA-256 algorithm
	  using the key specified in <xref target="HS256Example" />
	  and base64url encoding the result
	  yields this BASE64URL(JWS Signature) value:
	</t>

	<figure><artwork><![CDATA[
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	<t>
	  See <xref target="JWSExamples"/> for additional examples.
	</t>

      </section>
    </section>

    <section title="JWS Header" anchor="Header">

      <t>
	The members of the JSON object(s) representing the JWS Header describe the
	digital signature or MAC applied to the
	JWS Protected Header and the JWS Payload and optionally
	additional properties of the JWS.
	The Header Parameter names within the JWS Header MUST be unique;
	recipients MUST either reject JWSs with duplicate Header Parameter names
	or use a JSON parser that returns only the lexically last duplicate member name,
	as specified in Section 15.12 (The JSON Object) of
	ECMAScript 5.1 <xref target="ECMAScript"/>.
      </t>
      <t>
	Implementations are required to understand
	the specific Header Parameters defined by this specification 
	that are designated as "MUST be understood"
	and process them in the manner defined in this specification.
	All other Header Parameters defined by this specification that
	are not so designated MUST be ignored when not understood.
	Unless listed as a critical Header Parameter, per <xref target="critDef"/>,
	all Header Parameters not defined by this specification
	MUST be ignored when not understood.
      </t>
      <t>
        There are three classes of Header Parameter names:
	Registered Header Parameter names, Public Header Parameter names,
	and Private Header Parameter names.
      </t>

      <section title="Registered Header Parameter Names" anchor="RegisteredHeaderParameterName">
	<t>
	  The following Header Parameter names are registered
	  in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  defined in
	  <xref target="HdrReg"/>,
	  with meanings as defined below.
	</t>
	<t>
	  As indicated by the common registry, JWSs and JWEs share a
	  common Header Parameter space; when a parameter is used by
	  both specifications, its usage must be compatible
	  between the specifications.
	</t>

	<section title='"alg" (Algorithm) Header Parameter' anchor="algDef">
	  <t>
	    The <spanx style="verb">alg</spanx> (algorithm) Header Parameter
	    identifies the cryptographic algorithm used to
	    secure the JWS.
	    The signature, MAC, or plaintext value is not valid if the <spanx style="verb">alg</spanx>
	    value does not represent a supported algorithm, or if there is not a
	    key for use with that algorithm associated with the
	    party that digitally signed or MACed the content.
	    <spanx style="verb">alg</spanx> values should either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    defined in
	    <xref target="JWA" /> or be
	    a value that contains a Collision-Resistant Name.
	    The <spanx style="verb">alg</spanx> value is a case-sensitive string
	    containing a StringOrURI value.
	    This Header Parameter MUST be present
	    and MUST be understood and processed by implementations.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">alg</spanx> values
	    for this use can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    defined in
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 3.1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"jku" (JWK Set URL) Header Parameter' anchor="jkuDef">
	  <t>
	    The <spanx style="verb">jku</spanx> (JWK Set URL)
	    Header Parameter is a URI <xref target="RFC3986"/> that refers to a
	    resource for a set of JSON-encoded public keys, one of which
	    corresponds to the key
	    used to digitally sign the JWS.
	    The keys MUST be encoded as a JSON Web Key Set (JWK Set) <xref target="JWK" />.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    JWK Set MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"jwk" (JSON Web Key) Header Parameter' anchor="jwkDef">
	  <t>
	    The <spanx style="verb">jwk</spanx> (JSON Web Key)
	    Header Parameter is the public key
	    that corresponds to the key
	    used to digitally sign the JWS.
	    This key is represented as a JSON Web Key <xref target="JWK" />.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5u" (X.509 URL) Header Parameter' anchor="x5uDef">
	  <t>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) Header Parameter
	    is a URI <xref target="RFC3986"/> that refers to a resource for
	    the X.509 public key certificate or certificate chain <xref target="RFC5280"/>
	    corresponding to the key
	    used to digitally sign the JWS.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <xref target="RFC5280">RFC 5280</xref> in PEM encoded form
	    <xref target="RFC1421"/>.
	    The certificate containing the public key
	    corresponding to the key
	    used to digitally sign the JWS
	    MUST be the first certificate.
	    This MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter' anchor="x5tDef">
	  <t>
	    The <spanx style="verb">x5t</spanx> (X.509 Certificate SHA-1 Thumbprint)
	    Header Parameter is a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of
	    the X.509 certificate <xref target="RFC5280"/>
	    corresponding to the key
	    used to digitally sign the JWS.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	  <t>
	    If, in the future, certificate thumbprints need to be
	    computed using hash functions other than SHA-1, it is
	    suggested that additional related Header Parameters be
	    defined for that purpose.  For example, it is suggested
	    that a new <spanx style="verb">x5t#S256</spanx>
	    (X.509 Certificate Thumbprint using SHA-256) Header Parameter
	    could be defined by registering it in the IANA
	    JSON Web Signature and Encryption Header Parameters registry
	    defined in
	    <xref target="HdrReg" />.
	  </t>
	</section>

	<section title='"x5c" (X.509 Certificate Chain) Header Parameter' anchor="x5cDef">
	  <t>
	    The <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    Header Parameter contains the X.509 public key
	    certificate or certificate chain <xref target="RFC5280"/>
	    corresponding to the key
	    used to digitally sign the JWS.
	    The certificate or certificate chain is represented as
	    a JSON array of certificate value strings.
	    Each string in the array is a base64 encoded
	    (<xref target="RFC4648"/> Section 4 -- not base64url encoded)
	    DER <xref target="ITU.X690.1994"/> PKIX certificate value.
	    The certificate containing the public key
	    corresponding to the key
	    used to digitally sign the JWS
	    MUST be the first certificate.
	    This MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The recipient MUST verify the certificate chain according
	    to <xref target="RFC5280"/> and reject the signature if any
	    validation failure occurs.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	  <t>
	    See <xref target="x5cExample"/> for an example
	    <spanx style="verb">x5c</spanx> value.
	  </t>
	</section>

	<section title='"kid" (Key ID) Header Parameter' anchor="kidDef">
	  <t>
	    The <spanx style="verb">kid</spanx> (key ID) Header Parameter
	    is a hint indicating which key
	    was used to secure the JWS.
	    This parameter allows originators to explicitly signal a change of
	    key to recipients.
	    The structure of the
	    <spanx style="verb">kid</spanx> value is unspecified.
	    Its value MUST be a string.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	  <t>
	    When used with a JWK, the <spanx style="verb">kid</spanx>
	    value is used to match a JWK <spanx style="verb">kid</spanx>
	    parameter value.
	  </t>
	</section>

	<section title='"typ" (Type) Header Parameter' anchor="typDef">

	  <t>
	    The <spanx style="verb">typ</spanx> (type) Header Parameter
	    is used to declare the
	    MIME Media Type <xref target="IANA.MediaTypes"/>
	    of this complete JWS object
	    in contexts where this is useful to the application.
	    This parameter has no effect upon the JWS processing.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	  <t>
	    Per <xref target="RFC2045"/>, all media type values,
	    subtype values, and parameter names are case-insensitive.
	    However, parameter values are case-sensitive unless
	    otherwise specified for the specific parameter.
	  </t>
	  <t>
	    To keep messages compact in common situations,
	    it is RECOMMENDED that senders omit an "application/" prefix
	    of a media type value in a <spanx style="verb">typ</spanx>
	    Header Parameter when no other '/' appears in the media type value.
	    A recipient using the media type value MUST treat it as if
	    "application/" were prepended to any
	    <spanx style="verb">typ</spanx> value not containing a '/'.
	    For instance, a <spanx style="verb">typ</spanx> value of
	    <spanx style="verb">example</spanx> SHOULD be used to represent
	    the <spanx style="verb">application/example</spanx> media type;
	    whereas, the media type
	    <spanx style="verb">application/example;part="1/2"</spanx> cannot
	    be shortened to <spanx style="verb">example;part="1/2"</spanx>.
	  </t>
	  <t>
	    The <spanx style="verb">typ</spanx> value
	    <spanx style="verb">JOSE</spanx> can be used by applications
	    to indicate that this object is a JWS or JWE using
	    the JWS Compact Serialization or the JWE Compact Serialization.
	    The <spanx style="verb">typ</spanx> value
	    <spanx style="verb">JOSE+JSON</spanx> can be used by applications
	    to indicate that this object is a JWS or JWE using
	    the JWS JSON Serialization or the JWE JSON Serialization.
	    Other type values can also be used by applications.
	  </t>

	</section>

	<section title='"cty" (Content Type) Header Parameter' anchor="ctyDef">

	  <t>
	    The <spanx style="verb">cty</spanx> (content type) Header Parameter
	    is used to declare the
	    MIME Media Type <xref target="IANA.MediaTypes"/>
	    of the secured content (the payload)
	    in contexts where this is useful to the application.
	    This parameter has no effect upon the JWS processing.
	    Use of this Header Parameter is OPTIONAL.
	  </t>
	  <t>
	    Per <xref target="RFC2045"/>, all media type values,
	    subtype values, and parameter names are case-insensitive.
	    However, parameter values are case-sensitive unless
	    otherwise specified for the specific parameter.
	  </t>
	  <t>
	    To keep messages compact in common situations,
	    it is RECOMMENDED that senders omit an "application/" prefix
	    of a media type value in a <spanx style="verb">cty</spanx>
	    Header Parameter when no other '/' appears in the media type value.
	    A recipient using the media type value MUST treat it as if
	    "application/" were prepended to any
	    <spanx style="verb">cty</spanx> value not containing a '/'.
	    For instance, a <spanx style="verb">cty</spanx> value of
	    <spanx style="verb">example</spanx> SHOULD be used to represent
	    the <spanx style="verb">application/example</spanx> media type;
	    whereas, the media type
	    <spanx style="verb">application/example;part="1/2"</spanx> cannot
	    be shortened to <spanx style="verb">example;part="1/2"</spanx>.
	  </t>

	</section>

	<section title='"crit" (Critical) Header Parameter' anchor="critDef">
	  <t>
	    The <spanx style="verb">crit</spanx> (critical) Header Parameter
	    indicates that extensions to the initial RFC versions of
	    [[ this specification ]] and <xref target="JWA"/> are being used
	    that MUST be understood and processed.
	    Its value is an array listing the Header Parameter names
	    present in the JWS Header that use those extensions.
	    If any of the listed extension Header Parameters are not
	    understood and supported by the receiver, it MUST reject the JWS.
	    Senders must not include Header Parameter names defined by
	    the initial RFC versions of
	    [[ this specification ]] or <xref target="JWA"/> for use with JWS,
	    duplicate names, or
	    names that do not occur as Header Parameter names within the JWS Header
	    in the <spanx style="verb">crit</spanx> list.
	    Senders MUST not use the empty list <spanx style="verb">[]</spanx>
	    as the <spanx style="verb">crit</spanx> value.
	    Recipients MAY reject the JWS if the critical list
	    contains any Header Parameter names defined by the initial RFC versions of
	    [[ this specification ]] or <xref target="JWA"/> for use with JWS,
	    or any other constraints on its use are violated.
	    This Header Parameter MUST be integrity protected, and therefore
	    MUST occur only within the JWS Protected Header, when used.
	    Use of this Header Parameter is OPTIONAL.
	    This Header Parameter MUST be understood and processed by implementations.
	  </t>
	  <t>
	    <figure>
	      <preamble>
		An example use, along with a hypothetical
		<spanx style="verb">exp</spanx> (expiration-time) field is:
	      </preamble>
	      <artwork><![CDATA[
  {"alg":"ES256",
   "crit":["exp"],
   "exp":1363284000
  }
]]></artwork>
	    </figure>
	  </t>
	</section>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional Header Parameter names can be defined by those
	  using JWSs. However, in order to prevent collisions, any new
	  Header Parameter name should either be registered in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  defined in
	  <xref target="HdrReg" /> or be a Public Name:
	  a value that contains a Collision-Resistant Name.
	  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the Header Parameter name.
	</t>
	<t>
	  New Header Parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWS may agree to use Header Parameter names
	  that are Private Names:  names that are
	  not Registered Header Parameter names <xref target="RegisteredHeaderParameterName"></xref>
	  or Public Header Parameter names <xref target="PublicHeaderParameterName"></xref>.
	  Unlike Public Header Parameter names,
	  Private Header Parameter names are subject to collision and
	  should be used with caution.
	</t>

      </section>
    </section>

    <section title="Producing and Consuming JWSs" anchor="JWSRules">

      <section title="Message Signature or MAC Computation" anchor="MessageSignature">
	<t>
	  To create a JWS, one MUST perform these steps.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.

	  <list style="numbers">

	    <t>
	      Create the content to be used as the JWS Payload.
	    </t>
	    <t>
	      Compute the encoded payload value BASE64URL(JWS Payload).
	    </t>
	    <t>
	      Create the JSON object(s) containing the desired set of Header Parameters,
	      which together comprise the JWS Header:
	      the JWS Protected Header, and if the JWS JSON Serialization is being used,
	      the JWS Unprotected Header.
	    </t>
	    <t>
	      Compute the encoded header value BASE64URL(UTF8(JWS Protected Header)).
	      If the JWS Protected Header is not present
	      (which can only happen when using the JWS JSON Serialization
	      and no <spanx style="verb">protected</spanx> member is present),
	      let this value be the empty string.
	    </t>
	    <t>
	      Compute the JWS Signature in the manner defined for
	      the particular algorithm being used over the JWS Signing Input
	      ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)).
	      The <spanx style="verb">alg</spanx> (algorithm) Header Parameter MUST be
	      present in the JWS Header, with the algorithm value
	      accurately representing the algorithm used to construct
	      the JWS Signature.
	    </t>
	    <t>
	      Compute the encoded signature value BASE64URL(JWS Signature).
	    </t>
	    <t>
	      These three encoded values are used in both the
	      JWS Compact Serialization and the JWS JSON Serialization representations.
	    </t>
	    <t>
	      If the JWS JSON Serialization is being used, repeat this process
	      (steps 1-7) <!-- TBD Make sure that these numbers are correct -->
	      for each digital signature or MAC value being applied.
	    </t>
	    <t>
	      Create the desired serialized output.
	      The JWS Compact Serialization of this result is
	      BASE64URL(UTF8(JWS Protected Header))
	      || '.' || BASE64URL(JWS Payload)
	      || '.' || BASE64URL(JWS Signature).
	      The JWS JSON Serialization is described in <xref target="JSONSerialization"/>.
	    </t>
	  </list>
	</t>
      </section>

      <section title="Message Signature or MAC Validation" anchor="MessageValidation">
	<t>
	  When validating a JWS, the following steps MUST be taken.
	  The order of the steps is not significant in cases where
	  there are no dependencies between the inputs and outputs of the steps.
	  If any of the listed steps fails, then the signature or MAC cannot be validated.
	</t>
	<t>
	  It is an application decision which signatures, MACs, or plaintext values
	  must successfully validate for the JWS to be accepted.
	  In some cases, all must successfully validate or the JWS will be rejected.
	  In other cases, only a specific signature, MAC, or plaintext value
	  needs to be successfully validated.
	  However, in all cases, at least one signature, MAC, or plaintext value
	  MUST successfully validate or the JWS MUST be rejected.
	</t>
	<t>
	  <list style="numbers">
	    <t>
	      Parse the JWS representation to extract the serialized values
	      for the components of the JWS --
	      when using the JWS Compact Serialization,
	      the base64url encoded representations of
	      the JWS Protected Header,
	      the JWS Payload, and
	      the JWS Signature,
	      and when using the JWS JSON Serialization,
	      also the unencoded JWS Unprotected Header value.
	      When using the JWS Compact Serialization,
	      the JWS Protected Header,
	      the JWS Payload, and
	      the JWS Signature
	      are represented as base64url encoded values in that order,
	      separated by two period ('.') characters.
	      The JWS JSON Serialization
	      is described in <xref target="JSONSerialization"/>.
	    </t>
	    <t>
	      The encoded representation of the
	      JWS Protected Header
	      MUST be successfully base64url decoded following the
	      restriction that no padding characters have been used.
	    </t>
	    <t>
	      The resulting octet sequence
	      MUST be a UTF-8 encoded representation of
	      a completely valid JSON object
	      conforming to <xref target="RFC4627">RFC 4627</xref>,
	      which is the JWS Protected Header.
	    </t>
	    <t>
	      If using the JWS Compact Serialization, let the JWS Header be the
	      JWS Protected Header;
	      otherwise, when using the JWS JSON Serialization,
	      let the JWS Header be the union of
	      the members of the corresponding JWS Protected Header
	      and JWS Unprotected Header,
	      all of which must be completely valid JSON objects.
	    </t>
	    <t>
	      The resulting JWS Header MUST NOT contain duplicate
	      Header Parameter names.
	      When using the JWS JSON Serialization, this restriction includes
	      that the same Header Parameter name also MUST NOT occur in
	      distinct JSON object values that together comprise the JWS Header.
	    </t>
	    <t>
	      Verify that the implementation understands and can process
	      all fields that it is required to support,
	      whether required by this specification,
	      by the algorithm being used,
	      or by the <spanx style="verb">crit</spanx> Header Parameter value,
	      and that the values of those parameters are also understood and supported.
	    </t>
	    <t>
	      The encoded representation of the
	      JWS Payload MUST be successfully base64url
	      decoded following the restriction that
	      no padding characters have been used.
	    </t>
	    <t>
	      The encoded representation of the
	      JWS Signature MUST be successfully base64url
	      decoded following the restriction that
	      no padding characters have been used.
	    </t>
	    <t>
	      The JWS Signature MUST be successfully validated
	      against the JWS Signing Input
	      ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload))
	      in the manner defined for the algorithm being used, which
	      MUST be accurately represented by the value of the <spanx style="verb">alg</spanx> (algorithm)
	      Header Parameter, which MUST be present.
	    </t>
	    <t>
	      If the JWS JSON Serialization is being used, repeat this process
	      (steps 1-9) <!-- TBD Make sure that these numbers are correct -->
	      for each digital signature or MAC value contained in the representation.
	    </t>
	  </list>
	</t>
      </section>

      <section title="String Comparison Rules" anchor="StringComparison">

	<t>
	  Processing a JWS inevitably requires comparing known strings
	  to members and values in a JSON object. For example, in checking what the
	  algorithm is, the Unicode string
	  <spanx style="verb">alg</spanx> will be
	  checked against the member names in the JWS Header
	  to see if there is a matching Header Parameter name.
	  The same process is then used to determine if the value
	  of the <spanx style="verb">alg</spanx> Header Parameter
	  represents a supported algorithm.
	</t>
	<t>
	  Since the only string comparision operations that are performed are
	  equality and inequality, the same rules can be used for comparing
	  both member names and member values against known strings.
	  The JSON rules for doing member name comparison are described in
	  Section 8.3 of <xref target="I-D.ietf-json-rfc4627bis"/>.
	</t>
	<t>
	  Also, see the JSON security considerations in <xref target="JSONSecCon"/> and
	  the Unicode security considerations in <xref target="UnicodeSecCon"/>.
	</t>
      </section>

    </section>

    <section title="Key Identification" anchor="IDingKeys">
      <t>
	It is necessary for the recipient of a JWS to be able to determine
	the key that was employed for the digital signature or MAC operation.
	The key employed can be identified using the
	Header Parameter methods described in <xref
	target="RegisteredHeaderParameterName" /> or can be identified
	using methods that are outside the scope of this specification.
	Specifically, the Header Parameters
	<spanx style="verb">jku</spanx>,
	<spanx style="verb">jwk</spanx>,
	<spanx style="verb">x5u</spanx>,
	<spanx style="verb">x5t</spanx>,
	<spanx style="verb">x5c</spanx>,
	and <spanx style="verb">kid</spanx>
	can be used to identify the key used.
	These Header Parameters MUST be integrity protected if the
	information that they convey is to be utilized in a trust decision.
      </t>
      <t>
	The sender SHOULD include sufficient information in the Header Parameters
	to identify the key used, unless the application uses another means
	or convention to determine the key used.
	Validation of the signature or MAC fails when
	the algorithm used requires a key
	(which is true of all algorithms except for <spanx style="verb">none</spanx>) and
	the key used cannot be determined.
      </t>
      <t>
	The means of exchanging any shared symmetric keys used
	is outside the scope of this specification. 
      </t>
    </section>

    <section title="Serializations" anchor="Serializations">

      <t>
	JWS objects use one of two serializations, the
	JWS Compact Serialization
	or the
	JWS JSON Serialization.
	Applications using this specification need to specify what serialization
	and serialization features are used for that application.
	For instance, applications might specify
	that only the JWS JSON Serialization is used,
	that only JWS JSON Serialization support for a single signature or MAC value is used,
	or that support for multiple signatures and/or MAC values is used.
	JWS implementations only need to implement the features needed
	for the applications they are designed to support.
      </t>

      <section title="JWS Compact Serialization" anchor="CompactSerialization">

	<t>
	  The JWS Compact Serialization represents digitally signed or MACed
	  content as a compact URL-safe string.
	  This string is
	  BASE64URL(UTF8(JWS Protected Header))
	  || '.' || BASE64URL(JWS Payload)
	  || '.' || BASE64URL(JWS Signature).
	  Only one signature/MAC is supported by the JWS Compact Serialization
	  and it provides no syntax to represent a JWS Unprotected Header value.
	</t>

      </section>

      <section title="JWS JSON Serialization" anchor="JSONSerialization">

	<t>
	  The JWS JSON Serialization represents digitally signed or MACed
	  content as a JSON object.
	  Unlike the JWS Compact Serialization, content using
	  the JWS JSON Serialization can be secured with more than one
	  digital signature and/or MAC value.
	</t>
	<t>
	  The representation is closely related to that used in the
	  JWS Compact Serialization,
	  with the following differences for the
	  JWS JSON Serialization:
	  <list style="symbols">
	    <t>
	      Values in the JWS JSON Serialization are represented as members of
	      a JSON object, rather than as base64url encoded strings
	      separated by period ('.') characters.
	      (However binary values and values that are integrity protected
	      are still base64url encoded.)
	    </t>
	    <t>
	      The value BASE64URL(JWS Payload) is stored in the
	      <spanx style="verb">payload</spanx> member.
	    </t>
	    <t>
	      There can be multiple signature and/or MAC values, rather than just one.
	      A JSON array in the <spanx style="verb">signatures</spanx> member
	      is used to hold values that are specific to a particular
	      signature or MAC computation,
	      with one array element per signature/MAC represented.
	      These array elements are JSON objects.
	    </t>
	    <t>
	      Each value BASE64URL(JWS Signature), if non-empty, is stored in the
	      <spanx style="verb">signature</spanx> member of a JSON object
	      that is an element of the <spanx style="verb">signatures</spanx> array.
	    </t>
	    <t>
	      Each value BASE64URL(UTF8(JWS Protected Header)),
	      if non-empty, is stored in the
	      <spanx style="verb">protected</spanx> member of the corresponding
	      element of the <spanx style="verb">signatures</spanx> array.
	    </t>
	    <t>
	      Each JWS Unprotected Header value,
	      if non-empty, is stored in the
	      <spanx style="verb">header</spanx> member of the corresponding
	      element of the <spanx style="verb">signatures</spanx> array.
	      If present, a JWS Unprotected Header value is
	      represented as an unencoded JSON object,
	      rather than as a string.
	    </t>
	    <t>
	      The Header Parameter values used when creating or validating
	      individual signature or MAC values are
	      the union of the two sets of Header Parameter values that may be present:
	      (1) the JWS Protected Header values
	      represented in the <spanx style="verb">protected</spanx>
	      member of the signature/MAC's array element, and
	      (2) the JWS Unprotected Header values
	      in the <spanx style="verb">header</spanx>
	      member of the signature/MAC's array element.
	      The union of these sets of Header Parameters comprises the JWS Header.
	      The Header Parameter names in the two locations MUST be disjoint.
	    </t>
	  </list>
	</t>

	<figure>
	  <preamble>
	    The syntax of a JWS using the JWS JSON Serialization is as follows:
	  </preamble>
	  <artwork><![CDATA[
  {
   "payload":"<payload contents>"
   "signatures":[
    {"protected":<integrity-protected header 1 contents>",
     "header":"<non-integrity-protected header 1 contents>",
     "signature":"<signature 1 contents>"},
    ...
    {"protected":<integrity-protected header N contents>",
     "header":"<non-integrity-protected header N contents>",
     "signature":"<signature N contents>"}],
  }
]]></artwork></figure>

	<t>
	  Of these members, only the
	  <spanx style="verb">payload</spanx>,
	  <spanx style="verb">signatures</spanx>,
	  and <spanx style="verb">signature</spanx>
	  members MUST be present.
	  At least one of the
	  <spanx style="verb">protected</spanx> and
	  <spanx style="verb">header</spanx>
	  members MUST be present for each signature/MAC computation
	  so that an <spanx style="verb">alg</spanx>
	  Header Parameter value is conveyed.
	</t>
	<t>
	  The contents of the
	  JWS Payload and
	  JWS Signature
	  values are exactly as defined in the rest of this specification.
	  They are interpreted and validated in the same manner,
	  with each corresponding
	  JWS Signature and 
	  set of Header Parameter values
	  being created and validated together.
	  The JWS Header values used are the union of the Header Parameters in the
	  corresponding JWS Protected Header and
	  JWS Unprotected Header values,
	  as described earlier.
	</t>
	<t>
	  Each JWS Signature value is computed on the
	  JWS Signing Input using the
	  parameters of the corresponding JWS Header value
	  in the same manner as for the JWS Compact Serialization.
	  This has the desirable property that each
	  JWS Signature value represented
	  in the <spanx style="verb">signatures</spanx> array
	  is identical to the value
	  that would have been computed for the same parameter
	  in the JWS Compact Serialization,
	  provided that the JWS Protected Header value
	  for that signature/MAC computation
	  (which represents the integrity-protected Header Parameter values)
	  matches that used in
	  the JWS Compact Serialization.
	</t>
	<t>
	  See <xref target="JSONSerializationExample"/> for an example
	  of computing a JWS using the JWS JSON Serialization.
	</t>

      </section>

    </section>

    <section anchor="TLS_requirements" title="TLS Requirements">
      <t>
	Implementations MUST support TLS.
	Which version(s) ought to be implemented will vary over
	time, and depend on the widespread deployment and known
	security vulnerabilities at the time of implementation.
	At the time of this writing,
	TLS version 1.2 <xref target='RFC5246' />
	is the most recent version, but has very limited actual
	deployment, and might not be readily available in
	implementation toolkits.
	TLS version 1.0 <xref target='RFC2246' />
	is the most widely deployed version, and will give the
	broadest interoperability.
      </t>
      <t>
	To protect against information disclosure and tampering,
	confidentiality protection MUST be applied using TLS
	with a ciphersuite that provides confidentiality and
	integrity protection.
      </t>
      <t>
	Whenever TLS is used, a TLS server certificate check
	MUST be performed, per <xref target="RFC6125">RFC 6125</xref>.
      </t>
    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	The following registration procedure is used for all the
	registries established by this specification.
      </t>
      <t>
	Values are registered with a Specification Required
	<xref target="RFC5226"/> after a two-week review period on the [TBD]@ietf.org mailing
	list, on the advice of one or more Designated Experts. However, to allow for the
	allocation of values prior to publication, the Designated Expert(s) may approve
	registration once they are satisfied that such a specification will be published.
      </t>
      <t>
	Registration requests must be sent to the [TBD]@ietf.org mailing list for review and
	comment, with an appropriate subject (e.g., "Request for access token type: example").
	[[ Note to the RFC Editor:
	The name of the mailing list should be determined in consultation
	with the IESG and IANA. Suggested name: jose-reg-review. ]]
      </t>
      <t>
	Within the review period, the Designated Expert(s) will either approve or
	deny the registration request, communicating this decision to the review list and IANA.
	Denials should include an explanation and, if applicable, suggestions as to how to make
	the request successful.
	Registration requests that are undetermined for
	a period longer than 21 days can be brought to the IESG's attention
	(using the iesg@iesg.org mailing list) for resolution.
      </t>
      <t>
	Criteria that should be applied by the Designated Expert(s) includes
	determining whether the proposed registration duplicates existing functionality,
	determining whether it is likely to be of general applicability
	or whether it is useful only for a single application,
	and whether the registration makes sense.
      </t>
      <t>
	IANA must only accept registry updates from the Designated Expert(s) and should direct
	all requests for registration to the review mailing list.
      </t>
      <t>
	It is suggested that multiple Designated Experts be appointed who are able to
	represent the perspectives of different applications using this specification,
	in order to enable broadly-informed review of registration decisions.
	In cases where a registration decision could be perceived as
	creating a conflict of interest for a particular Expert,
	that Expert should defer to the judgment of the other Expert(s).
      </t>

      <section title="JSON Web Signature and Encryption Header Parameters Registry" anchor="HdrReg">
	<t>
	  This specification establishes the
	  IANA JSON Web Signature and Encryption Header Parameters registry
	  for JWS and JWE Header Parameter names.
	  The registry records the Header Parameter name
	  and a reference to the specification that defines it.
	  The same Header Parameter name can be registered multiple times,
	  provided that the parameter usage is compatible
	  between the specifications.
	  Different registrations of the same Header Parameter name
	  will typically use different
	  Header Parameter Usage Location(s) values.
	</t>

        <section title="Registration Template" anchor="HdrTemplate">
          <t>
            <list style='hanging'>
              <t hangText='Header Parameter Name:'>
                <vspace />
                The name requested (e.g., "example").
		Because a core goal of this specification is for the resulting
		representations to be compact, it is RECOMMENDED that the name be short
		-- not to exceed 8 characters without a compelling reason to do so.
		This name is case-sensitive.
		Names may not match other registered names in a case-insensitive manner
		unless the Designated Expert(s) state that there is a compelling reason
		to allow an exception in this particular case.
              </t>
              <t hangText='Header Parameter Description:'>
                <vspace />
                Brief description of the Header Parameter (e.g., "Example description").
              </t>
              <t hangText='Header Parameter Usage Location(s):'>
                <vspace />
                The Header Parameter usage locations, which should be one or more of the values
		<spanx style="verb">JWS</spanx> or
		<spanx style="verb">JWE</spanx>.
              </t>
              <t hangText='Change Controller:'>
                <vspace />
                For Standards Track RFCs, state "IESG". For others, give the name of the
                responsible party. Other details (e.g., postal address, email address, home page
                URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace />
                Reference to the document(s) that specify the parameter, preferably including URI(s) that
                can be used to retrieve copies of the document(s). An indication of the relevant
                sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

        <section title="Initial Registry Contents" anchor="HdrContents">
	  <t>
	    This specification registers the Header Parameter names defined in
	    <xref target="RegisteredHeaderParameterName"/> in this registry.
	  </t>
	  <t> <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">alg</spanx>
              </t>
              <t>
                Header Parameter Description: Algorithm
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="algDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jku</spanx>
              </t>
              <t>
                Header Parameter Description: JWK Set URL
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="jkuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jwk</spanx>
              </t>
              <t>
                Header Parameter Description: JSON Web Key
              </t>
              <t>
		Header Parameter Usage Location(s): JWS
	      </t>
	      <t>
                Change Controller: IESG
              </t>
              <t>
                Specification document(s): <xref target="jwkDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5u</spanx>
              </t>
              <t>
                Header Parameter Description: X.509 URL
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="x5uDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5t</spanx>
              </t>
              <t>
                Header Parameter Description: X.509 Certificate SHA-1 Thumbprint
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="x5tDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5c</spanx>
              </t>
              <t>
                Header Parameter Description: X.509 Certificate Chain
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="x5cDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">kid</spanx>
              </t>
              <t>
                Header Parameter Description: Key ID
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="kidDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">typ</spanx>
              </t>
              <t>
                Header Parameter Description: Type
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="typDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">cty</spanx>
              </t>
              <t>
                Header Parameter Description: Content Type
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="ctyDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">crit</spanx>
              </t>
              <t>
                Header Parameter Description: Critical
              </t>
	      <t>
		Header Parameter Usage Location(s): JWS
	      </t>
              <t>
                Change Controller: IESG
              </t>
              <t>
                Specification Document(s): <xref target="critDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section title="Media Type Registration" anchor="MediaReg">
	<section title="Registry Contents" anchor="MediaContents">
	  <t>
	    This specification registers the
	    <spanx style="verb">application/jose</spanx>
	    Media Type <xref target="RFC2046"/>
	    in the MIME Media Types registry <xref target="IANA.MediaTypes"/>,
	    which can be used to indicate that the content is
	    a JWS or JWE object using
	    the JWS Compact Serialization or the JWE Compact Serialization
	    and the
	    <spanx style="verb">application/jose+json</spanx>
	    Media Type in the MIME Media Types registry,
	    which can be used to indicate that the content is
	    a JWS or JWE object using
	    the JWS JSON Serialization or the JWE JSON Serialization.
	  </t>
	  <t> <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Type name: application
	      </t>
	      <t>
		Subtype name: jose
	      </t>
	      <t>
		Required parameters: n/a
	      </t>
	      <t>
		Optional parameters: n/a
	      </t>
	      <t>
		Encoding considerations: 8bit;
		application/jose values are encoded as a
		series of base64url encoded values (some of which may be the
		empty string) separated by period ('.') characters.
	      </t>
	      <t>
		Security considerations: See the Security Considerations section of [[ this document ]]
	      </t>
	      <t>
		Interoperability considerations: n/a
	      </t>
	      <t>
		Published specification: [[ this document ]]
	      </t>
	      <t>
		Applications that use this media type:
		OpenID Connect, Mozilla Persona, Salesforce, Google, numerous others that use signed JWTs
	      </t>
	      <t>
		Additional information:
		Magic number(s): n/a,
		File extension(s): n/a,
		Macintosh file type code(s): n/a
	      </t>
	      <t>
		Person &amp; email address to contact for further information:
		Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Intended usage: COMMON
	      </t>
	      <t>
		Restrictions on usage: none
	      </t>
	      <t>
		Author: Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Type name: application
	      </t>
	      <t>
		Subtype name: jose+json
	      </t>
	      <t>
		Required parameters: n/a
	      </t>
	      <t>
		Optional parameters: n/a
	      </t>
	      <t>
		Encoding considerations: 8bit;
		application/jose+json values are represented as a JSON Object;
		UTF-8 encoding SHOULD be employed for the JSON object.
	      </t>
	      <t>
		Security considerations: See the Security Considerations section of [[ this document ]]
	      </t>
	      <t>
		Interoperability considerations: n/a
	      </t>
	      <t>
		Published specification: [[ this document ]]
	      </t>
	      <t>
		Applications that use this media type:
		TBD
	      </t>
	      <t>
		Additional information:
		Magic number(s): n/a,
		File extension(s): n/a,
		Macintosh file type code(s): n/a
	      </t>
	      <t>
		Person &amp; email address to contact for further information:
		Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Intended usage: COMMON
	      </t>
	      <t>
		Restrictions on usage: none
	      </t>
	      <t>
		Author: Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

    </section>

    <section title="Security Considerations" anchor="Security">

      <section title="Cryptographic Security Considerations" anchor="CryptoSecCon">
	<t>
	  All of the security issues faced by any cryptographic application
	  must be faced by a JWS/JWE/JWK agent.  Among these issues are protecting
	  the user's private and symmetric keys, preventing various attacks, and helping the
	  user avoid mistakes such as inadvertently encrypting a message for
	  the wrong recipient.  The entire list of security considerations is
	  beyond the scope of this document, but some significant concerns are
	  listed here.
	</t>
	<t>
	  All the security considerations in
	  <xref target="W3C.CR-xmldsig-core2-20120124">XML DSIG 2.0</xref>,
	  also apply to this specification, other than those that are XML specific.
	  Likewise, many of the best practices documented in
	  <xref target="W3C.WD-xmldsig-bestpractices-20110809">XML Signature Best Practices</xref>
	  also apply to this specification,
	  other than those that are XML specific.
	</t>
	<t>
	  Keys are only as strong as the amount of entropy used to
	  generate them.  A minimum of 128 bits of entropy should be
	  used for all keys, and depending upon the application context,
	  more may be required.
	  In particular, it may be difficult to generate sufficiently
	  random values in some browsers and application environments.
	</t>
	<t>
	  Creators of JWSs should not allow third parties to insert
	  arbitrary content into the message without adding entropy
	  not controlled by the third party.
	</t>
	<t>
	  When utilizing TLS to retrieve information, the authority
	  providing the resource MUST be authenticated and the
	  information retrieved MUST be free from modification.
	</t>
	<t>
	  When cryptographic algorithms are implemented in such a way
	  that successful operations take a different amount of time
	  than unsuccessful operations, attackers may be able to
	  use the time difference to obtain information about the keys
	  employed.  Therefore, such timing differences must be avoided.
	</t>
	<t>
	  A SHA-1 hash is used when computing
	  <spanx style="verb">x5t</spanx> (x.509 certificate thumbprint) values,
	  for compatibility reasons.  Should an effective means of producing
	  SHA-1 hash collisions be developed, and should an attacker wish to
	  interfere with the use of a known certificate on a given system,
	  this could be accomplished by creating another certificate whose
	  SHA-1 hash value is the same and adding it to the certificate
	  store used by the intended victim.  A prerequisite to this
	  attack succeeding is the attacker having write access to the
	  intended victim's certificate store.
	</t>
	<t>
	  If, in the future, certificate thumbprints need to be
	  computed using hash functions other than SHA-1, it is
	  suggested that additional related Header Parameters be
	  defined for that purpose.  For example, it is suggested
	  that a new <spanx style="verb">x5t#S256</spanx>
	  (X.509 Certificate Thumbprint using SHA-256) Header Parameter
	  could be defined and used.
	</t>
      </section>

      <section title="JSON Security Considerations" anchor="JSONSecCon">
	<t>
	  Strict JSON validation is a security requirement.
	  If malformed JSON is received, then the intent of the sender
	  is impossible to reliably discern.
	  Ambiguous and potentially exploitable situations could arise
	  if the JSON parser used does not reject malformed JSON syntax.
	</t>
	<t>
	  Section 2.2 of the JavaScript Object Notation (JSON)
	  specification <xref target="RFC4627"/> states "The names
	  within an object SHOULD be unique", whereas this specification states that
	  "Header Parameter names within this object MUST be unique;
	  recipients MUST either reject JWSs with duplicate Header Parameter names
	  or use a JSON parser that returns only the lexically last duplicate member name,
	  as specified in Section 15.12 (The JSON Object) of
	  ECMAScript 5.1 <xref target="ECMAScript"/>".
	  Thus, this specification requires that the Section 2.2 "SHOULD"
	  be treated as a "MUST" by senders
	  and that it be either treated as a "MUST" or in the manner specified in
	  ECMAScript 5.1 by receivers.
	  Ambiguous and potentially exploitable situations could arise
	  if the JSON parser used does not enforce the uniqueness of member names
	  or returns an unpredictable value for duplicate member names.
	</t>
	<t>
	  Some JSON parsers might not reject input that contains extra
	  significant characters after a valid input.  For instance,
	  the input <spanx style="verb">{"tag":"value"}ABCD</spanx>
	  contains a valid JSON object followed by
	  the extra characters <spanx style="verb">ABCD</spanx>.
	  Such input MUST be rejected in its entirety.
	</t>
      </section>

      <section title="Unicode Comparison Security Considerations" anchor="UnicodeSecCon">
        <t>
	  Header Parameter names and algorithm names are Unicode strings.  For
	  security reasons, the representations of these names must be
	  compared verbatim after performing any escape processing (as
	  per <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	  This means, for instance, that these JSON strings must
	  compare as being equal ("sig", "\u0073ig"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("SIG", "Sig", "si\u0047").
	</t>
	<t>
	  JSON strings can contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>

    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/reference.ITU.X690.1994.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.WD-xmldsig-bestpractices-20110809.xml" ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-json-rfc4627bis-07.xml' ?>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-key" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key" type="HTML" />
      </reference>

      <reference anchor="JWA">
        <front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-algorithms" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms" type="HTML" />
      </reference>

      <reference anchor="USASCII">
	<front>
	  <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
	  <author>
	    <organization>American National Standards Institute</organization>
	  </author>
	  <date year="1986"/>
	</front>
	<seriesInfo name="ANSI" value="X3.4"/>
      </reference>

      <reference anchor="ECMAScript">
	<front>
	  <title>ECMAScript Language Specification, 5.1 Edition</title>
	  <author>
	    <organization>Ecma International</organization>
	  </author>
	  <date month="June" year="2011"/>
	</front>
	<seriesInfo name="ECMA" value="262"/>
	<format target="http://www.ecma-international.org/ecma-262/5.1/" type="HTML" />
	<format target="http://www.ecma-international.org/ecma-262/5.1/ECMA-262.pdf" type="PDF" />
      </reference>

      <reference anchor="IANA.MediaTypes">
        <front>
          <title>MIME Media Types</title>
          <author>
            <organization>Internet Assigned Numbers Authority (IANA)</organization>
          </author>
	  <date year="2005"/>
        </front>

	<format target="http://www.iana.org/assignments/media-types"
		type="HTML" />
      </reference>

    </references>

    <references title="Informative References">

      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xmldsig-core2-20120124.xml" ?>

      <reference anchor="JWT">
        <front>
          <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
        <seriesInfo value="draft-ietf-oauth-json-web-token" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token" type="HTML" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date day="7" month="January" year="2011" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-01.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
	    <organization abbrev="RTFM">RTFM, Inc.</organization>
	    <address>
	      <email>ekr@rtfm.com</email>
	    </address>
	  </author>

	  <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
	    <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
	    <address>
	      <email>jhildebr@cisco.com</email>
	    </address>
	  </author>

	  <date day="12" month="November" year="2013" />
        </front>
	<seriesInfo value="draft-ietf-jose-json-web-encryption" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption" type="HTML" />
      </reference>

    </references>

    <section title="JWS Examples" anchor="JWSExamples">

      <t>
	This section provides several examples of JWSs.
	While the first three
	examples all represent JSON Web Tokens (JWTs) <xref
	target="JWT" />, the payload can be any
	octet sequence, as shown in <xref target="ES512Example"/>.
      </t>

      <section title="Example JWS using HMAC SHA-256" anchor="HS256Example">
	<section title="Encoding" anchor="HS256Encoding">
	  <t>
	    The following example JWS Protected Header declares that the
	    data structure is a JSON Web Token (JWT) <xref target="JWT" />
	    and the JWS Signing Input is secured using
	    the HMAC SHA-256 algorithm.
	  </t>

	  <figure><artwork><![CDATA[
  {"typ":"JWT",
   "alg":"HS256"}
]]></artwork></figure>

	  <t>
	    The octets representing UTF8(JWS Protected Header) in this case are:
	  </t>
	  <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example
	    is the octets of the UTF-8 representation of the JSON object below.
	    (Note that the payload can be any base64url
	    encoded octet sequence, and need not be a base64url encoded JSON
	    object.)
	  </t>

	  <figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	  <t>
	     The following octet sequence, which is the UTF-8 representation
	     of the JSON object above, is the JWS Payload:
	  </t>
	  <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  </t>
	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value
	    (with line breaks for display purposes only):
	  </t>

          <figure><artwork><![CDATA[
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    Combining these as
	    BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)
	    gives this string
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    The resulting JWS Signing Input value,
	    which is the ASCII representation of above string,
	    is the following octet sequence:
	  </t>
	  <t>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    HMACs are generated using keys.
	    This example uses the symmetric key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"oct",
   "k":"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75
        aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow"
  }
]]></artwork></figure>
	  <t>
	    Running the HMAC SHA-256 algorithm on
	    the JWS Signing Input
	    with this key yields this JWS Signature octet sequence:
	  </t>
	  <t>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  </t>
	  <t>
	    Encoding this JWS Signature as
	    BASE64URL(JWS Signature) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
]]></artwork></figure>

	</section>

	<section title="Validating" anchor="HS256Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> Header Parameter
	    is <spanx style="verb">HS256</spanx>, we validate the HMAC SHA-256
	    value contained in the JWS Signature.
	  </t>
          <t>
	    To validate the HMAC value, we repeat the previous process
	    of using the correct key and
	    the JWS Signing Input
	    as input to the HMAC SHA-256 function
	    and then taking the output and determining if it matches
	    the JWS Signature.  If it matches exactly,
	    the HMAC has been validated.
	  </t>
	</section>
      </section>

      <section title="Example JWS using RSASSA-PKCS-v1_5 SHA-256" anchor="RS256Example">

	<section title="Encoding" anchor="RS256Encoding">
	  <t>
	    The JWS Protected Header in this example is different
	    from the previous example in two ways:  First, because a
	    different algorithm is being used, the <spanx style="verb">alg</spanx> value is
	    different.  Second, for illustration purposes only, the
	    optional <spanx style="verb">typ</spanx> parameter is not used.
	    (This difference is
	    not related to the algorithm employed.)  The
	    JWS Protected Header used is:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RS256"}
]]></artwork></figure>

	  <t>
	    The octets representing UTF8(JWS Protected Header) in this case are:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous example.  Since
	    the BASE64URL(JWS Payload) value will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	  <t>
	    Combining these as
	    BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)
	    gives this string
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    The resulting JWS Signing Input value,
	    which is the ASCII representation of above string,
	    is the following octet sequence:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>

	  <t>
	    This example uses the RSA key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"RSA",
   "n":"ofgWCuLjybRlzo0tZWJjNiuSfb4p4fAkd_wWJcyQoTbji9k0l8W26mPddx
        HmfHQp-Vaw-4qPCJrcS2mJPMEzP1Pt0Bm4d4QlL-yRT-SFd2lZS-pCgNMs
        D1W_YpRPEwOWvG6b32690r2jZ47soMZo9wGzjb_7OMg0LOL-bSf63kpaSH
        SXndS5z5rexMdbBYUsLA9e-KXBdQOS-UTo7WTBEMa2R2CapHg665xsmtdV
        MTBQY4uDZlxvb3qCo5ZwKh9kG4LT6_I5IhlJH7aGhyxXFvUK-DWNmoudF8
        NAco9_h9iaGNj8q2ethFkMLs91kzk2PAcDTW9gb54h4FRWyuXpoQ",
   "e":"AQAB",
   "d":"Eq5xpGnNCivDflJsRQBXHx1hdR1k6Ulwe2JZD50LpXyWPEAeP88vLNO97I
        jlA7_GQ5sLKMgvfTeXZx9SE-7YwVol2NXOoAJe46sui395IW_GO-pWJ1O0
        BkTGoVEn2bKVRUCgu-GjBVaYLU6f3l9kJfFNS3E0QbVdxzubSu3Mkqzjkn
        439X0M_V51gfpRLI9JYanrC4D4qAdGcopV_0ZHHzQlBjudU2QvXt4ehNYT
        CBr6XCLQUShb1juUO1ZdiYoFaFQT5Tw8bGUl_x_jTj3ccPDVZFD9pIuhLh
        BOneufuBiB4cS98l2SR_RQyGWSeWjnczT0QU91p1DhOVRuOopznQ"
  }
]]></artwork></figure>

	  <t>
	    The RSA private key is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the JWS Signing Input
	    as inputs.  The result of the digital signature is an octet sequence,
	    which represents a big endian integer.  In this example, it
	    is:
	  </t>
	  <t>
[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]
	  </t>
	  <t>
	    Encoding the signature as
	    BASE64URL(JWS Signature) produces this value
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
  AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
  BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
  0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
  hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
  p0igcN_IoypGlUPQGe77Rw
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
  AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
  BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
  0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
  hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
  p0igcN_IoypGlUPQGe77Rw
]]></artwork></figure>

	</section>

	<section title="Validating" anchor="RS256Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> Header Parameter
	    is <spanx style="verb">RS256</spanx>, we
	    validate the RSASSA-PKCS-v1_5 SHA-256 digital signature contained in the JWS Signature.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the previous example.
	    We pass (n, e), JWS Signature, and
	    the JWS Signing Input
	    to an RSASSA-PKCS-v1_5 signature verifier that has
	    been configured to use the SHA-256 hash function.
	  </t>

	</section>
      </section>

      <section title="Example JWS using ECDSA P-256 SHA-256" anchor="ES256Example">
	<section title="Encoding" anchor="ES256Encoding">
	  <t>
	    The JWS Protected Header for this example differs from
	    the previous example because a different algorithm is
	    being used.  The JWS Protected Header used is:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"ES256"}
]]></artwork></figure>

	  <t>
	    The octets representing UTF8(JWS Protected Header) in this case are:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous examples.  Since
	    the BASE64URL(JWS Payload) value will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	  <t>
	    Combining these as
	    BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)
	    gives this string
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	  <t>
	    The resulting JWS Signing Input value,
	    which is the ASCII representation of above string,
	    is the following octet sequence:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>

	  <t>
	    This example uses the elliptic curve key
	    represented in JSON Web Key <xref target="JWK" /> format below:
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"EC",
   "crv":"P-256",
   "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU",
   "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0",
   "d":"jpsQnnGQmL-YBIffH1136cspYG6-0iY7X1fCE9-E9LI"
  }
]]></artwork></figure>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and
	    the JWS Signing Input
	    as inputs.  The result of the
	    digital signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as octet sequences representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </c>

	    <c>S</c>
	    <c>

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </c>
	  </texttable>

	  <t>
	    The JWS Signature is the value R || S.
	    Encoding the signature as
	    BASE64URL(JWS Signature) produces this value
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
  pmWQxfKTUJqPP3-Kg6NU1Q
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
  DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
  pmWQxfKTUJqPP3-Kg6NU1Q
]]></artwork></figure>

	</section>

	<section title="Validating" anchor="ES256Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> Header Parameter
	    is <spanx style="verb">ES256</spanx>, we
	    validate the ECDSA P-256 SHA-256 digital signature contained in
	    the JWS Signature.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the first example.
	    We need to split the 64 member octet sequence of the JWS Signature
	    into two 32 octet sequences, the first R and the second S. We
	    then pass (x, y), (R, S) and 
	    the JWS Signing Input
	    to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  </t>

	</section>
      </section>


      <section title="Example JWS using ECDSA P-521 SHA-512" anchor="ES512Example">
	<section title="Encoding" anchor="ES512Encoding">
	  <t>
	    The JWS Protected Header for this example differs from
	    the previous example because different ECDSA curves
	    and hash functions are used.  The JWS Protected Header used is:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"ES512"}
]]></artwork></figure>

	  <t>
	    The octets representing UTF8(JWS Protected Header) in this case are:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 53, 49, 50, 34, 125]

	  </t>
	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzUxMiJ9
]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, is the ASCII string "Payload".
	    The representation of this string is the octet sequence:
	  </t>
	  <t>
[80, 97, 121, 108, 111, 97, 100]
	  </t>
	  <t>
	    Encoding this JWS Payload as
	    BASE64URL(JWS Payload) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  UGF5bG9hZA
]]></artwork></figure>

	  <t>
	    Combining these as
	    BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)
	    gives this string
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzUxMiJ9.UGF5bG9hZA
]]></artwork></figure>

	  <t>
	    The resulting JWS Signing Input value,
	    which is the ASCII representation of above string,
	    is the following octet sequence:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 85, 120, 77, 105, 74, 57, 46, 85, 71, 70, 53, 98, 71, 57, 104, 90, 65]
	  </t>

	  <t>
	    This example uses the elliptic curve key
	    represented in JSON Web Key <xref target="JWK" /> format below
	    (with line breaks for display purposes only):
	  </t>
	  <figure><artwork><![CDATA[
  {"kty":"EC",
   "crv":"P-521",
   "x":"AekpBQ8ST8a8VcfVOTNl353vSrDCLLJXmPk06wTjxrrjcBpXp5EOnYG_
        NjFZ6OvLFV1jSfS9tsz4qUxcWceqwQGk",
   "y":"ADSmRA43Z1DSNx_RvcLI87cdL07l6jQyyBXMoxVg_l2Th-x3S1WDhjDl
        y79ajL4Kkd0AZMaZmh9ubmf63e3kyMj2",
   "d":"AY5pb7A0UFiB3RELSD64fTLOSV_jazdF7fLYyuTw8lOfRhWg6Y6rUrPA
        xerEzgdRhajnu0ferB0d53vM9mE15j2C"
  }
]]></artwork></figure>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-521,
	    the hash type, SHA-512, and
	    the JWS Signing Input
	    as inputs.  The result of the
	    digital signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as octet sequences representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>
[1, 220, 12, 129, 231, 171, 194, 209, 232, 135, 233, 117, 247, 105, 122, 210,
 26, 125, 192, 1, 217, 21, 82, 91, 45, 240, 255, 83, 19, 34, 239, 71,
 48, 157, 147, 152, 105, 18, 53, 108, 163, 214, 68, 231, 62, 153, 150, 106,
 194, 164, 246, 72, 143, 138, 24, 50, 129, 223, 133, 206, 209, 172, 63, 237,
 119, 109]
	    </c>

	    <c>S</c>
	    <c>
[0, 111, 6, 105, 44, 5, 41, 208, 128, 61, 152, 40, 92, 61,
 152, 4, 150, 66, 60, 69, 247, 196, 170, 81, 193, 199, 78, 59, 194, 169,
 16, 124, 9, 143, 42, 142, 131, 48, 206, 238, 34, 175, 83, 203, 220, 159,
 3, 107, 155, 22, 27, 73, 111, 68, 68, 21, 238, 144, 229, 232, 148, 188,
 222, 59, 242, 103]
	    </c>
	  </texttable>

	  <t>
	    The JWS Signature is the value R || S.
	    Encoding the signature as
	    BASE64URL(JWS Signature) produces this value
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq
  wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp
  EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
]]></artwork></figure>

	<t>
	  Concatenating these values in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS representation
	  using the JWS Compact Serialization
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJFUzUxMiJ9
  .
  UGF5bG9hZA
  .
  AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq
  wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp
  EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
]]></artwork></figure>

	</section>

	<section title="Validating" anchor="ES512Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> Header Parameter
	    is <spanx style="verb">ES512</spanx>, we
	    validate the ECDSA P-521 SHA-512 digital signature contained in
	    the JWS Signature.
	  </t>
	  <t>
	    Validating the JWS Signature is similar to the previous example.
	    We need to split the 132 member octet sequence of the JWS Signature
	    into two 66 octet sequences, the first R and the second S. We
	    then pass (x, y), (R, S) and
	    the JWS Signing Input
	    to an ECDSA signature verifier that
	    has been configured to use the P-521 curve with the
	    SHA-512 hash function.
	  </t>

	</section>
      </section>

      <section title="Example Plaintext JWS" anchor="ExamplePlaintextJWS">

	<t>
	  The following example JWS Protected Header declares that the
	  encoded object is a Plaintext JWS:
	</t>

	<figure><artwork><![CDATA[
  {"alg":"none"}
]]></artwork></figure>

	<t>
	  Encoding this JWS Protected Header as
	  BASE64URL(UTF8(JWS Protected Header)) gives this value:
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJub25lIn0
]]></artwork></figure>

	<t>
	  The JWS Payload used in this example, which
	  follows, is the same as in the previous examples.  Since
	  the BASE64URL(JWS Payload) value will therefore be the same, its
	  computation is not repeated here.
	</t>

	<figure><artwork><![CDATA[
  {"iss":"joe",
   "exp":1300819380,
   "http://example.com/is_root":true}
]]></artwork></figure>

	<t>
	  The JWS Signature is the empty octet string
	  and BASE64URL(JWS Signature) is the empty string.
	</t>

	<t>
	  Concatenating these parts in the order
	  Header.Payload.Signature with period ('.') characters between the
	  parts yields this complete JWS (with line breaks for
	  display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJub25lIn0
  .
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
  .
]]></artwork></figure>
      </section>

      <section title="Example JWS Using JWS JSON Serialization" anchor="JSONSerializationExample">
	<t>
	  This section contains an example using the JWS JSON Serialization.
	  This example demonstrates the capability for
	  conveying multiple digital signatures and/or MACs for the
	  same payload.
	</t>
	<t>
	  The JWS Payload used in this example is the same as
	  that used in the examples in <xref target="RS256Example"/>
	  and <xref target="ES256Example"/>
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[
  eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
  cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
]]></artwork></figure>

	<t>
	  Two digital signatures are used in this example:
	  the first using RSASSA-PKCS-v1_5 SHA-256 and
	  the second using ECDSA P-256 SHA-256.
	  For the first, the JWS Protected Header and key
	  are the same as in <xref target="RS256Example"/>,
	  resulting in the same JWS Signature value;
	  therefore, its computation is not repeated here.
	  For the second, the JWS Protected Header and key
	  are the same as in <xref target="ES256Example"/>,
	  resulting in the same JWS Signature value;
	  therefore, its computation is not repeated here.
	</t>

	<section title="JWS Per-Signature Protected Headers" anchor="JSProtectedHeader">

	  <t>
	    The JWS Protected Header value used for the first signature is:
	  </t>
	  
	  <figure><artwork><![CDATA[
  {"alg":"RS256"}
]]></artwork></figure>

	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9
]]></artwork></figure>

	  <t>
	    The JWS Protected Header value used for the second signature is:
	  </t>
	  
	  <figure><artwork><![CDATA[
  {"alg":"ES256"}
]]></artwork></figure>

	  <t>
	    Encoding this JWS Protected Header as
	    BASE64URL(UTF8(JWS Protected Header)) gives this value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJFUzI1NiJ9
]]></artwork></figure>
	</section>

	<section title="JWS Per-Signature Unprotected Headers" anchor="JSRecipientHeaders">
	  <t>
	    Key ID values are supplied for both keys using per-signature
	    Header Parameters.
	    The two values used to represent these Key IDs are:
	  </t>

	  <figure><artwork><![CDATA[
  {"kid":"2010-12-29"}
]]></artwork></figure>

	  <t>
	    and
	  </t>

	  <figure><artwork><![CDATA[
  {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"}
]]></artwork></figure>
	</section>

	<section title="Complete JWS Header Values" anchor="JSHeader">
	  <t>
	    Combining the protected and unprotected header values
	    supplied, the JWS Header values used for the first and second
	    signatures respectively are:
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RS256",
   "kid":"2010-12-29"}
]]></artwork></figure>

	  <t>
	    and
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"ES256",
   "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"}
]]></artwork></figure>

	</section>


	<section title="Complete JWS JSON Serialization Representation" anchor="JSComplete">

	  <t>
	    The complete JSON Web Signature JSON Serialization
	    for these values is as follows
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[
  {"payload":
    "eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGF
     tcGxlLmNvbS9pc19yb290Ijp0cnVlfQ",
   "signatures":[
    {"protected":"eyJhbGciOiJSUzI1NiJ9",
     "header":
      {"kid":"2010-12-29"},
     "signature":
      "cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZ
       mh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjb
       KBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHl
       b1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZES
       c6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AX
       LIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw"},
    {"protected":"eyJhbGciOiJFUzI1NiJ9",
     "header":
      {"kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"},
     "signature":
      "DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8IS
       lSApmWQxfKTUJqPP3-Kg6NU1Q"}]
  }
]]></artwork></figure>
	</section>

      </section>

    </section>

    <section title='"x5c" (X.509 Certificate Chain) Example' anchor="x5cExample">
      <t>
	The JSON array below is an example of a certificate chain
	that could be used as the value of an
	<spanx style="verb">x5c</spanx> (X.509 Certificate Chain) Header Parameter,
	per <xref target="x5cDef"/>.
	Note that since these strings contain base64 encoded (not base64url encoded)
	values, they are allowed to contain white space and line breaks.
      </t>

      <figure><artwork><![CDATA[
  ["MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQAwYzELMAkGA1UEBhMCVVM
    xITAfBgNVBAoTGFRoZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR2
    8gRGFkZHkgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjExM
    TYwMTU0MzdaFw0yNjExMTYwMTU0MzdaMIHKMQswCQYDVQQGEwJVUzEQMA4GA1UE
    CBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTEaMBgGA1UEChMRR29EYWR
    keS5jb20sIEluYy4xMzAxBgNVBAsTKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYW
    RkeS5jb20vcmVwb3NpdG9yeTEwMC4GA1UEAxMnR28gRGFkZHkgU2VjdXJlIENlc
    nRpZmljYXRpb24gQXV0aG9yaXR5MREwDwYDVQQFEwgwNzk2OTI4NzCCASIwDQYJ
    KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMQt1RWMnCZM7DI161+4WQFapmGBWTt
    wY6vj3D3HKrjJM9N55DrtPDAjhI6zMBS2sofDPZVUBJ7fmd0LJR4h3mUpfjWoqV
    Tr9vcyOdQmVZWt7/v+WIbXnvQAjYwqDL1CBM6nPwT27oDyqu9SoWlm2r4arV3aL
    GbqGmu75RpRSgAvSMeYddi5Kcju+GZtCpyz8/x4fKL4o/K1w/O5epHBp+YlLpyo
    7RJlbmr2EkRTcDCVw5wrWCs9CHRK8r5RsL+H0EwnWGu1NcWdrxcx+AuP7q2BNgW
    JCJjPOq8lh8BJ6qf9Z/dFjpfMFDniNoW1fho3/Rb2cRGadDAW/hOUoz+EDU8CAw
    EAAaOCATIwggEuMB0GA1UdDgQWBBT9rGEyk2xF1uLuhV+auud2mWjM5zAfBgNVH
    SMEGDAWgBTSxLDSkdRMEXGzYcs9of7dqGrU4zASBgNVHRMBAf8ECDAGAQH/AgEA
    MDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZ29kYWR
    keS5jb20wRgYDVR0fBD8wPTA7oDmgN4Y1aHR0cDovL2NlcnRpZmljYXRlcy5nb2
    RhZGR5LmNvbS9yZXBvc2l0b3J5L2dkcm9vdC5jcmwwSwYDVR0gBEQwQjBABgRVH
    SAAMDgwNgYIKwYBBQUHAgEWKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5j
    b20vcmVwb3NpdG9yeTAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggE
    BANKGwOy9+aG2Z+5mC6IGOgRQjhVyrEp0lVPLN8tESe8HkGsz2ZbwlFalEzAFPI
    UyIXvJxwqoJKSQ3kbTJSMUA2fCENZvD117esyfxVgqwcSeIaha86ykRvOe5GPLL
    5CkKSkB2XIsKd83ASe8T+5o0yGPwLPk9Qnt0hCqU7S+8MxZC9Y7lhyVJEnfzuz9
    p0iRFEUOOjZv2kWzRaJBydTXRE4+uXR21aITVSzGh6O1mawGhId/dQb8vxRMDsx
    uxN89txJx9OjxUUAiKEngHUuHqDTMBqLdElrRhjZkAzVvb3du6/KFUJheqwNTrZ
    EjYx8WnM25sgVjOuH0aBsXBTWVU+4=",
   "MIIE+zCCBGSgAwIBAgICAQ0wDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1Z
    hbGlDZXJ0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIE
    luYy4xNTAzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb
    24gQXV0aG9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8x
    IDAeBgkqhkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTA0MDYyOTE3MDY
    yMFoXDTI0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRoZS
    BHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3MgM
    iBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN
    ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XC
    APVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux
    6wwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLO
    tXiEqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWo
    riMYavx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZ
    Eewo+YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjggHhMIIB3TAdBgNVHQ
    4EFgQU0sSw0pHUTBFxs2HLPaH+3ahq1OMwgdIGA1UdIwSByjCBx6GBwaSBvjCBu
    zEkMCIGA1UEBxMbVmFsaUNlcnQgVmFsaWRhdGlvbiBOZXR3b3JrMRcwFQYDVQQK
    Ew5WYWxpQ2VydCwgSW5jLjE1MDMGA1UECxMsVmFsaUNlcnQgQ2xhc3MgMiBQb2x
    pY3kgVmFsaWRhdGlvbiBBdXRob3JpdHkxITAfBgNVBAMTGGh0dHA6Ly93d3cudm
    FsaWNlcnQuY29tLzEgMB4GCSqGSIb3DQEJARYRaW5mb0B2YWxpY2VydC5jb22CA
    QEwDwYDVR0TAQH/BAUwAwEB/zAzBggrBgEFBQcBAQQnMCUwIwYIKwYBBQUHMAGG
    F2h0dHA6Ly9vY3NwLmdvZGFkZHkuY29tMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA
    6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5jb20vcmVwb3NpdG9yeS9yb290LmNybD
    BLBgNVHSAERDBCMEAGBFUdIAAwODA2BggrBgEFBQcCARYqaHR0cDovL2NlcnRpZ
    mljYXRlcy5nb2RhZGR5LmNvbS9yZXBvc2l0b3J5MA4GA1UdDwEB/wQEAwIBBjAN
    BgkqhkiG9w0BAQUFAAOBgQC1QPmnHfbq/qQaQlpE9xXUhUaJwL6e4+PrxeNYiY+
    Sn1eocSxI0YGyeR+sBjUZsE4OWBsUs5iB0QQeyAfJg594RAoYC5jcdnplDQ1tgM
    QLARzLrUc+cb53S8wGd9D0VmsfSxOaFIqII6hR8INMqzW/Rn453HWkrugp++85j
    09VZw==",
   "MIIC5zCCAlACAQEwDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1ZhbGlDZXJ
    0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNT
    AzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0a
    G9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkq
    hkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTk5MDYyNjAwMTk1NFoXDTE
    5MDYyNjAwMTk1NFowgbsxJDAiBgNVBAcTG1ZhbGlDZXJ0IFZhbGlkYXRpb24gTm
    V0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNTAzBgNVBAsTLFZhbGlDZ
    XJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0aG9yaXR5MSEwHwYDVQQD
    ExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkqhkiG9w0BCQEWEWluZm9
    AdmFsaWNlcnQuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOOnHK5a
    vIWZJV16vYdA757tn2VUdZZUcOBVXc65g2PFxTXdMwzzjsvUGJ7SVCCSRrCl6zf
    N1SLUzm1NZ9WlmpZdRJEy0kTRxQb7XBhVQ7/nHk01xC+YDgkRoKWzk2Z/M/VXwb
    P7RfZHM047QSv4dk+NoS/zcnwbNDu+97bi5p9wIDAQABMA0GCSqGSIb3DQEBBQU
    AA4GBADt/UG9vUJSZSWI4OB9L+KXIPqeCgfYrx+jFzug6EILLGACOTb2oWH+heQ
    C1u+mNr0HZDzTuIYEZoDJJKPTEjlbVUjP9UNV+mWwD5MlM/Mtsq2azSiGM5bUMM
    j4QssxsodyamEwCW/POuZ6lcg5Ktz885hZo+L7tdEy8W9ViH0Pd"]
]]></artwork></figure>
    </section>


    <section title="Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

      <t>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      </t>
      <t>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      </t>

      <figure><artwork><![CDATA[
  static string base64urlencode(byte [] arg)
  {
    string s = Convert.ToBase64String(arg); // Regular base64 encoder
    s = s.Split('=')[0]; // Remove any trailing '='s
    s = s.Replace('+', '-'); // 62nd char of encoding
    s = s.Replace('/', '_'); // 63rd char of encoding
    return s;
  }

  static byte [] base64urldecode(string arg)
  {
    string s = arg;
    s = s.Replace('-', '+'); // 62nd char of encoding
    s = s.Replace('_', '/'); // 63rd char of encoding
    switch (s.Length % 4) // Pad with trailing '='s
    {
      case 0: break; // No pad chars in this case
      case 2: s += "=="; break; // Two pad chars
      case 3: s += "="; break; // One pad char
      default: throw new System.Exception(
        "Illegal base64url string!");
    }
    return Convert.FromBase64String(s); // Standard base64 decoder
  }
]]></artwork></figure>

      <t>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      </t>
      <t>
	An example correspondence between unencoded and encoded values
	follows.  The octet sequence below encodes into the string
	below, which when decoded, reproduces the octet sequence.
      </t>

      <figure><artwork>3 236 255 224 193</artwork></figure>

      <figure><artwork>A-z_4ME</artwork></figure>
    </section>

    <section title='Negative Test Case for "crit" Header Parameter' anchor="critTest">
      <t>
	Conforming implementations must reject input containing critical extensions
	that are not understood or cannot be processed.  The following JWS must
	be rejected by all implementations, because it uses an extension
	Header Parameter name <spanx style="verb">http://example.invalid/UNDEFINED</spanx>
	that they do not understand.
	Any other similar input, in which the use of the value
	<spanx style="verb">http://example.invalid/UNDEFINED</spanx> is substituted for
	any other Header Parameter name not understood by the implementation,
	must also be rejected.

	<figure>
	  <preamble>
	    The JWS Protected Header value for this JWS is:
	  </preamble>
	  <artwork><![CDATA[
  {"alg":"none",
   "crit":["http://example.invalid/UNDEFINED"],
   "http://example.invalid/UNDEFINED":true
  }
]]></artwork>
	</figure>

	<figure>
	  <preamble>
	    The complete JWS that must be rejected is as follows
	    (with line breaks for display purposes only):
	  </preamble>
	  <artwork><![CDATA[
  eyJhbGciOiJub25lIiwNCiAiY3JpdCI6WyJodHRwOi8vZXhhbXBsZS5jb20vVU5ERU
  ZJTkVEIl0sDQogImh0dHA6Ly9leGFtcGxlLmNvbS9VTkRFRklORUQiOnRydWUNCn0.
  RkFJTA.
]]></artwork>
	</figure>
      </t>
    </section>

    <section anchor="DetachedContent" title="Detached Content">
      <t>
	In some contexts, it is useful integrity protect content that
	is not itself contained in a JWS object.
	One way to do this is create a JWS object in the normal fashion using
	a representation of the content as the payload,
	but then delete the payload representation from the JWS,
	and send this modified object to the recipient, rather than the JWS.
	When using the JWS Compact Serialization, the deletion is accomplished
	by replacing the second field (which contains BASE64URL(JWS Payload)) value
	with the empty string;
	when using the JWS JSON Serialization, the deletion is accomplished
	by deleting the <spanx style="verb">payload</spanx> member.
	This method assumes that the recipient can reconstruct
	the exact payload used in the JWS.
	To use the modified object, the recipient reconstructs the JWS
	by re-inserting the payload representation into the modified object,
	and uses the resulting JWS in the usual manner.
	Note that this method needs no support from JWS libraries, as applications
	can use this method by modifying the inputs and outputs of standard JWS libraries.
      </t>
    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for signing JSON content were previously explored by
	<xref target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
      </t>
      <t>
	Thanks to Axel Nennker for his early implementation
	and feedback on the JWS and JWE specifications.
      </t>
      <t>
        This specification is the work of the JOSE Working Group,
	which includes dozens of active and dedicated participants.
	In particular, the following individuals contributed ideas,
        feedback, and wording that influenced this specification:
      </t>
      <t>
	Dirk Balfanz,
	Richard Barnes,
	Brian Campbell,
	Breno de Medeiros,
	Dick Hardt,
	Joe Hildebrand,
	Jeff Hodges,
	Edmund Jay,
	Yaron Y. Goland,
	Ben Laurie,
	James Manger,
	Matt Miller,
	Tony Nadalin,
	Axel Nennker,
	John Panzer,
	Emmanuel Raviart,
	Eric Rescorla,
	Jim Schaad,
	Paul Tarjan,
	Hannes Tschofenig,
	and Sean Turner.
      </t>
      <t>
	Jim Schaad and Karen O'Donoghue chaired the JOSE working group and
	Sean Turner and Stephen Farrell served as Security area directors
	during the creation of this specification.
      </t>
    </section>

    <section title="Document History" anchor="History">
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>

      <t>
	-18
	<list style='symbols'>
	  <t>
	    Updated the mandatory-to-implement (MTI) language to say that
	    applications using this specification need to specify what serialization
	    and serialization features are used for that application,
	    addressing issue #119.
	  </t>
	  <t>
	    Changes to address editorial and minor issues
	    #25, #89, #97, #110, #114, #115, #116, #117, #120, and #184.
	  </t>
	  <t>
	    Added and used Header Parameter Description registry field.
	  </t>
	</list>
      </t>

      <t>
	-17
	<list style='symbols'>
	  <t>
	    Refined the <spanx style="verb">typ</spanx> and
	    <spanx style="verb">cty</spanx> definitions to always be
	    MIME Media Types, with the omission of "application/"
	    prefixes recommended for brevity,
	    addressing issue #50.
	  </t>
	  <t>
	    Updated the mandatory-to-implement (MTI) language to say
	    that general-purpose implementations must implement the
	    single signature/MAC value case for both serializations
	    whereas special-purpose implementations can implement
	    just one serialization if that meets the needs of
	    the use cases the implementation is designed for,
	    addressing issue #119.
	  </t>
	  <t>
	    Explicitly named all the logical components of a JWS
	    and defined the processing rules and serializations
	    in terms of those components,
	    addressing issues #60, #61, and #62.
	  </t>
	  <t>
	    Replaced verbose repetitive phases such as
	    "base64url encode the octets of the UTF-8 representation of X"
	    with mathematical notation such as "BASE64URL(UTF8(X))".
	  </t>
	  <t>
	    Terms used in multiple documents are now defined in
	    one place and incorporated by reference.
	    Some lightly used or obvious terms were also removed.
	    This addresses issue #58.
	  </t>
	</list>
      </t>

      <t>
	-16
	<list style='symbols'>
	  <t>
	    Changes to address editorial and minor issues
	    #50, #98, #99, #102, #104, #106, #107, #111, and #112.
	  </t>
	</list>
      </t>

      <t>
	-15
	<list style='symbols'>
	  <t>
	    Clarified that it is an application decision which
	    signatures, MACs, or plaintext values
	    must successfully validate for the JWS to be accepted,
	    addressing issue #35.
	  </t>
	  <t>
	    Corrected editorial error in <spanx style="verb">ES512</spanx> example.
	  </t>
	  <t>
	    Changes to address editorial and minor issues
	    #34, #96, #100, #101, #104, #105, and #106.
	  </t>
	</list>
      </t>

      <t>
	-14
	<list style='symbols'>
	  <t>
	    Stated that the <spanx style="verb">signature</spanx> parameter
	    is to be omitted in the JWS JSON Serialization
	    when its value would be empty
	    (which is only the case for a Plaintext JWS).
	  </t>
	</list>
      </t>

      <t>
	-13
	<list style='symbols'>
	  <t>
	    Made all header parameter values be per-signature/MAC,
	    addressing issue #24.
	  </t>
	</list>
      </t>

      <t>
	-12
	<list style='symbols'>
	  <t>
	    Clarified that the <spanx style="verb">typ</spanx> and
	    <spanx style="verb">cty</spanx> header parameters are used
	    in an application-specific manner
	    and have no effect upon the JWS processing.
	  </t>
	  <t>
	    Replaced the MIME types
	    <spanx style="verb">application/jws+json</spanx> and
	    <spanx style="verb">application/jws</spanx> with
	    <spanx style="verb">application/jose+json</spanx> and
	    <spanx style="verb">application/jose</spanx>.
	  </t>
	  <t>
	    Stated that recipients MUST either reject JWSs with
	    duplicate Header Parameter Names
	    or use a JSON parser that returns only
	    the lexically last duplicate member name.
	  </t>
	  <t>
	    Added a Serializations section with parallel treatment of the
	    JWS Compact Serialization
	    and the
	    JWS JSON Serialization
	    and also moved the former Implementation Considerations content there.
	  </t>
	</list>
      </t>

      <t>
	-11
	<list style='symbols'>
	  <t>
	    Added Key Identification section.
	  </t>
	  <t>
	    For the JWS JSON Serialization, enable header parameter values
	    to be specified in any of three parameters:
	    the <spanx style="verb">protected</spanx> member that is
	    integrity protected and shared among all recipients,
	    the <spanx style="verb">unprotected</spanx> member that is
	    not integrity protected and shared among all recipients,
	    and the <spanx style="verb">header</spanx> member that is
	    not integrity protected and specific to a particular recipient.
	    (This does not affect the JWS Compact Serialization, in which all
	    header parameter values are in a single integrity protected JWE Header value.)
	  </t>
	  <t>
	    Removed suggested compact serialization for multiple
	    digital signatures and/or MACs.
	  </t>
	  <t>
	    Changed the MIME type name <spanx style="verb">application/jws-js</spanx>
	    to <spanx style="verb">application/jws+json</spanx>,
	    addressing issue #22.
	  </t>
	  <t>
	    Tightened the description of the
	    <spanx style="verb">crit</spanx> (critical) header parameter.
	  </t>
	  <t>
	    Added a negative test case for the
	    <spanx style="verb">crit</spanx> header parameter
	  </t>
	</list>
      </t>
      <t>
	-10
	<list style='symbols'>
	  <t>
	    Added an appendix suggesting a possible compact serialization
	    for JWSs with multiple digital signatures and/or MACs.
	  </t>
	</list>
      </t>
      <t>
	-09
	<list style='symbols'>
	  <t>
	    Added JWS JSON Serialization, as specified by
	    draft-jones-jose-jws-json-serialization-04.
	  </t>
	  <t>
	    Registered <spanx style="verb">application/jws-js</spanx> MIME type
	    and <spanx style="verb">JWS-JS</spanx> typ header parameter value.
	  </t>
	  <t>
	    Defined that the default action for header parameters that
	    are not understood is to ignore them unless specifically
	    designated as "MUST be understood" or included in the new
	    <spanx style="verb">crit</spanx> (critical) header parameter list.
	    This addressed issue #6.
	  </t>
	  <t>
	    Changed term "JWS Secured Input" to "JWS Signing Input".
	  </t>
	  <t>
	    Changed from using the term "byte" to "octet" when referring to 8 bit values.
	  </t>
	  <t>
	    Changed member name from <spanx style="verb">recipients</spanx> to
	    <spanx style="verb">signatures</spanx> in the JWS JSON Serialization.
	  </t>
	  <t>
	    Added complete values using the JWS Compact Serialization
	    for all examples.
	  </t>
	</list>
      </t>
      <t>
	-08
	<list style='symbols'>
	  <t>
	    Applied editorial improvements suggested by
	    Jeff Hodges and Hannes Tschofenig.
	    Many of these simplified the terminology used.
	  </t>
	  <t>
	    Clarified statements of the form "This header parameter is OPTIONAL"
	    to "Use of this header parameter is OPTIONAL".
	  </t>
	  <t>
	    Added a Header Parameter Usage Location(s) field to the
	    IANA JSON Web Signature and Encryption Header Parameters registry.
	  </t>
	  <t>
	    Added seriesInfo information to Internet Draft references.
	  </t>
	</list>
      </t>
      <t>
	-07
	<list style='symbols'>
	  <t>
	    Updated references.
	  </t>
	</list>
      </t>
      <t>
	-06
	<list style='symbols'>
	  <t>
	    Changed <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    representation from being a single string to being an array of strings,
	    each containing a single base64 encoded DER certificate value,
	    representing elements of the certificate chain.
	  </t>
	  <t>
	    Applied changes made by the RFC Editor to RFC 6749's registry language
	    to this specification.
	  </t>
	</list>
      </t>
      <t>
	-05
	<list style='symbols'>
	  <t>
	    Added statement that
	    "StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied".
	  </t>
	  <t>
	    Indented artwork elements to better distinguish them from the body text.
	  </t>
	</list>
      </t>
      <t>
	-04
	<list style='symbols'>
	  <t>
	    Completed JSON Security Considerations section, including
	    considerations about rejecting input with duplicate member names.
	  </t>
	  <t>
	    Completed security considerations on the use of a SHA-1 hash when computing
	    <spanx style="verb">x5t</spanx> (x.509 certificate thumbprint) values.
	  </t>
	  <t>
	    Refer to the registries as the primary sources of defined
	    values and then secondarily reference the sections
	    defining the initial contents of the registries.
	  </t>
	  <t>
	    Normatively reference
	    <xref target="W3C.CR-xmldsig-core2-20120124">XML DSIG 2.0</xref>
	    for its security considerations.
	  </t>
	  <t>
	    Added this language to Registration Templates:
	    "This name is case sensitive.  Names that match other registered names
	    in a case insensitive manner SHOULD NOT be accepted."
	  </t>
	  <t>
	    Reference draft-jones-jose-jws-json-serialization
	    instead of draft-jones-json-web-signature-json-serialization.
	  </t>
	  <t>
	    Described additional open issues.
	  </t>
	  <t>
	    Applied editorial suggestions.
	  </t>
	</list>
      </t>
      <t>
        -03
        <list style='symbols'>
	  <t>
	    Added the <spanx style="verb">cty</spanx> (content type) header parameter
	    for declaring type information about the secured content,
	    as opposed to the <spanx style="verb">typ</spanx> (type) header parameter,
	    which declares type information about this object.
	  </t>
	  <t>
	    Added "Collision Resistant Namespace" to the terminology section.
	  </t>
	  <t>
	    Reference ITU.X690.1994 for DER encoding.
	  </t>
	  <t>
	    Added an example JWS using ECDSA P-521 SHA-512.  This has particular
	    illustrative value because of the use of the 521 bit integers
	    in the key and signature values.
	    This is also an example in which the payload is not a base64url
	    encoded JSON object.
	  </t>
	  <t>
	    Added an example <spanx style="verb">x5c</spanx> value.
	  </t>
	  <t>
	    No longer say "the UTF-8 representation of the JWS Secured Input
	    (which is the same as the ASCII representation)".  Just call it
	    "the ASCII representation of the JWS Secured Input".
	  </t>
	  <t>
	    Added Registration Template sections for defined registries.
	  </t>
	  <t>
	    Added Registry Contents sections to populate registry values.
	  </t>
	  <t>
	    Changed name of the JSON Web Signature and Encryption "typ" Values registry
	    to be the JSON Web Signature and Encryption Type Values registry, since
	    it is used for more than just values of the
	    <spanx style="verb">typ</spanx> parameter.
	  </t>
	  <t>
	    Moved registries
	    JSON Web Signature and Encryption Header Parameters and
	    JSON Web Signature and Encryption Type Values
	    to the JWS specification.
	  </t>
	  <t>
	    Numerous editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    Clarified that it is an error when a <spanx style="verb">kid</spanx>
	    value is included and no matching key is found.
	  </t>
	  <t>
	    Removed assumption that <spanx style="verb">kid</spanx> (key ID)
	    can only refer to an asymmetric key.
	  </t>
	  <t>
	    Clarified that JWSs with duplicate Header Parameter Names
	    MUST be rejected.
	  </t>
	  <t>
	    Clarified the relationship between
	    <spanx style="verb">typ</spanx> header parameter values
	    and MIME types.
	  </t>
	  <t>
	    Registered application/jws MIME type and "JWS" typ header parameter value.
	  </t>
	  <t>
	    Simplified JWK terminology to get replace the "JWK Key Object" and
	    "JWK Container Object" terms with simply "JSON Web Key (JWK)"
	    and "JSON Web Key Set (JWK Set)" and to eliminate potential
	    confusion between single keys and sets of keys.
	    As part of this change, the Header Parameter Name for a
	    public key value was changed from
	    <spanx style="verb">jpk</spanx> (JSON Public Key) to
	    <spanx style="verb">jwk</spanx> (JSON Web Key).
	  </t>
	  <t>
	    Added suggestion on defining additional header parameters
	    such as <spanx style="verb">x5t#S256</spanx> in the future
	    for certificate thumbprints using hash algorithms other
	    than SHA-1.
	  </t>
	  <t>
	    Specify RFC 2818 server identity validation, rather than
	    RFC 6125 (paralleling the same decision in the OAuth specs).
	  </t>
	  <t>
	    Generalized language to refer to Message Authentication Codes (MACs)
	    rather than Hash-based Message Authentication Codes (HMACs)
	    unless in a context specific to HMAC algorithms.
	  </t>
          <t>
            Reformatted to give each header parameter its own section heading.
          </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
          <t>
	    Moved definition of Plaintext JWSs (using "alg":"none")
	    here from the JWT specification since this functionality is
	    likely to be useful in more contexts that just for JWTs.
          </t>
	  <t>
	    Added <spanx style="verb">jpk</spanx> and <spanx
	    style="verb">x5c</spanx> header parameters for including
	    JWK public keys and X.509 certificate chains directly in
	    the header.
	  </t>
	  <t>
	    Clarified that this specification is defining the JWS
	    Compact Serialization.  Referenced the new JWS-JS spec,
	    which defines the JWS JSON Serialization.
	  </t>
	  <t>
	    Added text "New header parameters should be introduced
	    sparingly since an implementation that does not understand
	    a parameter MUST reject the JWS".
	  </t>
	  <t>
	    Clarified that the order of the creation and validation
	    steps is not significant in cases where there are no
	    dependencies between the inputs and outputs of the steps.
	  </t>
	  <t>
	    Changed "no canonicalization is performed" to "no
	    canonicalization need be performed".
	  </t>
          <t>
	    Corrected the Magic Signatures reference.
          </t>
	  <t>
	    Made other editorial improvements suggested by JOSE
	    working group participants.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-jones-json-web-signature-04 with no normative
            changes.
          </t>
	  <t>
	    Changed terminology to no longer call both digital
	    signatures and HMACs "signatures".
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
