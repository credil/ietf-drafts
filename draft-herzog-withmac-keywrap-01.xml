<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>         <!-- generate a table of contents -->
<?rfc symrefs="yes"?>     <!-- use anchors instead of numbers for references -->
<?rfc sortrefs="yes" ?>   <!-- alphabetize the references -->
<?rfc compact="yes" ?>    <!-- conserve vertical whitespace -->
<?rfc subcompact="no" ?> 
<rfc ipr='trust200902' docName='draft-herzog-withmac-keywrap-01' category="std">
  <front>
    <title abbrev="With-MAC keywrap algorithm">
      The With-MAC key-wrapping algorithm for Cryptographic Message
      Syntax
    </title>
    
    <author initials="J.C." surname="Herzog" 
	    fullname="Jonathan C. Herzog">
      <organization>MIT Lincoln Laboratory</organization>
      <address>
	<postal>
	  <street>244 Wood St.</street>
	  <city>Lexington</city>
	  <region>MA</region>
	  <code>02144</code>
	  <country>USA</country>
	</postal>
	<email>jherzog@ll.mit.edu</email>
      </address>
    </author>

    <author initials="R." surname="Khazan" 
	    fullname="Roger Khazan">
      <organization>MIT Lincoln Laboratory</organization>
      <address>
	<postal>
	  <street>244 Wood St.</street>
	  <city>Lexington</city>
	  <region>MA</region>
	  <code>02144</code>
	  <country>USA</country>
	</postal>
	<email>rkh@ll.mit.edu</email>
      </address>
      
    </author>
    
    <date month='March' year='2012'/>
    

    <abstract>
      <t> 
	This document describes a new key-wrapping algorithm to be
	used in the EnvelopedData, AuthenticatedData and
	AuthEnvelopedData structures of the Cryptographic Message
	Syntax. Because these structures do not provide data-origin
	authentication, a recipient cannot cryptographically verify
	that the plaintext received was the plaintext encapsulated by
	the message's original sender. The With-MAC key-wrapping
	algorithm allows an EncryptedKey value to hold both a wrapped
	symmetric key and a MAC value on the data to be authenticated.
	When used in EnvelopedData, AuthenticatedData and
	AuthEnvelopedData structures, therefore, these structures can
	achieve data-origin authentication (in some circumstances)
	using only symmetric-key algorithms. This is useful in cases
	where the structures must be generated by entities without
	certified digital-signature keys.
      </t>
    </abstract>

    <note title="Disclaimer">
      <t>This work is sponsored by the United States Air Force under
      Air Force Contract FA8721-05-C-0002.  Opinions, interpretations,
      conclusions and recommendations are those of the authors and are
      not necessarily endorsed by the United States Government.</t>
    </note>

    <!--
    <note title="Versioning information">
      <t>
	This is 
	$Revision: 4094 $ 
	of this document, produced at 
	$Date: 2010-11-03 13:48:22 -0400 (Wed, 03 Nov 2010) $.
	This information is to be removed before submission to the IETF.
      </t>
    </note>
    -->

  </front>


  <middle>


    <section anchor='sec:intro' title='Introduction'>

      <t>
	This document extends the Cryptographic Message Syntax (CMS)
	<xref target="RFC5652"/> so as to allow EncryptedKey values to
	contain both an encrypted key and a message authentication
	code (MAC) value. CMS is a standard notation and
	representation for cryptographic messages. Specifically, CMS
	uses ASN.1 notation <xref target="X.680"/> <xref
	target="X.681"/> <xref target="X.682"/> <xref target="X.683"/>
	to define a number of structures for encrypted data, signed
	data, authenticated data, and so on. Such structures carry
	both:
	<list style="symbols">
	  <t>
	    The cryptographically-protected information, and
	  </t>
	  <t>
	    Key-management information regarding the keys used.
	  </t>
	</list>
	Of particular interest here are three 'top-level' structures:
	<list style="symbols">
	  <t>
	    EnvelopedData, which holds encrypted (but not necessarily
	    authenticated) information <xref target="RFC5652"/>,
	  </t> 
	  <t>
	    AuthenticatedData, which holds authenticated (MACed)
	    information <xref target="RFC5652"/>, and
	  </t>
	  <t>
	    AuthEnvelopedData, which holds information protected by
	    authenticated encryption: a cryptographic scheme that
	    combines encryption and authentication <xref
	    target="RFC5083"/>.
	  </t> 
	</list>
	All three of these structures are constructed in the same
	basic way. 
	<list style="symbols">
	  <t>
	    First, the message-creator generates a fresh symmetric
	    key. In context of EnvelopedData structures,
	    AuthenticatedData structures and AuthEnvelopedData
	    structures, this key is called the content-encryption key,
	    the authentication key, and the
	    content-authenticated-encryption key respectively. We will
	    use the term CPK as a generic term when speaking of all
	    three of these structures in the aggregate.
	  </t>
	  <t>
	    Next, the creator uses the CPK to cryptographically
	    protect the content.
	  </t>
	  <t>
	    Lastly, the CPK is then wrapped for each recipient. That
	    is, copies of the CPK are encrypted in a sequence of 'wrap
	    keys' (one copy per wrap-key) such that every recipient
	    knows or can compute at least one wrap-key.
	  </t>
	  </list>
	A recipient, upon receiving the message, decrypts one of the
	wraps to retrieve the CPK and then uses the CPK to decrypt or
	verify the content.

	<vspace blankLines="1"/>
	CMS supports several different types of wrap-keys, including:
	<list style="symbols">
	  <t> 
	    Key transport: the wrap key is the public encryption key of
	    some recipient.
	  </t>
	  <t>
	    Key agreement: the wrap key is a key-encryption key (KEK)
	    created using a key-agreement scheme (such as
	    Diffie-Hellman <xref target="RFC3370"/>) and a
	    key-derivation function (KDF).
	  </t>
	  <t>
	    Key-encryption key: the wrap key is a
	    previously-distributed symmetric key-encrypting key known
	    to the recipient.
	  </t>
	  <t>
	    Password: the wrap key is a key-encryption key derived
	    from a password.
	  </t>
	</list>
	Each of these methods is represented by a different 'key wrap'
	structure, called the KeyTransRecipientInfo,
	KeyAgreeRecipientInfo, KEKRecipientInfo and
	PasswordRecipientInfo structures, respectively. Each such
	structure is an instance of the RecipientInfo type, which can
	be embedded in each of EnvelopedData, AuthenticatedData and
	AuthEnvelopedData, respectively. Thus, each key-wrap method can
	be used in each top-level structure mentioned above.

	<vspace blankLines="1"/>
	Furthermore, a single top-level structure can hold multiple
	key-wrap structures, as might be the case when a single
	message has multiple distinct receivers. In this case, every
	wrap-structure in the message will encrypt the same CPK. This
	means, unfortunately, that the top-level CMS structures
	described above do not provide data-origin authentication.
	Consider, for example, the following sequence of events:
	<list style="symbols">
	  <t> 
	    Alice sends an AuthEnvelopedData message to both Bob and
	    Mallory. This message uses a fresh, new
	    content-authenticated-encryption key to protect the
	    plaintext with authenticated-encryption algorithm. This
	    algorithm will produce both ciphertext and MAC value, thus
	    providing both confidentiality and integrity guarantees.
	    Furthermore, Alice will wrap this
	    content-authenticated-encryption key to both Bob and
	    Mallory. The final AuthEnvelopedData message contains the
	    ciphertext, the MAC value, and both wrap-structures (one
	    for Bob and one for Mallory).
	  </t>

	  <t> Mallory intercepts the message and prevents Bob from
	  receiving it.</t>

	  <t> Mallory unwraps the content-authenticated-encryption key
	  from the wrap intended for her. Mallory then creates new
	  plaintext of her choice, and encrypts it using the same
	  authenticated-encryption algorithm and the same
	  content-authenticated-encryption key used by Alice.</t>

	  <t> Mallory then replaces the ciphertext and MAC value of
	  Alice's message with the values just generated. She may
	  additionally remove her key-wrap structure from Alice's
	  message.</t>

	  <t>Mallory sends the modified message to Bob.</t>

	  <t> Bob receives the message, unwraps the
	  content-authenticated-encryption key, and
	  decrypts/authenticates the message.</t>
	</list>
	At this point, Bob has received and validated a message that
	appears to have been sent by Alice, but whose content was
	chosen by Mallory. Furthermore, Mallory may not even be an
	apparent receiver of the modified message.

	<vspace blankLines="1"/>
	This same 'attack' can be successfully launched against
	EnvelopedData and AuthenticatedData structures. We rush to
	note, however, that none of these structures were actually
	designed to provide 'data-origin authentication'. By
	data-origin authentication, we mean the guarantee that a
	recipient will not accept a message that was not sent, exactly
	as received, by the ostensible sender. This would require that
	the messages identify the ostensible sender, but these
	structures might not do so:
	<list style="symbols">
	  <t>
	    These structures do contain an OriginiatorInfo field,
	    which would identify the sender. This value is sometimes
	    optional, however.
	  </t>
	  <t>
	    The key-wrap structures, listed above, may partially
	    identify the sender. The use of password-based key-wrap,
	    for example, implies that the (ostensible) sender is among
	    the entities that know the password. Likewise, the use of
	    key-encrypting-key key-wrap implies that the (ostensible)
	    sender is among the entities that know the key. This is
	    only partial identification, however, and the
	    key-transport key-wrap method will not identify the
	    ostensible sender. (The key-agreement method will identify
	    the sender, if the sender uses a certified public value
	    <xref target ="RFC6278"/>.)
	  </t>
	</list>
	We also note that it is not strictly necessary for these
	top-level CMS structures to provide data-origin
	authentication.  CMS already provides an entirely separate
	structure for this purpose: the SignedData structure, which
	applies digital signatures to the encapsulated 'plaintext.'
	Furthermore, these top-level structures can be encapsulated in
	each other. Alice, above, can entirely prevent the described
	attack by encapsulating the AuthEnvelopedData structure in a
	SignedData structure. Then the AuthEnvelopedData structure
	would be signed by Alice, and Mallory could not change that
	structure's plaintext without invalidating Alice's signature.

	<vspace blankLines="1"/>
	Unfortunately, this is not a universal solution. In
	particular, the sender may not have a certified public
	signature key, or the ability to send their
	signature-verification key to the recipients in an
	authenticated manner. In this case, the SignedData structure
	will not be able to provide data-origin authentication
	guarantees to the recipients(s). Also, 'small' hardware
	implementations may not be able to include the
	number-theoretic algorithms that underlie public-key signature
	schemes, and would therefore be unable to create or process
	SignedData structures.


	<vspace blankLines="1"/>
	Given this, it is desirable to identify alternate methods to
	achieve data-origin authentication in CMS. In this document,
	we describe a method by which EnvelopedData,
	AuthenticatedData, and AuthEnvelopedData structures can
	provide data-origin authentication using only symmetric
	cryptographic algorithms. Specifically, we define the With-MAC
	key-wrap 'algorithm.' In actuality, this 'algorithm' is a
	pseudo-algorithm which allows key-wrap structures to contain
	both:
	<list style='symbols'>
	  <t>
	    A content-protecting symmetric key (encrypted, as before),
	    and
	  </t>
	  <t>
	    A MAC value protecting the contents of the enclosing
	    EnvelopedData, AuthenticatedData, or AuthEnvelopedData
	    structure.
	  </t>
	</list>
	If the standard CMS encryption operation in an EnvelopedData
	structure is
	<figure>
	<artwork>
KEK1( CPK ) || KEK2( CPK ) || ... || CPK( data )
	</artwork>
	</figure>
	then the encryption operation of this document is
	<figure>
	<artwork>
KEK1'( CPK ), MAC1'( CPK( data ) ) || 
  KEK2'( CPK ), MAC2'( CPK( data) ) ||... || CPK( data )
	</artwork>
	</figure>
	where KEK1' and MAC1' are both derived from
	KEK1. Specifically, the encryption of the CPK is created using
	a 'wrap-encryption' key, and the MAC is generated using a
	'wrap-MAC' key. Both of these keys are derived from the
	wrap-key using a key-derivation function. Therefore, the MAC
	value authenticates the origin of the data to the same extent
	that the key-wrap mechanism cryptographically authenticates
	the sender of the message.
	
	<vspace blankLines="1"/>
	In this way, the With-MAC algorithm provides the following
	guarantees:
	<list style="symbols">
	  <t>
	    When the key-wrap mechanism is based on a shared
	    key-encrypting key (KEKRecipientInfo) it guarantees to the
	    receiver that the data was sent by someone who knows the
	    relevant key-transportation key.
	  </t> 
	  <t>
	    When the key-wrap mechanism is based on passwords
	    (PasswordRecipientInfo) it guarantees to the receiver that
	    the data was sent by someone who knows the relevant
	    password.
	  </t> 
	  <t>
	    When the key-wrap mechanism is based on key-agreement
	    mechanisms (KeyAgreeRecipientInfo) and the sender uses a
	    long-term, certified value, it guarantees to the receiver
	    that the data was sent by someone who knows the sender's
	    private key-agreement key.
	  </t>
	</list>
	The With-MAC algorithm can not be used when the key-wrap
	method is based on key-transport. It can be used when the
	key-wrap method is based on key-agreement and the sender uses
	an ephemeral value, but it provides no data-authentication
	properties.

	<vspace blankLines="1"/>
	Because the With-MAC algorithm uses only symmetric-key
	algorithms, it may also be more appropriate than the
	SignedData structure for resource-constrained (e. g., power,
	space) hardware implementations. Lastly, we note that MAC
	values tend to be smaller than digital signatures. Under some
	circumstances, such as when there are relatively few
	key-wraps, the With-MAC algorithm may result in shorter
	messages than a SignedData structure.

      </t>
    </section>        

    <section anchor="terminology" title="Requirements Terminology">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	  in <xref target="RFC2119"/>.
      </t>
    </section>


    <section title="Structures of the With-MAC key-wrap algorithm">
      <t>
	In the KeyTransRecipientInfo, KeyAgreeRecipientInfo,
	PasswordRecipientInfo and KEKRecipientInfo, the CPK-wrapping
	algorithm is identified through an AlgorithmIdentifier
	structure <xref target="RFC5280"/>:
	<figure>
	  <artwork>
<![CDATA[
AlgorithmIdentifier  ::=  SEQUENCE  {
     algorithm     OBJECT IDENTIFIER,
     parameters    ANY DEFINED BY algorithm OPTIONAL  }
]]>
	  </artwork>
	</figure>
The With-MAC key-wrap algorithm has the algorithm identifier:
	<figure>
	  <artwork>
<![CDATA[
id-alg-WithMACWrap OBJECT IDENTIFIER ::= { iso(1) member-body(2)
    us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) alg(3) X }
]]>
	  </artwork>
	</figure>
	When the algorithm field of an AlgorithmIdentifier structure is
	id-alg-WithMACWrap, the parameters field MUST be a WithMACParameters
	value:
	<figure>
	  <artwork>
<![CDATA[
WithMACParameters  ::=  SEQUENCE  {
     wrapAlgorithm   KeyEncryptionAlgorithmIdentifier,
     kdfAlgorithm    KeyDerivationAlgorithmIdentifier,
     macAlgorithm    MessageAuthenticationCodeAlgorithm }
]]>
	  </artwork>
	</figure>
	The fields are used as follows:
	<list style="symbols">
	  <t>
	    The wrapAlgorithm value identifies the algorithm which
	    will be used to wrap the CPK.
	  </t>
	  <t>
	    The kdfAlgorithm value identifies the key-derivation
	    function which will be used to derive the wrap-encryption
	    key and the wrap-MAC key from the wrap-key.
	  </t>
	  <t>
	    The macAlgorithm value identifies the MAC algorithm used
	    to provide data-origin authentication.
	  </t>
	</list>
	The With-MAC algorithm CAN NOT be used in a
	KeyTransRecipientInfo structure, but CAN be used in a
	KeyAgreeRecipientInfo, KEKRecipientInfo or
	PasswordRecipientInfo structure.  When the With-MAC key-wrap
	algorithm is provided as the key-wrap algorithm in one of
	these three structures, the encryptedKey field of that
	structure MUST hold the DER encoding of a
	EncryptedKeyWithMACValue value:
	<figure>
	  <artwork>
<![CDATA[
EncryptedKeyWithMACValue  ::=  SEQUENCE  {
     encryptedKey             EncryptedKey,
     macValue                 MessageAuthenticationCode }
]]>
	  </artwork>
	</figure>
	These fields are used as follows:
	<list style='symbols'>
	  <t>
	    The encryptedKey field holds the wrapped CPK, and
	  </t>
	  <t>
	    The macValue holds a MAC value computed over the
	    'ciphertext' of the enclosing EnvelopedData,
	    AuthenticatedData, or AuthEnvelopedData. That is, this
	    document follows the 'encrypt then MAC' paradigm, in which
	    the plaintext is encrypted and the ciphertext MACed.
	  </t>
	</list>
	These fields are discussed in more detail in the next sections.
      </t>
    </section>

    <section anchor="sec:sender" title="Actions of the sender">
      <t>
	The specific actions of the sender depend on whether it is
	being used as the key-wrap algorithm of a
	KeyAgreeRecipientInfo, PasswordRecipientInfo or
	KEKRecipientInfo structure, and whether that structure is in
	an EnvelopedData, AuthenticatedData or AuthEnvelopedData
	structure. In all cases, the sender chooses a key-encryption
	algorithm, a key-derivation algorithm, and a MAC algorithm. It
	then encodes these choices and their associated parameters
	in a WithMACParameters structure. If the kdfAlgorithm
	parameters includes a 'key length' field of any type
	(e.g. PBKDF2 <xref target="RFC3370"/>) then this MUST be set
	to zero. The sender then creates an AlgorithmIdentifier
	structure composed of the id-alg-WithMACWrap value in the
	algorithm field and that WithMACParameters structure in the
	parameters field.
	
	<vspace blankLines="1"/>
	The sender then places this AlgorithmIdentifier in the
	keyEncryptionAlgorithm of the key-wrap structure being
	constructed (KeyAgreeRecipientInfo, KEKRecipientInfo, or
	PasswordRecipientInfo). Then, the sender performs the
	following actions once per EncryptedKey value in the key-wrap
	structure. This will be exactly once, in the case of
	KEKRecipientInfo and PasswordRecipientInfo, and once per
	RecipientEncryptedKey in the case of KeyAgreeRecipientInfo.
	<list style='symbols'>
	  <t> First, the sender generates the CPK and uses it to
	  protect the payload of the EnvelopedData, AuthenticatedData
	  or AuthEnvelopedData structure as described in <xref
	  target="RFC5652"/>.
	  </t>
	  <t> Then, the sender generates the wrap-key according to
	  the standard CMS process for this key-wrap type:
	  <list style='symbols'>
	    <t>
	      In the case of PasswordRecipientInfo, the wrap key is
	      generated by applying a key-derivation function
	      (identified in the keyDerivationAlgorithm field of the
	      PasswordRecipientInfo structure) to the password.
	      </t>
	      <t>
		In the case of KEKRecipientInfo, the wrap key is the
		key identified by the kekid field of that structure.
	      </t>
	      <t>
		And in the case of KeyAgreeRecipientInfo, the wrap key
		is generated by applying the relevant key-agreement
		algorithm to the public value or the sender
		(identified in the originator field of the
		KeyAgreeRecipientInfo structure), the public value of
		the receiver (identified in the rid field of the
		RecipientEncryptedKey structure being built) and the
		fresh per-message randomness (in the ukm field if the
		KeyAgreeRecipientInfo structure) if present.
	      </t>
	  </list>
	  </t>
	  <t> 
	    The sender then derives the wrap-encryption key from the
	    wrap-key by applying the KDF identified in the
	    kdfAlgorithm field of the WithMACParameters
	    structure. Typically, key-derivation functions are used to
	    transform a password into a key, and some take an
	    additional 'context' or 'info' input <xref
	    target="HKDF"/> <xref target="RFC5869"/>:
	    <list style="symbols">
	    <t>
	      If the KDF takes a 'context' or 'info' parameter, then
	      the 'password' input to the KDF is the wrap key and the
	      'context'/'info' parameter will be the value of the
	      wrapAlgorithm field of the WithMACParameters
	      structure. That is, the type and length bytes are
	      omitted.
	    </t>
	    <t>
	      If the KDF does not take a 'context' or 'info'
	      parameter, then the 'password' input to the KDF is the
	      concatenation of the wrap-key and the value of the
	      wrapAlgorithm field of the WithMACParameters
	      structure. That is, the type and length bytes are
	      omitted.
	    </t>
	    </list>
	    In both cases, the length of the key to be generated is
	    that required by the algorithm identified in the
	    wrapAlgorithm field of the WithMACParameters structure.
	  </t>
	  <t>
	    The sender then uses the wrap-encryption key to wrap the
	    CPK, which depends on the top-level structure being built:
	    <list style='symbols'>
	      <t>
		In the case of EnvelopedData, the CPK is the
		content-encryption key.
	      </t>
	      <t> 
		In the case of AuthenticatedData, the CPK is the
		authentication key.
	      </t>
	      <t>
		In the case of AuthEnvelopedData, the CPK is the
		content-authenticated-encryption key.
	      </t>
	    </list>
	    In all cases, the CPK is wrapped according to the
	    algorithm and parameters identified in the wrapAlgorithm
	    field of the WithMACParameters structure created
	    above. This process results in an EncryptedKey value,
	    which we will call the 'inner EncryptedKey'.
	  </t>
	  <t> 
	    The sender then derives the wrap-MAC key from the
	    wrap-key by applying the KDF identified in the
	    kdfAlgorithm field of the WithMACParameters
	    structure: 
	    <list style="symbols">
	    <t>
	      If this KDF takes a 'context' or 'info' parameter, then
	      the 'password' input to the KDF is the wrap key and the
	      'context'/'info' parameter will be the value of the
	      macAlgorithm field of the WithMACParameters
	      structure. That is, the type and length bytes are
	      omitted.
	    </t>
	    <t>
	      If the KDF does not take a 'context' or 'info'
	      parameter, then the 'password' input to the KDF is the
	      concatenation of the wrap-key and the value of the
	      macAlgorithm field of the WithMACParameters
	      structure. That is, the type and length bytes are
	      omitted.
	    </t>
	    </list>
	    In both cases, the length of the key to be generated is
	    that required by the algorithm identified in the
	    macAlgorithm field of the WithMACParameters structure.
	  </t>
	  <t>
	    The sender then computes a MAC value by applying the MAC
	    algorithm identified in the macAlgorithm field of the
	    WithMACParameters structure to the wrap-MAC key and the data to
	    be protected:
	    <list style='symbols'>
	      <t>
		In the case of an EnvelopedData structure, the data to
		be protected is the value of the structure's
		encryptedContentInfo field. The type and length bytes
		are omitted.
	      </t>
	      <t>
		In the case of an AuthenticatedData structure, the
		data to be protected is the the DER encoding of the
		following structure:
		<figure>
		  <artwork>
<![CDATA[
AuthenticatedDataAuthenticatedContents  ::=  SEQUENCE  {
     encapContentInfo        EncapsulatedContentInfo, 
     authAttrs               AuthAttributes OPTIONAL }
]]>
		  </artwork>
		</figure>
		In this structure, the encapContentInfo field
		holds the same value as the same field in the
		AuthenticatedData structure. Likewise, the
		authAttrs field holds the same value as the same
		field in the AuthenticatedData structure if
		present, and omitted if absent.
	      </t>
	      <t>
		In the case of an AuthEnvelopedData structure, the
		data to be protected is the DER encoding of the
		following structure:
		<figure>
		  <artwork>
<![CDATA[
AuthEnvelopedDataAuthenticatedContents  ::=  SEQUENCE  {
     authEncryptedContentInfo        EncapsulatedContentInfo, 
     authAttrs                       AuthAttributes OPTIONAL }
]]>
		  </artwork>
		</figure>
		In this structure, the authEncryptedContentInfo field
		holds the same value as the same field in the
		AuthEnvelopedData structure. Likewise, the authAttrs
		field holds the same value as the same field in the
		AuthEnvelopedData structure if present, and omitted if
		absent.
	      </t>
	    </list>
	    The MAC algorithm will output a MessageAuthenticationCode
	    value.
	  </t>
	  <t>
	    The sender then embeds the inner EncryptedKey value and
	    this MessageAuthenticationCode value in an
	    EncryptedKeyWithMACValue structure.
	  </t>
	  <t>
	    The sender then DER-encodes this EncryptedKeyWithMACValue
	    structure, and embeds these octets (the 'outer
	    EncryptedKey value') in the encryptedKey field being constructed.
	  </t>
	</list>
      </t>
    </section>

    <section anchor="sec:receiver" title="Actions of the receiver">
      <t>
	When the receiver processes an EnvelopedData,
	AuthenticatedData or AuthEnvelopedData structure, and
	<list style='symbols'>
	  <t>
	    has selected has selected a RecipientInfo structure to
	    process for the CPK, and
	  </t>
	  <t>
	    recognizes the id-alg-WithMACWrap value in the algorithm field
	    of the AlgorithmIdentifier value in the keyEncryptionAlgorithm
	    field of that RecipientInfo structure,
	  </t>
	</list>
	it will perform the following steps:
	<list style='symbols'>
	  <t>
	    It first parses the parameters field of that
	    AlgorithmIdentifier as a WithMACParameters structure,
	    above. If the AlgorithmIdentifier in the kdfAlgorithm
	    field contains a key-length parameter in the Parameters
	    field, this MUST be set to zero.
	  </t>
	  <t>
	    The receiver then generates or retrieves the wrap-key
	    according to the standard CMS process for this key-wrap
	    type. It then derives a wrap-encryption key and wrap-MAC
	    key from the wrap-key as described in <xref
	    target="sec:sender"/>, using the algorithm identified in
	    the kdfAlgorithm field of the WithMACParameters structure.
	  </t>
	  <t>
	    It then parses the encryptedKey field of that
	    RecipientInfo structure (or the relevant
	    RecipientEncryptedKey structure, in the case of a
	    KeyAgreeRecipientInfo) as the DER encoding of a
	    EncryptedKeyWithMACValue. In this way, it recovers the
	    'inner' EncryptedKey value and a MessageAuthenticationCode
	    value.
	  </t>
	  <t>
	    It then decrypts the inner EncryptedKey value with the
	    wrap-encryption key, according to the algorithm identified
	    in the wrapAlgorithm field of the WithMACParameters
	    structure, In doing so, it recovers the wrapped key--be it
	    content-encryption key, authentication key, or
	    content-authenticated-encryption key.
	  </t>	
	  <t>
	    At this point, the receiver MUST both:
	    <list style="symbols">
	      <t>
		Use the wrapped key to process the encryptedContentInfo,
		encapContentInfo, or authEncryptedContentInfo as specified
		in <xref target="RFC5652"/>, <xref target="RFC5652"/> and <xref
		target="RFC5083"/> respectively, and
	      </t>
	      <t>
		Use the wrap-MAC key and the MAC algorithm specified in the
		macAlgorithm field of the WithMACParameters structure to
		verify the integrity of the protected data (defined in
		<xref target="sec:sender"/>).
	      </t>
	    </list>
	    The receiver SHOULD reject the entire top-level structure
	    (EnvelopedData, AuthenticatedData, or AuthEnvelopedData) if
	    the MAC value fails to verify.
	  </t>
	</list>
      </t>
    </section>


    <section anchor='sec:requirements' title="Requirements and Recommendations">
      <t>
	This document does not define the actions of sender or
	receiver when the top-level structure is EncryptedData or
	DigestedData. Therefore, this algorithm MUST NOT be used in
	EncryptedData or DigestedData structures. Similarly, this
	document does not define the actions of sender or receiver
	when the key-wrap mechanism is key-transport. Therefore, the
	With-MAC algorithm MUST NOT be used when the key-wrap
	structure is KeyTransRecipientInfo. This algorithm MAY but
	SHOULD NOT be used when the key-wrap method is based on
	key-agreement and the sender uses an ephemeral value, as the
	algorithm provides no data-origin guarantees in this
	case. (See <xref target="sec:security"/>.) However, receivers
	that support the use of this algorithm when the sender uses a
	static key-agreement key MUST also gracefully accept this use
	of this algorithm when the sender uses an ephemeral
	value. Such receivers MUST also reject the entire top-level
	structure when the MAC fails to verify, as in <xref
	target="sec:receiver"/>, even when the sender uses an
	ephemeral value.

	<vspace blankLines="1"/>      
	It is RECOMMENDED that implementations of this specification
	support EnvelopedData, AuthenticatedData and
	AuthEnvelopedData. 

	<vspace blankLines="1"/>      
	Implementations that support this specification MUST support
	the following key-wrap algorithms: id-aes128-wrap,
	id-aes192-wrap, id-aes256-wrap <xref target='RFC3394'/>.

	<vspace blankLines="1"/>      
	Implementations that support this specification MUST support
	the following key-derivation function algorithm: id-PBKDF2
	<xref target='RFC3370'/>. Furthermore, implementations that
	support this specification MUST support the use of the MAC
	algorithms of the next paragraph for use as the prf or this
	KDF <xref target="SP800-132"/>.

	<vspace blankLines="1"/>      
	Implementations that support this specification MUST support
	the following MAC algorithms: id-hmacWithSHA224,
	id-hmacWithSHA256, id-hmacWithSHA384, id-hmacWithSHA512, all
	with parameters present but set to type NULL <xref
	target='RFC4231'/>.


      </t>
      </section>
      

    <section anchor="sec:security" title="Security considerations">
      <t>
	The goal of this document is to add data-origin authentication
	to EnvelopedData, AuthenticatedData, and AuthEnvelopedData
	structures without weakening the existing security properties
	of those structures. To that end, it is essential that the
	key-derivation function used to derive the wrap-encryption and
	wrap-MAC key from the wrap key be sufficiently strong. Such
	algorithms are designed to take two inputs: some secret, weak
	randomness and some public, strong randomness, and are
	designed to output strong, secret randomness. In this
	application, the strong, public randomness is a salt value
	included in the AlgorithmIdentifier structure in the
	kdfAlgorithm field. However, this salt will be used twice:
	either to derive two keys from two related 'passwords' (the
	wrap-key concatenated with either the wrapAlgorithm value or
	the macAlgorithm value) or the same password (the wrap-key) in
	two different contexts (the wrapAlgorithm value or the
	macAlgorithm value). The security of this algorithm requires
	that the KDF ensure two resulting key (the wrap-encryption and
	wrap-MAC keys) are cryptographically independent. See <xref
	target='HKDF'/> for details. It is not yet known whether
	the PBKDF2 function satisfies this property, but there is no
	evidence to the contrary either. However, the HKDF scheme
	<xref target='RFC5869'/> provably achieves this property, and
	should be added to <xref target='sec:requirements'/> as a
	required and default algorithm when it receives an object
	identifier.

	<vspace blankLines="1"/> 
	In keeping with <xref  target="RFC6476"/>, this specification
	uses the 'encrypt then MAC' approach to combining encryption
	and integrity, rather than the 'MAC then encrypt'
	approach. For a discussion of this issue, see <xref
	target="EncryptThenAuth"/>. 

	<vspace blankLines="1"/> 
	This algorithm provides no data-origin guarantees when there
	is no binding between the wrap-key and the
	data-origin. Therefore, this document does not define the
	usage of this algorithm when the key-wrap mechanism is
	key-transport. Similarly, this algorithm will provide no
	data-origin guarantees when the key-wrap mechanisms is
	key-agreement and the data-origin uses an ephemeral
	key-agreement key value. Although such usage is valid under
	this specification, there is no advantage to using this
	algorithm rather than the algorithm identified in the
	wrapAlgorithm field of the WithMACParameters structure.

      </t>

    </section>


    <section anchor="iana" title="IANA Considerations">
      <t>
	This document makes use of object identifiers.  These object
	identifiers have been registered in an arc delegated to the
	IETF S/MIME Working Group. This arc and its registration
	procedures will be transferred to IANA soon.  No further
	action by IANA is necessary for this document or any
	anticipated updates.
      </t>
    </section>

    <section anchor="sec:acknowledgements" title="Acknowledgements">
      <t>
      The authors would like thank Jim Schaad for informing them of
      the attack described in <xref target="sec:intro"/>. We would
      also like to thank Russ Housely and Sean Turner for their
      valuable comments.
      </t>
    </section>


  </middle>



  <back>
    <references title="Normative References">



      <reference anchor='RFC5652'>
	<front>
	  <title>Cryptographic Message Syntax (CMS)</title>


	  <author initials='R.' surname='Housley' fullname='Russ Housley'>
	    <organization>Vigil Security</organization>
	  </author>

	  <date month='September' year='2009'/>

	  <area>Security</area>

	  <workgroup>S/MIME Main Security</workgroup> 
	</front>

	<seriesInfo name='RFC' value='5652'/>

	<format type='TXT'
		target='http://www.ietf.org/rfc/rfc5652.txt'/>
      </reference>

         

      <reference anchor='RFC5280'>
	<front>
	  <title>Internet X.509 Public Key Infrastructure Certificate
             and Certificate Revocation List (CRL) Profile</title>


	  <author initials='D.' surname='Cooper' fullname='D. Cooper'>
	    <organization>NIST</organization>
	  </author>
	  <author initials='S.' surname='Santesson' fullname='S. Santesson'>
	    <organization>Microsoft</organization>
	  </author>
	  <author initials='S.' surname='Farrell' fullname='S. Farrell'>
	    <organization>Trinity College Dublin</organization>
	  </author>
	  <author initials='S.' surname='Boeyen' fullname='S. Boeyen'>
	    <organization>Entrust</organization>
	  </author>
	  <author initials='R.' surname='Housley' fullname='R. Housley'>
	    <organization>Vigil Security</organization>
	  </author>
	  <author initials='W.' surname='Polk' fullname='W. Polk'>
	    <organization>NIST</organization>
	  </author>

	  <date month='May' year='2008'/>

	</front>

	<seriesInfo name='RFC' value='5280'/>

	<format type='TXT'
		target='http://www.ietf.org/rfc/rfc5280.txt'/>
      </reference>




      <reference anchor='RFC5083'>
	<front>
	  <title>
	    Cryptographic Message Syntax (CMS)
	    Authenticated-Enveloped-Data Content Type
	  </title>

	  <author initials='R.' surname='Housley' fullname='Russ Housley'>
	    <organization>Vigil Security</organization>
	  </author>

	  <date month='November' year='2007'/>

	  <area>Security</area>

	  <workgroup>S/MIME Main Security</workgroup> 
	</front>

	<seriesInfo name='RFC' value='5083'/>

      </reference>

      <reference anchor="RFC2119">
	<front>
	  <title>
	    Key words for use in RFCs to Indicate Requirement Levels
	  </title>
	  <author initials='S.' surname="Bradner" fullname="S. Bradner">
	    <organization>Harvard University</organization>
	  </author>
	  <date month='March' year='1997'/>
	</front>
	<seriesInfo name='RFC' value='2119'/>
      </reference>


      <reference anchor='RFC3370'>
	<front>
	  <title>Cryptographic Message Syntax (CMS) Algorithms</title>


	  <author initials='R.' surname='Housley' fullname='Russ Housley'>
	    <organization>RSA Laboratories</organization>
	  </author>

	  <date month='August' year='2002'/>

	  <area>Security</area>

	  <workgroup>S/MIME Main Security</workgroup> 
	</front>

	<seriesInfo name='RFC' value='3370'/>

      </reference>



      <reference anchor='RFC3394'>
	<front>
	  <title>
	    Advanced Encryption Standard (AES) Key Wrap Algorithm
	  </title>

	  <author initials='J.' surname='Schaad' fullname='J. Schaad'>
	    <organization>Soaring Hawk Consulting</organization>
	  </author>
	  <author initials='R.' surname='Housley' fullname='R. Housley'>
	    <organization>RSA Laboratories</organization>
	  </author>

	  <date month='September' year='2002'/>
	</front>

	<seriesInfo name='RFC' value='3394'/>
	<format type='TXT'
		target='http://www.rfc-editor.org/rfc/rfc3394.txt'/>

      </reference>

      <reference anchor='RFC4231'>
	<front>
	  <title>
	    Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256,
	    HMAC-SHA-384, and HMAC-SHA-512
	  </title>

	  <author initials='M.' surname='Nystrom' fullname='M. Nystrom'>
	    <organization>RSA Security</organization>
	  </author>

	  <date month='December' year='2005'/>
	</front>

	<seriesInfo name='RFC' value='4231'/>
	<format type='TXT'
		target='http://www.rfc-editor.org/rfc/rfc4231.txt'/>

      </reference>

      <reference anchor='SP800-132'>
	<front>
	  <title>
	    Recommendation for Password-Based Key Derivation
	    Part 1: Storage Applications (DRAFT)
	  </title>

	  <author initials='M. S.' surname='Turan' fullname='Meltem Sönmez Turan'>
	    <organization>NIST</organization>
	  </author>
	  <author initials='E.' surname='Barker' fullname='Elaine Barker'>
	    <organization>NIST</organization>
	  </author>
	  <author initials='W.' surname='Burr' fullname='William Burr'>
	    <organization>NIST</organization>
	  </author>
	  <author initials='L.' surname='Chen' fullname='Lily Chen'>
	    <organization>NIST</organization>
	  </author>

	  <date month='June' year='2010'/>
	</front>

	<seriesInfo name='NIST Special Publication' value='800-132'/>

      </reference>

      <reference anchor='X.680'>
	<front>
	  <title>Information Technology - Abstract Syntax Notation One</title>

	  <author>
	    <organization>ITU-T</organization>
	  </author>

	  <date year='2002'/>
	</front>

	<seriesInfo name="Recommendation" value="X.680"/>
	<seriesInfo name="ISO/IEC" value="8824-1:2002"/>

      </reference>

      <reference anchor='X.681'>
	<front>
	  <title>Information Technology - Abstract Syntax Notation
	  One: Information Object Specification</title>

	  <author>
	    <organization>ITU-T</organization>
	  </author>

	  <date year='2002'/>
	</front>

	<seriesInfo name="Recommendation" value="X.681"/>
	<seriesInfo name="ISO/IEC" value="8824-2:2002"/>

      </reference>

      <reference anchor='X.682'>
	<front>
	  <title>Information Technology - Abstract Syntax Notation
	  One: Constraint Specification</title>

	  <author>
	    <organization>ITU-T</organization>
	  </author>

	  <date year='2002'/>
	</front>

	<seriesInfo name="Recommendation" value="X.682"/>
	<seriesInfo name="ISO/IEC" value="8824-3:2002"/>

      </reference>

      <reference anchor='X.683'>
	<front>
	  <title>Information Technology - Abstract Syntax Notation
	  One: Parameterization of ASN.1 Specifications</title>

	  <author>
	    <organization>ITU-T</organization>
	  </author>

	  <date year='2002'/>
	</front>

	<seriesInfo name="Recommendation" value="X.683"/>
	<seriesInfo name="ISO/IEC" value="8824-4:2002"/>

      </reference>


    </references>


    <references title="Informative References">




      <reference anchor='RFC6278'>
	<front>
	  <title>Use of static-static Elliptic-Curve Diffie-Hellman key agreement in Cryptographic Message Syntax</title>

	  <author initials='J.' surname='Herzog' fullname='J. Herzog'>
	    <organization>MIT Lincoln Laboratory</organization>
	  </author>
	  <author initials='R.' surname='Khazan' fullname='R. Khazan'>
	    <organization>MIT Lincoln Laboratory</organization>
	  </author>

	  <date month='November' year='2010'/>

	  <area>Security</area>

	</front>

	<seriesInfo name='RFC' value='6278'/>

	<format type='TXT'
		target='http://www.rfc-editor.org/rfc/rfc6278.txt'/>
      </reference>


      <reference anchor='RFC6476'>
	<front>
	  <title>Using Message Authentication Code (MAC) Encryption
    in the Cryptographic Message Syntax (CMS)</title>

	  <author initials='p.' surname='Gutmann' fullname='P. Gutmann'>
	    <organization>University of Auckland</organization>
	  </author>

	  <date month='January' year='2012'/>


	</front>

	<seriesInfo name='RFC' value='6476'/>

	<format type='TXT'
		target='http://www.rfc-editor.org/rfc/rfc6476.txt'/>
      </reference>


      <reference anchor='HKDF'>
	<front>
	  <title>Cryptographic Extraction and Key
                Derivation: The HKDF Scheme</title>

	  <author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'>
	    <organization>IBM Research</organization>
	  </author>

	  <date month='August' year='2010'/>


	</front>

	<seriesInfo name='Proceedings of CRYPTO' value='2010'/>

	<format type='TXT'
		target='http://eprint.iacr.org/2010/264'/>
      </reference>


      <reference anchor='EncryptThenAuth'>
	<front>
	  <title>The Order of Encryption and Authentication for Protecting Communications (or: How Secure Is SSL?)</title>

	  <author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'>
	  </author>

	  <date month='August' year='2001'/>


	</front>

	<seriesInfo name='Proceedings of CRYPTO' value='2001'/>

      </reference>


      <reference anchor='RFC5869'>
	<front>
	  <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>


	  <author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'>
	    <organization>IBM Research</organization>
	  </author>
	  <author initials='P.' surname='Eronen' fullname='P. Eronen'>
	    <organization>Nokia</organization>
	  </author>

	  <date month='May' year='2010'/>

	</front>

	<seriesInfo name='RFC' value='5869'/>
	<format type='TXT'
		target='http://tools.ietf.org/rfc/rfc5869.txt/'/>

      </reference>



    </references>

    <section title="ASN.1 Module">
      <t>
	This appendix provides the normative ASN.1 definitions for the 
	structures described in this specification using ASN.1 as defined in 
	<xref target="X.680"/> through <xref target="X.683"/>. 

	<figure>
	  <artwork>
WithMACKeyEncryption
  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9) 
    smime(16) modules(0) XX } 

DEFINITIONS IMPLICIT TAGS ::= 

BEGIN 

-- EXPORTS ALL  

IMPORTS 

   KeyEncryptionAlgorithmIdentifier,
   KeyDerivationAlgorithmIdentifier,
   MessageAuthenticationCodeAlgorithm,
   EncryptedKey,
   MessageAuthenticationCode,
   AuthAttributes,
   EncapsulatedContentInfo,
   EncryptedContentInfo
     FROM CryptographicMessageSyntax2004
       { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
         smime(16) modules(0) cms-2004(24)}
   ;

id-alg-WithMACWrap OBJECT IDENTIFIER ::= { iso(1) member-body(2)
    us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) alg(3) X }

WithMACParameters  ::=  SEQUENCE  {
     wrapAlgorithm               KeyEncryptionAlgorithmIdentifier,
     kdfAlgorithm                KeyDerivationAlgorithmIdentifier,
     macAlgorithm                MessageAuthenticationCodeAlgorithm }

EncryptedKeyWithMACValue  ::=  SEQUENCE  {
     encryptedKey             EncryptedKey,
     macValue                 MessageAuthenticationCode }


AuthenticatedDataAuthenticatedContents  ::=  SEQUENCE  {
     encapContentInfo        EncapsulatedContentInfo, 
     authAttrs               AuthAttributes OPTIONAL }

AuthEnvelopedDataAuthenticatedContents  ::=  SEQUENCE  {
     authEncryptedContentInfo        EncryptedContentInfo, 
     authAttrs                       AuthAttributes OPTIONAL }

END 
	  </artwork>
	</figure>
      </t>
    </section>



  </back>
</rfc>


<!-- LocalWords:  Diffie Hellman ECDH AuthEnvelopedData AuthenticatedData kari
-->
<!-- LocalWords:  EnvelopedData RecipientInfo originatorInfo EC ukm CEK KEK DER
-->
<!-- LocalWords:  KeyAgreeRecipientInfo subjectKeyIdentifier KeyWrapAlgorithm
-->
<!-- LocalWords:  keyEncryptionAlgorithm recipientEncryptedKeys EncryptedKey
-->
<!-- LocalWords:  RecipientEncryptedKey KeyAgreeRecipientIdentifier keydatalen
-->
<!-- LocalWords:  RecipientKeyIdentifier SharedInfo entityUInfo macAlgorithm
-->
<!-- LocalWords:  StaticECDHUserKeyingMaterial digestAlgorithm
-->
