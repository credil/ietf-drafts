<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="no" ?>
<?rfc subcompact="no" ?>
<?rfc comments="yes" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1964 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1964.xml">
<!ENTITY RFC2138 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2138.xml">
<!ENTITY RFC2203 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2203.xml">
<!ENTITY RFC2743 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml">
<!ENTITY RFC2865 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml">
<!ENTITY RFC2903 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2903.xml">
<!ENTITY RFC2904 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2904.xml">
<!ENTITY RFC3579 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3579.xml">
<!ENTITY RFC3588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml">
<!ENTITY RFC3645 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3645.xml">
<!ENTITY RFC3748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml">
<!ENTITY RFC4017 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4017.xml">
<!ENTITY RFC4072 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4072.xml">
<!ENTITY RFC4282 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4282.xml">
<!ENTITY RFC4422 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml">
<!ENTITY RFC4462 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4462.xml">
<!ENTITY RFC5056 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml">
<!ENTITY RFC5106 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5106.xml">
<!ENTITY RFC5801 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5801.xml">
<!ENTITY RFC5849 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml">
<!ENTITY RFC6677 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6677.xml">
<!ENTITY I-D.nir-tls-eap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nir-tls-eap.xml">
<!ENTITY I-D.ietf-oauth-v2 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2.xml">
<!ENTITY I-D.iab-privacy-considerations SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.iab-privacy-considerations.xml">
<!ENTITY I-D.ietf-abfab-gss-eap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-abfab-gss-eap.xml">
<!ENTITY I-D.ietf-abfab-aaa-saml SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-abfab-aaa-saml.xml">
<!ENTITY I-D.hartman-emu-mutual-crypto-bind SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hartman-emu-mutual-crypto-bind.xml">
<!ENTITY I-D.ietf-emu-chbind SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-emu-chbind.xml">
<!ENTITY I-D.ietf-emu-eap-tunnel-method SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-emu-eap-tunnel-method.xml">
<!ENTITY SAML20 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
]>

<!-- Ticket #7 Open -->
<!-- Ticket #8 Open -->
<!-- Ticket #9 Open -->
<!-- Ticket #10 Open -->
<!-- Ticket #23 Open -->
<!-- Ticket #27 Open -->


<rfc category="info" docName="draft-ietf-abfab-arch-04.txt" ipr="trust200902">
  <front>
    <title abbrev="ABFAB Architecture">Application Bridging for Federated Access Beyond Web (ABFAB) Architecture</title>

    <author initials="J." surname="Howlett" fullname="Josh Howlett">
      <organization>JANET(UK)</organization>
      <address>
        <postal>
          <street>Lumen House, Library Avenue, Harwell</street>
          <city>Oxford</city>
          <code>OX11 0SG</code>
          <country>UK</country>
        </postal>
        <phone>+44 1235 822363</phone>
        <email>Josh.Howlett@ja.net</email>
      </address>
    </author>
    <author initials="S." surname="Hartman" fullname="Sam Hartman">
      <organization>Painless Security</organization>
      <address>
        <postal>
          <street> </street>
          <city> </city>
          <code> </code>
          <country> </country>
        </postal>
        <phone> </phone>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Nokia Siemens Networks</organization>
      <address>
        <postal>
          <street>Linnoitustie 6</street>
          <city>Espoo</city>
          <code>02600</code>
          <country>Finland</country>
        </postal>
        <phone>+358 (50) 4871445</phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>
    <author fullname="Eliot Lear" initials="E." surname="Lear">
      <organization>Cisco Systems GmbH</organization>
      <address>
        <postal>
          <street>Richtistrasse 7</street>
          <city>Wallisellen</city>
          <code>CH-8304</code>
          <region>ZH</region>
          <country>Switzerland</country>
        </postal>
        <phone>+41 44 878 9200</phone>
        <email>lear@cisco.com</email>
      </address>
    </author>
    <author fullname="Jim Schaad" initials="J." surname="Schaad">
      <organization>Soaring Hawk Consulting</organization>
      <address>
        <email>ietf@augustcellars.com</email>
      </address>
    </author>
    <date/>
    <area>Security</area>
    <workgroup>ABFAB</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Federated Authentication</keyword>
    <keyword>AAA</keyword>
    <keyword>RADIUS</keyword>
    <keyword>Diameter</keyword>
    <keyword>GSS-API</keyword>
    <keyword>EAP</keyword>
    <keyword>SAML</keyword>
    <abstract>
      <t>
        Over the last decade a substantial amount of work has occurred in
        the space of federated access management.  Most of
        this effort has focused on two use-cases: network and
        web-based access. However, the solutions to these use-cases that
        have been proposed and deployed tend to have few common building blocks in common.
      </t>
      <t>
        This memo describes an architecture that makes use of
        extensions to the commonly used security mechanisms for both federated and
        non-federated access management, including
        the Remote Authentication Dial In User Service (RADIUS)
        and the Diameter protocol, the Generic Security Service (GSS), the GS2 family, the Extensible Authentication Protocol (EAP) and the Security Assertion Markup Language (SAML). The architecture addresses 
        the problem of federated access management to primarily non-web-based
        services, in a manner that will scale to large numbers of identity providers, relying parties, and 
        federations.
      </t>
    </abstract>
  </front>
  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
    <section anchor="introduction" title="Introduction">
      <t>
        The Internet uses numerous security mechanisms to manage
        access to various resources.  These mechanisms have been generalized
        and scaled over the last decade through mechanisms such as
        <xref target="RFC5801">Simple Authentication and Security Layer (SASL) with the Generic Security Server Application Program Interface (GSS-API) (known as the GS2 family)</xref>, <xref target="OASIS.saml-core-2.0-os">Security Assertion Markup Language (SAML)</xref>, and the Authentication, Authorization, and Accounting (AAA) architecture as embodied in <xref target="RFC2865">RADIUS</xref> and <xref target="RFC3588">Diameter</xref>.
      </t>
      <t>
        A Relying Party (RP) is the entity that manages access to some resource.
        The actor that is requesting access to that resource is often described as the Client.
        Many security mechanisms are manifested as an exchange of information between these actors.
        The RP is therefore able to decide whether the Client is authorized, or not.
      </t>
      <t>
        Some security mechanisms allow the RP to delegate aspects 
        of the access management decision to an actor called the
        Identity Provider (IdP).
        This delegation requires technical signaling, trust and a common understanding of
        semantics between the RP and IdP. These aspects are generally managed within a 
        relationship known as a 'federation'. This style of access management is accordingly
        described as 'federated access management'.
      </t>
      <t>
        Federated access management has evolved over
        the last decade through specifications like SAML <xref target="OASIS.saml-core-2.0-os"/>,
        <eref target="http://www.openid.net">OpenID</eref>, OAuth <xref target="RFC5849"/>, <xref target="I-D.ietf-oauth-v2"/> and WS-Trust <xref target="WS-TRUST"/>. The benefits of federated access management include:
        <list style="hanging">
          <t hangText="Single or Simplified sign-on:"> 
            <vspace blankLines="1"/> An Internet service can delegate access management, 
            and the associated responsibilities such as identity management and credentialing,
            to an organisation that already has a long-term relationship with the Subject.
            This is often attractive for Relying Parties who frequently do not want these responsibilities.
            The Subject also requires fewer credentials, which is also desirable.
          </t>
          <t hangText="   Data Minimization and User Participation:">
            <!-- Old title - Privacy  - DONE -->
            <vspace blankLines="1"/> 
            Often a Relying Party does not need to know the identity of a Subject to reach an access management decision.
            It is frequently only necessary for the Relying Party know specific attributes about the subject, for example, that the Subject is affiliated with a particular organisation or has a certain role or entitlement.
            Sometimes the RP only needs to know a pseudonym of the Subject.

            <vspace blankLines="1"/>
            Prior to the release of attributes to the IdP from the IdP, the IdP will check configuration and policy to determine if the attributes are to be released.
            There is currently no direct client participation in this decision.
            
            <!-- Old text
                 Sometimes the RP does not need to know the identity of the Subject, but does require a unique long-term identifier for the Subject (for example, so that it can recognise
                 the Subject subsequently); in this case, it is a common practise for the IdP to only
                 release a pseudonym that is specific to that particular Relying Party.
                 Federated access management therefore provides various strategies for protecting
                 the Subject's privacy. Other privacy aspects typically of concern are the policy for releasing 
                 personal data about the Subject from the IdP to the RP, the purpose of the usage, the retention period
                 of the data, and many more. 
                 DONE -->
          </t>
          <!-- Hannes

Data Minimization and User Participation: 

Often a Relying Party does not need to know the identity of a
Subject to reach an access management decision.  It is frequently
only necessary for the Relying Party know specific attributes
about the subject, for example, that the Subject is affiliated
with a particular organisation or has a certain role or
entitlement.

Prior to the transfer of attributes from the IdP to the RP the 
consent of the Subject is often explicitly obtained. Along with the 
transfer of attributes usage constraints and retention policies 
are enforced by the IdP. 

JLS - Pushback on the last paragraph for consent - however we probably need to say something here
M00TODO
- DONE - Tried to get a new text for the concern, but with consent.
          -->

          <t hangText="Provisioning"><vspace blankLines="1"/>
          Sometimes a Relying Party needs, or would like, to know more about
          a subject than an affiliation or a pseudonym. For example, a Relying Party may want
          the Subject's email address or name. Some federated access management technologies 
          provide the ability for the IdP to supply this information, either on request
          by the RP or unsolicited.
          </t>
        </list>
      </t>
      <t>
        This memo describes the Application Bridging for Federated Access Beyond the Web (ABFAB) architecture.
        This architecture makes use of extensions to the commonly used security mechanisms for both federated and non-federated access management, including the RADIUS and the Diameter protocols, the Generic Security Service (GSS), the GS2 family, the Extensible Authentication Protocol (EAP) and SAML.
        The architecture addresses the problem of federated access management primarily for non-web-based services.
        It does so in a manner that will scale to large numbers of identity providers, relying parties, and federations.
      </t>

      <!-- ////////////////////////////////////////////////////////////////////////////////// -->

      <section anchor="terminology" title="Terminology">

        <t>
          This document uses identity management and privacy terminology from <xref target="I-D.iab-privacy-considerations"/>. 
          In particular, this document uses the terms identity provider, relying party, (data) subject, identifier, pseudonymity, unlinkability, and anonymity.
        </t> 

        <t>
          In this architecture the IdP consists of the following components: an EAP server, a RADIUS or a Diameter server, and optionally a SAML Assertion service.  
        </t>
        
        <t>
          This document uses the term Network Access Identifier (NAI), as defined in <xref target="RFC4282"/>.   An NAI consists of a realm identifier, which is associated with an IdP and a username which is associated with a specific client of the IdP.
        </t> 

        <t>
          One of the problems people will find with reading this document is that the terminology sometimes appears to be inconsistent.
          This is due the fact that the terms used by the different standards we are picking up don't use the same terms.
          In general the document uses either a consistent term or the term associated with the standard under discussion as appropriate.
          For reference we include this table which maps the different terms into a single table.
        </t>

        <texttable>
          <ttcol align='left'>Protocol</ttcol>  <ttcol align='left'>Subject</ttcol> <ttcol align='left'>Relying Party</ttcol> <ttcol align='left'>Identity Provider</ttcol>
          <c>ABFAB</c>                    <c>Client</c>                  <c>Relying Party (RP)</c>            <c>Identity Provider (IdP)</c>
          <c></c>                         <c>Initiator</c>                <c>Acceptor</c>                              <c></c>
          <c>SAML</c>                     <c>Subject</c>                  <c>Service Provider</c>              <c>Issuer</c>
          <c>GSS-API</c>                  <c>Initiator</c>                  <c>Acceptor</c>            <c></c>
          <c>EAP</c>                      <c>EAP peer</c>                <c></c>                                <c>EAP server</c>
          <c>AAA</c>                      <c></c>                         <c>AAA Client</c>                       <c>AAA server</c>
          <c>RADIUS</c>                   <c>user</c>                   <c>NAS</c>                              <c>RADIUS server</c>
          <c></c>                         <c></c>                   <c>RADIUS client</c>                   <c></c>
        </texttable>

        <t>
          Note that in some cases a cell has been left empty, in these cases there is no direct name that represents this concept.
        </t>
        
        <t>
          Note to reviewers - I have most likely missed some entries in the table.
          Please provide me with both correct names from the protocol and missing names that are used in the text below.
        </t>

      </section>

      <section title="An Overview of Federation">
        <t>
          In the previous section we introduced the following actors:
          <list style="symbols">
            <t>the Client,</t>
            <t>the Identity Provider, and </t>
            <t>the Relying Party.</t>
          </list>

          One additional actor in can be an Individual.  An individual is a human being that is using a client.  Individuals may or may not exist in any given deployment.  The client may be either a front end on an individual or an independent automated entity.
        </t>
        <t>
          These entities and their relationships are illustrated graphically in <xref target="framework"/>.
        </t>
        <t>
          <figure title="Entities and their Relationships" anchor="framework">
            <artwork><![CDATA[

 ,----------\                        ,---------\
 | Identity |       Federation       | Relying |
 | Provider +  <-------------------> + Party   |
 `----------'                        '---------'
        <
         \                              
          \ Authentication                   
           \                 
            \                         
             \                      
              \                    
               \  +---------+  
                \ |         |  O    
                 v| Client  | \|/ Individual
                  |         |  |
                  +---------+ / \
            ]]></artwork>
          </figure>
        </t>

        <t>
          The relationships between the entities in <xref target="framework"/> are:
          <list style="hanging">
            <t hangText="Federation">
              <vspace blankLines="1"/>
              The Identity Provider and the Relying Parties are part of a Federation.
              The relationship may be direct (they have an explicit trust relationship) or transitive (the trust releationship is mediated by one or more entities).
              The federation relationship is governed by a federation agreement.
              Within a single federation, there may be multiple Identity Providers as well as multiple Relying Parties.
              A federation is governed by a federation agreement.
            </t>
            <t hangText="Authentication">
              <vspace blankLines="1"/>
              There is a direct relationship between the Client and the Identity Provider by which the entities trust and can securely authenticate each other.
            </t>
          </list>
        </t>
        
        <t>
          A federation agreement typically encompasses operational specifications and legal rules:
        </t>
        
        <t>
          <list style="hanging">
            <t hangText="Operational Specifications:">
              <vspace blankLines="1"/>
              These includes the technical specifications (e.g. protocols used to communicate between the three parties), 
              process standards, policies, identity proofing, credential and authentication algorithm requirements, performance requirements, assessment and audit criteria, etc.
              The goal of operational specifications is to provide enough definition that the system works and interoperability is possible.
            </t>
            <t hangText="Legal Rules:">
              <vspace blankLines="1"/>
              The legal rules take the legal framework into consideration and provides contractual obligations for each entity.  The rules define the responsibilities of each party and provide further clarification of the operational specifications.
              These legal rules regulate the operational specifications, make operational specifications legally binding to the participants, define and govern the rights and responsibilities of the participants. 
              The legal rules may, for example, describe liability for losses, termination rights, enforcement mechanisms, measures of damage, dispute resolution, warranties, etc.
            </t>
          </list>
        </t>
        
        <!-- Talk about operational implications -->
        <t>
          <!-- This feels out of context at this point in the text - Paul Leach -->
          <!-- Hannes - 
               Some deployments demand the usage of sophisticated technical
               infrastructure, including message routing intermediaries, to offer
               the required technical functionality.  In other deployments fewer
               technical components are needed.
               - DONE
          -->
          The Operational Specifications can demand the usage of a sophisticated technical infrastructure, including requirements on the message routing intermediaries, to offer the required technical functionality.
          In other environments, the Operational Specifications require  fewer technical components in order to meet the required technical functionality.
        </t>

        <!--  Talk about Legal Rules -->
        <t>
          <!-- This is an awkward sentence and needs to be fixed - Paul Leach - DONE -->
          The Legal Rules include many non-technical aspects of federation, such as business practices and legal arrangements, which are  outside the scope of the IETF.  The Legal Rules can still have an impact the architectural setup or on how to ensure the dynamic establishment of trust.
        </t>

        <!-- General Federation -->
        <t>
          While a federation agreement is often discussed within the context of formal relationships, such as between an enterprise and an employee or a government and a citizen, a federation agreement does not have to require any particular level of formality.
          For an IdP and a Client, it is sufficient for a relationship to be established by something as simple as using a web form and confirmation email.
          For an IdP and an RP, it is sufficient for the IdP to publish contact information along with a public key and for the RP to use that data.
          With in the framework of ABFAB, it will generally be required that a mechanism exists for the IdP to be able to trust the identity of the RP, if this is not present then the IdP cannot provide the assurances to the client that the identity of the RP has been established.
          <!-- Paul says I don't understand this. - DONE -->
          <!-- Jim says - I don't know that this is a true statement anymore - how do you get channel binding done in this situation? - DONE -->
        </t>
        <!-- IdP TO RP -->
        
        <t>
          The nature of federation dictates that there is some form of relationship between the identity provider and the relying party.
          This is particularly important when the relying party wants to use information obtained from the identity provider for access management decisions and when the identity provider does not want to release information to every relying party (or only under certain conditions).
        </t>
        
        <t>
          While it is possible to have a bilateral agreement between every IdP and every RP; on an Internet scale this setup requires the introduction of the multi-lateral federation concept, as the management of such pair-wise relationships would otherwise prove burdensome.
        </t>
        
        <!-- IdP To Client -->
        
        <t>
          The IdP will typically have a long-term relationship with the Client.
          This relationship typically involves the IdP positively identifying and credentialing the Client (for example, at time of employment within an organization).
          <!-- s/often be instantiated within/also involve/ - Paul Leech -->
          <!-- Hannes - NIST SP 800-63 calls this initial phase identity proofing.  Should we re-use that terminology? - OPEN -->
          The relationship will often be instantiated within an agreement between the IdP and the Client (for example, within an employment contract or terms of use that stipulates the appropriate use of credentials and so forth).
        </t>
        
        
        <t>
          The nature and quality of the relationship between the Subject and the IdP is an important contributor to the level of trust that an RP may attribute to an assertion describing a Client made by an IdP.
          This is sometimes described as the Level of Assurance. <!-- Hannes - Reference NIST SP 800-63 as they since they came up with the concept? -->
        </t>
        
        <t>
          <!-- Paul - s/imposes requirement of/require/ - DONE -->
          Federation does not require an a priori relationship or a long-term relationship between the RP and the Client; it is this property of federation that yields many of its benefits. 
          However, federation does not preclude the possibility of a pre-existing relationship between the RP and the Client, nor that they may use the introduction to create a new long-term relationship independent of the federation.
        </t>

        <t>
          Finally, it is important to reiterate that in some scenarios there might indeed be an Individual behind the Client and in other cases the Client may be autonomous.
          <!-- Paul - Please provide an example - M00TODO -->
          <!-- Hannes - use Individual not human - DONE -->
        </t>
      </section>


      
      <section title="Challenges for Contemporary Federation">
        <t>
          As the number of federated services has proliferated, the role of the individual can become ambiguous in certain circumstances. 
          
          
          For example, a school might provide online access for a student's grades to their parents for review, and to the student's teacher for modification.
          A teacher who is also a parent must clearly distinguish her role upon access.
        </t>
        
        <t>
          Similarly, as the number of federations proliferates, it becomes increasingly difficult to discover which identity provider(s) a user is associated with.
          This is true for both the web and non-web case, but is particularly acute for the latter as many non-web authentication systems are not semantically rich enough on their own to allow for such ambiguities.
          For instance, in the case of an email provider, the use of SMTP and IMAP protocols do not have the ability for the server to get additional information, beyond the clients NAI, in order to provide additional input to decide between multiple federations it may be associated with.
          However, the building blocks do exist to add this functionality.
          
          <!-- Paul - What does this mean ("select a federation")?  I can see what selecting an IdP means, but what does it mean to select a federation? - DONE -->
        </t>
      </section>

      <section title="An Overview of ABFAB-based Federation">
        <t>
          The previous section described the general model of federation, and its the application of federated access management.
          This section provides a brief overview of ABFAB in the context of this model.
          <!-- Paul - Something wrong here.  Also, wasn't anything called "federated access management".  Also suggest running through the steps in an auth exchange w/o mentioning particular mechanism -->
        </t>
        
        <t>
          In this example, a client is attempting to connect to a server in order to either get access to some data or perform some type of transaction.
          In order for the client to mutually authenticate with the server, the following steps are taken in an ABFAB federated architecture:
        </t>
        
        <t>
          <list style="numbers">
            <!-- Paul - Before this step, I'd introduce that Principals have NAIs, and that an IdP owns all NAIs in some set of realms. - DONE -->
            <t>
              Client Configuration:
              <!-- Paul- In addition to the principal's NAI? - DONE -->
              The Client Application is configured with an NAI assigned by the IdP.  It is also configured with any keys, certificates, passwords or other secret and public information needed to run the EAP protocols between it and the IdP.
              <!-- Old Text
                   The provided NAI contains, at a minimum, the realm of the client's NAI.
                   The realm represents the IdP to be discovered.
              -->
            </t>
            
            <t>
              Authentication mechanism selection:
              The GSS-EAP GSS-API mechanism is selected for authentication/authorization.
            </t>
            
            <t>
              Client provides an NAI to RP:
              
              The client application sets up a transport to the RP and begins the GSS-EAP authentication.
              In response, the RP sends an  EAP request message (nested in the GSS-EAP protocol) asking for the Client's name.
              The Client sends an EAP response with an NAI name form that at a minimum, contains the realm portion of it's full NAI.
            </t>
            
            <t>
              Discovery of federated IdP:

              The RP uses pre-configured information or a federation proxy to determine what IdP to use based on policy and the realm portion of the provided Client NAI.
              This is discussed in detail below (<xref target="discovery"/>).
            </t>
            
            <t>
              Request from Relying Party to IdP:

              Once the RP knows who the IdP is, it (or its agent) will send a RADIUS/Diameter request to the IdP.
              The RADIUS/Diameter access request encapsulates the EAP response.
              At this stage, the RP will likely  have no idea who the client is.
              The RP sends its identity to the IdP in AAA attributes, and
              <!-- Paul - What does claims mean here?  Unless it is anything more than "sends", then "sends" would be clearer - DONE -->
              it may send a SAML Attribute Requests in a AAA attribute.
              <!-- Paul - s/contain/send/ - DONE -->
              The AAA network checks that the identity claimed by the RP is valid.
            </t>
            
            <t>
              IdP begins EAP with the client:

              The IdP sends an EAP message to the client with an EAP method to be run.
              The IdP may re-request the clients name in this message, but this is unexpected behavior.
              
              The available and appropriate methods are discussed below in this memo (<xref target="Client_Eap"/>).
            </t>

            <t>
              <!-- Paul - didn't the EAP protocol get run in step 3 - need to clean that up - DONE -->
              The EAP protocol is run:

              A bunch of EAP messages are passed between the client (EAP peer) and the IdP (EAP server), until the result of the authentication protocol is determined.
              The number and content of those messages depends on the EAP method selected.
              If the IdP is unable to authenticate the client, the IdP sends a EAP failure message to the RP.

              As part of the EAP protocol, the client sends a channel bindings EAP message to the IdP (<xref target="client_channel_binding"/>).
              In the channel binding message the client identifies, among other things, the RP to which it is attempting to authenticate.

              <!-- Paul - How are RPs identified? - M00TODO -->

              The IdP checks the channel binding data from the client with that provided by the RP via the AAA protocol.
              
              If the bindings do not match the IdP sends an EAP failure message to the RP.

              <!-- Paul - He has a confusion between the different things that are called channel bindings - may need to move that discussion higher in the text - M00TODO-->
            </t>
            
            <t>
              Successful EAP Authentication:
              
              At this point, the IdP (EAP server) and client (EAP peer) have mutually authenticated each other.
              As a result, the subject and the IdP hold two cryptographic keys: a Master Session Key (MSK), and an Extended MSK (EMSK).

              At this point the client has a level of assurance about the identity of the RP based on the name checking the IdP has done using the RP naming information from the AAA framework and from the client (by the channel binding data).
              
              <!--
                  There is some confidence that the RP is the one the client is communicating with as the channel binding data validated.
                  This allows for a claim of authentication for the RP to the client.
              -->
              <!-- Paul - I can't follow this argument - - last two sentences - DONE -->
            </t>
            
            <t> 
              Local IdP Policy Check:
              
              At this stage, the IdP checks local policy to determine whether the RP and client are authorized for a given transaction/service, and if so, what if any,
              <!-- Paul - Which transaction/service? Nothing has been said about the client app specifying one. - DONE -->
              attributes will be released to the RP.
              If the IdP gets a policy failure, it sends an EAP failure message to the RP.<cref source="JLS">Should this be an EAP failure to the client as well?</cref>
              
              (The RP will have done its policy checks during the discovery process.)
            </t>

            <t>
              IdP provide the RP with the MSK:

              The IdP sends a positive result EAP to the RP, along with an optional set of AAA attributes associated with the client (usually as one or more SAML assertions).
              In addition, the EAP MSK is returned to the RP.
              <!-- Paul - How did the RP prove it's identity?  What prevent an attacker pretending to be an RP or being a man-in-the-middle? - DONE -->
            </t>

            <t>
              RP Processes Results:
              When the RP receives the result from the IdP, it should have enough information to either grant or refuse a resource access request.
              It may have information that associates the client with specific authorization identities.
              If additional attributes are needed from the IdP the RP may make a new SAML Request to the IdP.
              It will apply these results in an application-specific way.
            </t>
            
            <t>
              RP returns results to client:
              Once the RP has a response it must inform the client application of the result.
              If all has gone well, all are authenticated, and the application proceeds with appropriate authorization levels.
              The client can now complete the authentication of the RP by the use of the EAP MSK value.
            </t>
            
          </list>
        </t>
        <t>
          An example communication flow is given below:
        </t>
        <t>
          <figure>
            <artwork><![CDATA[
    Relying           Client        Identity
    Party            App          Provider
    
    |              (1)             | Client Configuration
    |               |              |
    |<-----(2)----->|              | Mechanism Selection
    |               |              |
    |<-----(3)-----<|              | NAI transmitted to RP
    |               |              |
    |<=====(4)====================>| Discovery
    |               |              |
    |>=====(5)====================>| Access request from RP to IdP
    |               |              |
    |               |< - - (6) - -<| EAP method to Client
    |               |              |
    |               |< - - (7) - ->| EAP Exchange to authenticate
    |               |              | Client
    |               |              |
    |               |           (8 & 9) Local Policy Check
    |               |              |
    |<====(10)====================<| IdP Assertion to RP
    |               |              |
    (11)              |              | RP processes results
    |               |              |
    |>----(12)----->|              | Results to client app.



    ----- = Between Client App and RP
    ===== = Between RP and IdP
    - - - = Between Client App and IdP
    ]]>

   </artwork>
          </figure>
        </t>
      </section>
      <section title="Design Goals">
        <t>Our key design goals are as follows:</t>
        <t>
          <list style="symbols">
            <t>
              Each party of a transaction will be authenticated, although perhaps not identified, and the client will be authorized for access to a specific resource.
            </t>
            <!-- Hannes - I believe we have mutual authentication between the EAP peer and the EAP server; we may have mutual authentication between the AAA server and the AAA client.
                 We don't really have the authentication of the Subject to the RP (since the Subject may be anonymous towards the RP).
                 We also do not have a classical authentication of the RP to the Subject/App since the only guarantee we get is the channel binding mechanism (which may not be present, right?)
                 - M00TODO 
            -->

            <t>
              Means of authentication is decoupled so as to allow for multiple authentication methods.
            </t>
            <t>
              Hence, the architecture requires no sharing of long term private keys between clients and servers.
              <!-- Paul - User and IDP share keys, don't they?  If RP is authenticated, then it will need to share key with IdP ... so I don't understand this statement. - DONE -->
              <!-- Hannes - I believe we should be more specific here: No sharing of the Subject's <-> IdP long term key with the RP. -->
            </t>
            <t>The system will scale to large numbers of identity providers,
            relying parties, and users.</t>
            <t>The system will be designed primarily for non-Web-based
            authentication.</t>
            <t>The system will build upon existing standards, components, and
            operational practices.
            </t>
          </list>
        </t>
        <t>Designing new three party authentication and authorization
        protocols is hard and fraught with risk of cryptographic
        flaws. Achieving widespead deployment is even more
        difficult. A lot of attention on federated access has been devoted to the Web. This document instead
        focuses on a non-Web-based environment and focuses on those protocols where HTTP is not
        used. Despite the increased excitement for layering every protocol on top of HTTP there are
        still a number of protocols available that do not use HTTP-based transports. Many of these
        protocols are lacking a native authentication and authorization framework of the style shown in
        <xref target="framework"/>.
        </t>
      </section>


      <!-- ////////////////////////////////////////////////////////////////////////////////// -->
    </section>
    <section title="Architecture">
      <t>
        We have already introduced the federated access architecture, with the illustration of the different actors that need to interact, but did not expand on the specifics of providing support for non-Web based applications.
        This section details this aspect and motivates design decisions.
        The main theme of the work described in this document is focused on re-using existing building blocks that have been deployed already and to re-arrange them in a novel way.
      </t>

      <t>
        Although this architecture assumes updates to the relying party, the client application, and the Identity Provider, those changes are kept at a minimum.
        A mechanism that can demonstrate deployment benefits (based on ease of update of existing software, low implementation effort, etc.) is preferred and there may be a need to specify multiple mechanisms to support the range of different deployment scenarios.
      </t>

      <t>
        There are a number of ways for encapsulating EAP into an application protocol.
        For ease of integration with a wide range of non-Web based application protocols the usage of the GSS-API was chosen.
        A description of the technical specification can be found in <xref target="I-D.ietf-abfab-gss-eap"/>.
        Other alternatives exist as well and may be considered later, such as "TLS using EAP Authentication" <xref target="I-D.nir-tls-eap"/>.<cref source="JLS">I don't believe this is a true statement - check it with Josh and Sam.</cref>
      </t>
      
      <t>
        The architecture consists of several building blocks, which is shown graphically in <xref target="abfab-arch"/>. 
        In the following sections, we discuss the data flow between each of the entities, the protocols used for that data flow and some of the trade-offs made in choosing the protocols.
      </t>

      <t><figure title="ABFAB Protocol Instantiation" anchor="abfab-arch">
        <artwork><![CDATA[
                                 +--------------+
                                 |   Identity   |
                                 |   Provider   |
                                 |    (IdP)     |
                                 +-^----------^-+
                                   * EAP      o RADIUS/
                                   *          o Diameter
                                 --v----------v--
                              ///                \\\
                            //                      \\     
                           |        Federation        | 
                           |        Substrate         | 
                            \\                      //  
                              \\\                ///
                                 --^----------^--
                                   * EAP      o RADIUS/
                                   *          o Diameter
+-------------+                  +-v----------v--+
|             |<---------------->|               |
| Client      |  EAP/EAP Method  | Relying Party |
| Application |<****************>|     (RP)      |
|             |  GSS-API         |               |
|             |<---------------->|               |
|             |  Application     |               |
|             |  Protocol        |               |
|             |<================>|               |
+-------------+                  +---------------+

Legend:

 <****>: Client-to-IdP Exchange
 <---->: Client-to-RP Exchange
 <oooo>: RP-to-IdP Exchange 
 <====>: Protocol through which GSS-API/GS2 exchanges are tunneled
 ]]></artwork>
      </figure>
      </t>
      
      <section title="Relying Party to Identity Provider">
        <t>
          Communications between the Relying Party and the Identity Provider is done by the federation substrate.
          This communication channel is responsible for:
          <list style="symbols">
            <t>Establishing the trust relationship between the RP and the IdP.</t>
            <t>Determining the rules governing the relationship.</t>
            <t>Conveying EAP packets between the RP and IdP.</t>
            <!-- Hannes - s/packets/signaling messages/ - DONE -->
<!--            <t>Providing the means of establishing a trust relationship between the RP and the client.</t> - JLS - see hannes comment below and resolve it to put this back - M00TODO -->
          </list>
        </t>

        <t>
          The ABFAB working group has chosen the AAA framework for the messages transported between the RP and IdP.

          This allows for the current AAA protocols to be used to establish the trust relationship between the RP and the IdP.
          Future protocols that support the same framework but do different routing may be used in the future. 
          There is currently an effort to setup a framework that creates a trusted point-to-point channel on the fly.

          The ABFAB protocol itself details the method of establishing the trust relationship between the RP and the client.
          
          <!-- Hannes - I am not sure what this is talking about. Is this trying to hint to the channel binding?
               Looking at the last bullet above and the previous sentence - See above note - M00TODO-->
        </t>

        <section title="AAA, RADIUS and Diameter">
          <!-- ******************************* -->
          <t>
            Interestingly, for network access authentication the usage of the AAA framework with RADIUS <xref target="RFC2865"/> and Diameter <xref target="RFC3588"/> was quite successful from a deployment point of view.
            To map the terminology used in <xref target="framework"/> to the AAA framework the IdP corresponds to the AAA server, the RP corresponds to the AAA client, and the technical building blocks of a federation are AAA proxies, relays and redirect agents (particularly if they are operated by third parties, such as AAA brokers and clearing houses).
            The front-end, i.e. the end host to AAA client communication, is in case of network access authentication offered by link layer protocols that forward authentication protocol exchanges back-and-forth.
            An example of a large scale RADIUS-based federation is <eref target="http://www.eduroam.org">EDUROAM</eref>.
          </t>

          <t>
            By using the AAA framework, ABFAB gets a lot of mileage as many of the federation agreements already exist and merely need to be expanded to cover the ABFAB additions.
            The AAA framework has already addressed some of the problems outlined above.  For example,
            <list style="symbols">
              <t>It already has a method for routing requests based on a domain.</t>
              <t>It already has an extensible architecture allowing for new attributes to be defined and transported.</t>
              <t>Pre-existing relationships can be re-used.</t>
            </list>
          </t>

          <t>
            The astute reader will notice that RADIUS and Diameter have substantially similar characteristics.
            Why not pick one?
            RADIUS and Diameter are deployed in different environments.
            RADIUS can often be found in enterprise and university networks, and is also in use by fixed network operators.
            Diameter, on the other hand, is deployed by mobile operators. 
            Another key difference is that today RADIUS is largely transported upon UDP.

            We leave as a deployment decision, which protocol will be appropriate.
            The protocol defines all the necessary new AAA attributes as RADIUS attributes.
            A future document would defined the same AAA attributes for a Diameter environment.
            <!-- Hannes - Actually, it is not so easy and for that reason there is a separate RADIUS document and one for Diameter. So, I would delete this sentence and maybe put references to the drafts. - DONE -->
            We also note that there exist proxies which convert from RADIUS to Diameter and back.
            This makes it possible for both to be deployed in a single federation substrate.
          </t>
          
          <t>
            Through the integrity protection mechanisms in the AAA framework, the identity provider can establish technical trust that messages are being sent by the appropriate relying party.
            Any given interaction will be associated with one federation at the policy level.
            The legal or business relationship defines what statements the identity provider is trusted to make and how these statements are interpreted by the relying party.
            The AAA framework also permits the relying party or elements between the relying party and identity provider to make statements about the relying party.
          </t>

          <t>
            The AAA framework provides transport for attributes.
            Statements made about the subject by the identity provider, statements made about the relying party and other information are transported as attributes.
          </t>

          <t>
            One demand that the AAA substrate makes of the upper layers is that they must properly identify the end points of the communication.
            It must be possible for the AAA client at the RP to determine where to send each RADIUS or Diameter message.
            Without this requirement, it would be  the RP's responsibility to determine the identity of the client on its own, without the assistance of an IdP.
            This architecture makes use of the Network Access Identifier (NAI), where the IdP is indicated by the realm component <xref target="RFC4282"/>.
            The NAI is represented and consumed by the GSS-API layer as GSS_C_NT_USER_NAME as specified in <xref target="RFC2743"/>.
            The GSS-API EAP mechanism includes the NAI in the EAP Response/Identity message.
          </t>
          
        </section>

        <section title="Discovery and Rules Determination" anchor="discovery">

          <t>
            While we are using the AAA protocols to communicate with the IdP, the RP may have multiple federation substrates to select from.
            The RP has a number of criteria that it will use in selecting which of the different federations to use:
            <list style="symbols">
              <t>The federation selected must be able to communicate with the IdP.</t>
              <t>The federation selected must match the business rules and technical policies required for the RP security requirements.</t>
            </list>
          </t>

          <t>
            The RP needs to discover which federation will be used to contact the IdP.
            The first selection criteria in discovery is going to be the name of the IdP to be contacted.
            The second selection criteria in discovery is going to be the set of business rules and technical policies governing the relationship; this is called rules determination.
            The RP also needs to establish technical trust in the communications with the IdP.
          </t>
          
          <t>
            Rules determination covers  a broad range of decisions about the exchange.
            One of these is whether the given RP is permitted to talk to the IdP using a given federation at all, so rules determination encompasses the basic authorization decision.
            Other factors are included, such as what policies govern release of information about the principal to the RP and what policies govern the RP's use of this information.
            While rules determination is ultimately a business function, it has significant impact on the technical exchanges.
            The protocols need to communicate the result of authorization.
            When multiple sets of rules are possible, the protocol must disambiguate which set of rules are in play.
            Some rules have technical enforcement mechanisms; for example in some federations intermediaries validate information that is being communicated within the federation.
          </t>

          <t>
            ABFAB has not formally defined any part of discovery at this point.
            The process of specifying and evaluating the business rules and technical policies is too complex to provide a simple framework.
            There is not currently a way to know if a AAA proxy is able to communicate with a specific IdP, although this may change with some of the routing protocols that are being considered.
            At the present time, the discovery process is going to be a manual configuration process.

            
            <!-- Hannes - Would it make sense to write this paragrah as follows since the work will progress but this document, once published as an RFC will remain unchanged:

At the time of writing the discovery process is going to be a manual configuration
process. Proposals for supporting such a dynamic discovery procedure exist, see [I-D.mrw-abfab-trust-router], 
and allow an RP to know if a AAA proxy is able to communicate with a specific IdP.
        - JLS - I don't like referecing IDs in documents
            -->
          </t>

        </section>

        <section title="Routing and Technical Trust">
          <t>
            Several approaches to having messages routed through the federation substrate are possible.
            These routing methods can most easily be classified based on the mechanism for technical trust that is used.
            The choice of technical trust mechanism constrains how rules determination is implemented.

            Regardless of what deployment strategy is chosen, it is important that the technical trust mechanism be able to validate the names of both parties to the exchange.
            <!-- Paul - In what way? - DONE -->

            The trust mechanism must to ensure that the entity acting as IdP for a given NAI is permitted to be the IdP for that realm, and that any service name claimed by the RP is permitted to be claimed by that entity.

            Here are the categories of technical trust determination:

            <list style="hanging">
              <t hangText="AAA Proxy:"><vspace/>
              The simplest model is that an RP supports a request directly to an AAA proxy.
              The hop-by-hop integrity protection of the AAA fabric provides technical trust.
              An RP can submit a request directly to a federation.
              Alternatively, a federation disambiguation fabric can be used.
              Such a fabric takes information about what federations the RP is part of and what federations the IdP is part of and routes a message to the appropriate federation.
              The routing of messages across the fabric plus attributes added to requests and responses provides rules determination.
              For example, when a disambiguation fabric routes a message to a given federation, that federation's rules are chosen.
              Name validation is enforced as messages travel across the fabric.
              <!-- Paul - Naming constraints? - DONE -->
              The entities near the RP confirm its identity and validate names it claims.
              The fabric routes the message towards the appropriate IdP, validating the IdP's name in the process.
              The routing can be statically configured.
              Alternatively a routing protocol could be developed to exchange reachability information about given IdPs and to apply policy across the AAA fabric.
              Such a routing protocol could flood naming constraints to the appropriate points in the fabric.
              </t>
              <t hangText="Trust Broker:"><vspace/>
              Instead of routing messages through AAA proxies, some trust broker could establish keys between entities near the RP and entities near the IdP.
              The advantage of this approach is efficiency of message handling.
              Fewer entities are needed to be involved for each message.
              Security may be improved by sending individual messages over fewer hops.
              Rules determination involves decisions made by trust brokers about what keys to grant.
              Also, associated with each credential is context about rules and about other aspects of technical trust including names that may be claimed.
              A routing protocol similar to the one for AAA proxies is likely to be useful to trust brokers in flooding rules and naming constraints.
              </t>
              <t hangText="Global Credential:"><vspace/>
              A global credential such as a public key and certificate in a public key infrastructure can be used to establish technical trust.
              A directory or distributed database such as the Domain Name System is used by the RP to discover the endpoint to contact for a given NAI.
              Either the database or certificates can provide a place to store information about rules determination and naming constraints.
              Provided that no intermediates are required (or appear to be required) and that the RP and IdP are sufficient to enforce and determine rules, rules determination is reasonably simple.
              However applying certain rules is likely to be quite complex.
              For example if multiple sets of rules are possible between an IdP and RP, confirming the correct set is used may be difficult.
              This is particularly true if intermediates are involved in making the decision.
              Also, to the extent that directory information needs to be trusted, rules determination may be more complex.
              </t>
            </list>
          </t>
          <t>
            Real-world deployments are likely to be mixtures of these basic approaches.
            For example, it will be quite common for an RP to route traffic to a AAA proxy within an organization.
            That proxy could then use any of the three methods to get closer to the IdP.
            It is also likely that rather than being directly reachable, the IdP may have a proxy on the edge of its organization.
            Federations will likely provide a traditional AAA proxy interface even if they also provide another mechanism for increased efficiency or security.
          </t>
        </section>


        <section title="SAML Assertions">
          <t>For the traditional use of AAA frameworks, network access, the only requirement that was necessary to grant access was an affirmative response from the IdP.  In the ABFAB world, the RP may need to get additional information about the client before granting access.  ABFAB therefore has a requirement that it can transport an arbitrary set of attributes about the client from the IdP to the RP.</t>
          <t>Security Assertions Markup Language (SAML) <xref target="OASIS.saml-core-2.0-os"/> was designed in order to carry an extensible set of attributes about a subject.  Since SAML is extensible in the attribute space, ABFAB has no immediate needs to update the core SAML specifications for our work.  It will be necessary to update IdPs that need to return SAML assertions to IdPs and for both the IdP and the RP to implement a new SAML profile designed to carry SAML assertions in AAA.  The new profile can be found in RFCXXXX <xref target="I-D.ietf-abfab-aaa-saml"/>.</t>
          <!-- Hannes - Reference the Diameter document as well - JLS - No Diameter document to reference -->
          <t>There are two issues that need to be highlighted:  
          <list style="symbols">
            <t>The security of SAML assertions.</t>
            <t>Namespaces and mapping of SAML attributes.</t>
          </list>
          </t>
          <t>SAML assertions have an optional signature that can be used to protect and provide origination of the assertion.  These signatures are normally based on asymmetric key operations and require that the verifier be able to check not only the cryptographic operation, but also the binding of the originators name and the public key.  In a federated environment it will not always be possible for the RP to validate the binding, for this reason the technical trust established in the federation is used as an alternate method of validating the origination and integrity of the SAML Assertion.</t>
          <t>Attributes placed in SAML assertions can have different namespaces assigned to the same name.  In many, but not all, cases the federation agreements will determine what attributes can be used in a SAML statement.  This means that the RP needs to map from the federation names, types and semantics into the ones that the policies of the RP are written in.  In other cases the federation substrate may modify the SAML assertions in transit to do the necessary namespace, naming and semantic mappings as the assertion crosses the different boundaries in the federation.  If the proxies are modifying the SAML Assertion, then will obviously remove any signatures on the SAML assertions as they would no longer validate.  In this case the technical trust is the required mechanism for validating the integrity of the assertion.  
          Finally, the attributes may still be in the namespace of the originating IdP.  When this occurs the RP will need to get the required mapping operations from the federation agreements and do the appropriate mappings itself.
          <!-- Paul - s/In the last case/finally/ - DONE-->
          </t>
        </section>

      </section>

      
      <section title="Client To Identity Provider">
        <t>
          Looking at the communications between the client and the IdP, the following items need to be dealt with:
          <list style="symbols">
            <t>The client and the IdP need to mutually authenticate each other.</t>
            <t>The client and the IdP need to mutually agree on the identity of the RP.</t>
          </list>
        </t>

        <t>
          ABFAB selected EAP for the purposes of mutual authentication and assisted in creating some new EAP channel binding documents for dealing with determining the identity of the RP.
          A framework for the channel binding mechanism has been defined in RFC 6677 <xref target="RFC6677"/> that allows the IdP to check the identity of the RP provided by the AAA framework with that provided by the client.
          <!-- Hannes - I would write: 

A new channel binding mechanism that operates as an EAP
method for the purpose of agreeing on the identity of the RP has been 
specified in [TBD: whatever that document is].
- DONE
          -->
        </t>

        <section title="Extensible Authentication Protocol (EAP)" anchor="Client_Eap">
          <t>
            Traditional web federation does not describe how a subject interacts with an identity provider for authentication.
            As a result, this communication is not standardized.
            There are several disadvantages to this approach.
            Since the communication is not standardized, it is difficult for machines to correctly enter their credentials with different authentications, where Individuals can correctly identify the entyr mechanism on the fly.
            <!-- Paul - Not clear who has the programatic credential - DONE -->
            The use of browsers for authentication restricts the deployment of more secure forms of authentication beyond plaintext username and password known by the server.
            In a number of cases the authentication interface may be presented before the subject has adequately validated they are talking to the intended server.
            By giving control of the authentication interface to a potential attacker, then the security of the system may be reduced and phishing opportunities introduced.
          </t>

          <t>
            As a result, it is desirable to choose some standardized approach for communication between the subject's end-host and the identity provider.
            There are a number of requirements this approach must meet.
          </t>

          <t>
            Experience has taught us one key security and scalability requirement: it is important that the relying party not get possession of the long-term secret of the client.
            Aside from a valuable secret being exposed, a synchronization problem can develop when the client changes keys with the IdP.
          </t>

          <t>
            Since there is no single authentication mechanism that will be used everywhere there is another associated requirement:
            The authentication framework must allow for the flexible integration of authentication mechanisms.
            For instance, some IdPs require hardware tokens while others use passwords.
            A service provider wants to provide support for both authentication methods, and other methods from IdPs not yet seen.
          </t>

          <t>
            Fortunately, these requirements can be met by utilizing standardized and successfully deployed technology, namely by the Extensible Authentication Protocol (EAP) framework <xref target="RFC3748"/>.
            <xref target="abfab-arch"/> illustrates the integration graphically.
          </t>

          <t>
            EAP is an end-to-end framework; it provides for two-way communication between a peer (i.e,service client or principal) through the authenticator (i.e., service provider) to the back-end (i.e., identity provider).
            Conveniently, this is precisely the communication path that is needed for federated identity.
            Although EAP support is already integrated in AAA systems (see <xref target="RFC3579"/> and <xref target="RFC4072"/>) several challenges remain:
            <list style="symbols">
              <t>The first is how to carry EAP payloads from the end host to the relying party.</t>
              <t>Another is to verify statements the relying party has made to the subject, confirm these statements are consistent with statements made to the identity provider and confirm all the above are consistent with the federation and any federation-specific policy or configuration.</t>
              <t>Another challenge is choosing which identity provider to use for which service.</t>
            </list>
          </t>

          <t>
            The EAP method used for ABFAB needs to meet the following requirements:
            <list style="symbols">
              <t>It needs to provide mutual authentication of the client and IdP.</t>
              <t>It needs to support channel binding.</t>
            </list>
            As of this writing, the only EAP method that meets these criteria is TEAP <xref target="I-D.ietf-emu-eap-tunnel-method"/> either alone (if client certificates are used) or with an inner EAP method that does mutual authentication.
          </t>
        </section>

        <section title="EAP Channel Binding" anchor="client_channel_binding">
          <t>
            EAP channel binding is easily confused with a facility in GSS-API also called channel binding.
            GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used as authentication inside some tunnel; it is similar to a facility called cryptographic binding in EAP.
            See <xref target="RFC5056"/> for a discussion of the differences between these two facilities and Section 6.1 for how GSS-API channel binding is handled in this mechanism.
          </t>

          <t>
            The client knows, in theory, the name of the RP that it attempted to connect to, however in the event that an attacker has intercepted the protocol, the client and the IdP need to be able to detect this situation.  A general overview of the problem along with a recommended way to deal with the channel binding issues can be found in RFC 6677 <xref target="RFC6677"/>.
          </t>

          <t>
            Since that document was published, a number of possible attacks were found and methods to address these attacks have been outlined in <xref target="I-D.hartman-emu-mutual-crypto-bind"/>.
            <!-- Hannes - replace last sentence with 
                 A general overview of the channel binding problem can be found in
                 RFC 6677. - DONE
            -->
          </t>

        </section>

      </section>

      <section title="Client to Relying Party">
        <t>
          The final set of interactions between parties to consider are those between the client and the RP.  In some ways this is the most complex set since at least part of it is outside the scope of the ABFAB work.  The interactions between these parties include:
          <list style="symbols">
            <t>Running the protocol that implements the service that is provided by the RP and desired by the client.</t>
            <!-- Paul - non-web service? - That's what the first paragraph of section 2 said this is about - DONE -->
            <t>Authenticating the client to the RP and the RP to the client.</t>
            <t>Providing the necessary security services to the service protocol that it needs beyond authentication.</t>
            <!-- Paul - ditto s/web/non-web/ - DONE -->
          </list>
        </t>

        <section title="GSS-API">
          <t>
            One of the remaining layers is responsible for integration of federated authentication into the application.
            There are a number of approaches that applications have adopted for security.
            So, there may need to be multiple strategies for integration of federated authentication into applications.
            However, we have started with a strategy that provides integration to a large number of application protocols.
          </t>
          <t>
            Many applications such as SSH <xref target="RFC4462"/>, NFS <xref target="RFC2203"/>, DNS <xref target="RFC3645"/> and several non-IETF applications support the Generic Security Services Application Programming Interface <xref target="RFC2743"/>.
            Many applications such as IMAP, SMTP, XMPP and LDAP support the Simple Authentication and Security Layer (SASL) <xref target="RFC4422"/> framework.
            These two approaches work together nicely: by creating a GSS-API mechanism, SASL integration is also addressed.
            In effect, using a GSS-API mechanism with SASL simply requires placing some headers on the front of the mechanism and constraining certain GSS-API options.
          </t>
          <t>
            GSS-API is specified in terms of an abstract set of operations which can be mapped into a programming language to form an API.
            When people are first introduced to GSS-API, they focus on it as an API.
            However, from the prospective of authentication for non-web applications, GSS-API should be thought of as a protocol not an API.
            It consists of some abstract operations such as the initial context exchange, which includes two sub-operations (gss_init_sec_context and gss_accept_sec_context).
            An application defines which abstract operations it is going to use and where messages produced by these operations fit into the application architecture.
            A GSS-API mechanism will define what actual protocol messages	result from that abstract message for a given abstract operation.
            So, since this work is focusing on a particular GSS-API mechanism, we generally focus on protocol elements rather than the API view of GSS-API.
          </t>
          <t>
            The API view has significant value.
            Since the abstract operations are well defined, the set of information that a mechanism gets from the application is well defined.
            Also, the set of assumptions the application is permitted to make is generally well defined.
            As a result, an application protocol that supports GSS-API or SASL is very likely to be usable with a new approach to authentication including this one with no required modifications.
            In some cases, support for a new authentication mechanism has been added using plugin interfaces to applications without the application being modified at all.
            Even when modifications are required, they can often be limited to supporting a new naming and authorization model.
            For example, this work focuses on privacy; an application that assumes it will always obtain an identifier for the principal will need to be modified to support anonymity, unlinkability or pseudonymity.
          </t>
          <t>
            So, we use GSS-API and SASL because a number of the application protocols we wish to federate support these strategies for security integration.
            What does this mean from a protocol standpoint and how does this relate to other layers?
            This means we need to design a concrete GSS-API mechanism.
            We have chosen to use a GSS-API mechanism that encapsulates EAP authentication.
            So, GSS-API (and SASL) encapsulate EAP between the end-host and the service.
            The AAA framework encapsulates EAP between the relying party and the identity provider.
            The GSS-API mechanism includes rules about how principals and services are named as well as per-message security and other facilities required by the applications we wish to support.
          </t>
        </section>

        <section title="Protocol Transport">
          <t>The transport of data between the client and the relying party is not provided by GSS-API.  GSS-API creates and consumes messages, but it does not provide the transport itself, instead the protocol using GSS-API needs to provide the transport.  In many cases HTTP or HTTPS is used for this transport, but other transports are perfectly acceptable.  The core GSS-API document <xref target="RFC2743"/> provides some details on what requirements exist.</t>
          <t>
            In addition we highlight the following:
            <list style="symbols">
              <t>The transport does not need to provide either privacy or integrity.  After GSS-EAP has finished negotiation, GSS-API can be used to provide both services.  If the negotiation process itself needs protection from eavesdroppers then the transport would need to provide the necessary services.</t>
              <t>The transport needs to provide reliable transport of the messages.</t>
              <t>The transport needs to ensure that tokens are delivered in order during the negotiation process.</t>
              <t>GSS-API messages need to be delivered atomically.  If the transport breaks up a message it must also reassemble the message before delivery.</t>
            </list>
          </t>
        </section>
      </section>
             
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Application Security Services">
      <t>
        One of the key goals is to integrate federated authentication into existing application protocols and where possible, existing implementations of these protocols.
        Another goal is to perform this integration while meeting the best security practices of the technologies used to perform the integration.
        This section describes security services and properties required by the EAP GSS-API mechanism in order to meet these goals.
        This information could be viewed as specific to that mechanism.
        However, other future application integration strategies are very likely to need similar services.
        So, it is likely that these services will be expanded across application integration strategies if new application integration strategies are adopted.
      </t>
      
      <section title="Authentication">
        <!-- Hannes - 
             The authentication section is indeed interesting and I understand that there is a challenge to describe it properly. However, may the way how the story was phrased for earlier EAP-related publications may help. I believe that the situation is similar to the Secure Association Protocol, as http://tools.ietf.org/html/rfc4962 calls it. Here is the short description: 

A protocol for managing security associations derived from EAP
and/or AAA exchanges.  The protocol establishes a security
association, which includes symmetric keys and a context for
the use of the keys.  An example of a Secure Association
Protocol is the 4-way handshake defined within [802.11i].

The properties of the exchange between the GSS initiator and the GSS acceptor can similar to the IEEE 802.11i 4-way handshake protocol, i.e., where the Supplient and the Access Point do not authenticate each other directly but they both independently derive keying material obtained via the EAP MSK to confirm through this protocol exchange that they indeed know the same keying material. 

A possible variation (which is also supported with the ABFAB work) is that there is indeed direct authentication of the acceptor to the initiator (when TLS with server-side authentication is used in GSS). Here the appropriate comparison would be the IKEv2-EAP integration. 

The details matter here and since I am not the GSS-API expert I am wondering how the exchange looks in detail. Maybe a diagram would help to illustrate how the keying material is derived.
- M00TODO
        -->

        <t>
          GSS-API provides an optional security service called mutual authentication.
          This service means that in addition to the initiator providing (potentially anonymous or pseudonymous) identity to the acceptor, the acceptor confirms its identity to the initiator.
          Especially for the ABFAB context, this service is confusingly named.
          We still say that mutual authentication is provided when the identity of an acceptor is strongly authenticated to an anonymous initiator.
        </t>
        <t>
          RFC 2743, unfortunately, does not explicitly talk about what mutual authentication means.
          Within this document we therefore define it as:
          <list style="symbols">
            <t>
              If a target name is supplied to the initiator, then the initiator trusts that the supplied target name describes the acceptor.
              This implies both that appropriate cryptographic exchanges took place for the initiator to make such a trust decision, and that after evaluating the results of these exchanges, the initiator's policy trusts that the target name is accurate.
              <!-- Paul - It isn't always necessary to do crypto exchange to believe that the supplied target name describes the supplied target name describes the acceptor.  E.g. the taret name is the DNS name of the server, which was entered by the user - in which case it is assumed to be what the user wanted. - M00TODO -->
            </t>
            <t>
              If no target name is supplied to the initiator, then the initiator trusts that the acceptor name, supplied by the acceptor, correctly names the entity it is communicating with.
              <!-- Paul - Don't get this.  If no target name is suppled, where did the initiator get the "idea" - DONE -->
            </t>
            <t>
              Both the initiator and acceptor have the same key material for per-message keys and both parties have confirmed they actually have the key material.
              In EAP terms, there is a protected indication of success.
            </t>
          </list>
        </t>
        
                        <t>
                          Mutual authentication is an important defense against certain aspects of phishing.
                          Intuitively, users would like to assume that if some party asks for their credentials as part of authentication, successfully gaining access to the resource means that they are talking to the expected party.
                          Without mutual authentication, the acceptor could "grant access" regardless of what credentials are supplied.
                          Mutual authentication better matches this user intuition.
                        </t>
                        <t>
                          It is important, therefore, that the GSS-EAP mechanism implement mutual authentication.
                          That is, an initiator needs to be able to request mutual authentication.
                          <!-- Paul,  Shouldn't it always request mutual authenticaiton in this day and age? - M00TODO -->
                          When mutual authentication is requested, only EAP methods capabale of providing the necessary service can be used, and appropriate steps need to be taken to provide mutual authentication.
                          A broader set of EAP methods could be supported when a particular application	does not request mutual authentication.
                          It is an open question whether the mechanism will permit this.
                        </t>
                        <t>
                          <!-- May want to move this paragraph to a different section - M00TODO -->
                          The AAA infrastructure MAY hide the peer's identity from the GSS-API acceptor, providing anonymity between the peer and initiator.
                          At this time, whether the identity is disclosed is determined by EAP server policy rather than by an indication from the peer.
                          Also, peers are unlikely to be able to determine whether anonymous communication will be provided.
                          For this reason, peers are unlikely to set the anonymous return flag from GSS_Init_Sec_context.
                        </t>
                      </section>

                      
                      <section title="GSS-API Channel Binding">
                        <t><xref target="RFC5056"/> defines a concept of channel
                        binding to prevent man-in-the-middle attacks. It is common to
                        provide SASL and GSS-API with another layer to provide
                        transport security; Transport Layer Security (TLS) is the most
                        common such layer. TLS provides its own server
                        authentication.
                        However there are a variety of situations where this authentication is not checked for policy or usability reasons.
                        <!-- Hannes - We cannot make the assumption that the software does not do authentication or check the result of the authentication process since then the entire security solution does not work anymore. If this check is not done how can we assume that other checks are done instead. - M00TODO -->
                        <!-- Sam - Section 3.2 is all about providing alternatives when this check is not done.
                             This check is not done in practice a *lot*. There are lots of application libraries that do not check server certificates.-->

                        Even when it is checked, if the trust
                        infrastructure behind the TLS authentication is different from
                        the trust infrastructure behind the GSS-API mutual
                        authentication then confirming the end-points using both trust infrastructures is likely to enhance security. If the endpoints of the GSS-API authentication
                        are different than the endpoints of the lower layer, this is a
                        strong indication of a problem such as a man-in-the-middle
                        attack. Channel binding provides a facility to determine
                        whether these endpoints are the same.
                        <!-- Hannes - I believe the cases that you will detect using this technique are TLS load balancers that terminate the TLS at the edge of the network. Are those the main concern or are you also trying to prevent "TLS inspection" in the style of http://www.juniper.net/techpubs/en_US/idp5.0/topics/concept/intrusion-detection-prevention-ssl-decryption-overview.html - M00TODO -->
                        </t>
                        <t>The GSS-EAP mechanism needs to support channel
                        binding. When an application provides channel binding data,
                        the mechanism needs to confirm this is the same on both sides
                        consistent with the GSS-API specification. 
                        </t>
                        <t>Typically when considering channel binding, people think of
                        channel binding in combination with mutual
                        authentication. This is sufficiently common that without
                        additional qualification channel binding should be assumed to
                        imply mutual authentication. Without mutual authentication, only one party
                        knows that the endpoints are correct. That's sometimes
                        useful. Consider for example a user who wishes to access a
                        protected resource from a shared whiteboard in a conference
                        room. The whiteboard is the initiator; it does not need to
                        actually authenticate that it is talking to the correct
                        resource because the user will be able to recognize whether
                        the displayed content is correct. If channel binding were used
                        without mutual authentication, it would in effect be a request
                        to only disclose the resource in the context of a particular
                        channel. Such an authentication would be similar in concept to
                        a holder-of-key SAML assertion. However, also note that while
                        it is not happening in the protocol, mutual authentication is
                        happening in the overall system: the user is able to visually
                        authenticate the content. This is consistent with all uses of
                        channel binding without protocol level mutual authentication
                        found so far.</t>
                        <!-- Paul - It isn't clear why this is here - how it relates to the purposes of the ABFAB protocol. - M00TODO -->
                        <t>RFC 5056 channel binding (also called GSS-API channel
                        binding when GSS-API is involved) is not the same thing as EAP
                        channel binding. EAP channel binding is also used in the ABFAB
                        context in order to implement acceptor naming and mutual
                        authentication. Details are discussed in the mechanisms
                        specification <xref target="I-D.ietf-abfab-gss-eap"/>.
                        <!-- Hannes - I would put this sentence at the beginnin  of section 3.2 with a "Note..." - M00TODO -->
                        </t>
                        <!-- Pual - In what way is it conceptionally different?  (Of course it is different at a detailed level). - M00TODO -->
                      </section>
                      <section title="Host-Based Service Names">
                        <t>IETF security mechanisms typically take the name of a
                        service entered by a user and make some trust decision about
                        whether the remote party in an interaction is the intended
                        party. GSS-API has a relatively flexible naming
                        architecture. However most of the IETF applications that use
                        GSS-API, including SSH, NFS, IMAP, LDAP and XMPP, have chosen
                        to use host-based service names when they use GSS-API. In this
                        model, the initiator names an acceptor based on a service <!-- Paul - Service type name --> such
                        as "imap" or "host" (for login services such as SSH) and a
                        host name.</t>
                        <t>Using host-based service names leads to a challenging trust
                        delegation problem. Who is allowed to decide whether a
                        particular hostname maps to an entity. The public-key
                        infrastructure (PKI) used by the web has chosen to have a
                        number of trust anchors (root certificate authorities) each of
                        which can map any name to a public key. A number of GSS-API
                        mechanisms, such as Kerberos <xref target="RFC1964"/>, split
                        the problem into two parts. A new concept called a realm is
                        introduced. Then the mechanism decides what realm is
                        responsible for a given name. That realm is responsible for
                        deciding if the acceptor entity is allowed to claim the
                        name. ABFAB needs to adopt this approach.</t>
                        <!-- Hannes - Actually, I do not follow the line of argument in Seciton 3.3.  What is the problem you are solving? 

I understand that the user either enters a URI of the resource (or gets it from somewhere else). 
The URI indicates the resolution mechanism. In our cases it will typically involve a DNS-based resolution mechanism for resolving the hostname part to an address (potentially through a series of resolution steps). 
                        -->
                        <!-- Paul - This is an architecture doucment not a requierments document - remove last sentence -->
                        <t>Host-based service names do not work ideally when different
                        instances of a service are running on different ports. Also,
                        these do not work ideally when SRV record or other insecure
                        referrals are used.</t>
                        <!-- Paul - And what is being done about this problem?  MS target names include port numbers -->
                        <t>The GSS-EAP mechanism needs to support host-based service
                        names in order to work with existing IETF protocols.</t>
                      </section>
                      <section title="Per-Message Tokens">
                        <t>
                          GSS-API provides per-message security services that can
                          provide confidentiality and integrity. Some IETF protocols
                          such as NFS and SSH take advantage of these services. As a
                          result GSS-EAP needs to support these services.
                          As with mutual authentication, per-message services will limit the set of EAP methods that are available.
                          <!-- Hannes - I wouldn't say that it restricts the choice of EAP methods in any realistic way since EAP methods have to generate keying material also for other reasons and all EAP methods published since about 15 years expert the MSK. EAP-MD5 is one method that would work but we have already standardized a Standards Track replacement for it. -->
                          Any EAP method that produces a Master Session Key (MSK) is able to support per-message security services described in [X].
                          <!-- Hannes - In [X] we put the reference to the document that explains how the MSK that is make available to the relying party is further derived to create these session keys for per-message security protection, which is http://www.ietf.org/id/draft-ietf-abfab-gss-eap-09.txt I believe.  -->


                        </t>
                        <t>GSS-API provides a pseudo-random function. While the
                        pseudo-random function does not involve sending data over the
                        wire, it provides an algorithm that both the initiator and
                        acceptor can run in order to arrive at the same key
                        value. This is useful for designs where a successful
                        authentication is used to key some other function. This is
                        similar in concept to the TLS extractor. No current IETF
                        protocols require this. However GSS-EAP supports this service
                        because it is valuable for the future and easy to do given
                        per-message services. Non-IETF protocols are expected to take
                        advantage of this in the near future.</t>
                        <!-- Hannes - I would delete this paragraph since it is confusing, is not relevant for the work we are doing, and does not relate to the previous paragraph either.  -->
                      </section>
                    </section>
                    <section anchor="attribute-providers" title="Future Work:
                                                                 Attribute Providers">
                      <t>
                        This architecture provides for a federated authentication and
                        authorization framework between IdPs, RPs, principals, and
                        subjects.  It does not at this time provide for a means to
                        retrieve attributes from 3rd parties.  However, it envisions
                        such a possibility.  We note that in any extension to the
                        model, an attribute provider must be authorized to release
                        specific attributes to a specific RP for a specific
                        principal.  In addition, we note that it is an open question
                        beyond this architecture as to how the RP should know to trust
                        a particular attribute provider.
                      </t>
                      <t>There are a number of possible technical means to provide 
                      attribute provider capabilities.  One possible approach is for the
                      IdP to provide a signed attribute request to RP that it in turn
                      will provide to the attribute authority.  Another approach  would be
                      for the  IdP to provide a URI to the RP that contains a token of
                      some form.  The form of communications between the IdP and attribute
                      provider as well as other considerations are left for the future.
                      One thing we can say now is that the IdP would merely be asserting
                      who the attribute authority is, and not the contents of what the
                      attribute authority would return.  (Otherwise, the IdP might as well
                      make the query to the attribute authority and then resign it.)
                      </t>
                    </section>


                    <section title="Privacy Considerations">
                           <t>
                             ABFAB, as an architecture designed to enable federated authentication and allow for the secure transmission of identity information between entities, obviously requires careful consideration around privacy and the potential for privacy violations.
                           </t>
                           <t>
                             This section examines the privacy related information presented in this document, summarising the entities that are involved in ABFAB communications and what exposure they have to identity information. In discussing these privacy considerations in this section, we use terminology and ideas from
                             <xref target="I-D.iab-privacy-considerations"/>.
                           </t>
                           <t>
                             Note that the ABFAB architecture uses at its core several existing technologies and protocols; detailed privacy discussion around these is not examined. This section instead focuses on privacy considerations specifically related to overall architecture and usage of ABFAB.
                           </t>
                           <section title="Entities and their roles">
                             <t>
                               In an ABFAB environment, there are four distinct types of entities involved in communication paths. Figure 2 shows the ABFAB architecture with these entity types. We have:
                               <list style="symbols">
                                 <t>The client application: usually a piece of software running on a user's device. This communicates with a service (the Relying Party) that the user wishes to interact with.</t>
                                 <t>The Identity Provider: The home AAA server for the user.</t>
                                 <t>The Relying Party: The service the user wishes to connect to.</t>
                                 <t>The federation substrate: A set of entities through which messages pass on their path between RP and AAA server.</t>
                               </list>
                             </t>
                             <t>
                               As described in detail earlier in this document, when a user wishes to access a Relying Party, a secure tunnel is set up between their client application and their Identity Provider (via the Relying Party and the federation substrate) through which credentials are exchanged. An indication of success or failure, alongside a set of AAA attributes about a principal is then passed from the Identity Provider to the Relying Party (usually in the form of a SAML assertion).
                             </t>
                           </section>
                           <section title="Relationship between user and entities">
                             <t>
                             <list style="symbols">
                               <t>
                                 Between User and Identity Provider - the identity Provider is an entity the user will have a direct relationship with, created when the organisation that operates the entity provisioned and exchanged the user's credentials. Privacy and data protection guarantees may form a part of this relationship.
                               </t>
                               <t>
                                 Between User and Relying Party - the Relying Party is an entity the user may or may not have a direct relationship with, depending on the service in question. Some services may only be offered to those users where such a direct relationship exists (for particularly sensitive services, for example), while some may not require this and would instead be satisfied with basic federation trust guarantees between themselves and the Identity Provider). This may well include the option that the user stays anonymous with respect to the Relying Party (though obviously not to the Identity Provider). If attempting to preserve privacy through the mitigation of data minimisation, then the only attribute information about individuals exposed to the Relying Party should be that which is strictly necessary for the operation of the service.
                               </t>
                               <t>
                                 Between User and Federation substrate - the user is highly likely to have no knowledge of, or relationship with, any entities involved with the federation substrate (not that the Identity Provider and/or Relying Party may, however). Knowledge of attribute information about individuals for these entities is not necessary, and thus such information should be protected in such a way as to prevent access to this information from being possible.
                               </t>
                             </list>
                             </t>
                           </section>
                           <section title="Data and Identifiers in use">
                             <t>
                               In the ABFAB architecture, there are a few different types of data and identifiers in use.
                             </t>
                             <section title="NAI">
                               <t>
                                 In order for the Relying Party to be able to route messages to enable an EAP transaction to occur between client application and the correct identity Provider, it is necessary for the client application to provide enough information to the Relying Party to enable the identification of the correct Identity Provider. This takes the form of an Network Access Identifier (NAI) (as specified in
                                 <xref target="RFC4282"/>). Note that an NAI can have inner and outer forms in a AAA architecture.
                                 <list style="symbols">
                                   <t>
                                     The outer part of NAI is exposed to the Relying Party; this can simply contain realm information. Doing so (i.e. not including user identification details such as a username) minimises the data given to the Relying Part to that which is purely necessary to support the necessary routing decision.
                                   </t>
                                   <t>
                                     The inner part of NAI is sent through the secure tunnel as established by the EAP protocol; this form of the NAI will contain credentials for the user suitable for authenticating them successfully (e.g. a username and password). Since the entire purpose of the secure tunnel is to protect communications between client application (EAP client) and Identity Provider (EAP server), then it is considered secure from eavesdroppers or malicious intermediaries and no further privacy discussion is necessary.
                                   </t>
                                 </list>
                               </t>
                             </section>
                             <section title="Identity Information">
                               <t>
                                 As a part of the ABFAB process, after a successful authentication has occurred between client application and Identity Provider, an indication of this success is sent to the Relying Party. Alongside this message, information about the user may be returned through AAA attributes, usually in form of a SAML assertion. This information is arbitrary and may include either only attributes that prevent an individual from being identified by the Relying Party (thus enabling anonymous or pseudonymous access) or attributes that contain personally identifiable information.
                               </t>
                               <t>
                                 Depending on the method used, this information carried through AAA attributes may or may not be accessible to intermediaries involved in communications - e.g. in the case of RADIUS and unencrypted SAML, these headers are plain text and could be seen by any observer, whereas if using RADSEC or encrypted SAML, these headers are protected from observers. Obviously, where the protection of the privacy of an individual is required then this information needs to be protected by some appropriate means.
                               </t>
                             </section>
                             <section title="Accounting Information">
                               <t>
                                 Alongside the core authentication and authorization that occurs in AAA communications, accounting information about resource consumption may be delivered as part of the accounting exchange during the lifetime of the granted application session.
                               </t>
                             </section>
                             <section title="Collection and retention of data and identifiers">
                               <t>
                                 In cases where Relying Parties do not require to identify a particular individual when an individual wishes to make use of their service, the ABFAB architecture enable anonymous or pseudonymous access. Thus data and identifiers other than pseudonyms and unlinkable attribute information need not be stored and retained.
                               </t>
                               <t>
                                 However, in cases where Relying Parties require the ability to identify a particular individual (e.g. so they can link this identity information to a particular account in their service, or where identity information is required for audit purposes), the service will need to collect and store such information, and to retain it for as long as they require. Deprovisioning of such accounts and information is out of scope for ABFAB, but obviously for privacy protection any identifiers collected should be deleted when they are no longer needed.
                               </t>
                             </section>
                           </section>
                           <section title="User Participation">
                             <t>
                               In the ABFAB architecture, by its very nature users are active participants in the sharing of their identifiers as they initiate the communications exchange every time they wish to access a server. They are, however, not involved in control of the set of information related to them that transmitted from Identity Provider to Relying Party for authorisation purposes.
                             </t>
                           </section>
                         </section>

                         <!-- ////////////////////////////////////////////////////////////////////////////////// -->

                         <section title="Deployment Considerations">
                           <section title="EAP Channel Binding">
                             <t>Discuss the implications of needing EAP channel
                             binding.</t>

                           </section>
                           <section title="AAA Proxy Behavior">
                             <t>Discuss deployment implications of our proxy requirements.</t>
                           </section>
                         </section>

                         <!-- ////////////////////////////////////////////////////////////////////////////////// -->

                         <section anchor="sec-cons" title="Security Considerations">

                           <t>This document describes the architecture for Application Bridging for Federated Access Beyond Web (ABFAB) and security is therefore the main focus. This section highlights the main communication channels and their security properties: 
                           
                           <list style="hanging"> 
                             <t hangText="Client-to-RP Channel:">
                               <vspace blankLines="1"/>
                               The channel binding material is provided by any certificates and the final message (i.e., a cryptographic token for the channel).
                               Authentication may be provided by the RP to the client but a deployment without authentication at the TLS layer is possible as well.
                               In addition, there is a channel between the GSS requestor and the GSS  acceptor, but the keying material is provided by a "third party" to both entities.
                               The client can derive keying material locally, but the RP gets the material from the IdP.

                               In the absence of a transport that provides encryption and/or integrity, the channel between the client and the RP has no ability to have any cryptographic protection until the EAP authentication has been completed and the MSK is transfered from the IdP to the RP.
                             </t> 

                             <t hangText="RP-to-IdP Channel:">
                               <vspace blankLines="1"/>
                               The security of this communication channel is mainly provided by the functionality offered via RADIUS and Diameter.
                               At the time of writing there are no end-to-end security mechanisms standardized and thereby the architecture has to rely on hop-by-hop security with trusted AAA entities or, as an alternative but possible deployment variant, direct communication between the AAA client to the AAA server.
                               Note that the authorization result the IdP provides to the RP in the form of a SAML assertion may, however, be protected such that the SAML related components are secured end-to-end.
                               <vspace blankLines="1"/>
                               The MSK is transported from the IdP to the RP over this channel.  As no end-to-end security is provided by AAA, all AAA entities on the path between the RP and IdP have the ability to eavesdrop if no additional security measures are taken.  One such measure is to use a transport between the client and the IdP that provides confidentiality.
                             </t>

                             <t hangText="Client-to-IdP Channel:"><vspace blankLines="1"/>This communication interaction is accomplished with the help of EAP and EAP methods. The offered security protection will depend on the EAP method that is chosen but a minimum requirement is to offer mutual authentication, and key derivation. The IdP is responsible during this process to determine that the RP that is communication to the client over the RP-to-IdP channel is the same one talking to the IdP. This is accomplished via the EAP channel binding.</t>
                             
                           </list> 
                           </t> 

                           <t>Partial list of issues to be addressed in this section:  Privacy, SAML, Trust Anchors, EAP Algorithm Selection, Diameter/RADIUS/AAA Issues, Naming of Entities, Protection of passwords, Channel Binding, End-point-connections (TLS), Proxy problems</t>

                           <t>When a psuedonym is generated as a unique long term identifier for a Subject by an IdP, care MUST be taken in the algorithm that it cannot easily be reverse engineered by the service provider.  If it can be reversed then the service provider can consult an oracle to determine if a given unique long term identifier is associated with a different known identifier.</t>

                           
                         </section>


                         <!-- ////////////////////////////////////////////////////////////////////////////////// -->

                         <section anchor="iana" title="IANA Considerations">
                           <t>This document does not require actions by IANA.</t>
                         </section>

                         <!-- ////////////////////////////////////////////////////////////////////////////////// -->

                         <section title="Acknowledgments">
                                <t>We would like to thank Mayutan Arumaithurai and Klaas Wierenga for their feedback. Additionally, we would like to
                                thank Eve Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, Paul Leach, and Luke Howard for their feedback on the
                                federation terminology question.</t>
                                <t>Furthermore, we would like to thank Klaas Wierenga for his review of the pre-00 draft version.</t>
                         </section>

                         <!-- ////////////////////////////////////////////////////////////////////////////////// -->
                       </middle>

                       <!-- ////////////////////////////////////////////////////////////////////////////////// -->

                       <back>
                         <references title="Normative References">
                           &RFC2743;
                           &RFC2865; &RFC3588;
                           &RFC3748;  &RFC3579; &RFC4072; &RFC4282; 
                           &I-D.ietf-abfab-gss-eap;
                           &I-D.ietf-abfab-aaa-saml;
                           &RFC6677;
                         </references>

                         <references title="Informative References">
                           &RFC2903;
                           &I-D.nir-tls-eap;
                           &I-D.ietf-oauth-v2;
                           &I-D.iab-privacy-considerations;
                           &RFC4017;
                           &RFC5106;
                           &RFC1964;
                           &RFC2203;
                           &RFC3645;
                           &RFC2138;
                           &RFC4462;
                           &RFC4422;
                           &RFC5056;
                           &RFC5801; 
                           &RFC5849;
                           &SAML20;
                           &RFC2904;
                           &I-D.hartman-emu-mutual-crypto-bind;
                           &I-D.ietf-emu-eap-tunnel-method;
                           <reference anchor="WS-TRUST" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">
                             <front>
                               <title>WS-Trust 1.4</title>
                               <author initials="K" surname="Lawrence"/>
                               <author initials="C" surname="Kaler"/>
                               <author initials="A" surname="Nadalin"/>
                               <author initials="M" surname="Goodner"/>
                               <author initials="M" surname="Gudgin"/>
                               <author initials="A" surname="Barbir"/>
                               <author initials="H" surname="Granqvist"/>
                               <date month="February" day='2' year='2009'/>
                             </front>
                             <seriesInfo name="OASIS Standard" value="ws-trust-200902"/>
                             <format type="HTML" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">
                             </format>
                           </reference>
                         </references>
                       </back>
                     </rfc>
