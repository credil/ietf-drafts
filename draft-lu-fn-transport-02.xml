<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
There has to be one entity for each item to be referenced. 
An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2154 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2154.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC2328 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2328.xml">
<!ENTITY RFC5015 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5015.xml">
<!ENTITY I-D.lu-fast-notification-framework SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.lu-fast-notification-framework">
<!ENTITY I-D.csaszar-ipfrr-fn SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.csaszar-ipfrr-fn">
<!ENTITY I-D.kini-ospf-fast-notification SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.kini-ospf-fast-notification">

]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
(Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
(using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-lu-fn-transport-02"
     ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
       ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
       you can add the attributes updates="NNNN" and obsoletes="NNNN" 
       they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
	 full title is longer than 39 characters -->

    <title>Transport of Fast Notification Messages</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Wenhu Lu" initials="W.L." surname="Lu">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>300 Holger Way</street>

          <!-- Reorder these if your country does things differently -->

          <city>San Jose</city>

          <region>California</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>Wenhu.Lu@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Sriganesh Kini" initials="S.K." surname="Kini">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>300 Holger Way</street>

          <!-- Reorder these if your country does things differently -->

          <city>San Jose</city>

          <region>California</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>Sriganesh.Kini@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Andras Csaszar" initials="A.Cs." role="editor" surname="Csaszar">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Irinyi J utca 4-10</street>

          <!-- Reorder these if your country does things differently -->

          <city>Budapest</city>

          <country>Hungary</country>

          <code>1117</code>
        </postal>

        <email>Andras.Csaszar@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Gabor Sandor Enyedi" initials="G.E." surname="Enyedi">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Irinyi J utca 4-10</street>

          <!-- Reorder these if your country does things differently -->

          <city>Budapest</city>

          <country>Hungary</country>

          <code>1117</code>
        </postal>

        <email>Gabor.Sandor.Enyedi@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Jeff Tantsura" initials="J.T." surname="Tantsura">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>300 Holger Way</street>

          <!-- Reorder these if your country does things differently -->

          <city>San Jose</city>

          <region>California</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>Jeff.Tantsura@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date year="2011" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
	 in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <!-- WG name at the upperleft corner of the doc,
	 IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
	 which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>fast notification, IPFRR, FN, convergence</keyword>

    <!-- Keywords will be incorporated into HTML output
	 files in a meta tag but they have no effect on text or nroff
	 output. If you submit your draft to the RFC Editor, the
	 keywords will be used for the search engine. -->

    <abstract>
      <t>
	This document specifies a fast, light-weight event
	notification protocol, called Fast Notification (FN) protocol. The
	draft discusses the design goals, the message container and options
	for delivering the notifications to all routers within a routing
	area.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	Draft <xref target="I-D.lu-fast-notification-framework"/> describes the
	architectural framework to enable fast dissemination of a
	network event to routers in a limited area.  Existing use
	cases involve new approaches for IP Fast ReRoute such as <xref
	target="I-D.csaszar-ipfrr-fn" />, and faster dissemination of
	link state information for routing protocols <xref
	target="I-D.kini-ospf-fast-notification" /> in order to speed
	up convergence.
      </t>

      <t>
	A hop by hop control plane based flooding mechanism is used widely today in link state routing protocols such as OSPF and ISIS to propagate routing information throughout an area. In this mechanism, the information
	is processed in the control plane at each hop before being forwarded to the next. The extra processing, scheduling, and communications overhead causes unnecessary delays in the dissemination of the information. 
      </t>

      <t>
	This draft proposes a generic fast notification (FN) protocol as a separate
	transport layer, which focuses on delivering notifications quickly in a secure manner. It can be used by many existing applications to enhance the performance of those applications, as well as to enable new services in the network. 
      </t>


      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>

      <section title="Acronyms">

	<t><list hangIndent="7" style="hanging">
	  <t hangText="FN    &ndash;">Fast Notification</t>
	  <t hangText="IGP   &ndash;">Interior Gateway Protocol</t>
	  <t hangText="IS-IS &ndash;">Intermediate System to Intermediate System</t>
	  <t hangText="MD5   &ndash;">Message Digest 5</t>
	  <t hangText="OSPF  &ndash;">Open Shortest Path First</t>
	  <t hangText="RPF   &ndash;">Reverse Path Forwarding</t>
	  <t hangText="SHA   &ndash;">Secure Hash</t>
	  <t hangText="SPT   &ndash;">Shortest Path Tree</t>
	  <t hangText="STP   &ndash;">Spanning Tree Protocol</t>
	</list></t>

      </section>

    </section>

    <section anchor="Design_Goals" title="Design Goals">
      <t>
	A light-weight event notification mechanism that could be used to
	facilitate quick dissemination of information in a limited
	area should have the following properties.
      </t>

      <t><list style="numbers">
	<t>
	  The mechanism should be fast. It should provide low end to end propagation delay for the notifications.
	</t>

	<t>
	  The signaling mechanism should offer a high degree of reliability under network failure conditions.
	</t>

	<t>
	  The mechanism should be secure; that is, it should provide means to verify the authenticity of the notifications.
	</t>

	<t>
	  The new protocol should not be dependent upon routing protocol flooding procedures.
	</t>

	<t>
	  The mechanism should have low processing overhead
	</t>
      </list></t>

      <t>
	These design goals present a trade-off. Proper balance needs to be
	found that offers good authentication and reliability while keeping
	processing complexity sufficiently low to enable implementation in
	dataplane.  This draft proposes solutions that take the above goals
	and trade-offs into considerations.
      </t>
    </section>













    <section anchor="Transport_Logic" title="Transport Logic - Distribution of the Notifications">
      <t>
	The distribution of a notification to multiple receivers can be
	implemented in many ways.  The main body of this draft describes
	one such option, a flooding-like approach.  	
      </t>

      <t>
	In flooding mode, the IGP configures the dataplane cards to
	replicate each received FN message to each interface with a
	neighbour router in the same area.
      </t>

      <t>
	This happens by making use of bidirectional multicast
	forwarding.  In bidir multicast, all interfaces added to the
	multicast group can be incoming and outgoing interfaces as
	well.  The principle is that a router replicates the incoming
	packet to *all* assigned interfaces except the incoming
	interface.  If the local router is the source of the packet to
	be forwarded, then the packet is replicated to all interfaces.
	That is, the decision about which interfaces should actually
	be used as outgoing is determined on demand.
      </t>
      <t>
	First, the FN service is assigned a multicast group address,
	let us call this MC-FN address.  Then, the IGP assigns all
	interfaces to MC-FN which lead to neighbouring routers.
      </t>
      <t> 
	When the FN service is instructed to disseminate a message, it
	creates an IP packet (as described below in <xref
	target="Message_Encoding" />) and sets its IP destination
	address to the MC-FN multicast address.  This IP packet is
	then multicasted to all IGP neighbours in the area.
      </t>

      <t>
	Recipients of FN multicast-forward the packet according to the
	rules of bidirectional multicast, i.e. to all interfaces which
	the local IGP pre-configured except the incoming interface.
	As this may cause loops without pre-caution (consider three
	routers in a triangle).  Before forwarding, therefore, the
	forwarding engine has to perform duplicate check.  
      </t>
      <section anchor="Dupl_Check" title="Duplicate Check">
	<t>
	  Duplicate check can be performed in numeruous ways.
	</t>

	<t>
	  Duplicate check can be performed by maintaining a short queue
	  of previously forwarded FN messages.  Before forwarding, if
	  the FN message is found in the queue, then it was forwarded
	  beforehand, so it may be dropped.  Otherwise it should be
	  forwarded and it should be added to the queue.
	</t>

	<t>
	  Alternatively, the queue may contain a signature of the
	  previously forwarded FN messages, such as an MD5 or SHA256
	  signature or any other hash.  This signature may be carried in
	  the packet, e.g. due to authentication purposes, such as with
	  the authentication mechanisms described in <xref
	  target="Authentication" />.
	</t>

	<t>
	  In either of the above queue-based mechanisms, the size of the
	  queue can be set to a value that corresponds to the maximal
	  number of legal FN messages generated by a single event.  For
	  instance, if FN is used to broadcast failure identifiers in
	  case of failures, then it is likely that the failure of the
	  node with the most neighbours will trigger the most FN
	  messages (1 from each neighbour).  
	</t>

	<t>
	  It is also possible to use application-dependent duplicate
	  check: the state machine of the FN-application can be left
	  responsible to decide whether the information carried in the
	  packet contains new information or it is a duplicate. This is
	  only useful in the case if the application can perform the
	  duplicate check faster then the above generic mechanisms.
	</t>

      </section>
    </section>















    <section anchor="Message_Encoding" title="Message Encoding">

      <section anchor="Seamless_Encapsulation" title="Seamless Encapsulation">
	<t>
	  An application may define its own message for FN to distribute quickly. In
	  this case, only the special destination address (e.g. MC-FN) shows
	  that the message was sent using the FN service.
	</t>

	<t>
	  In this case, the entire payload of the IP packet is determined by
	  the application including sequence numbering and authentication. The
	  IP packet's protocol field can also be set by the application. 
	</t>
      </section>

      <section anchor="Dedicated_FN_Message" title="Dedicated FN Message">
	<t>
	  An alternative option is for the FN messages to be distributed in UDP
	  datagrams with well-known port values in the UDP header that need to
	  be allocated by IANA.
	</t>

	<t>
	  The FN packet format inside a UDP datagram is the following:
	</t>

        <figure align="center" anchor="UDP_datagram"
		title="FN packet format as a UDP datagram">
          <preamble></preamble>

	  <artwork align="center">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-                                                             -+
   |                           IP Header                           |
   +-                +-------------+                              -+
   |                 | Protocol=UDP|                               |
   +-                +-------------+                              -+
   |                                                               |
   +-                                                             -+
   |                                                               |
   +---------------------------------------------------------------+
   |     UDP Source Port = FN      |   UDP Destination Port = FN   |
   +---------------------------------------------------------------+
   |                       UDP Header cont'd                       |
   +---------------------------------------------------------------+
   |                           FN Header                           |
   +---------------------------------------------------------------+
   |                              ...                              |
   .                                                               .
   .                          FN Payload                           .
   .                                                               .
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              ...                              |
   .                                                               .
   .                     Authentication (optional)                 .
   .                                                               .
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          </artwork>

          <postamble></postamble>
        </figure> 

	<t>
	  The encoding of the FN Header is as follows:
	</t>

        <figure align="center" anchor="encoding"
		title="FN Header encoding">
          <preamble></preamble>

	  <artwork align="center">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           FN Length           |  FN App Type  | AuType|unused |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
          </artwork>

          <postamble></postamble>
        </figure> 

	<t><list hangIndent="3" style="hanging">
          <t hangText="FN Length (16 bits)"><vspace blankLines="0" />
	  The length of the FN message in bytes including the FN Header and
	  the FN Payload. The authentication data optionally appended to the
	  FN packet is not considered part of the FN message: the
	  authentication data is not included in the FN Length field,
	  although it is included in the length field of the packet's IP
	  header.
          </t>

          <t hangText="FN App Type (8 bits)"><vspace blankLines="0" />
	  Identifies the application which should be the receiver of the
	  notification. A value for each application needs to be assigned by
	  IANA.
          </t>

          <t hangText="AuType"><vspace blankLines="0" /> Identifies
          the authentication procedure to be used for the packet.
          Authentication options are discussed in <xref
          target="Authentication" /> of the specification.
          </t>
	  

        </list></t>

        <section anchor="Authentication" title="Authentication">
          <t>
	    Fast Notification intends to provide a trustable service
	    option, so that receivers of FN packets are able to verify
	    that the packet is sent by an authentic source. Simple
	    password authentication and hash based authentication
	    methods (with Md5 or SHA256) are described in the
	    following subsections.
          </t>

          <t>
	    If AuType is set to 0x0, then the FN packet is not
	    carrying an Authentication field at the end of the packet.
	    If AuType is zero, AuLength must also be zero.  Note that
	    even in this case the FN application in the payload may
	    still use its own authentication mechanism.
          </t>

          <t>
	    If AuType is non null, an Authentication field must be appended after
	    the FN message. The encoding of this field is as described below.
          </t>

        <figure align="center" anchor="Auth_field"
		title="Authentication field in FN packets">
          <preamble></preamble>

	  <artwork align="center">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   AuLength    |        ... Authentication Data ...            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              ...                              |
   
          </artwork>

          <postamble></postamble>
        </figure> 

	<t><list hangIndent="3" style="hanging">
          <t hangText="AuLength"><vspace blankLines="0" />
      Describes the length of the entire Authentication field in bytes.
          </t>
        </list></t> 

	  <section anchor="Auth_scope" title="Areas-scoped and Link-scoped Authentication">
	    <t>
	      Since FN is a solution to disseminate an event notification from one
	      source to a whole area of nodes, the simplest approach would be to
	      use per-area authentication, for example. a common password, a common pre-
	      shared key among all nodes in the area as described in the following
	      sub-sections, or digital signatures.
	    </t>

	    <t>
	      Carriers may, however, prefer per-link authentication. In order not
	      to lose the speed (simple per-hop processing, fast forwarding
	      property) of FN, link-scoped authentication is suggested only if the
	      forwarding plane supports it, i.e. if there is hardware support to verify
	      and re-generate authentication hop-by-hop. In such cases, the
	      operator may need to configure a common pre-shared key only on
	      routers connected by the same link. It is even possible that there is
	      no authentication on some links considered safe.
	    </t>
          </section>

	  <section anchor="Simple_Auth" title="Simple Password Authentication">
	    <t>
	      Simple password authentication guards against routers inadvertently
	      joining the routing area; each router must first be configured with a
	      password before it can participate in Fast Notification.
	    </t>

	    <t>
	      The password is stored in the Authentication Data field. AuLength is
	      set to the length of the password in bytes plus 1. Two AuType values
	      for simple password authentication need to be allocated by IANA: one
	      for area-scope and another for link-scoped.
	    </t>

	    <t>
	      With per-link authentication mode, the Authentication field must be
	      stripped and regenerated hop-by-hop.
	    </t>

	    <t>
	      Simple password authentication, however, can be easily compromised as
	      anyone with physical access to the network can read the password.
	    </t>
          </section>

	  <section anchor="Crypto_Auth" title="Cryptographic Authentication for FN">
	    <t>
	      Using this authentication type, a secret key is used to
	      generate/verify a "message digest" that is appended to
	      the end of the FN packet. The message digest is a
	      one-way function of the FN packet and the secret
	      key. This authentication mechanism resembles the
	      cryptographic authentication mechanism of <xref
	      target="RFC2328" />.
	    </t>
          </section>

	  <section anchor="MD5" title="MD5">
	    <t>
	      The packet signature is created by an MD5 hash performed on an object
	      which is the concatenation of the FN message, including the FN
	      header, and the pre-shared secret key. The resulting 16 byte MD5
	      message digest is appended to the FN message into the Authentication
	      field as shown below.
	    </t>

	    <t>
	      The AuType in the FN header is set to indicate cryptographic
	      authentication, the specific value is to be assigned by IANA both for
	      area-scoped and for link-scoped versions.
	    </t>

	    <figure align="center" anchor="MD5_auth"
		    title="Authentication field in FN packets with MD5 cryptographic authentication.">
	      <preamble></preamble>

	      <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   AuLength    |    Key ID     |             Unused            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Message Digest (bytes 1-4)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Message Digest (bytes 5-8)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Message Digest (bytes 9-12)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Message Digest (bytes 13-16)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	      </artwork>

	      <postamble></postamble>
	    </figure> 

	    <t><list hangIndent="3" style="hanging">
	      <t hangText="AuLength"><vspace blankLines="0" />
	      AuLength is set to 20 bytes.
	      </t>

	      <t hangText="Key ID"><vspace blankLines="0" />
	      This field identifies the algorithm and secret key used to create
	      the message digest appended to the FN packet. This field allows
	      that multiple pre-shared keys may exist in parallel.
	      </t>

	      <t hangText="Message Digest"><vspace blankLines="0" />
	      The 16 byte long MD5 hash performed on an object which is the
	      concatenation of the FN message, including the FN header, and the
	      pre-shared secret key identified by Key ID.
	      </t>
	    </list></t>


	    <t>
	      When receiving an FN message, if the FN header indicates MD5
	      authentication, then the last 20 bytes of the FN message are set
	      aside. The recipient forwarding plane element calculates a new MD5 digest
	      of the remainder of the FN message to which it appends its own known
	      secret key identified by Key ID. The calculated and received digests
	      are compared. In case of mismatch, the FN message is discarded.
	    </t>

	    <t>
	      In per-link authentication mode, the Authentication field must be
	      regenerated hop-by-hop using the key of the outgoing
	      link.
	    </t>
	    
          </section>
	  

	  <section anchor="SHA256" title="SHA256">
	    <t>
	      Similarly to how MD5 authentication works, it is possible
	      to use Secure Hash 256 hash.  Currently this is a more
	      secure hash function than MD5.  The Authentication field
	      would look like this:
	    </t>

	    <figure align="center" anchor="SHA256_auth"
		    title="Authentication field in FN packets with MD5 cryptographic authentication.">
	      <preamble></preamble>

	      <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   AuLength    |    Key ID     |             Unused            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Message Digest (bytes 1-4)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Message Digest (bytes 5-8)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              . . .                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Message Digest (bytes 25-28)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Message Digest (bytes 29-32)              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	      </artwork>

	      <postamble></postamble>
	    </figure> 

	    <t><list hangIndent="3" style="hanging">
	      <t hangText="AuLength"><vspace blankLines="0" />
	      AuLength is set to 36 bytes.
	      </t>

	      <t hangText="Key ID"><vspace blankLines="0" />
	      This field identifies the algorithm and secret key used to create
	      the message digest appended to the FN packet. This field allows
	      that multiple pre-shared keys may exist in parallel.
	      </t>

	      <t hangText="Message Digest"><vspace blankLines="0" />
	      The 32 bytes long SHA256 value calculated on an object
	      which is the concatenation of the FN message, including
	      the FN header, and the pre-shared secret key identified
	      by Key ID.
	      </t>
	    </list></t>


	    <t>
	      When receiving an FN message, if the FN header indicates
	      SHA256 authentication, then the last 68 bytes of the FN
	      message are set aside. The recipient forwarding plane
	      element calculates a new SHA256 digest of the remainder
	      of the FN message to which it appends its own known
	      secret key identified by Key ID. The calculated and
	      received digests are compared. In case of mismatch, the
	      FN message is discarded.
	    </t>

	    <t>
	      In per-link authentication mode, the Authentication field must be
	      regenerated hop-by-hop using the key of the outgoing
	      link.
	    </t>

	  </section>

	  <section anchor="Digital_Signatures" title="Digital Signatures">
            <t>
	      A router may choose to use public key cryptography to
	      digitally sign the notification to provide certification
	      of authenticity. This mechanism can avoid shared secret
	      that is required for other authentication mechanisms
	      described in this document. This authentication
	      mechanism resembles the authentication mechanism of OSPF
	      with digital signatures as defined in <xref
	      target="RFC2154" />.
            </t>
          </section>

        </section>
      </section>
    </section>






    <section anchor="Security_Considerations" title="Security Considerations">
      <t>
	This draft has described basic optional procedures for
	authentication. The mechanism, however, does not protect against
	replay attacks.
      </t>

      <t>
	If an application of FN require protection against replay attacks, then
	these applications should provide their own specific sequence
	numbering within the FN payload. Recipient applications should accept
	FN messages only if the included sequence number is valid.
      </t>

      <t>
	Since the message digest of cryptographic authentication also covers
	the payload, even if an attacker knew how to construct the new
	sequence number, it would not be able to generate a correct message
	digest without the pre shared key. This way, a sequence number in the
	payload combined with FN's cryptographic authentication offers
	sufficient protection against replay attacks.
      </t>
    </section>



    <section anchor="Packet_Proc" title="FN Packet Processing Summary">
      <t>
	When receiving an FN packet, a node has to perform the following steps.
      </t>

      <t>
	It has to identify that the packet is an FN packet. This can
	be done utilising the destination IP address (MC-FN) or by
	inspecting the UDP port field.
      </t>

      <t>
	If the flooding like transport logic described in <xref
	target="Transport_Logic" /> is used the node has to perform duplicate check
	following the teachings in <xref target="Dupl_Check" />.
      </t>

      <t>
	If AuType is non-null, the node has to perform authentication
	check as discussed in <xref target="Authentication" />.
      </t>

      <t>
	To protect against replay attacks, the node shall perform
	verification of the sequence number provided by the
	application.
      </t>

      <t>
	Punt and forward.  The notification may need to be multicasted
	but it also needs to be punted to the local application on the
	linecard to start processing.
      </t>

      <t>
	Authentication check, sequence number check and
	punting/forwarding may commence in any order deemed necessary
	by the operator.  If the operator prefers highest level of
	security, then both checks should be performed before
	forwarding.  If, however, the operator prefers per-hop
	performance but still wants to ensure that malice packets
	cannot harm the network, then authentication and sequence
	number checks may also happen after punting the packet,
	i.e. before processing the information contained inside the FN
	payload.  In this case, malicious packets may get propagated
	to every node but they still do not cause any change in the
	configuration.
      </t>
    </section>




    <section anchor="IANA_Considerations" title="IANA Considerations">
      <t>
	A UDP port value needs to be assigned by IANA for FN. IANA also
	needs to maintain values for FN App Type as applications are being
	proposed.
      </t>

      <t>
	Multicast addresses used for the distribution trees are either
	allocated by IANA or they can be a configuration parameter within
	the local domain.
      </t>
    </section>



    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
	The authors owe thanks to Acee Lindem, Joel Halpern and Jakob
	Heitz for their review and comments.  Also thanks to Alia
	Atlas for constructive feedback.
      </t>
    </section>


  </middle>













  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
	 1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
	 2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
	 (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

Both are cited textually in the same manner: by using xref elements.
If you use the PI option, xml2rfc will, by default, try to find included files in the same
directory as the including file. You can also define the XML_LIBRARY environment variable
with a value containing a set of directories to search.  These can be either in the local
filing system or remote ones accessed by http (http://domain/dir/... ).-->





    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC2119;
      &RFC5015;

    </references>





    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      <reference anchor="Eny2009">
        <!-- the following is the minimum to make xml2rfc happy -->

        <front>
	  <title>On Finding Maximally Redundant Trees in Strictly Linear Time, IEEE Symposium on Computers and Communications (ISCC)</title>
          <author initials="G." surname="Enyedi">
          </author>
          <author initials="G." surname="Retvari">
          </author>
          <author initials="A." surname="Csaszar">
          </author>
          <date year="2009" />
        </front>
      </reference>

      &I-D.lu-fast-notification-framework;
      &I-D.csaszar-ipfrr-fn;
      &RFC2328;
      &I-D.kini-ospf-fast-notification;
      &RFC2154;

    </references>








    <section anchor="Further_Options" title="Further Options for Transport Logic">
      <t>
	The options described in this appendix represent alternative
	solutions to the flooding based approach described in
	Section <xref target="Transport_Logic" />.
      </t>

      <t>
	It is left for WG discussion and further evaluation to decide whether
	any of these options should potentially be preferred instead of
	redundant trees.
      </t>


      <section anchor="MTree" title="Multicast Tree-based Transport">
        <t>
	  One way of transporting an identical piece of information to
	  several receivers at the same time is to use multicast distribution
	  trees. A tree based transport solution is beneficial since multicast
	  support is already implemented in all forwarding entities, so it is
	  possible to use existing implementations.
        </t>

        <t>
	  With multicast or tree based transport, the Fast Notification (FN)
	  packet can be recognized by a pre-configured or well known
	  destination IP address, denoted by MC-FN in the following, which is
	  the group address of the FN service.
        </t>

        <t>
	  If the FN service is triggered to send out a notification, the
	  notification will be encapsulated in a new IP packet, where the
	  destination IP address is set to MC-FN.
        </t>

	
        <section anchor="FTree" title="Fault Tolerance of a Single Distribution Tree">
          <t>
	    Several solutions described in this draft use a single
	    tree to disseminate a notification from one
	    given source.
          </t>

          <t>
	    The single tree solution is simple, however it is not redundant: a single failure may
	    partition the tree, which will prevent notifications from 
	    reaching some nodes in the area.
	  </t>

          <t>
	    Different applications may have different needs for reliability. For example, when we use fast notification to disseminate network failure information, all nodes surrounding the failure can detect and originate the failure notifications independently. Any one of these notifications (or a subset of them) may be sufficient for the application to make the right decision. This draft provides several different transport options from which an applications can choose. 
          </t>

	</section>
	
        <section anchor="Pair_Trees" title="Pair of Redundant Trees">
          <t>
	    If an FN application needs the exact same data to be distributed
	    in the case of any single node or any single link failure, the FN
	    service could opt to run in "redundant tree mode".
          </t>

          <t>
	    A pair of "redundant trees" ensures that at each single node or link
	    failure each node still reaches the common root of the trees through
	    at least one of the trees. A redundant tree pair is a known prior-art
	    graph-theoretical object that is possible to find on any 2-node
	    connected network. Even better, it is even possible to find maximally
	    redundant trees in networks where the 2-node connected criterion does
	    not "fully" hold (e.g. there are a few cut vertices) [Eny2009].
          </t>

          <t>
	    Note that the referenced algorithm(s) build a pair of trees
	    considering a specific root. The root can be selected in different
	    ways, the only thing that is important that each node makes the same
	    selection, consistently. For instance, the node with the highest or
	    lowest router ID can be used.
          </t>
	  
	  <figure align="center" anchor="Common_Root"
		  title="Example: a pair of redundant trees (double lines) of a common root R">
	    <preamble></preamble>

	    <artwork align="center">
      #1 tree                              #2 tree
      +---+       +---+                    +---+       +---+
      | B |=======|   |                    | B |=======|   |
      +---+       +---+                    +---+       +---+
      //               \\                 //                 \
      //                 \\               //                   \
 +---+                     +---+      +---+                     +---+
 | A |---------------------| R |      | A |=====================| R |
 +---+                     +---+      +---+                     +---+
      \                  //               \\                   /
      \                //                 \\                 /
      +---+       +---+                    +---+       +---+
      |   |=======|   |                    |   |=======|   |
      +---+       +---+                    +---+       +---+
	    </artwork>

	    <postamble></postamble>
	  </figure> 

          <t>
	    There is one special constraint in building the redundant trees. A
	    (maximally) redundant tree pair is needed, where in one of the trees
	    the root has only one child in order to protect against the failure
	    of the root itself. Algorithms presented in [Eny2009] produce such
	    trees. 
          </t>

          <t>
	    In redundant-tree mode, each node multicasts the requested
	    notification on both trees, if it is possible, but at least along one
	    of the trees. Redundant trees require two multicast group addresses.
	    MC-FN identifies one of the trees, and MC-FN-2 identifies the other
	    tree.
          </t>

          <t>
	    Each node multicast forwards the received notification packet (on the
	    same tree). The root node performs as every other node but in
	    addition it also multicast the notification on the other tree! I.e.
	    it forwards a replica of the incoming notification in which it
	    replaces the destination address identifying the other multicast
	    distribution tree.
          </t>

          <t>
	    When the network remains connected and the root remains operable
	    after a single failure, the root will be reached on at least one of
	    the trees. Thus, since the root can reach every node along at least
	    one of the trees, all the notifications will reach each node.
	    However, when the root or the link to the root fails, that tree, in
	    which the root has only one child, remains connected (the root is a
	    leaf there), thus, all the nodes can be reached along that tree.
          </t>

          <t>
	    For example, let us consider that in <xref target="Common_Root" /> FN is used to
	    disseminate failure information. If link A-B fails, the notifications
	    originating from node B (e.g. reporting that the connectivity from B
	    to A is lost) will reach R on tree #1. Notifications originating from
	    A (e.g. reporting that the connectivity from A to B is lost) will
	    reach R on tree #2. From R, each node is reachable through one of the
	    trees, so each node will be notified about both events.
          </t>
	</section>
      </section>


      <section anchor="Unicast" title="Unicast">
        <t>
	  This method addresses the need in a unique way. It has the following
	  properties:
	</t>

        <t><list style="empty">
          <t>
	    Plain simple, without the need of any forwarding plane change or cooperation;
          </t>

          <t>
	    Short turnaround time (i.e. ready for next hit);
          </t>

          <t>
	    100% link break coverage (may not work in certain node failure cases);
          </t>

          <t>
	    Little change to OSPF (need encapsulation for IS-IS).
          </t>
        </list></t>


        <section anchor="Method" title="Method">
          <t>
	    The method is simple in design, easy to implement and quick to
	    deploy. It requires no topology changes or specific configurations.
	    It adds little overhead to the overall system.
          </t>


          <t>
	    The method sends the event message to every router in
	    the area in an IP packet. This appears burdensome to the
	    sending router which has to duplicate the packet sending effort many
	    times. Practical experience has shown, however, that the amount of
	    effort is not a big concern in reasonable sized networks.
          </t>


          <t>
	    Normal flooding (regular or fast) process requires a router to
	    duplicate the packet to all flooding eligible interfaces. All routers
	    have to be fast-flooding-aware. This implies new code to every router
	    in control plane and/or forwarding plane.
          </t>


          <t>
	    The method uses a different approach. It takes advantage of the given
	    routing/forwarding table in each router in the IP domain. The
	    originating router of the flooding information simply sends multiple
	    copies of the packet to each and every router in the domain. These
	    packets are forwarded to the destination routers at forwarding plane speed,
          </t>


          <t>
	    just like the way the regular IP data traffic is handled. No special
	    handling in any other routers is needed.
          </t>


          <t>
	    This small delay on the sender can be minimized by pre-downloading
	    the link-broken message packets to the forwarding plane. Since the forwarding
	    plane already has the list of all routers which are part of the IGP
	    routing table, the forwarding plane can dispatch the packet directly.
          </t>


          <t>
	    In essence, the flooding in this method is tree based, just like a
	    multicast tree. The key is that no special tree is generated for this
	    purpose; the normal routing table which is an SPF tree (SPT) plays a
	    role of the flooding tree. This logic guarantees that the flooding
	    follows the shortest path and no flooding loop is created.
          </t>

	  
        </section>

        <section anchor="Sample_Operation" title="Sample Operation">
          <t>
	    <xref target="Multiple_Unicast" /> depicts a scenario where router A wants to flood its message to
	    all other routers in the domain using the unicast flooding method.
          </t>

          <t>
	    Instead of sending one packet to each of its neighbor, and letting the
	    neighbor flood the packet further, router A directly send the same
	    packet to each router in the domain, one at a time. In this sample
	    network, router A sends out 5 packets.
          </t>


	  <figure align="center" anchor="Multiple_Unicast"
		  title="Multiple Unicast Packets">
	    <preamble></preamble>

	    <artwork align="center">
	      A---B---C---D
	      \
	      --E---F

	      1. Packet(A->B);
	      2. Packet(A->C);
	      3. Packet(A->D);
	      4. Packet(A->E);
	      5. Packet(A->F).
	    </artwork>

	    <postamble></postamble>
	  </figure> 


          <t>
	    The unicast flooding procedure is solely controlled by the sending
	    router. No action is needed from other routers other than their
	    normal forwarding functionalities. This method is extremely simple
	    and useful for quick prototyping and deployment.
          </t>
	  
        </section>

      </section>



      <section anchor="Gated" title="Gated Multicast through RPF Check">
        <t>
	  This method fulfills the purpose with the following characters:
	</t>

        <t><list style="numbers">
          <t>
	    No need to build the multicast tree. It is the same as the SPT computed by the IGP routing process;
          </t>

          <t>
	    Flooding loops are prevented by RPF Check.
          </t>
        </list></t>



        <t>
	  The method has all the benefits of multicast flooding. It, however,
	  does not require running multicast protocol to setup the multicast
	  tree. The unicast shortest path tree is used as a multicast
	  tree.
	</t>
	

        <section anchor="RPF_Check" title="Loop Prevention - RPF Check">
	  <t>
	    In this mechanism, the distribution tree is not explicitly built.
	    Rather, each node will first do a Reverse Path Forwarding (RPF) check
	    before it floods the notification to other links.
	  </t>

	  <t>
	    A special multicast address is defined and is subject to IANA
	    approval. This address is used to qualify the notification packet for
	    fast flooding. When a notification packet arrives, the receiving node
	    will perform an IP unicast routing table lookup for the originator IP
	    address of the notification and find the outgoing interface. Only
	    when the arriving interface of the notification is the same as the
	    outgoing interface leading towards the originator IP address, will the
	    notification be flooded to other interfaces.
	  </t>

	  <t>
	    IP Multicast forwarding with RPF check is available on most of the
	    routing/switching platforms. To support flooding with RPF check, a
	    special IP multicast group must be used. A bi-directional IP
	    multicast forwarding entry is created that consists of all interfaces
	    within the flooding scope, typically an IGP area.
	  </t>
	  
        </section>

        <section anchor="Operation" title="Operation">
	  <t>
	    The Gated flooding operation is illustrated in <xref target="Gated_flooding" />.
	  </t>

	  <figure align="center" anchor="Gated_flooding"
		  title="Gated flooding operation">
	    <preamble></preamble>

	    <artwork align="center">
      All Routers, IGP Process:
      if (SPT ready) {
       duplicate the SPT as Bidir_Multicast_tree;
       download the multicast_tree to forwarding plane;
      }
      add FNF_multicast_group_addr;

	      Sender of the FNF notification:
      if (breakage detected) {
       pack the notification in a packet;
       send the packet to the FNF_multicast_group_addr;
      }

      Receiver of the FNF notification:
       if (notification received) {
       if (RPC_interface == incoming_interface) {
        multicast the notification to all other interfaces;
       }
       forward the notification to IGP for processing;
      }
	    </artwork>

	    <postamble></postamble>
	  </figure> 



	  <t>
	    <xref target="Loop_Prevention" /> shows a sample operation on a four-router mesh network. The
	    left figure is the topology. The right figure is the shortest path
	    tree rooted at A.
	  </t>

	  <t>
	    Router A initiates the flooding. But the downstream routers B, C, and
	    D will drop all messages except the ones that come from their
	    shortest path parent node. For example, A's message to C via B is
	    dropped by C, because C knows that its reverse path forwarding (RPF)
	    nexthop is A.
	  </t>


	  <figure align="center" anchor="Loop_Prevention"
		  title="Loop Prevention through the RPF check">
	    <preamble></preamble>

	    <artwork align="center">
	      A       A
	      /|\     / \
	      B---C   B   C
	      \|/     \
	      D       D
	    </artwork>

	    <postamble></postamble>
	  </figure> 
	  
        </section>

      </section>



      <section anchor="Further_Multicast" title="Further Multicast Tree based Transport Options">

        <section anchor="Source_Specific" title="Source Specific Trees">
	  <t>
	    One implementation option is to rely on source specific multicast.
	    This means that even though there is only a single multicast group
	    address (MC-FN) allocated to the FN service, the FIB of each router
	    is configured with forwarding information for as many trees as many
	    FN sources (nodes) there are in the routing area, i.e. to each
	    (S_i,MC-FN) pair.
	  </t>
        </section>

        <section anchor="A_Single" title="A Single Bidirectional Shared Tree">
	  <t>
	    In the previous solution each source specific tree is a spanning
	    tree. It is possible to reduce the complexity of managing and
	    configuring n spanning trees in the area by using bidirectional
	    shared trees. By building a bidirectional shared tree, all nodes on
	    the tree can send and receive traffic using that single tree. Each
	    sent packet from any source is multicasted on the tree to all other
	    receivers.
	  </t>

	  <t>
	    The tree must be consistently computed at all routers. For this, the
	    following rules may be given:
	  </t>

	  <t>
	    The tree can be computed as a shortest path tree rooted at e.g. the
	    highest router-id. When multiple paths are available, the
	    neighbouring node in the graph e.g. with highest router-id can be
	    picked. When multiple paths are available through multiple interfaces
	    to a neighbouring node, e.g. a numbered interface may be preferred
	    over an unnumbered interface. A higher IP address may be preferred
	    among numbered interfaces and a higher ifIndex may be preferred among
	    unnumbered interfaces.
	  </t>

	  <t>
	    Note, however, that the important point is that the rules are
	    consistent among nodes. That is, a router may pick the lower router
	    IDs if it is ensured that ALL routers will do the same to ensure
	    consistency.
	  </t>

	  <t>
	    Multicast forwarding state is installed using such a tree as a bi-
	    directional tree. Each router on the tree can send packets to all
	    other routers on that tree.
	  </t>

	  <t>
	    Note that the multicast spanning tree can be built using
	    <xref target="RFC5015" /> so that each router within an
	    area subscribes to the same multicast group address. Using
	    BIDIR-PIM in such a way will eventually build a multicast
	    spanning tree among all routers within the
	    area. (BIDIR-PIM is normally used to build a shared,
	    bidirectional multicast tree among multiple sources and
	    receivers.)
	  </t>
	  
        </section>

      </section>



      <section anchor="Layer_2" title="Layer 2 Networks">
	<t>
	  Layer 2 (e.g. Ethernet) networks offer further options for
	  distributing the notification (e.g. using spanning trees offered by
	  STP). Definition of these is being considered and will be included in
	  a future revision of this draft.
	</t>
      </section>
      
    </section>




    <!-- Change Log

v02 2011-07-07  Andras   Adding flooding mode and SHA256 description. Removed redundant tree details.

    -->
  </back>
</rfc>
