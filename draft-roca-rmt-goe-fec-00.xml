<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="exp" ipr="trust200902">

<?xml-stylesheet type='text/xsl'
                 href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>


	<front>
		<title abbrev='The GOE Approach for FEC'>
			The Generalized Object Encoding (GOE) Approach for the Forward Erasure Correction (FEC) Protection of Objects and its Application to Reed-Solomon Codes over GF(2^^8)
		</title>

		<author initials='V' surname="Roca" fullname='Vincent Roca'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>655, av. de l'Europe</street>
					<street>Inovallee; Montbonnot</street>
					<city>ST ISMIER cedex</city>
					<code>38334</code>
					<country>France</country>
				</postal>
				<email>vincent.roca@inria.fr</email>
				<uri>http://planete.inrialpes.fr/people/roca/</uri>
			</address>
		</author>
		<author initials='A' surname="Roumy" fullname='Aline Roumy'>
			<organization>INRIA</organization>
			<address>
				<postal>
					<street>Campus Universitaire de Beaulieu</street>
					<city>RENNES Cedex</city>
					<code>35042</code>
					<country>France</country>
				</postal>
				<email>aline.roumy@inria.fr</email>
				<uri>http://www.irisa.fr/prive/Aline.Roumy/</uri>
			</address>
		</author>
		<author initials='B' surname="Sayadi" fullname='Bessem Sayadi'>
			<organization>Alcatel-Lucent, Bell Labs</organization>
			<address>
				<postal>
					<street></street>
					<city></city>
					<code></code>
					<country>France</country>
				</postal>
				<email>bessem.sayadi@alcatel-lucent.com</email>
			</address>
		</author>
		<date day="4" month="July" year="2011"/>
		<area>Transport</area>
		<workgroup>RMT</workgroup>
		<keyword>Forward Error Correction</keyword>
		<keyword>FEC</keyword>

		<abstract>
<t>
This document describes a Generalized Object Encoding (GOE) approach for the protection of
one or multiple objects, using one or several FEC schemes, in the context of a Content
Delivery Protocol (CDP) like FLUTE/ALC, FCAST/ALC or FCAST/NORM.
In RFC5052, the encoding process is determined by the object (e.g., file) boundaries,
i.e., the same code is applied to the whole object that has been submitted to the CDP by
the user.
The GOE approach instead decouples the definition of source blocks that are FEC encoded from
the natural object boundaries.
More precisely, either different portions of a given object can be protected with different FEC
codes (i.e., portions  of different nature and/or with different code rates), with a possible
overlapping, or at the opposite, different consecutive objects can be protected globally
through a single FEC encoding.
If a GOE FEC Scheme defines how to create and process repair packets using the GOE approach,
source objects must be encoded with a standard No-Code FEC Scheme.
Therefore the same flow of source packets can be shared by different flows of repair packets,
using different systematic GOE FEC schemes.
An additional benefit is that the GOE approach is backward compliant since the source packets
can be processed by receivers that do not support any GOE FEC scheme by simply discarding the
repair packets.
The present document first of all introduces the GOE approach. It then defines the
GOE Reed-Solomon FEC Scheme for the particular case of Reed-Solomon codes over GF(2^^8)
and no encoding symbol group, the GOE equivalent to FEC Encoding ID 5 defined in RFC5510.
</t>
		</abstract>
	</front>

	<middle>

<section anchor="Introduction" title="Introduction">
<!-- =========================================== -->

<t>The use of Forward Error Correction (FEC) codes is a classic solution to improve the
reliability of unicast, multicast and broadcast Content Delivery Protocols (CDP) and applications
<xref target="RFC3453"/>.
The <xref target="RFC5052"/> document describes a generic framework to use FEC schemes
with objects (e.g., files) delivery applications based on the ALC  <xref target="RFC5775"/>
and NORM <xref target="RFC5740"/> reliable multicast transport protocols.
</t>

<t>More specifically, the <xref target="RFC5053"/> (Raptor) and <xref target="RFC5170"/>
(LDPC-Staircase) FEC schemes introduce erasure codes based on sparse parity check matrices
for object delivery protocols like ALC and NORM.
Similarly, the <xref target="RFC5510"/> document introduces Reed-Solomon codes based on
Vandermonde matrices for the same object delivery protocols.
</t>

<t>
The way these FEC schemes is used leads to two limitations.
First of all, <xref target="RFC5052"/> defines an approach where the same FEC encoding
is applied to all the blocks of a given object, i.e., the whole object is encoded using
the same FEC scheme, with the same target code rate, resulting in an equivalent protection.
This approach may not suit situations where some subsets of an object deserve a
higher erasure protection than the others.
</t>

<t>
A second limitation is associated to the protection of a large set of small objects.
<xref target="RFC5052"/> defines an approach where each object is protected individually.
This feature limits the robustness of their delivery: since there is a small number of
source and repair packets for a given small object, a significant number of these packets
may be erased thereby preventing this object to be decoded at a receiver.
For instance, if the source and repair packets of a given object are transmitted in sequence
(which may not be the best strategy), a packet erasure burst will significantly impact
transmission robustness.
Other transmission ordering strategies (e.g., with long packet interleavings or random
ordering strategies) can reduce the impacts of packet erasure bursts, but they do not
solve the fundamental problem of the protection of small objects.
On the opposite a global FEC protection of all the objects of this set, using a single
FEC encoding (when possible), provides optimal transmission robustness, since all the
objects can be decoded as long as the erasure rate remains lower than the protection
brought by the FEC code rate (we assume an ideal (MDS) FEC code is used).
</t>

<t>
In order to mitigate the above limitations, a better approach consists in decoupling
FEC protection from the natural object boundaries.
This is the goal of the Generalized Object Encoding (GOE) approach defined in the
present document.
The GOE approach is independent of the nature of the FEC code, in the sense that
the general mechanisms it defines are not restricted to a single type of FEC code.
On the opposite, the GOE approach can be used associated to any of the existing
FEC schemes, re-using their code definition.
However a new FEC Encoding ID value, a new FEC Object Transmission Information (FEC OTI)
and a new FEC Payload ID (FPI) must be defined in order to accommodate the GOE specifics.
This means that a dedicated FEC Scheme must be defined, for instance 
for Reed-Solomon codes (re-using the <xref target="RFC5510"/> code definition)
and for LDPC-Staircase codes (re-using the <xref target="RFC5170"/> code definition).
</t>

<t>
The present document, in addition to presenting the GOE approach, defines the
GOE Reed-Solomon FEC Scheme for the particular case of Reed-Solomon codes over GF(2^^8)
and no encoding symbol group, the GOE equivalent to FEC Encoding ID 5 defined in
<xref target="RFC5510"/>.
Similar documents are expected to specify GOE equivalents to other FEC schemes.
</t>

</section>


<section anchor="Terminology" title="Terminology">
<!-- =========================================== -->

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>


	<section anchor="DefinitionsNotationsandAbbreviations" title="Definitions, Notations and Abbreviations">
	<!-- =========================================== -->

		<section anchor="Definitions" title="Definitions">
		<!-- =========================================== -->

<t>This document uses the following terms and definitions.
Some of them are FEC scheme specific and are in line with <xref target="RFC5052"/>:
<list style="hanging">
<t hangText="Source Packet:">	a data packet containing only source symbols, that is
				sent over the packet erasure channel. Most of the time
				a source packet will contain a single source symbol.</t>

<t hangText="Repair Packet:">	a data packet containing only repair symbols, that is
				sent over the packet erasure channel. Most of the time
				a repair packet will contain a single repair symbol.</t>

<t hangText="Packet Erasure Channel:"> 
				a communication path where packets are either
				dropped (e.g., by a congested router, or because the
				number of transmission errors exceeds the correction
				capabilities of the physical layer codes) or
				received. When a packet is received, it is assumed
				that this packet is not corrupted.</t>

<t hangText="Systematic code:">	FEC code in which the source symbols are part
				of the encoding symbols. The Reed-Solomon codes
				introduced in this document are systematic.</t>

<t hangText="Code rate:">	the k/n ratio, i.e., the ratio between the number
				of source symbols and the number of encoding symbols.
				By definition, the code rate is such that: 0 &lt; code rate &le; 1.
				A code rate close to 1 indicates that a small number of repair
				symbols have been produced during the encoding process.</t>

<t hangText="Object:">		the object (e.g., file) submitted to the CDP by the
				user.</t>

<t hangText="Generalized Object:"> a group of consecutive source symbols, that belong
				to one or several objects (as defined above) and that
				are considered together for the purpose of a GOE scheme.
				Generalized objects may be a subset of a given object or
				at the opposite encompass several objects.
				The key point when defining generalized objects is that all
				the source symbols of a generalized object require an equal
				erasure protection.</t>

<t hangText="Source symbol:">	unit of data used during the encoding process.
				In this specification, there is always one source symbol per ADU.</t>

<t hangText="Encoding symbol:">	unit of data generated by the encoding process.
				With systematic codes, source symbols are part
				of the encoding symbols.</t>

<t hangText="Repair symbol:">	encoding symbol that is not a source symbol.</t>

<t hangText="Source block:">	a block of k source symbols that are considered
				together for the encoding.</t>
</list>
</t>

		</section>


		<section anchor="Notations" title="Notations">
		<!-- =========================================== -->

<t>This document uses the following notations:
<list style="hanging" hangIndent="7">
<t hangText="k">	denotes the number of source symbols in a source block.</t>
<!-- <t hangText="max_k">	denotes the maximum number of source symbols for any source block.</t>-->
<!-- <t hangText="n_r">	denotes the number of repair symbols generated for a source block.</t> -->
<t hangText="n">	denotes the number of encoding symbols generated for a source block.</t>
<!--			Therefore: n = k + n_r.</t> -->
<!--
<t hangText="max_n">	denotes the maximum number of encoding symbols generated for any source block.</t> -->
<t hangText="E">	denotes the encoding symbol length in bytes.</t>
<!--
<t hangText="CR">	denotes the "code rate", i.e., the k/n ratio.</t>
<t hangText="N1">	denotes the target number of "1s" per column in the left side of
			the parity check matrix.</t>
<t hangText="N1m3">	denotes the value N1 - 3.</t>
<t hangText="G">	denotes the number of Repair Symbols in a given FEC Repair Packet.
			This value may differ between different FEC Repair Packets.</t>
<t hangText="a^^b">	denotes a raised to the power b.</t> -->
<t hangText="NO">	denotes the number of objects to be considered.</t>
<t hangText="NGO">	denotes the number of generalized objects to be considered.</t>
</list>
</t>
		</section>


		<section anchor="Abbreviations" title="Abbreviations">
		<!-- =========================================== -->

<t>This document uses the following abbreviations:
<list style="hanging" hangIndent="7">
<t hangText="ADU">	stands for Application Data Unit.</t>
<t hangText="TOI">	stands for Transmission Object Identifier.</t>
<t hangText="SBN">	stands for Source Block Number, i.e., a block identifier.</t>
<t hangText="ESI">	stands for Encoding Symbol ID.</t>
<t hangText="FEC">	stands for Forward Error (or Erasure) Correction code.</t>
<t hangText="LDPC">	stands for Low Density Parity Check.</t>
<t hangText="RS">	stands for Reed-Solomon.</t>
<t hangText="MDS">	stands for Maximum Distance Separable code.</t>
<t hangText="GO">	stands for Generalized Object.</t>
<t hangText="UEP">	stands for Unequal Erasure Protection.</t>
<t hangText="FEC OTI">	stands for FEC Object Transmission Information.</t>
</list>
</t>
		</section>

	</section>

</section>


<section anchor="sec:requirements" title="Goals and Requirements">
<!-- ==================================== -->

<t>
The main goal of the GOE FEC protection approach is to decouple FEC protection
from the natural object boundaries, in order to enable either
a differentiated protection of sub-parts of a single object (e.g., to achieve
Unequal Erasure Protection (UEP)),
or at the opposite a global protection of several objects (e.g., a large set of
small objects).
<xref target="annex:goe_exple"/> gives two examples where the mapping from object(s)
to generalized object(s) brings benefits in terms of either UEP or global protection
of a set of objects.
</t>

<t>
Additionally, the following are general requirements for GOE FEC schemes:
<list style="symbols">
<t> it MUST be possible, within a single CDP session, to use different GOE FEC schemes.
	This requirement enables each GOE FEC scheme to be used where it is the
	most valuable, for instance a GOE Reed-Solomon FEC scheme MAY be used for a small
	generalized object while a GOE LDPC-Staircase FEC scheme MAY be used for
	a large generalized object;</t>
<t> it MUST be possible, within a single CDP session, to include objects protected
	with one or several GOE FEC schemes and objects protected with one or several
	traditional (i.e., non GOE-compatible) FEC schemes.
	The same object MAY be protected both with a GOE FEC scheme and traditional FEC scheme.
	This requirement enables GOE FEC schemes to be used only where they bring added value;</t>
<t> if a source packet is part of several generalized objects, then this source packet
	MUST be useful to all the associated repair flows.
	It enables the same flow of source packets to be associated to different flows
	of repair packets, for instance to address different sets of receivers with
	different FEC capabilities;</t>
</list>
</t>

<t>
Because of the GOE features, the following are specific requirements that a CDP
SHOULD consider:
<list style="symbols">
<t> the order in which the objects are submitted to the CDP is significant.
	More specifically, if a goal is to enable a global protection of several objects,
	these objects MUST be submitted in sequence.
	The Transmission Object Identifier (TOI) of these objects MUST be sequential.</t>
<t> the FEC Object Transmission Information (FEC OTI) of a GOE FEC scheme determines
	in particular the composition of a generalized object, i.e., which source symbols
	of which objects are considered.
	However a receiver needs to know, upon processing this FEC OTI, the FEC OTI
	resulting from the No-Code FEC Encoding of each associated object.
	There is therefore a dependency that the CDP SHOULD try to minimize.
	In case of FLUTE, if the same FDT Instance ID includes the FEC OTI of all the
	objects and generalized objects, this is not an issue.
	In case of LCT, if the EXT_FTI mechanism is used to carry the FEC OTI, then great
	care should be taken since the FEC OTI of each object and generalized object is
	transmitted independently.
	The CDP sender must be aware of that dependency and SHOULD manage the session in
	such a way to maximize the probability that a receiver receives all the required
	FEC OTI in due time.
</t>
</list>
</t>


</section>


<section anchor="sec:GOE" title="GOE Principles">
<!-- ==================================== -->

  <section anchor="sec:GOP_sender" title="GOE at a CDP Sender">
  <!-- ==================================== -->

<t>
Let us consider a CDP sender first. GOE encoding works as follows:
<list style="symbols">
<t> within the CDP session, let us consider the set of objects that need to be
	protected by a GOE FEC scheme.
	These objects MUST be submitted submitted sequentially to the CDP and MUST be
	processed in their submission order.
	The Transmission Object Identifier (TOI) assigned to these objects MUST be sequential.
	Let NO be the number of such objects.
	Let O[i], with i in 1..NO, be these objects.
	Additional objects, that are not to be considered by a GOE FEC scheme, MAY
	be submitted to the same CDP session.
	These additional objects are not considered in the following and will be
	managed with a traditional FEC scheme, as defined in <xref target="RFC5052"/>,
	without interfering with the GOE FEC scheme(s);</t>
<t> the GOE sender chooses a source symbol size (see <xref target="sec:encoding_symbol_length"/>
	for considerations on how to choose this size).
	Let E be this source symbol size (in bytes).
	This is the size that MUST be considered for all the NO objects.
	By doing so, a generalized object that straddles several objects (among the NO possibles)
	benefits from the same source symbol size across object boundaries;</t>
<t> each object, O[i], is encoded with the No-Code FEC scheme (FEC Encoding ID 0),
	to produce an appropriate number of source symbols, of fixed size E, except
	perhaps for the last symbol of an object which may be shorter. This is
	the standard No-Code FEC encoding process, as defined in <xref target="RFC5445"/>;
	During this encoding, each (source) symbol is assigned a unique {TOI, SBN, ESI}
	tuple that fully identifies this symbol within the whole CDP session;</t>
<t> the set of source symbols from all the NO objects is now truncated into one
	or more sequences of symbols, called Generalized Objects (GO).
	Let NGO be the number of such generalized objects.
	Let GO[i], with i in 1..NGO, be these generalized objects.
	The size (i.e., number of source symbols) of a generalized object depends on
	the desired protection features and is left as a choice for the CDP.
	The generalized objects MAY also overlap (e.g., a given subset of source symbols
	can be FEC protected multiple times).
	On the opposite, there MAY be gaps (e.g., if the sender considers that
	a given subset of source symbols is not worth any FEC protection).
	The key point when defining generalized objects is that all the source symbols of
	a generalized object require an equal erasure protection;</t>
<t> each generalized object, GO[i], is assigned a new TOI value, otherwise unused.
	It consists of a sequence of a certain number of source symbols (i.e., the size
	of this generalized object), starting from the Initial Source Symbol ISS_i whose
	{TOI, SBN, ESI} tuple is well known.
	</t>
<t> each generalized object is partitioned into source blocks using the standard
	block partitioning algorithm defined in Section 9.1 of <xref target="RFC5052"/>.
	This algorithm is used in the same way, with the exception that
	the term "object" of that algorithm should be replaced by "generalized object"
	as defined in this document, and the variable T (number of source symbols
	in the object) of that algorithm is already known and is the "size of the
	generalized object" as defined in this document;</t>
<t> for a given source block, source symbols of size strictly inferior to E
	are first zero padded (this may happen if the generalized object straddles
	several objects as explained above).
	Then FEC encoding takes place for this block, taking into account the 
	optional zero padding (when present), using the associated GOE FEC Scheme.
	A certain number of FEC repair symbols is produced, depending on the
	target coding rate.
	Although the FEC codes used by a particular GOE FEC scheme is systematic
	(i.e., source symbols are part of the encoding symbols), these source symbols
	MUST NOT be sent to the receivers as GOE FEC scheme symbols, since they will
	already be sent as No-Code FEC scheme symbols;</t>
<t> FEC OTI for this generalized object is communicated to the receiver(s) using
	the same mechanisms (in-band versus out-of-band) as those used for other objects
	of that session if any <xref target="RFC5052"/>.
	At a minimum the Scheme-specific element of this FEC OTI identifies the ISS
	and size (in terms number of source symbols) for that generalized object.
	Additional information may be added as required by the GOE FEC scheme;</t>
<t> to each FEC repair symbol an FPI, that is specific to the GOE FEC Scheme used,
	is attached that indicates which block of which generalized object this FEC repair
	symbol belongs to, and its position within this block.
	Within the LCT or NORM header, the TOI of each repair symbol is that of the
	generalized object;</t>
<t> then source and repair packets are sent over the network, using an appropriate
	packet ordering scheme that is out of the scope of this document;</t>
</list>
</t>


<!--
Questions :
- il est plus simple de considérer la même taille de symboles pour tous les objets.
	=> OUI, KISS

- peut on avoir une session mélant GOE FEC Schemes et non FEC Scheme traditionnels ?
	problème de l'interprétation d'un Source FPI. Utilise le codepoint ?
	Ce serait très positif => reprendre le document en évitant de mentionner
		"tous les objects de la session" mais seulement ceux
		qui sont concernés par ce schéma.
	Pas sûr !

- quelles différences entre avoir des gaps dans les protections et assigner un
	GOE-NULL, ou bien un code_rate=1.0 ? Doit on interdir une possibilité ?
	* NULL => supporté facilement
	* CR=1 => si on a déja un codec, rien à faire de plus, c'est supporté.
	* ne rien faire => c'est comme si on avait perdu tous les repairs d'un bloc.

- doit on padder le dernier symbole de chaque objet? Doit on pour cela ajouter
	une info de longueur à chaquer source FPI ? PAS SUR !!!!
	=> OUI, on padde, NON on n'ajoute rien dans le FPI ni ailleurs.

- quel TOI mettre dans un symbole GOE Repair et dans un symbole GOE source ?
	Doit on créer un autre objet (virtuel), ou bien reprendre celui du 1er
	symbole source (puisqu'un GO peut être à cheval sur plusieurs objets) ?
	=> PAS DE SOUCIS avec l'approche No-Code FEC Scheme !

- un SSID de 32 bits est il suffisant ? Que faire si le nombre de symboles
	source d'une session dépasse ? Peut on etre bloqué dans le cas d'une
	session de très longue durée, avec mise à jour du jeux d'objets ?
	=> PAS DE SOUCIS avec l'approche No-Code FEC Scheme !

- sur réception d'un paquet, comment savoir s'il s'agit d'un symbole source
	ou d'un repair ? Les FPI sont distincts et ne peuvent être utilisés
	pour les différencier (!= ancienne approche).
	=> PAS DE SOUCIS avec l'approche No-Code FEC Scheme !
	=> Utiliser le codepoint pour cela : source si codepoint == GOE No-Code,
	repair si codepoint == GOE RS ou un autre schema GOE

- comment gérer les mise à jour de contenu d'une session ?
	=> on s'en fiche

- comment gérer la FDT Instance ?
	Restreint aux objets, pas aux GO. Donc pas de FEC OTI puisque
	ceux ci sont relatifs aux GO qui ne sont pas dans la FDT.
	NON.
	=> on suit le même principe, vu qu'il s'agit d'un objet (virtuel) associé à
	un flux de protection spécifique.

- comment gérer les FEC OTI ? Que mettre dedans ?
	=> defini par le GOE FEC scheme.

- rendre obligatoire le fait que l'on a un seul espace SSID pour tout CDP,
	durant toute la durée de la session, afin de ne pas avoir à redéfinir
	un espace bis.
	Traditionellement, c'était le TOI qui était unique, ensuite les
	SBN/ESI étaient liés à ce TOI. Là c'est différent.
	=> PAS DE SOUCIS avec l'approche No-Code FEC Scheme !

-->

  </section>


  <section anchor="sec:GOP_receiver" title="GOE at a CDP Receiver">
  <!-- ==================================== -->

<t>
Let us now consider a CDP receiver. GOE decoding works as follows:
<list style="symbols">
<t> upon reception of a FEC OTI for an object that is considered by at least one generalized object,
	using either an in-band or out-of-band mechanism, process this FEC OTI in order to be ready to
	process the source symbols received with a No-Code FEC scheme.
	Note that the information contained in this FEC OTI will be required during the processing
	of the FEC OTI of the associated generalized object(s);</t>
<t> upon reception of a FEC OTI for a generalized object, using either an in-band or out-of-band
	mechanism, process this FEC OTI in order to be ready to process the repair symbols received
	with a GOE FEC scheme, for the same generalized object;</t>
<t> in case of a packet associated to a traditional FEC scheme, then process
	this packet in the traditional way.</t>
<t> if the receiver is not interested by a generalized object(s) or does not support the
	GOE FEC scheme(s) being used, this receiver silently discards the associated packets;</t>
<t> process all incoming packets containing a source symbol for one of the NO objects,
	generated with a No-Code FEC encoding, in the traditional way.
	If this source symbol is part of one (or several) generalized object(s), check whether
	this fresh symbol helps in decoding a block;</t>
<t> incoming packets containing a repair symbol for one of the NGO generalized objects are easily
	identified by their TOI value (and in case of an ALC session by the Codepoint value of
	the LCT header, that contains the GOE FEC Encoding ID).
	Process this packet as specified by the GOE FEC scheme.
	Then check whether this fresh symbol helps in decoding a block of the generalized object;</t>
</list>
</t>

<t>
Concerning FEC OTI processing, as explained in <xref target="sec:requirements"/>, 
if a given generalized object, say GO[0], includes source symbols that belong
to several objects, say O[0], O[1] and O[2], then at some point of time, the receiver
must have processed the FEC OTI of both GO[0] and O[0], O[1] and O[2].
When the FEC OTI is sent in separate packets (e.g., if FEC OTI is sent within
EXT_FTI LCT or NORM header extensions), there is a dependency between all of them.
The CDP sender must be aware of that dependency and SHOULD manage the session in
such a way to maximize the probability that a receiver receives all the required
FEC OTI in due time.
</t>

  </section>

</section> <!-- GOE Principles -->


<!-- ================================================================================================= -->


<section title="Formats and Codes with FEC Encoding ID XXX for Reed-Solomon codes over GF(2^^8)">
<!-- ========================== -->

<t>This section introduces the formats and codes associated with the Fully-Specified FEC Scheme
with FEC Encoding ID XXX, which focuses on the special case of Reed-Solomon codes over GF(2^^8)
and no encoding symbol group.
This GOE FEC Scheme is the GOE equivalent to FEC Encoding ID 5 defined in <xref target="RFC5510"/>.
</t>


  <section title="FEC Payload ID (for Repair Packets Only)">
  <!-- =========================-->
  
<t>The FEC Payload ID, to be used only with repair packet, i.e., packets containing a repair symbol each,
is composed of the Source Block Number (SBN) and the Encoding Symbol ID (ESI).
There is no change in terms of format with respect to <xref target="RFC5510"/> but a restriction
in terms of valid ESI as explained below:</t>

<t>
<list style="symbols">
<t>The Source Block Number (24-bit field) identifies from which source block
   of the object the encoding symbol in the payload is generated.
   There is a maximum of 2^^24 blocks per object.</t>

<t>The Encoding Symbol ID (8-bit field) identifies which specific encoding
   symbol generated from the source block is carried in the packet payload.
   There is a maximum of 2^^8 encoding symbols per block.
   The first k values (0 to k - 1) identify source symbols; the remaining n-k
   values identify repair symbols.
   Since only repair symbols are considered by this GOE FEC scheme, values 0 to k-1
   inclusive MUST NOT be used.</t>
</list>
</t>

<t>There MUST be exactly one FEC Payload ID per repair packet.
This FEC Payload ID refers to the one and only symbol of the packet.
</t>

<figure anchor="fig_fec_payload_id_EncID5" title="FEC Payload ID Encoding Format with FEC Encoding ID XXX"> 
  <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Source Block Number (24 bits)          | Enc. Symb. ID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

  </section>

  <section title="FEC Object Transmission Information" anchor="FEC_OTI_EncID5">
  <!-- =============================================-->

    <section title="Mandatory Elements">
    <!-- ============================-->
   
<t>
<list style="symbols">
   <t>FEC Encoding ID:
   the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID XXX.
   </t>
</list>
</t>

    </section>

    <section title="Common Elements">
    <!-- =========================-->

<t> The Common elements are the same as those specified in <xref target="RFC5510"/> for FEC Encoding ID 5.</t>

    </section>

    <section title="Scheme-Specific Elements" anchor="scheme_specific_elt">
    <!-- ==================================-->

<t> The following element MUST be defined with the present FEC scheme.
It defines the composition of a generalized object:</t>

<t>
<list style="symbols">
    <t> the Initial Source Symbol TOI (ISS_TOI) identifies the TOI of
	the first source symbol of this generalized object.
	The exact format of this field depends on the TOI format, which is
	CDP and use-case specific. For instance the TOI field of an ALC session
	is stored in a field of length 32*O+16*H bits;</t>
    <t> the Initial Source Symbol TOI size (ISS_O) two bit field determines the TOI size,
	which is equal to 32*ISS_O + 30 bits. This flexibility is meant to be compatible with
	any NORM or ALC TOI format;</t>
    <t> the Initial Source Symbol Source Block Number (ISS_SBN) identifies the SBN of
	the first source symbol of this generalized object, within its
	original object. This is a 16 bit field, since this value results
	from the No-Code FEC encoding of the original object;</t>
    <t> the Initial Source Symbol Encoding Symbol ID (ISS_ESI) identifies the ESI of
	the first source symbol of this generalized object, within its
	original block.  This is a 16 bit field, since this value results
	from the No-Code FEC encoding of the original object;</t>
    <t> the Generalized Object Size (GOS) identifies the size, in terms of number
	of source symbols that compose this generalized object;</t>
</list>
</t>

    </section>

    <section title="Encoding Format" anchor="FEC_OTI_encoding_format">
    <!-- =========================-->
    
    <t>This section shows the two possible encoding formats of the above FEC OTI.
    The present document does not specify when one encoding format or the other should be used.</t>
    
        <section title="Using the General EXT_FTI Format">
        <!-- =========================-->

<t>
The FEC OTI binary format is the following, when the EXT_FTI mechanism
is used (e.g., within the ALC <xref target="RFC5775"/>
 or NORM <xref target="RFC5740"/> protocols).
</t>

    <figure title="EXT_FTI Header Format with FEC Encoding ID XXX" anchor="fig:EXT_FTI_format_EncID5">
    <artwork>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   HET = 64    |    HEL = 3    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Transfer Length (L)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     | 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|*_O|                                                           |
+-+-+         ISS_TOI (length = 32*ISS_O + 30 bits)             +
|                          ...                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    ISS Source Block Number    |    ISS Encoding Symbol ID     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Generalized Object Size                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </artwork>
    </figure>

        </section>

        <section title="Using the FDT Instance (FLUTE specific)">
        <!-- =========================-->

<t>When it is desired that the FEC OTI be carried in the FDT Instance
of a FLUTE session <xref target="FLUTE"/>,
the following XML attributes must be described for the associated object:
<list style="symbols">
	<t>FEC-OTI-FEC-Encoding-ID</t>
	<t>FEC-OTI-Transfer-Length (L)</t>
	<t>FEC-OTI-Encoding-Symbol-Length (E)</t>
	<t>FEC-OTI-Maximum-Source-Block-Length (B)</t>
	<t>FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)</t>
	<t>FEC-OTI-Scheme-Specific-Info</t>
</list>
The FEC-OTI-Scheme-Specific-Info contains the string resulting from
the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
following value:
</t>

<figure anchor="fig_scheme_specific_EncID2"
	title="FEC OTI Scheme Specific Information To Be Included in the FDT Instance"> 
  <artwork>
 0                   1          
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|*_O|                                                           |
+-+-+         ISS_TOI (length = 32*ISS_O + 30 bits)             +
|                          ...                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    ISS Source Block Number    |    ISS Encoding Symbol ID     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Generalized Object Size                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </artwork>
</figure>

<t>
During Base64 encoding, the FEC OTI Scheme-Specific Information (of variable length) 
is transformed into a string of printable characters (in the 64-character
alphabet) that is added to the FEC-OTI-Scheme-Specific-Info attribute.
</t>

        </section>

    </section>

  </section>

</section> <!-- Formats and Codes -->


<section title="Procedures with FEC Encoding ID XXX for Reed-Solomon codes over GF(2^^8)" anchor="procedures">
<!-- =================== -->

<t>
This section defines procedures that MUST be applied to FEC Encoding ID XXX.
The block partitioning algorithm that is defined in Section 9.1 of <xref target="RFC5052"/> MUST be used.
The procedure called "Determining the Maximum Source Block Length (B)" in <xref target="RFC5510"/> MUST be used.
The procedure called "Determining the Number of Encoding Symbols of a Block" in <xref target="RFC5510"/> MUST be used.
</t>

	<section title="Determining the Encoding Symbol Length (E)" anchor="sec:encoding_symbol_length">
	<!-- ================ -->

<t>
The E parameter usually depends on the maximum transmission unit on the
path Maximum Transmission Unit (PMTU) from the source to each receiver.
This PTMU may be known, may be discovered, or may be estimated, depending on
the target use case.
In order to minimize the protocol header overhead (e.g., the Layered Coding Transport
(LCT), UDP, IPv4, or IPv6 headers in the case of ALC), E MAY be chosen to be as large
as possible.
In that case, E is chosen so that the size of a packet composed of a single
encoding symbol remains below but close to the PMTU (or by the minimum PMTU
to each possible destinations in case of one-to-many sessions).
This value E is also the source symbol size (i.e., the source symbols, before
FEC encoding, and the encoding symbols, after FEC encoding, are of equal size).
</t>

<t>
This size MUST be used to segment all of the NO objects considered by the GOE FEC
schemes for this CDP into source symbols.
By doing so, a generalized object that straddles several objects (among the NO possibles)
benefits from the same source symbol size across object boundaries.
</t>

	</section>

</section> <!-- Procedures -->


<section anchor="SecurityConsiderations" title="Security Considerations">
<!-- ==================================== -->

<t>
TBD
</t>

</section>


<section anchor="iana-cons" title="IANA Considerations">
<!-- =============================================== -->

<t>
Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration.
For general guidelines on IANA considerations as they apply to this document,
see <xref target="RFC5052" />.
</t>

<t>
This document assigns the Fully-Specified FEC Encoding ID XXX 
under the "ietf:rmt:fec:encoding" name-space to "Generalized Object Encoding for Reed-Solomon Codes over GF(2^^8)".
</t>

</section>


<section anchor="Acknowledgments" title="Acknowledgments">
<!-- =============================================== -->

<t>
TBD
</t>

</section>

	</middle>

	<back>

		<references title="Normative References">
		<!-- ==================================== -->
			<reference anchor="RFC2119">
				<front>
					<title>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials="S." surname="Bradner" fullname="Scott Bradner">
						<organization/>
					</author>
					<date year=""/>
				</front>
				<seriesInfo name="RFC" value="2119"/>
			</reference>

		</references>

		<references title="Informative References">
		<!-- ==================================== -->

			<?rfc include='reference.RFC.3453'?>
			<?rfc include='reference.RFC.5445'?> 	<!-- Basic FEC Schemes -->

			<reference anchor="RFC5170">
				<front>
					<title>Low Density Parity Check (LDPC) Forward Error Correction</title>
					<author initials="V." surname="Roca"> <organization/> </author>
					<author initials="C." surname="Neumann"> <organization /> </author>
					<author initials="D." surname="Furodet"> <organization /> </author>
					<date month="June" year="2008"/>
				</front>
				<seriesInfo name="RFC" value="5170"/>
			</reference>

			<reference anchor="RFC5052">
				<front>
					<title>Forward Error Correction (FEC) Building Block</title>
					<author initials="M." surname="Watson"> <organization/> </author>
					<author initials='M.' surname='Luby'> <organization /> </author>
					<author initials='L.' surname='Vicisano'> <organization /> </author>
					<date month="August" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5052"/>
			</reference>

			<reference anchor="RFC5510">
				<front>
				<title>Reed-Solomon Forward Error Correction (FEC) Schemes</title>
					<author initials="J." surname="Lacan" fullname="Jerome Lacan">
						<organization></organization> </author>
					<author initials="V." surname="Roca" fullname="Vincent Roca">
						<organization></organization> </author>
					<author initials="J." surname="Peltotalo" fullname="Jani Peltotalo">
						<organization></organization> </author>
					<author initials="S." surname="Peltotalo" fullname="Sami Peltotalo">
						<organization></organization> </author>
					<date month="April" year="2009" />
				</front>
				<seriesInfo name="RFC" value="5510" />
			</reference>

			<reference anchor="RFC5053">
				<front>
					<title>Raptor Forward Error Correction Scheme</title>
					<author initials="M." surname="Luby" fullname="M. Luby"> <organization/> </author>
					<author initials="A" surname="Shokrollahi" fullname="A. Shokrollahi"> <organization/> </author>
					<author initials="M" surname="Watson" fullname="M.  Watson"> <organization/> </author>
					<author initials="T" surname="Stockhammer" fullname="T. Stockhammer"> <organization/> </author>
					<date month="June" year="2007"/>
				</front>
				<seriesInfo name="RFC" value="5053"/>
			</reference>

			<?rfc include='reference.RFC.5740'?> 	<!-- NORM -->

			<?rfc include='reference.RFC.5775'?> 	<!-- ALC -->

			<reference anchor="FLUTE">
				<front>
					<title>FLUTE - File Delivery over Unidirectional Transport</title>
					<author initials='T.' surname='Paila'>
						<organization />
					</author>
					<author initials="R." surname="Walsh">
						<organization/>
					</author>
					<author initials='M.' surname='Luby'>
						<organization />
					</author>
					<author initials='V.' surname='Roca'>
						<organization />
					</author>
					<author initials='R.' surname='Lehtonen'>
						<organization />
					</author>
					<date month="February" year="2011"/>
				</front>
				<seriesInfo name="Work in" value="Progress"/>
			</reference>

			<!-- =================================================== -->


		</references>

<section anchor="annex:goe_exple" title="Two Examples of GOE Protection of Objects">
<!-- =============================================== -->

<t>
<xref target="fig_uep_example"/> is an example of use of a GOE FEC scheme to provide unequal erasure protection
of a large object, whose first part is of higher importance than the remaining bytes.
Different code rates are applied to each generalized object, to provide for different erasure protection.
The 80 packets generated after a No-Code FEC encoding of the object of TOI 1, along with the 20 repair symbols
generated after a Reed-Solomon(60, 40) encoding of the high priority generalized object of TOI=10 and the 10 repair
symbols generated after a Reed-Solomo(50, 40) encoding of the low priority generalized object of TOI=11 are sent
over the network.
Here the two generalized objects are kept separate, however nothing in the GOE approach requires this is the
case. Other types of mappings are possible.
</t>

<figure anchor="fig_uep_example"
	title="Example of Object to Generalized Object mapping to provide Unequal Erasure Protection."> 
  <artwork>
+------------------------------------------------------------------+
| Object, TOI=1, k=80 source symbols                               |
+------------------------------------------------------------------+
\--------------- ----------------/\--------------- ----------------/
                V                                 V
 +------------------------------+  +------------------------------+
 |      1st GO (high prio)      |  |      2nd GO (low prio)       | 
 |     TOI=10, k=40 symbols     |  |     TOI=11, k=40 symbols     |
 +------------------------------+  +------------------------------+
                |                                 |
   FEC Encoding, code rate=0.5       FEC Encoding, code rate=0.8
                |                                 |
                V                                 V
        20 repair symbols                 10 repair symbols
  </artwork>
</figure>


<t>
On the opposite, <xref target="fig_uep_example"/> is an example of use of a GOE FEC scheme to globally protect
a set of small objects.
A single generalized object of TOI 10 is defined that gathers the source symbols of the original objects
of TOI 1 to 7 included.
The 80 packets generated after a No-Code FEC encoding of the objects of TOI 1 to 7, along with the 40 repair
symbols generated after a Reed-Solomon(120, 80) encoding of the generalized object of TOI=10 are sent
over the network.
With an MDS code, any subset of 80 packets among the 120 possible packets are sufficient to decode all the
original objects.
</t>

<figure anchor="fig_global_enc_example"
	title="Example of Object to Generalized Object mapping to globally protect several small objects."> 
  <artwork>
+-----+ +-----+ +-----+ +-----+ +-----+ +-----+ +------------------+
|TOI=1| |TOI=2| |TOI=3| |TOI=4| |TOI=5| |TOI=6| |       TOI=7      |
+-----+ +-----+ +-----+ +-----+ +-----+ +-----+ +------------------+
\-------------------------------- ---------------------------------/
                                 V
+------------------------------------------------------------------+
| Generalized Object, TOI=10, k=80 source symbols                  |
+------------------------------------------------------------------+
                                 |
                    FEC Encoding, code rate=0.5
                                 | 
                                 V
                         40 repair symbols
  </artwork>
</figure>

</section>

	</back>

</rfc>
