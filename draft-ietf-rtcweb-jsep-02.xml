<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="no" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-ietf-rtcweb-jsep-02" ipr="trust200902">
  <front>
    <title abbrev="JSEP">Javascript Session Establishment Protocol</title>

    <author fullname="Justin Uberti" initials="J." surname="Uberti">
      <organization>Google</organization>

      <address>
        <postal>
          <street>747 6th Ave S</street>

          <city>Kirkland</city>

          <region>WA</region>

          <code>98033</code>

          <country>USA</country>
        </postal>

        <email>justin@uberti.name</email>
      </address>
    </author>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>fluffy@iii.ca</email>
      </address>
    </author>

    <date day="22" month="October" year="2012" />

    <area>RAI</area>

    <abstract>
      <t>This document proposes a mechanism for allowing a Javascript
      application to fully control the signaling plane of a multimedia
      session, and discusses how this would work with existing signaling
      protocols. </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The thinking behind WebRTC call setup has been to fully specify and
      control the media plane, but to leave the signaling plane up to the
      application as much as possible. The rationale is that different
      applications may prefer to use different protocols, such as the existing
      SIP or Jingle call signaling protocols, or something custom to the
      particular application, perhaps for a novel use case. In this approach,
      the key information that needs to be exchanged is the multimedia session
      description, which specifies the necessary transport and media
      configuration information necessary to establish the media plane.</t>

      <t>The browser environment also has its own challenges that cause
      problems for an embedded signaling state machine. One of these is that
      the user may reload the web page at any time. If this happens, and the
      state machine is being run at a server, the server can simply push the
      current state back down to the page and resume the call where it left
      off.</t>

      <t>This document describes the Javascript Session Establishment Protocol
      (JSEP) that pulls the signaling state machine out of the browser and
      into Javascript. This mechanism effectively removes the browser almost
      completely from the core signaling flow; the only interface needed is a
      way for the application to pass in the local and remote session
      descriptions negotiated by whatever signaling mechanism is used, and a
      way to interact with the ICE state machine.</t>

      <t>JSEP's handling of session descriptions is simple and
      straightforward. Whenever an offer/answer exchange is needed, the
      initiating side creates an offer by calling a createOffer() API. The
      application optionally modifies that offer, and then uses it to set
      up its local config via the setLocalDescription() API. The offer is then
      sent off to the remote side over its preferred signaling mechanism (e.g.,
      WebSockets); upon receipt of that offer, the remote party installs it
      using the setRemoteDescription() API.</t>

      <t>When the call is accepted, the callee uses the createAnswer() API to
      generate an appropriate answer, applies it using setLocalDescription(),
      and sends the answer back to the initiator over the signaling channel.
      When the offerer gets that answer, it installs it using
      setRemoteDescription(), and initial setup is complete. This process can
      be repeated for additional offer/answer exchanges.</t>

      <t>Regarding ICE, JSEP decouples the ICE state machine from the overall
      signaling state machine, as the ICE state machine must remain in the
      browser, because only the browser has the necessary knowledge of
      candidates and other transport info. Performing this separation also
      provides additional flexibility; in protocols that decouple session
      descriptions from transport, such as Jingle, the transport information
      can be sent separately; in protocols that don't, such as SIP, the
      information can be used in the aggregated form. Sending transport
      information separately can allow for faster ICE and DTLS startup, since
      the necessary roundtrips can occur while waiting for the remote side to
      accept the session.</t>

      <t>The JSEP approach does come with a minor downside. As the application
      now is responsible for driving the signaling state machine, slightly
      more application code is necessary to perform call setup; the
      application must call the right APIs at the right times, and convert the
      session descriptions and ICE information into the defined messages of
      its chosen signaling protocol, instead of simply forwarding the messages
      emitted from the browser.</t>

      <t>One way to mitigate this is to provide a Javascript library that
      hides this complexity from the developer, which would implement the
      state machine and serialization of the desired signaling protocol. For
      example, this library could convert easily adapt the JSEP API into the
      exact ROAP API <xref target="I-D.jennings-rtcweb-signaling"></xref>,
      thereby implementing the ROAP signaling protocol. Such a library could
      of course also implement other popular signaling protocols, including
      SIP or Jingle. In this fashion we can enable greater control for the
      experienced developer without forcing any additional complexity on the
      novice developer.</t>
    </section>

    <section title="Other Approaches Considered">
      <t>Another approach that was considered for JSEP was to move the
      mechanism for generating offers and answers out of the browser as well.
      Instead of providing createOffer/createAnswer methods within the
      browser, this approach would instead expose a getCapabilities API which
      would provide the application with the information it needed in order to
      generate its own session descriptions. This increases the amount of work
      that the application needs to do; it needs to know how to generate
      session descriptions from capabilities, and especially how to generate
      the correct answer from an arbitrary offer and the supported
      capabilities. While this could certainly be addressed by using a library
      like the one mentioned above, it basically forces the use of said
      library even for a simple example. Exposing createOffer/createAnswer
      avoids that problem, but still allows applications to generate their own
      offers/answers if they choose, using the description generated by
      createOffer as an indication of the browser's capabilities.</t>

      <t>Note also that while JSEP transfers more control to Javascript, it is
      not intended to be an example of a "low-level" API. The general argument
      against a low-level API is that there are too many necessary API points,
      and they can be called in any order, leading to something that is hard
      to specify and test. In the approach proposed here, control is performed
      via session descriptions; this requires only a few APIs to handle these
      descriptions, and they are evaluated in a specific fashion, which
      reduces the number of possible states and interactions.</t>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in RFC 2119 [RFC2119].</t>
    </section>

    <section title="Semantics and Syntax">
      <section title="Signaling Model">
        <t>JSEP does not specify a particular signaling model or state
        machine, other than the generic need to exchange RFC 3264 offers and
        answers in order for both sides of the session to know how to conduct
        the session. JSEP provides mechanisms to create offers and answers, as
        well as to apply them to a session. However, the actual mechanism by
        which these offers and answers are communicated to the remote side,
        including addressing, retransmission, forking, and glare handling, is
        left entirely up to the application.</t>

        <figure anchor="fig-sigModel" title="JSEP Signaling Model">
          <artwork><![CDATA[
    +-----------+                               +-----------+ 
    |  Web App  |<--- App-Specific Signaling -->|  Web App  |
    +-----------+                               +-----------+
          ^                                            ^
          |  SDP                                       |  SDP 
          V                                            V
    +-----------+                                +-----------+ 
    |  Browser  |<----------- Media ------------>|  Browser  |
    +-----------+                                +-----------+
]]></artwork>
        </figure>
      </section>

      <section title="Session Descriptions and State Machine">
        <t>In order to establish the media plane, the user agent needs
        specific parameters to indicate what to transmit to the remote side,
        as well as how to handle the media that is received. These parameters
        are determined by the exchange of session descriptions in offers and
        answers, and there are certain details to this process that must be
        handled in the JSEP APIs.</t>

        <t>Whether a session description was sent or received affects the
        meaning of that description. For example, the list of codecs sent to a
        remote party indicates what the local side is willing to decode, and
        what the remote party should send. Not all parameters follow this
        rule; for example, the SRTP parameters [RFC4568] sent to a remote
        party indicate what the local side will use to encrypt, and thereby
        how the remote party should expect to receive.</t>

        <t>In addition, various RFCs put different conditions on the format of
        offers versus answers. For example, a offer may propose multiple SRTP
        configurations, but an answer may only contain a single SRTP
        configuration.</t>

        <t>Lastly, while the exact media parameters are only known only after
        a offer and an answer have been exchanged, it is possible for the
        offerer to receive media after they have sent an offer and before they
        have received an answer. To properly process incoming media in this
        case, the offerer's media handler must be aware of the details of the
        offerer before the answer arrives.</t>

        <t>Therefore, in order to handle session descriptions properly, the
        user agent needs: <list style="numbers">
            <t>To know if a session description pertains to the local or
            remote side.</t>

            <t>To know if a session description is an offer or an answer.</t>

            <t>To allow the offer to be specified independently of the
            answer.</t>
          </list> JSEP addresses this by adding both a setLocalDescription and
        a setRemoteDescription method and having session description objects
	contain a type field indicating
        the type of session description being supplied. This
        satisfies the requirements listed above for both the offerer, who
        first calls setLocalDescription(sdp [offer]) and then later
        setRemoteDescription(sdp [answer]), as well as for the answerer, who
        first calls setRemoteDescription(sdp [offer]) and then later
        setLocalDescription(sdp [answer]). While it could be possible to
        implicitly determine the value of the offer/answer argument, requiring
        it to be specified explicitly is more robust, allowing invalid
        combinations (i.e. an answer before an offer) to generate an
        appropriate error.</t>

        <t>JSEP also allows for an answer to be treated as provisional by the
        application. Provisional answers provide a way for an answerer to
        communicate initial session parameters back to the offerer, in order
	to allow the
        session to begin, while allowing a final answer to be specified later.
        This concept of a final answer is important to the offer/answer model;
        when such an answer is received, any extra resources allocated by the
        caller can be released, now that the exact session configuration is
        known. These "resources" can include things like extra ICE components,
        TURN candidates, or video decoders. Provisional answers, on the other
        hand, do no such deallocation results; as a result, multiple dissimilar
        provisional answers can be received and applied during call setup.</t>

        <t>
          In [RFC3264], the constraints at the signaling level is that only one
          offer can be outstanding for a given session but from the media stack
          level, a new offer can be generated at any point. For example, when
          using SIP for signaling, if one offer is sent, then cancelled using a
          SIP CANCEL, another offer can be generated even though no answer was
          received for the first offer. To support this, the JSEP media layer
          can provide an offer whenever the Javascript application needs one for
          the signaling.
        The answerer can send back zero or
        more provisional answers, and finally end the offer-answer exchange by
        sending a final answer. The state machine for this is as follows:
        <figure anchor="fig-state-machine" title="JSEP State Machine">
            <artwork><![CDATA[
      +-----------+
      |           |
      |           |
      |  Stable   |<---------------\
      |           |                |
      |           |                |
      +-----------+                |
          ^   |                    | 
          |   | OFFER              |
   ANSWER |   |                    | ANSWER
          |   V                    |
      +-----------+          +-----------+
      |           |          |           |
      |           | PRANSWER |           |
      |   Offer   |-------- >| Pranswer  |
      |           |          |           |
      |           |----\     |           |----\
      +-----------+    |     +-----------+    |
                 ^     |                ^     |
                 |     |                |     |
                 \-----/                \-----/
                  OFFER                 PRANSWER
]]></artwork>
          </figure> Aside from these state transitions, there is no other
        difference between the handling of provisional ("pranswer") and final
        ("answer") answers.</t>
      </section>

      <section title="Session Description Format">
        <t>In the WebRTC specification, session descriptions are formatted as
        SDP messages. While this format is not optimal for manipulation from
        Javascript, it is widely accepted, and frequently updated with new
        features. Any alternate encoding of session descriptions would have to
        keep pace with the changes to SDP, at least until the time that this
        new encoding eclipsed SDP in popularity. As a result, JSEP continues
        to use SDP as the internal representation for its session
        descriptions.</t>

        <t>However, to simplify Javascript processing, and provide for future
        flexibility, the SDP syntax is encapsulated within a
        SessionDescription object, which can be constructed from SDP, and be
        serialized out to SDP. If future specifications agree on a JSON format
        for session descriptions, we could easily enable this object to
        generate and consume that JSON.</t>

        <t>Other methods may be added to SessionDescription in the future to
        simplify handling of SessionDescriptions from Javascript. Though it
        is unclear exactly what manipulations developer will commonly want to do to SDP, it
        would be simple to write a Javascript library to perform these
        manipulations.</t>
      </section>

      <section title="ICE">
        <t>When a new ICE candidate is available, the ICE Agent will notify
        the application via a callback; these candidates will automatically be
        added to the local session description. When all candidates have been
        gathered, the callback will also be invoked to signal that the
        gathering process is complete.</t>

        <section title="ICE Candidate Trickling">
          <t>Candidate trickling is a technique through which a caller may
          incrementally provide candidates to the callee after the initial
          offer has been dispatched; the semantics of "Trickle ICE" are defined in <xref
          target="I-D.rescorla-mmusic-ice-trickle"></xref>. This process allows the
          callee to begin acting upon the call and setting up the ICE (and
          perhaps DTLS) connections immediately, without having to wait for
          the caller to gather all possible candidates. This results in faster
          call startup in cases where gathering is not performed prior to initating the call.</t>

          <t>JSEP supports optional candidate trickling by providing APIs that
          provide control and feedback on the ICE candidate gathering process.
          Applications that support candidate trickling can send the initial
          offer immediately and send individual candidates when they get the
          notified of a new candidate; applications that do not support this
          feature can simply wait for the indication that gathering is complete,
          and then create and send their offer, with all the candidates, at this
          time.</t>

          <t>Upon receipt of trickled candidates, the receiving application
          will supply them to its ICE Agent. This triggers the ICE Agent to
          start using the new remote candidates for connectivity checks.</t>

          <section title="ICE Candidate Format">
            <t>As with session descriptions, the syntax of the IceCandidate
            object provides some abstraction, but can be easily converted to
            and from the SDP a=candidate lines.</t>

            <t>The a=candidate lines are the only SDP information that is
            contained within IceCandidate, as they represent the only
            information needed that is not present in the initial offer (i.e.
            for trickle candidates). This information is carried with the same
            syntax as the "a=candidate" line in SDP. For example:</t>

            <figure>
              <artwork><![CDATA[
a=candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host
]]></artwork>
            </figure>

            <t>The IceCandidate object also contains fields to indicate which m= line
            it should be associated with. The m line can be identified in one
            of two ways; either by a m-line index, or a MID. The m-line index is a zero-based
            index, referring to the Nth m-line in the SDP.
            The MID uses the "media stream identification", as defined in
            [RFC 3388], to identify the m-line. WebRTC implementations creating an ICE
            Candidate object MUST populate both of these fields. Implementations receiving an
            ICE Candidate object SHOULD use the MID if they implement that functionality,
            or the m-line index, if not.</t>
          </section>
        </section>
      </section>

      <section title="Interactions With Forking">
        <t>Some call signaling systems allow various types of forking where an
        SDP Offer may be provided to more than one device. For example, SIP
        RFC 3261 defines both a "Parallel Search" and "Sequential Search".
        Although these are primarily signaling level issues that are outside
        the scope of JSEP, they do have some impact on the configuration of
        the media plane, which is relevant. When forking
        is happening at the signaling layer, the Javascript application
        responsible for the signaling needs to make the decisions about what
        media should be sent or received at any point of time and which
        remote endpoint it should communicate with. JSEP is used to make sure the
        media engine can make the RTP and media perform as required by the
        application. The basic operations that the applications can have the
        media engine do are: <list>
            <t>Start exchanging media to a given remote peer but keep all the
            resources reserved in the offer.</t>

            <t>Start exchanging media with a given remote peer and free any
            resources in the offer that are not being used.</t>
          </list></t>

        <section title="Sequential Forking">
          <t>Sequential forking involves a call being dispatched to multiple
          remote callees, where each callee can accept the call, but only one
          active session ever exists at a time; no mixing of received media is
          performed.</t>

          <t>JSEP handles serial forking well, allowing the application to
          easily control the policy for selecting the desired remote endpoint.
          When an answer arrives from one of the callees, the application can
          choose to apply it either as a provisional answer, leaving open the
          possibility of using a different answer in the future, or apply it
          as a final answer, ending the setup flow.</t>

          <t>In a "first-one-wins" situation, the first answer will be applied
          as a final answer, and the application will reject any subsequent
          answers. In SIP parlance, this would be ACK + BYE.</t>

          <t>In a "last-one-wins" situation, all answers would be applied as
          provisional answers, and any previous call leg will be terminated.
          At some point, the application will end the setup process, perhaps
          with a timer; at this point, the application could reapply the
          existing remote description as a final answer.</t>
        </section>

        <section title="Parallel Forking">
          <t>Parallel forking involves a call being dispatched to multiple
          remote callees, where each callee can accept the call, and multiple
          simultaneous active signaling sessions can be established as a
          result. If multiple callees send media at the same time, the
          possibilities for handling this are described in Section 3.1 of RFC
          3960. Most SIP devices today only support exchanging media with a
          single device at a time, and do not try to mix multiple early media
          audio sources, as that could result in a confusing situation. For example.
          consider having a European ringback tone mixed together with the North American ringback tone - the
          resulting sound would not be like either tone, and would confuse the user.
          If the signaling application wishes to only exchange media with one
          of the remote endpoints at a time, then from a media engine point of view,
          this is exactly like the sequential forking case.</t>

          <t>In the parallel forking case where the Javascript application
          wishes to simultaneously exchange media with multiple peers, the flow is
          slightly more complex, but the Javascript application can
          follow the strategy that RFC 3960 describes using UPDATE. (It is
          worth noting that use cases where this is the desired behavior are
          very unusual.) The UPDATE approach allows the signaling to set up a
          separate media flow for each peer that it wishes to exchange media
          with. In JSEP, this offer used in the UPDATE would be formed by
          simply creating a new PeerConnection and making sure that the same
          local media streams have been added into 
          this new PeerConnection. Then the new PeerConnection object would produce
          a SDP offer that could be used by the signaling to
          perform the UPDATE strategy discussed in RFC 3690.</t>

          <t>As a result of sharing the media streams, the application will
          end up with N parallel PeerConnection sessions, each with a local
          and remote description and their own local and remote addresses. The
          media flow from these sessions can be managed by specifying SDP
          direction attributes in the descriptions, or the application can
          choose to play out the media from all sessions mixed together. Of
          course, if the application wants to only keep a single session, it
          can simply terminate the sessions that it no longer needs.</t>
        </section>
      </section>

      <section title="Session Rehydration">
        <t>In the event that the local application state is reinitialized,
        either due to a user reload of the page, or a decision within the
        application to reload itself (perhaps to update to a new version), it
        is possible to keep an existing session alive via a process called
        "rehydration".</t>

        <t>With rehydration, the current signaling state
        is persisted somewhere outside of the page, perhaps on the application
        server, or in browser local storage. The page is then reloaded, and a
        new session object is created in Javascript. The saved signaling state
        is now retrieved, and a new PeerConnection object is created for the 
        session. At this point a new offer can be generated by the new PeerConnection,
        with new ICE and SDES credentials. This can then be used to re-initiate the
        session with the existing remote endpoint, who simply sees the new offer as
        an in-call renegotiation, and will reply with an answer that can be supplied to
        setRemoteDescription. ICE processing proceeds as usual, and as soon as
        connectivity is established, the session will be back up and running
        again.</t>

        <t>Open Issue: EKR proposed an alternative rehydration approach where
        the actual internal PeerConnection object in the browser was kept
        alive for some time after the web page was killed and provided some
        way for a new page to acquire the old PeerConnection object.</t>
      </section>
    </section>

    <section title="Interface">
      <t>This section details the basic operations that must be present to
      implement JSEP functionality. The actual API exposed in the W3C API may
      have somewhat different syntax, but should map easily to these
      concepts.</t>

      <section title="SDP Requirements">
        <t>Note: The text in this section may not represent working group
        consensus and is put here so that the working group can discuss it and
        find out how to change it such that it does have consensus.</t>

        <t>When generating SDP blobs, either for offers or answers, the generated SDP
        needs to conform to the following specifications. Similarly, in order to properly process
        received SDP blobs, implementations need to implement the
        functionality described in the following specifications. 
        This list is derived from <xref
        target="I-D.ietf-rtcweb-rtp-usage"></xref>.
        <list>
            <!-- TODO - fix the refs in here -->

            <t>RFC4566 is the base SDP specification and MUST be
            implemented.</t>

            <t>RFC5124 MUST be supported for signaling RTP/SAVPF RTP
            profile.</t>

            <t>RFC5104 MUST be implemented to signal RTCP based feedback.</t>

            <t>RFC5761 MUST be implemented to signal multiplexing of RTP and
            RTCP.</t>

            <t>RFC5245 MUST be implemented for signaling the ICE candidate
            lines corresponding to each media stream.</t>

            <t>RFC3264 MUST be implemented to signal information about media
            direction.</t>

            <t>The RFC5888 grouping framework MUST be implemented for
            signaling the grouping information.</t>

            <t>RFC5506 MAY be implemented to signal Reduced-Size RTCP
            messages.</t>

            <t>RFC5576 MAY be implemented to signal RTP SSRC values.</t>

            <t>RFC3556 with bandwidth modifiers MAY be supported for
            specifying RTCP bandwidth as a fraction of the media bandwidth,
            RTCP fraction allocated to the senders and setting maximum media
            bit-rate boundaries.</t>
          </list></t>

       <t>As required by RFC 4566 Section 5.13 JSEP implementations MUST
	  ignore unknown attributes (a=) lines.
       </t>
        <t>Example SDP for RTCWeb call flows can be found in <xref
        target="I-D.nandakumar-rtcweb-sdp"></xref>.</t>
      </section>

      <section title="Methods">
        <section title="createOffer">
          <t>The createOffer method generates a blob of SDP that contains a
          RFC 3264 offer with the supported configurations for the session,
          including descriptions of the local MediaStreams attached to this
          PeerConnection, the codec/RTP/RTCP options supported by this
          implementation, and any candidates that have been gathered by the
          ICE Agent. A constraints parameters may be supplied to provide
          additional control over the generated offer, e.g. to get a full set
          of session capabilities, or to request a new set of ICE
          credentials.</t>

          <t>In the initial offer, the generated SDP will contain all desired
          functionality for the session (certain parts that are supported but
          not desired by default may be omitted); for each SDP line, the
          generation of the SDP must follow the appropriate process for
          generating an offer. In the event createOffer is called after the
          session is established, createOffer will generate an offer that is
          compatible with the current session, incorporating any changes that
          have been made to the session since the last complete offer-answer
          exchange, such as addition or removal of streams. If no changes have
          been made, the offer will be identical to the current local
          description.</t>

          <t>Session descriptions generated by createOffer must be immediately
          usable by setLocalDescription; if a system has limited resources
          (e.g. a finite number of decoders), createOffer should return an
          offer that reflects the current state of the system, so that
          setLocalDescription will succeed when it attempts to acquire those
          resources. Because this method may need to inspect the system state
          to determine the currently available resources, it may be
          implemented as an async operation.</t>

          <t>Calling this method may do things such as generate new ICE
          credentials, but does not change media state.</t>
        </section>

        <section title="createAnswer">
          <t>The createAnswer method generates a blob of SDP that contains a
          RFC 3264 SDP answer with the supported configuration for the session
          that is compatible with the parameters supplied in the offer. Like
          createOffer, the returned blob contains descriptions of the local
          MediaStreams attached to this PeerConnection, the codec/RTP/RTCP
          options negotiated for this session, and any candidates that have
          been gathered by the ICE Agent. A constraints parameter may be
          supplied to provide additional control over the generated
          answer.</t>

          <t>As an answer, the generated SDP will contain a specific
          configuration that specifies how the media plane should be
          established.</t>

          <t>Session descriptions generated by createAnswer must be
          immediately usable by setLocalDescription; like createOffer, the
          returned description should reflect the current state of the system.
          Because this method may need to inspect the system state to
          determine the currently available resources, it may need to be
          implemented as an async operation.</t>

          <t>Calling this method may do things such as generate new ICE
          credentials, but does not change media state.</t>
        </section>

        <section title="SessionDescriptionType">
          <t>Session description objects (RTCSessionDescription)
	  may be of type "offer", "pranswer", and "answer".
	  These types
          provide information as to how the description parameter should be
          parsed, and how the media state should be changed.</t>

          <t>"offer" indicates that a description should be parsed as an
          offer; said description may include many possible media
          configurations. A description used as an "offer" may be applied
          anytime the PeerConnection is in a stable state, or as an update to
          a previously sent but unanswered "offer".</t>

          <t>"pranswer" indicates that a description should be parsed as an
          answer, but not a final answer, and so should not result in the
          freeing of allocated resources. It may result in the start of media
          transmission, if the answer does not specify an inactive media
          direction. A description used as a "pranswer" may be applied as a
          response to an "offer", or an update to a previously sent
          "answer".</t>

          <t>"answer" indicates that a description should be parsed as an
          answer, the offer-answer exchange should be considered complete, and
          any resources (decoders, candidates) that are no longer needed can
          be released. A description used as an "answer" may be applied as a
          response to a "offer", or an update to a previously sent
          "pranswer".</t>

          <t>The application can use some discretion on whether an answer
          should be applied as provisional or final. For example, in a serial
          forking scenario, an application may receive multiple "final"
          answers, one from each remote endpoint. The application could accept
          the initial answers as provisional answers, and only apply an answer
          as final when it receives one that meets its criteria (e.g. a live
          user instead of voicemail).</t>

          <section title="Creating Answers">
            <t>Most web applications will not need to create answers using the
            "pranswer" type. The general recommendation for a web application
            would be to create an answer more or less immediately after
            receiving the offer, instead of waiting for a human user to provide
            input. Later when the human input is received, the applications
            can create a new offer to update the previous offer/answer pair.
            Some applications may not be able to do this, particularly ones that
            Some application may not be able to do this, particular ones that
            are attempting to gateway to other signaling protocols.</t>

            <t>Consider a typical web application that will set up a data
            channel, an audio channel, and a video channel. When an endpoint
            receives an offer with these channels, it could send an answer accepting the
            data channel for two-way data, and accepting the audio and video
            tracks as receive-only. It could then ask the user if they wanted
            to transmit audio and video to the far end, acquire the local
            media streams, and send a new offer to the remote side moving the
            audio and video to be two-way media. By the time the human has
            authorized sending media, it is likely that the ICE and
            DTLS handshaking with the remote side will already be set up.</t>
          </section>
        </section>

        <section title="setLocalDescription">
          <t>The setLocalDescription method instructs the PeerConnection to
          apply the supplied SDP blob as its local configuration. The type
          field indicates whether the blob should be processed as an
          offer, provisional answer, or final answer; offers and answers are
          checked differently, using the various rules that exist for each SDP
          line.</t>

          <t>This API changes the local media state; among other things, it
          sets up local resources for receiving and decoding media. In order
          to successfully handle scenarios where the application wants to
          offer to change from one media format to a different, incompatible
          format, the PeerConnection must be able to simultaneously support
          use of both the old and new local descriptions (e.g. support codecs
          that exist in both descriptions) until a final answer is received,
          at which point the PeerConnection can fully adopt the new local
          description, or roll back to the old description if the remote side
          denied the change.</t>

          <t>If setRemoteDescription was previous called with an offer, and
          setLocalDescription is called with an answer (provisional or final),
          and the media directions are compatible, this will result in the
          starting of media transmission.</t>
        </section>

        <section title="setRemoteDescription">
          <t>The setRemoteDescription method instructs the PeerConnection to
          apply the supplied SDP blob as the desired remote configuration. As
          in setLocalDescription, the type field of the indicates how the blob
          should be processed.</t>

          <t>This API changes the local media state; among other things, it
          sets up local resources for sending and encoding media.</t>

          <t>If setRemoteDescription was previous called with an offer, and
          setLocalDescription is called with an answer (provisional or final),
          and the media directions are compatible, this will result in the
          starting of media transmission.</t>
        </section>

        <section title="localDescription">
          <t>The localDescription method returns a copy of the current local
          configuration, i.e. what was most recently passed to
          setLocalDescription, plus any local candidates that have been
          generated by the ICE Agent.</t>

          <t>A null object will be returned if the local description has not
          yet been established.</t>
        </section>

        <section title="remoteDescription">
          <t>The remoteDescription method returns a copy of the current remote
          configuration, i.e. what was most recently passed to
          setRemoteDescription, plus any remote candidates that have been
          supplied via processIceMessage.</t>

          <t>A null object will be returned if the remote description has not
          yet been established.</t>
        </section>

        <section title="updateIce">
          <t>The updateIce method allows the configuration of the ICE Agent to
          be changed during the session, primarily for changing which types of
          local candidates are provided to the application and used for
          connectivity checks. A callee may initially configure the ICE Agent
          to use only relay candidates, to avoid leaking location information,
          but update this configuration to use all candidates once the call is
          accepted.</t>

          <t>Regardless of the configuration, the gathering process collects
          all available candidates, but excluded candidates will not be
          surfaced in onicecallback or used for connectivity checks.</t>

          <t>This call may result in a change to the state of the ICE Agent,
          and may result in a change to media state if it results in
          connectivity being established.</t>
        </section>

        <section title="addIceCandidate">
          <t>The addIceCandidate method provides a remote candidate to the ICE
          Agent, which will be added to the remote description. Connectivity
          checks will be sent to the new candidate.</t>

          <t>This call will result in a change to the state of the ICE Agent,
          and may result in a change to media state if it results in
          connectivity being established.</t>
        </section>
      </section>
    </section>

    <section title="Configurable SDP Parameters">
      <t>Note: This section is still very early and is likely to significantly
      change as we get a better understanding of the a) the use cases for this
      b) the implications at the protocol level c) feedback from implementors
      on what they can do.</t>

      <t>The following is a partial list of SDP parameters that an application
      may want to control, in either local or remote descriptions, using this
      API.</t>

      <t><list style="symbols">
          <t>remove or reorder codecs (m=)</t>

          <t>change codec attributes (a=fmtp; ptime)</t>

          <t>enable/disable BUNDLE (a=group)</t>

          <t>enable/disable RTCP mux (a=rtcp-mux)</t>

          <!--
            <t>remove or reorder SRTP crypto-suites (a=crypto)</t>

            <t>change SRTP parameters or keys (a=crypto)</t>
           -->

          <t>change send resolution or framerate (TBD)</t>

          <t>change desired recv resolution or framerate (TBD)</t>

          <t>change total bandwidth (b=)</t>

          <t>remove desired AVPF mechanisms (a=rtcp-fb)</t>

          <t>remove RTP header extensions (a=rtphdr-ext)</t>

          <t>add/change SSRC grouping (e.g. FID, RTX, etc) (a=ssrc-group)</t>

          <t>add SSRC attributes (a=ssrc)</t>

          <t>change media send/recv state (a=sendonly/recvonly/inactive)</t>
        </list></t>

      <t>For example, an application could implement call hold by adding an
      a=inactive attribute to its local description, and then applying and
      signaling that description.</t>
    </section>

    <section title="Security Considerations">
      <t>TODO</t>
    </section>

    <section title="IANA Considerations">
      <t>This document requires no actions from IANA.</t>
    </section>

    <section title="Acknowledgements">
      <t>
        <!-- ACK 1 -->
        Harald Alvestrand, Dan Burnett, Neil Stratford, Eric
        Rescorla, Anant Narayanan, 
        <!-- ACK 2 -->
        
        <!-- ACK 3 -->
        
        <!-- ACK 4 -->
        
        and Adam Bergkvist all provided valuable feedback on this proposal.
        
        <!-- ACK 5 -->
        
        Suhas Nandakumar provided text and input for SDP requirements.
        
        <!-- ACK 5a -->
        
        <!-- ACK 5b -->
        
        <!-- ACK 5c --> 
        
        Matthew Kaufman provided the observation
        that keeping state out of the browser allows a call to continue even if
        the page is reloaded.
        <!-- ACK 6 -->
        
        <!-- ACK 7 -->
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <!-- NORM 1 -->

      <!-- NORM 2 -->

      <!-- NORM 3 -->

      <!-- NORM 4 -->

      <!-- NORM 5 -->

      <!-- NORM 6 -->

      <!-- NORM 7 -->

      <!-- NORM 8 -->

      <!-- NORM 9 -->

      <!-- NORM 10 -->

      <!-- NORM 11 -->

      <!-- NORM 12 -->

      <!-- NORM 13 -->

      <!-- NORM 14 -->

      <!-- NORM 15 -->

      <!-- NORM 16 -->

      <!-- NORM 17 -->

      <!-- NORM 18 -->

      <reference anchor="I-D.rescorla-mmusic-ice-trickle">
        <front>
          <title>Trickle ICE: Incremental Provisioning of Candidates for the
          Interactive Connectivity Establishment (ICE) Protocol</title>

          <author fullname="Eric Rescorla" initials="E" surname="Rescorla">
            <organization></organization>
          </author>

          <author fullname="Justin Uberti" initials="J" surname="Uberti">
            <organization></organization>
          </author>

          <author fullname="Emil Ivov" initials="E" surname="Ivov">
            <organization></organization>
          </author>

          <date day="10" month="October" year="2012" />

          <abstract>
            <t>This document describes an extension to the Interactive
            Connectivity Establishment (ICE) protocol that allows ICE agents
            to send and receive candidates incrementally rather than
            exchanging complete lists. With such incremental provisioning, ICE
            agents can begin connectivity checks while they are still
            gathering candidates and considerably shorten the time necessary
            for ICE processing to complete. The above mechanism is also
            referred to as "trickle ICE".</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-rescorla-mmusic-ice-trickle-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-rescorla-mmusic-ice-trickle-00.txt"
                type="TXT" />
      </reference>

      <!-- NORM 19 -->

      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>- +1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997" />

          <area>General</area>

          <keyword>keyword</keyword>
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />

        <format octets="4723"
                target="http://www.rfc-editor.org/rfc/rfc2119.txt" type="TXT" />

        <format octets="17491"
                target="http://xml.resource.org/public/rfc/html/rfc2119.html"
                type="HTML" />

        <format octets="5777"
                target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
                type="XML" />
      </reference>

      <reference anchor="RFC3264">
        <front>
          <title>An Offer/Answer Model with Session Description Protocol
          (SDP)</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3264" />

        <format octets="60854"
                target="http://www.rfc-editor.org/rfc/rfc3264.txt" type="TXT" />
      </reference>

      <reference anchor="RFC4566">
        <front>
          <title>SDP: Session Description Protocol</title>

          <author fullname="M. Handley" initials="M." surname="Handley">
            <organization></organization>
          </author>

          <author fullname="V. Jacobson" initials="V." surname="Jacobson">
            <organization></organization>
          </author>

          <author fullname="C. Perkins" initials="C." surname="Perkins">
            <organization></organization>
          </author>

          <date month="July" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4566" />

        <format octets="108820"
                target="http://www.rfc-editor.org/rfc/rfc4566.txt" type="TXT" />
      </reference>
    </references>

    <references title="Informative References">
      <!-- INFORM 1 -->


<reference anchor='I-D.ietf-rtcweb-rtp-usage'>
<front>
<title>Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</title>

<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>

<author initials='M' surname='Westerlund' fullname='Magnus Westerlund'>
    <organization />
</author>

<author initials='J' surname='Ott' fullname='Joerg Ott'>
    <organization />
</author>

<date month='July' day='16' year='2012' />

<abstract><t>The Web Real-Time Communication (WebRTC) framework provides support for direct interactive rich communication using audio, video, text, collaboration, games, etc. between two peers' web-browsers.  This memo describes the media transport aspects of the WebRTC framework. It specifies how the Real-time Transport Protocol (RTP) is used in the WebRTC context, and gives requirements for which RTP features, profiles, and extensions need to be supported.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-rtp-usage-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-rtp-usage-04.txt' />
</reference>


      <!-- INFORM 2 -->

      <!-- INFORM 3 -->

      <!-- INFORM 4 -->

      <!-- INFORM 5 -->

      <!-- INFORM 6 -->

      <!-- INFORM 7 -->

      <!-- INFORM 8 -->

      <!-- INFORM 9 -->

      <!-- INFORM 10 -->

      <!-- INFORM 11 -->

      <!-- INFORM 12 -->

      <!-- INFORM 13 -->

      <!-- INFORM 14 -->

      <!-- INFORM 15 -->

      <reference anchor="I-D.jennings-rtcweb-signaling">
        <front>
          <title>RTCWeb Offer/Answer Protocol (ROAP)</title>

          <author fullname="Cullen Jennings" initials="C" surname="Jennings">
            <organization></organization>
          </author>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="Randell Jesup" initials="R" surname="Jesup">
            <organization></organization>
          </author>

          <date day="30" month="October" year="2011" />

          <abstract>
            <t>This document describes an protocol used to negotiate media
            between browsers or other compatible devices. This protocol
            provides the state machinery needed to implement the offer/answer
            model (RFC 3264), and defines the semantics and necessary
            attributes of messages that must be exchanged. The protocol uses
            an abstract transport in that it does not actually define how
            these messages are exchanged. Rather, such exchanges are handled
            through web-based transports like HTTP or WebSockets. The protocol
            focuses solely on media negotiation and does not handle call
            control, call processing, or other functions.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-jennings-rtcweb-signaling-01" />

        <format target="http://www.ietf.org/internet-drafts/draft-jennings-rtcweb-signaling-01.txt"
                type="TXT" />

        <format target="http://www.ietf.org/internet-drafts/draft-jennings-rtcweb-signaling-01.pdf"
                type="PDF" />
      </reference>

      <!-- INFORM 16 -->

      <reference anchor="I-D.nandakumar-rtcweb-sdp">
        <front>
          <title>SDP for the WebRTC</title>

          <author fullname="Suhas Nandakumar" initials="S"
                  surname="Nandakumar">
            <organization></organization>
          </author>

          <author fullname="Cullen Jennings" initials="C" surname="Jennings">
            <organization></organization>
          </author>

          <date day="15" month="October" year="2012" />

          <abstract>
            <t>The Web Real-Time Communication (WebRTC) [WEBRTC] working group
            is charged to provide protocol support for direct interactive rich
            communication using audio, video and data between two peers' web
            browsers. With in the WebRTC framework, Session Description
            protocol (SDP) [RFC4566] is used for negotiating session
            capabilities between the peers. Such a negotiataion happens based
            on the SDP Offer/Answer exchange mechanism described in the RFC
            3264 [RFC3264]. This document serves a introductory purpose in
            describing the role of SDP for the most common WebRTC
            use-cases.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-nandakumar-rtcweb-sdp-00" />

        <format target="http://www.ietf.org/internet-drafts/draft-nandakumar-rtcweb-sdp-00.txt"
                type="TXT" />
      </reference>

      <!-- INFORM 17 -->

      <reference anchor="RFC4568">
        <front>
          <title>Session Description Protocol (SDP) Security Descriptions for
          Media Streams</title>

          <author fullname="F. Andreasen" initials="F." surname="Andreasen">
            <organization></organization>
          </author>

          <author fullname="M. Baugher" initials="M." surname="Baugher">
            <organization></organization>
          </author>

          <author fullname="D. Wing" initials="D." surname="Wing">
            <organization></organization>
          </author>

          <date month="July" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4568" />

        <format octets="107881"
                target="http://www.rfc-editor.org/rfc/rfc4568.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5245">
        <front>
          <title>Interactive Connectivity Establishment (ICE): A Protocol for
          Network Address Translator (NAT) Traversal for Offer/Answer
          Protocols</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <date month="April" year="2010" />
        </front>

        <seriesInfo name="RFC" value="5245" />

        <format octets="285120"
                target="http://www.rfc-editor.org/rfc/rfc5245.txt" type="TXT" />
      </reference>

      <reference anchor="W3C.WD-webrtc-20111027"
                 target="http://www.w3.org/TR/2011/WD-webrtc-20111027">
        <front>
          <title>WebRTC 1.0: Real-time Communication Between Browsers</title>

          <author fullname="Adam Bergkvist" initials="A." surname="Bergkvist">
            <organization></organization>
          </author>

          <author fullname="Daniel C. Burnett" initials="D." surname="Burnett">
            <organization></organization>
          </author>

          <author fullname="Anant Narayanan" initials="A." surname="Narayanan">
            <organization></organization>
          </author>

          <author fullname="Cullen Jennings" initials="C." surname="Jennings">
            <organization></organization>
          </author>

          <date day="27" month="October" year="2011" />
        </front>

        <seriesInfo name="World Wide Web Consortium WD"
                    value="WD-webrtc-20111027" />

        <format target="http://www.w3.org/TR/2011/WD-webrtc-20111027"
                type="HTML" />
      </reference>
    </references>

    <section title="JSEP Implementation Examples">
      <section title="Example API Flows">
        <t>Below are several sample flows for the new PeerConnection and
        library APIs, demonstrating when the various APIs are called in
        different situations and with various transport protocols. For clarity
        and simplicity, the createOffer/createAnswer calls are assumed to be
        synchronous in these examples, whereas the actual APIs are async.</t>

        <section title="Call using ROAP">
          <t>This example demonstrates a ROAP call, without the use of trickle
          candidates. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   iceCallback(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  {"type":"OFFER", "sdp":offer }

// OFFER arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", msg.sdp);
AnswererUA->AnswererJS: onaddstream(remoteStream);
AnswererUA->OffererUA:  iceCallback(candidate);

// Answerer accepts call
AnswererJS->AnswererUA: peer.addStream(localStream, null);
AnswererJS->AnswererUA: answer = peer.createAnswer(msg.sdp, null);
AnswererJS->AnswererUA: peer.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  {"type":"ANSWER","sdp":answer }

// ANSWER arrives at Offerer
OffererJS->OffererUA:   peer.setRemoteDescription("answer", answer); 
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Answerer)
AnswererUA->AnswererJS: onopen();
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->OffererJS:   onopen();
OffererJS->AnswererJS:  {"type":"OK" }
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Call using XMPP">
          <t>This example demonstrates an XMPP call, making use of trickle
          candidates. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              xmpp = createSessionInitiate(offer);
OffererJS->AnswererJS:  <jingle action="session-initiate"/>

OffererJS->OffererUA:   pc.startIce();
OffererUA->OffererJS:   onicecandidate(cand);
OffererJS:              createTransportInfo(cand);
OffererJS->AnswererJS:  <jingle action="transport-info"/>

// session-initiate arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS:             offer = parseSessionInitiate(xmpp);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererUA->AnswererJS: onaddstream(remoteStream);

// transport-infos arrive at Answerer
AnswererJS->AnswererUA: candidate = parseTransportInfo(xmpp);
AnswererJS->AnswererUA: pc.addIceCandidate(candidate);
AnswererUA->AnswererJS: onicecandidate(cand)
AnswererJS:             createTransportInfo(cand);
AnswererJS->OffererJS:  <jingle action="transport-info"/>

// transport-infos arrive at Offerer
OffererJS->OffererUA:   candidates = parseTransportInfo(xmpp);
OffererJS->OffererUA:   pc.addIceCandidate(candidates);

// Answerer accepts call
AnswererJS->AnswererUA: peer.addStream(localStream, null);
AnswererJS->AnswererUA: answer = peer.createAnswer(offer, null);
AnswererJS:             xmpp = createSessionAccept(answer);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  <jingle action="session-accept"/>

// session-accept arrives at Offerer
OffererJS:              answer = parseSessionAccept(xmpp);
OffererJS->OffererUA:   peer.setRemoteDescription("answer", answer); 
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Answerer)
AnswererUA->AnswererJS: onopen();
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->OffererJS:   onopen();
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Adding video to a call, using XMPP">
          <t>This example demonstrates an XMPP call, where the XMPP
          content-add mechanism is used to add video media to an existing
          session. For simplicity, candidate exchange is not shown.</t>

          <t>Note that the offerer for the change to the session may be
          different than the original call offerer. <figure>
              <artwork><![CDATA[
// Offerer adds video stream
OffererJS->OffererUA:   pc.addStream(videoStream)
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS:              xmpp = createContentAdd(offer);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  <jingle action="content-add"/>

// content-add arrives at Answerer
AnswererJS:             offer = parseContentAdd(xmpp);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS:             xmpp = createContentAccept(answer);
AnswererJS->OffererJS:  <jingle action="content-accept"/>

// content-accept arrives at Offerer
OffererJS:              answer = parseContentAccept(xmpp);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
]]></artwork>
            </figure></t>
        </section>

        <section title="Simultaneous add of video streams, using XMPP">
          <t>This example demonstrates an XMPP call, where new video sources
          are added at the same time to a call that already has video; since
          adding these sources only affects one side of the call, there is no
          conflict. The XMPP description-info mechanism is used to indicate
          the new sources to the remote side. <figure>
              <artwork><![CDATA[
// Offerer and "Answerer" add video streams at the same time
OffererJS->OffererUA:   pc.addStream(offererVideoStream2)
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS:              xmpp = createDescriptionInfo(offer);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  <jingle action="description-info"/>

AnswererJS->AnswererUA: pc.addStream(answererVideoStream2)
AnswererJS->AnswererUA: offer = pc.createOffer(null);
AnswererJS:             xmpp = createDescriptionInfo(offer);
AnswererJS->AnswererUA: pc.setLocalDescription("offer", offer);
AnswererJS->OffererJS:  <jingle action="description-info"/>

// description-info arrives at "Answerer", and is acked
AnswererJS:             offer = parseDescriptionInfo(xmpp);
AnswererJS->OffererJS:  <iq type="result"/>  // ack

// description-info arrives at Offerer, and is acked
OffererJS:              offer = parseDescriptionInfo(xmpp);
OffererJS->AnswererJS:  <iq type="result"/>  // ack

// ack arrives at Offerer; remote offer is used as an answer
OffererJS->OffererUA:   pc.setRemoteDescription("answer", offer);

// ack arrives at "Answerer"; remote offer is used as an answer
AnswererJS->AnswererUA: pc.setRemoteDescription("answer", offer);
]]></artwork>
            </figure></t>
        </section>

        <section title="Call using SIP">
          <t>This example demonstrates a simple SIP call (e.g. where the
          client talks to a SIP proxy over WebSockets). <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   onicecandidate(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              sip = createInvite(offer);
OffererJS->AnswererJS:  SIP INVITE w/ SDP

// INVITE arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS:             offer = parseInvite(sip);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererUA->AnswererJS: onaddstream(remoteStream);
AnswererUA->OffererUA:  onicecandidate(candidate);

// Answerer accepts call
AnswererJS->AnswererUA: peer.addStream(localStream, null);
AnswererJS->AnswererUA: answer = peer.createAnswer(offer, null);
AnswererJS:             sip = createResponse(200, answer);
AnswererJS->AnswererUA: peer.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  200 OK w/ SDP

// 200 OK arrives at Offerer
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   peer.setRemoteDescription("answer", answer); 
OffererUA->OffererJS:   onaddstream(remoteStream);
OffererJS->AnswererJS:  ACK

// ICE Completes (at Answerer)
AnswererUA->AnswererJS: onopen();
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->OffererJS:   onopen();
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling early media (e.g. 1-800-GO FEDEX), using SIP">
          <t>This example demonstrates how early media could be handled; for
          simplicity, only the offerer side of the call is shown. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   onicecandidate(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              sip = createInvite(offer);
OffererJS->AnswererJS:  SIP INVITE w/ SDP

// 180 Ringing is received by offerer, w/ SDP
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("pranswer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Offerer)
OffererUA->OffererJS:   onopen();
OffererUA->AnswererUA:  Media

// 200 OK arrives at Offerer
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererJS->AnswererJS:  ACK
]]></artwork>
            </figure></t>
        </section>
      </section>
    </section>

    <section title="Change log">
      <t>Changes in draft -02: <list style="symbols">
          <!-- A -->

          <t>Converted from nroff</t>

          <!-- B -->

          <t>Removed comparisons to old approaches abandoned by the working
          group</t>

          <!-- C -->

          <t>Removed stuff that has moved to W3C specificaiton</t>

          <!-- D -->

          <t>Align SDP handling with W3C draft</t>

          <!-- E -->

          <t>Clarified section on forking.</t>

          <!-- F -->

          <!-- G -->

          <!-- H -->

          <!-- I -->

          <!-- J -->

          <!-- K -->

          <!-- L -->
        </list></t>

      <t>Changes in draft -01: <list style="symbols">
          <t>Added diagrams for architecture and state machine.</t>

          <t>Added sections on forking and rehydration.</t>

          <t>Clarified meaning of "pranswer" and "answer".</t>

          <t>Reworked how ICE restarts and media directions are
          controlled.</t>

          <t>Added list of parameters that can be changed in a
          description.</t>

          <t>Updated suggested API and examples to match latest thinking.</t>

          <t>Suggested API and examples have been moved to an appendix.</t>
        </list></t>

      <t>Changes in draft -00: <list style="symbols">
          <t>Migrated from draft-uberti-rtcweb-jsep-02.</t>
        </list></t>
    </section>
  </back>
</rfc>
