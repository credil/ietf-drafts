<?xml version="1.0"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<rfc ipr="trust200902" docName="draft-laurie-pki-sunlight-05" category="exp">
  <front>
    <title>Certificate Transparency</title>
    <author initials="B" surname="Laurie" fullname="Ben Laurie">
      <address>
	<email>benl@google.com</email>
      </address>
    </author>
    <author initials="A" surname="Langley" fullname="Adam Langley">
      <address>
	<email>agl@google.com</email>
      </address>
    </author>
    <author initials="E" surname="Kasper" fullname="Emilia Kasper">
      <address>
	<email>ekasper@google.com</email>
      </address>
    </author>
    <date year='2012'></date>
    <abstract>
      <t>
	The aim of Certificate Transparency is to have every public end-entity (for example, web servers) and intermediate TLS certificate issued by a known Certificate Authority recorded in one or more certificate logs. In order to detect misissuance of certificates, all logs are publicly auditable. In particular, domain owners or their agents will be able to monitor logs for certificates issued on their own domain.
      </t>
      <t>
	To protect clients from unlogged misissued certificates, each log signs all certificates it records, and clients can choose not to trust certificates that are not accompanied by an appropriate log signature. For privacy and performance reasons log signatures are embedded in the TLS handshake via the TLS authorization extension, in a stapled OCSP extension, or in the certificate itself via an X.509v3 certificate extension.
      </t>
      <t>
	To ensure a globally consistent view of any particular log, each log also provides a global signature over the entire log. Any inconsistency of logs can be detected through cross-checks on the global signature. Consistency between any pair of global signatures, corresponding to snapshots of a particular log at different times, can be efficiently shown.
      </t>
      <t>
	Logs are only expected to certify that they have seen a certificate, and thus we do not specify any revocation mechanism for log signatures in this document. Logs are append-only, and log signatures do not expire. 
      </t>
    </abstract>
    <note title="Requirements Language">
      <t>
	The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
      </t>
  </note>
  </front>
  <middle>
    <section title="Informal introduction">
      <t>
        Certificate Transparency aims to mitigate the problem of misissued certificates by providing publicly auditable, append-only, untrusted logs of all issued certificates. The logs are publicly auditable so that it is possible for anyone to verify the correct operation of each log, and to monitor when new certificates are added to it. The logs do not themselves prevent misissue, but they ensure that interested parties (particularly those named in certificates) can detect such misissuance. Note that this is a general mechanism, but in this document we only describe its use for public TLS server certificates issued by public CAs.
      </t>
      <t>
        Each log consists of certificate chains, which can be submitted by anyone. It is expected that public CAs will contribute all their newly-issued certificates to one or more logs; it is also expected that certificate holders will contribute their own certificate chains. In order to avoid logs being spammed into uselessness, it is required that each chain is rooted in a known CA certificate. When a chain is submitted to a log, a signed timestamp is returned, which can later be used to provide evidence to clients that the chain has been submitted. Clients can thus require that all certificates they see have been logged.
      </t>
      <t>
        Those who are concerned about misissue can monitor the logs, asking them regularly for all new entries, and can thus check whether domains they are responsible for have had certificates issued that they did not expect. What they do with this information, particularly when they find that a misissuance has happened, is beyond the scope of this document, but broadly speaking they can invoke existing business mechanisms for dealing with misissued certificates. Of course, anyone who wants can monitor the logs, and if they believe a certificate is incorrectly issued, take action as they see fit.
      </t>
      <t>
        Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors' copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow TLS connections to proceed without delay, despite network connectivity issues and the vagaries of firewalls.
      </t>
      <t>
        The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular version of the log is a superset of any particular previous version. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviours of any log (e.g. issuing signed timestamps for certificates they then don't log) can be efficiently detected and proved to the world at large.
      </t>
    </section>
    <section title="Cryptographic components">
      <section title="Merkle Hash Trees">
	<t>
	  Logs use a binary Merkle hash tree for efficient auditing. The hashing algorithm is SHA-256 (note that this is fixed for this experiment but it is anticipated that each log would be able to specify a hash algorithm). The input to the Merkle tree hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle hash tree. The output is a single 32-byte root hash. Given an ordered list of n inputs, D[n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH) is thus defined as follows:
	</t>
	<t>
	  The hash of an empty list is the hash of an empty string:
	  <vspace blankLines='1' />
	  MTH({}) = SHA-256().
	  <vspace blankLines='1' />
	  The hash of a list with one entry is:
	  <vspace blankLines='1' />
	  MTH({d(0)}) = SHA-256(0x00 || d(0)).
	  <vspace blankLines='1' />
	  For n &gt; 1, let k be the largest power of two smaller than n. The Merkle Tree Hash of an n-element list D[n] is then defined recursively as
	  <vspace blankLines='1' />
	  MTH(D[n]) = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
	  <vspace blankLines='1' />
	  where || is concatenation and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)}. (Note that the hash calculation for leaves and nodes differ. This domain separation is required to give second preimage resistance.)
	</t>
	<t>
	  Note that we do not require the length of the input list to be a power of two. The resulting Merkle tree may thus not be balanced, however, its shape is uniquely determined by the number of leaves. [This Merkle tree is essentially the same as the <eref target='http://tamperevident.cs.rice.edu/Logging.html'>history tree</eref> proposal, except our definition omits dummy leaves.]
	</t>
      <section title="Merkle audit paths" anchor='merkle_paths'>
	<t>
	  A Merkle audit path for a leaf in a Merkle hash tree is the shortest list of additional nodes in the Merkle tree required to compute the Merkle Tree Hash for that tree. Each node in the tree is either a leaf node, or is computed from the two nodes immediately below it (i.e. towards the leaves). At each step up the tree (towards the root), a node from the audit path is combined with the node computed so far. In other words, the audit path consists of the list of missing nodes required to compute the nodes leading from a leaf to the root of the tree. If the root computed from the audit path matches the true root, then the audit path is proof that the leaf exists in the tree.
	</t>
	<t> Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle audit path PATH(m, D[n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
	</t>
	<t>
	  The path for the single leaf in a tree with a one-element input list D[1] = {d(0)} is empty:
	  <vspace blankLines='1' />
	  PATH(0, {d(0)}) = {}
	  <vspace blankLines='1' />
	  For n &gt; 1, let k be the largest power of two smaller than n. The path for the (m+1)th element d(m) in a list of n &gt; m elements is then defined recursively as
	  <vspace blankLines='1' />
	  PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
	  <vspace blankLines='1' />
	  PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m &ge; k,
	  <vspace blankLines='1' />
	  where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
	</t>
      </section>

      <section title="Merkle consistency proofs" anchor='consistency'>
	<t>
	  Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof. 
	</t>
	<t> Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous root hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as PROOF(m, D[n]) = SUBPROOF(m, D[n], true):
	</t>
	<t>
	  The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree root hash MTH(D[0:m]) is known):
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[m], true) = {}
	  <vspace blankLines='1' />
 	  The subproof for m = n is the root hash committing inputs D[0:m] otherwise:
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[m], false) = {MTH(D[m])}
	  <vspace blankLines='1' />    
	  For m &lt; n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
	  <vspace blankLines='1' />
If m &le; k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n]).
	  <vspace blankLines='1' />
If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
	  <vspace blankLines='1' />
	  SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k]).
	  <vspace blankLines='1' />
	  Here : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
	</t>
	<t>
	  The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
	</t>
      </section>

	<section title="Example">
	  <t>
	    The binary Merkle tree with 7 leaves:
<figure>
<artwork>    
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \ 
   /     \        /     \    
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6       
 | |     | |    | |                               
d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
	  </t>
	  <t>
	    The audit path for d0 is [b, h, l].
	  </t>
	  <t>
	    The audit path for d3 is [c, g, l].
	  </t>
	  <t>
	    The audit path for d4 is [f, j, k].
	  </t>
	  <t>
	    The audit path for d6 is [i, k].
	  </t>
	  <t>
	    The same tree, built incrementally in four steps:
<figure>
<artwork>    
    hash0          hash1=k 
    / \              /  \  
   /   \            /    \ 
  /     \          /      \ 
  g      c         g       h 
 / \     |        / \     / \ 
 a b     d2       a b     c d 
 | |              | |     | |                   
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \    
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6       
| |     | |             | |     | |    | |                               
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5    
</artwork>
</figure>
	  </t>
	  <t>
	    The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to show hash is consistent with hash0.
	  </t>
	  <t>
	    The consistency proof between hash1 and hash is PROOF(4, D[7]) = [l]. hash can be verified, using hash1=k and l.
	  </t>
	  <t>
	    The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i, j, k]. k, i are used to verify hash2, and j is additionally used to show hash is consistent with hash2.
	  </t>
	</section>
	<section title="Signatures">
	  <t>
	    Various data structures are signed. A log can use either elliptic curve signatures using the NIST P-256 curve (section D.1.2.3 of <xref target="DSS">DSS</xref>) or RSA signatures using a key of at least 2048 bits.
	  </t>
	</section>
      </section>
    </section>
    <section title="Log Format">
      <t>
	Anyone can submit certificates to certificate logs for public auditing, however, since certificates will not be accepted by clients unless logged, it is expected that certificate owners or their CAs will usually submit them. A log is a single, ever-growing, append-only Merkle Tree of such certificates.
      </t>
      <t>
	When a valid certificate is submitted to a log, the log MUST immediately return a Signed Certificate Timestamp (SCT). The SCT is the log's promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). If the log has previously seen the certificate, it MAY return the same SCT as it returned before. TLS servers MUST present an SCT from one or more logs to the client together with the certificate. TLS clients MUST reject certificates that do not have a valid SCT for the end-entity certificate.
      </t>
      <t>
	Periodically, each log appends all its new entries to the Merkle Tree, and signs the root of the tree. Clients and auditors can thus verify that each certificate for which an SCT has been issued indeed appears in the log. The log MUST incorporate a certificate in its Merkle Tree within the Maximum Merge Delay period after the issuance of the SCT.
      </t>
      <t>
	Logs MUST NOT impose any conditions on copying data retrieved from the log.
      </t>
      <section title="Log Entries">
	<t>
	  Anyone can submit a certificate to any log. In order to enable attribution of each logged certificate to its issuer, the log SHALL publish a list of acceptable root certificates (this list might usefully be the union of root certificates trusted by major browser vendors). Each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The root certificate itself MAY be omitted from this list. 
	</t>
        <t>
	  Alternatively, (root as well as intermediate) Certificate Authorities may submit a certificate to logs prior to issuance. To do so, a Certificate Authority constructs a Precertificate by adding a special critical poison extension (OID 1.3.6.1.4.1.11129.2.4.3, whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)) to the leaf TBSCertificate (this extension is to ensure that the Precertificate cannot be validated by a standard X.509v3 client), and signing the resulting TBSCertificate <xref target='RFC5280'/> with either
	  <list style="symbols">
	    <t>
	      a special-purpose (Extended Key Usage: Certificate Transparency, OID 1.3.6.1.4.1.11129.2.4.4) Precertificate Signing Certificate. The Precertificate Signing Certificate MUST be certified by the CA certificate that will ultimately sign the leaf TBSCertificate (note that the log may relax standard validation rules to allow this, so long as the final signed certificate will be valid),
	    </t>
	    <t>
	      or, the CA certificate that will sign the final certificate.
	    </t>
	  </list>
	  As above, the Precertificate submission MUST be accompanied by the Precertificate Signing Certificate, if used, and all additional certificates required to verify the chain up to an accepted root certificate. The signature on the TBSCertificate indicates the Certificate Authority's intent to issue a certificate. This intent is considered binding (i.e., misissuance of the Precertificate is considered equal to misissuance of the final certificate). Each log verifies the Precertificate signature chain, and issues a Signed Certificate Timestamp on the corresponding TBSCertificate.
	</t>
	<t>
	  Logs MUST verify that the submitted leaf certificate or Precertificate has a valid signature chain leading back to a trusted root CA certificate, using the chain of intermediate CA certificates provided by the submitter. In case of Precertificates, each log MUST also verify that the Precertificate Signing Certificate has the correct Extended Key Usage extension. Logs MAY accept certificates that have expired, are not yet valid, have been revoked or are otherwise not fully valid according to X.509 verification rules in order to accomodate quirks of CA certificate issuing software. However, logs MUST refuse to publish certificates without a valid chain to a known root CA. If a certificate is accepted and an SCT issued, the accepting log MUST store the chain used for verification including the certificate or Precertificate itself, and MUST present this chain for auditing upon request. This chain is required to prevent a CA avoiding blame by logging a partial or empty chain [Note: this effectively excludes self-signed and DANE-based certificates until some mechanism to control spam for those certificates is found - the authors welcome suggestions].
	</t>
	<t>
	  Each certificate entry in a log MUST include the following components:
	</t>
<figure>
  <artwork>
    enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;

    struct {
        LogEntryType entry_type;
        select (entry_type) {
            case x509_entry: X509ChainEntry;
            case precert_entry: PrecertChainEntry;
        } entry;
    } LogEntry;

    opaque ASN.1Cert&lt;1..2^24-1&gt;;

    struct {
        ASN.1Cert leaf_certificate;
        ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
    } X509ChainEntry;

    struct {
        ASN.1Cert tbs_certificate;
        ASN.1Cert precertificate_chain&lt;1..2^24-1&gt;;
    } PrecertChainEntry;
  </artwork>
</figure>
	<t>
	  Logs MAY limit the length of chain they will accept.
	</t>
	<t>
	  <spanx style="verb">entry_type</spanx> is the type of this entry. Future revisions of this protocol version may add new LogEntryType values. <xref target="client_messages"/> explains how clients should handle unknown entry types.
	</t>
	<t>
	  <spanx style="verb">leaf_certificate</spanx> is the end-entity certificate submitted for auditing.
	</t>
	<t>
	  <spanx style="verb">certificate_chain</spanx> is a chain of additional certificates required to verify the leaf certificate. The first certificate MUST certify the leaf certificate. Each following certificate MUST directly certify the one preceding it. The self-signed root certificate MAY be omitted from the chain.
	</t>
	<t>
	  <spanx style="verb">tbs_certificate</spanx> is the TBSCertificate component of the Precertificate (i.e., the original TBSCertificate, without the Precertificate signature and the SCT extension).
	</t>
	<t>
	  <spanx style="verb">precertificate_chain</spanx> is a chain of certificates required to verify the Precertificate submission. The first certificate MUST be the original Precertificate, with its unsigned part matching the <spanx style="verb">tbs_certificate</spanx>. The second certificate MUST be a valid Precertificate Signing Certificate, and MUST certify the first certificate. Each following certificate MUST directly certify the one preceding it. The self-signed root certificate MAY be omitted from the chain.
	</t>
	<t>
	  Structure of the Signed Certificate Timestamp:
	</t>
	<figure>
	  <artwork>
    enum { certificate_timestamp(0), tree_hash(1), 255 }
      SignatureType;

    enum { v1(0), 255 }
      Version;

      struct {
          opaque key_id[32];
      } LogID;

      opaque CtExtensions&lt;0..2^16-1&gt;;
	  </artwork>
	</figure>
	<t>
	  <spanx style="verb">key_id</spanx> is the SHA-256 hash of the log's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo.
	</t>
	<figure>
	  <artwork>
    struct {
        Version sct_version;
        LogID id;
        uint64 timestamp;
        CtExtensions extensions;
        digitally-signed struct {
            Version sct_version;
            SignatureType signature_type = certificate_timestamp;	    
            uint64 timestamp;
            LogEntryType entry_type;
            select(entry_type) {
                case x509_entry: ASN.1Cert;
                case precert_entry: ASN.1Cert;
            } signed_entry;
           CtExtensions extensions;
        };
    } SignedCertificateTimestamp;
	  </artwork>
	</figure>
	<t>
	  The encoding of the digitally-signed element is defined in <xref target='RFC5246'/>.
	</t>
	<t>
	  <spanx style="verb">sct_version</spanx> is the version of the protocol the SCT conforms to. This version is v1.
	</t>
	<t>
	  <spanx style="verb">timestamp</spanx> is the current UTC time since epoch (January 1, 1970, 00:00), in milliseconds.
	</t>
	<t>
	  <spanx style="verb">entry_type</spanx> may be implicit from the context in which the SCT is presented.
	</t>
	<t>
	  <spanx style="verb">signed_entry</spanx> is the <spanx style="verb">leaf_certificate</spanx> (in case of an X509ChainEntry), or <spanx style="verb">tbs_certificate</spanx> (in case of a PrecertChainEntry).
	</t>
        <t>
          <spanx style="verb">extensions</spanx> are future extensions to this protocol version (v1). Currently, no extensions are specified.
        </t>
      </section>

      <section title="Including the Signed Certificate Timestamp in the TLS Handshake">
	<t>
	The SCT data from at least one log must be included in the TLS handshake, either by using an Authorization Extension <xref target='RFC5878'/> with type 182, or by using OCSP Stapling (section 8 of <xref target='RFC6066'/>), where the response includes an OCSP extension with OID 1.3.6.1.4.1.11129.2.4.5 (see <xref target='RFC2560'/>) and body:
	</t>
	<figure>
	  <artwork>
    SignedCertificateTimestampList ::= OCTET STRING
	  </artwork>
	</figure>
	<t>
	  At least one SCT MUST be included. Server operators MAY include more than one SCT.
	</t>
	<t>
	  Similarly, a Certificate Authority MAY submit the precertificate to more than one log, and all obtained SCTs can be directly embedded in the final certificate, by encoding the SignedCertificateTimestampList structure as an ASN.1 OCTET STRING and inserting the resulting data in the TBSCertificate as an X.509v3 certificate extension (OID 1.3.6.1.4.1.11129.2.4.2). Upon receiving the certificate, clients can reconstruct the original TBSCertificate to verify the SCT signature.
	</t>
	<t>
	  The contents of the ASN.1 OCTET STRING embedded in an OCSP extension or X509v3 certificate extension are as follows:
	</t>
	<figure>
	  <artwork>
     opaque SerializedSCT&lt;1..2^16-1&gt;; 

     struct {
         SerializedSCT sct_list &lt;1..2^16-1&gt;;
     } SignedCertificateTimestampList;
	  </artwork>
	</figure>
        <t>
        Here <spanx style="verb">SerializedSCT</spanx> is an opaque bytestring that contains the serialized TLS structure. This encoding ensures that clients can decode each SCT individually (i.e., if there is a version upgrade, out of date clients can still parse old SCTs while skipping over new SCTs whose version they don't understand).
        </t>
	<t>
	  SCTs embedded in the TLS Authorization Extension are each encoded as an individual AuthorizationDataEntry <xref target='RFC5878'/>.
	</t>
      </section>
      <section title="Merkle Tree" anchor="tree">
	<t> Each certificate log MUST periodically append all its new log entries to the log Merkle Tree. The log MUST sign these entries by constructing a binary Merkle Tree with log entries as consecutive inputs to the tree, signing the corresponding Merkle Tree Hash, and publishing each update to the tree in a Signed Merkle Tree Update. The hashing algorithm for the Merkle Tree Hash is SHA-256.
	</t>
	<t>
	  Structure of the Merkle Tree input:
	</t>
<figure>
  <artwork>
    enum { timestamped_entry(0), 255 }
      MerkleLeafType;

    struct {
        uint64 timestamp;
        LogEntryType entry_type;
        select(entry_type) {
            case x509_entry: ASN.1Cert;
            case precert_entry: ASN.1Cert;
        } signed_entry;
        CtExtensions extensions;
    } TimestampedEntry;

    struct {
        Version version;
        MerkleLeafType leaf_type;
        select (leaf_type) {
            case timestamped_entry: TimestampedEntry;  
        }    
    } MerkleTreeLeaf;
  </artwork>
</figure>
        <t>
	  Here <spanx style="verb">version</spanx> is the version of the protocol the MerkleTreeLeaf corresponds to. This version is v1.
	</t>
	<t>
	  <spanx style="verb">leaf_type</spanx> is the type of the leaf input. Currently, only <spanx style="verb">timestamped_entry</spanx> (corresponding to an SCT) is defined. Future revisions of this protocol version may add new MerkleLeafType types. <xref target="client_messages"/> explains how clients should handle unknown leaf types.
	</t>
	<t>
	  <spanx style="verb">timestamp</spanx> is the timestamp of the corresponding SCT issued for this certificate.
	</t>
	<t>
	  <spanx style="verb">signed_entry</spanx> is the <spanx style="verb">signed_entry</spanx> of the corresponding SCT.
	</t>
	<t>
	  <spanx style="verb">extensions</spanx> are <spanx style="verb">extensions</spanx> of the corresponding SCT.
	</t>
	<t>
	  The leaves of the Merkle Tree are the hashes of the corresponding <spanx style="verb">MerkleTreeLeaf</spanx> structures.
	</t>
      </section>
      <section title="Tree Head Signature">
	<t>
        Every time a log appends new entries to the tree, the log MUST sign the corresponding tree hash and tree information (see also the corresponding Signed Tree Head client message in <xref target="fetch_sth"/>). The signature input is structured as follows:
	</t>
	<t>
<figure>
  <artwork>
    digitally-signed struct {
        Version version;
        SignatureType signature_type = tree_hash;
        uint64 timestamp;
        uint64 tree_size;
        opaque sha256_root_hash[32];
    } TreeHeadSignature;
  </artwork>
</figure>
	</t>
	<t>
	  <spanx style="verb">version</spanx> is the version of the protocol the TreeHeadSignature conforms to. This version is v1.
	</t>
	<t>
	  <spanx style="verb">timestamp</spanx> is the current time. The timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.
	</t>
	<t>
	  <spanx style="verb">tree_size</spanx> equals the number of entries in the new tree.
	</t>
	<t>
	  <spanx style="verb">sha256_root_hash</spanx> is the root of the Merkle Hash Tree.
	</t>
	<t>Each log MUST produce a Tree Head Signature at least as often as the Maximum Merge Delay. In the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
	</t>
      </section>
    </section>
    <section title="Client Messages" anchor="client_messages">
      <t>
	Messages are sent as HTTPS GET or POST requests. Parameters for POSTs and all responses are encoded as JSON objects. Parameters for GETs are encoded as URL parameters. Binary data is base64 encoded as specified in the individual messages.
      </t>
      <t>
	The &lt;log server&gt; prefix can include a path as well as a server name and a port. It must map one-to-one to a known public key (how this mapping is distributed is out of scope for this document).
      </t>
      <t>
	In general, where needed, the <spanx style="verb">version</spanx> is v1 and the <spanx style="verb">id</spanx> is the log id for the log server queried.
      </t>
      <section title="Add Chain to Log" anchor="sct">
	<t>
	  POST https://&lt;log server&gt;/ct/v1/add-chain
	</t>
	<t>
	  Inputs
	  <list style="hanging">
	    <t hangText="chain">
	      An array of base64 encoded certificates. The first element is the leaf certificate, the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
	    </t>
	  </list>
	</t>
	<t>
	  Outputs
	  <list style="hanging">
	    <t hangText="sct_version">
	      The version of the SignedCertificateTimestamp structure, in decimal. A compliant v1 implementation MUST NOT expect this to be 0 (i.e. v1).
	    </t>
	    <t hangText="id">
	      The log ID, base64 encoded. Since clients who request an SCT for inclusion in the TLS handshake are not required to verify it, we do not assume they know the ID of the log.
	    </t>
	    <t hangText="timestamp">
	      The SCT timestamp, in decimal.
	    </t>
	    <t hangText="extensions">
	      An opaque type for future expansion. It is likely that not all participants will need to understand data in this field. Logs should set this to the empty string. Clients should decode the base64 encoded data and include it in the SCT.
	    </t>
	    <t hangText="signature">
	      The SCT signature, base64 encoded.
	    </t>
	  </list>
	  If the <spanx style="verb">sct_version</spanx> is not v1, then a v1 client may be unable to verify the signature. It MUST NOT construe this as an error. [Note: log clients don't need to be able to verify this structure, only TLS clients do - if we were to serve the structure binary, then we could completely change it without requiring an upgrade to v1 clients].
	</t>
      </section>
      <section title="Add PreCertChain to Log">
	<t>
	  POST https://&lt;log server&gt;/ct/v1/add-pre-chain
	</t>
	<t>
	  Inputs
	  <list style="hanging">
	    <t hangText="chain">
	      An array of base64 encoded precertificates. The first element is the leaf certificate, the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
	    </t>
	  </list>
	</t>
	<t>
	  Outputs are the same as <xref target="sct"/>.
	</t>
      </section>
      <section title="Retrieve Latest Signed Tree Head" anchor="fetch_sth">
	<t>
	  GET https://&lt;log server&gt;/ct/v1/get-sth
	</t>
	<t>
	  No inputs.
	</t>
	<t>
	  Outputs
	  <list style="hanging">
	    <t hangText="tree_size">
	      The size of the tree, in entries, in decimal.
	    </t>
	    <t hangText="timestamp">
	      The timestamp, in decimal.
	    </t>
	    <t hangText="sha256_root_hash">
	      The root hash of the tree, in base64.
	    </t>
	    <t hangText="tree_head_signature">
	      A TreeHeadSignature for the above data.
	    </t>
	  </list>
	</t>
      </section>
      <section title="Retrieve Merkle Consistency Proof between two Signed Tree Heads" anchor="fetch_consistency">
	<t>
	  GET https://&lt;log server&gt;/ct/v1/get-sth-consistency
	</t>
	<t>
	  Inputs
	  <list style="hanging">
	    <t hangText="first">
	      The tree_size of the first tree, in decimal.
	    </t>
	    <t hangText="second">
	      The tree_size of the second tree, in decimal.
	    </t>
	  </list>
	  Both tree sizes must be from published v1 STHs (Signed Tree Heads).
	</t>
	<t>
	  Outputs
	  <list style="hanging">
	    <t hangText="consistency">
	    An array of Merkle tree nodes, base64 encoded.
	    </t>
	  </list>
	  Note that no signature is required on this data, as it is used to verify an STH, which is signed.
	</t>
      </section>
      <section title="Retrieve Merkle Audit Proof from Log by Leaf Hash" anchor="fetch_proof">
	<t>
	  GET https://&lt;log server&gt;/ct/v1/get-proof-by-hash
	</t>
	<t>
	  Inputs
	  <list style="hanging">
	    <t hangText="hash">
	      A base64 encoded v1 leaf hash.
	    </t>
	    <t hangText="tree_size">
	      The tree_size of the tree to base the proof on, in decimal.
	    </t>
	  </list>
	  The <spanx style="verb">hash</spanx> must be calculated as defined in <xref target="tree"/>. The <spanx style="verb">tree_size</spanx> must designate a published v1 STH.
	</t>
	<t>
	  Outputs
	  <list style="hanging">
	    <t hangText="timestamp">
	      The tree's timestamp, in decimal.
	    </t>
	    <t hangText="leaf_index">
	      The index of the leaf corresponding to the <spanx style="verb">hash</spanx> parameter.
	    </t>
	    <t hangText="audit_path">
	      An array of base64 encoded Merkle tree nodes proving the inclusion of the chosen certificate.
	    </t>
	  </list>
	</t>
      </section>
      <section title="Retrieve Entries from Log" anchor="fetch_entries">
	<t>
	  GET https://&lt;log server&gt;/ct/v1/get-entries
	</t>
	<t>
	  Inputs
	  <list style="hanging">
	    <t hangText="start">
	      Index of first entry to retrieve, in decimal.
	    </t>
	    <t hangText="end">
	      Index of last entry to retrieve, in decimal.
	    </t>
	  </list>
	</t>
	<t>
	  Outputs
	  <list style="hanging">
	    <t hangText="entries">
	      An array of objects, each consisting of
              <list style="hanging">
                <t hangText="leaf_input">
                  The base64-encoded MerkleTreeLeaf structure.
                </t>
                <t hangText="extra_data">
                  The base64-encoded unsigned data pertaining to the log entry. In the case of an X509ChainEntry, this is the <spanx style="verb">certificate_chain</spanx>. In the case of a PrecertChainEntry, this is the  <spanx style="verb">precertificate_chain</spanx>.
                </t>
              </list>
	    </t>
	  </list>
	</t>
	<t>
	  Note that this message is not signed - the retrieved data can be verified by constructing the root hash corresponding to a retrieved STH. All leaves MUST be v1. However, a compliant v1 client MUST NOT construe an unrecognized MerkleLeafType or LogEntryType value as an error. This means it may be unable to parse some entries, but note that each client can inspect the entries it does recognize, as well as verify the integrity of the data by treating unrecognized leaves as opaque input to the tree.
	</t>
      </section>
      <section title="Retrieve Entry+Merkle Audit Proof from Log">
	<t>
	  GET https://&lt;log server&gt;/ct/v1/get-entry-and-proof
	</t>
	<t>
	  Inputs
	  <list style="hanging">
	    <t hangText="leaf_index">
	      The index of the desired entry.
	    </t>
	    <t hangText="tree_size">
	      The tree_size of the tree for which the proof is desired.
	    </t>
	  </list>
	  The tree size must designate a published STH.
	</t>
	<t>
	  Outputs
	  <list style="hanging">
	    <t hangText="entries">
	      An array of objects, each consisting of
              <list style="hanging">
                <t hangText="leaf_input">
                  The base64-encoded MerkleTreeLeaf structure.
                </t>
                <t hangText="auxiliary_data">
                  The base64-encoded unsigned data, same as in <xref target='fetch_entries'/>.
                </t>
	      </list>
	    </t>
	    <t hangText="timestamp">
	      The tree's timestamp, in decimal.
	    </t>
	    <t hangText="audit_path">
	      An array of base64 encoded Merkle tree nodes proving the inclusion of the chosen certificate.
	    </t>
	  </list>
	  This API is probably only useful for debugging.
	</t>
      </section>
    </section>
    <section title="Clients">
      <t>
	There are various different functions clients of logs might perform. We describe here some typical clients and how they could function. Any inconsistency may be used as evidence that a log has not behaved correctly, and the signatures on the data structures prevent the log from denying that misbehaviour.
      </t>
      <t>
	All clients should gossip with each other, exchanging STHs at least: this is all that is required to ensure that they all have a consistent view. The exact mechanism for gossip will be described in an separate document, but it is expected there will be a variety.
      </t>
      <section title="Monitor">
	<t>
	  Monitors watch logs and check that they behave correctly. They also watch for certificates of interest.
	</t>
	<t>
	  A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:
	  <list style="numbers">
	    <t>
	      Fetch the current STH using <xref target="fetch_sth"/>.
	    </t>
	    <t>
	      Verify the STH signature.
	    </t>
	    <t>
	      Fetch all the entries in the tree corresponding to the STH using <xref target="fetch_entries"/>.
	    </t>
	    <t>
	      Confirm that the tree made from the fetched entries produces the same hash as that in the STH.
	    </t>
	    <t anchor="monitor_loop">
	      Fetch the current STH using <xref target="fetch_sth"/>. Repeat until STH changes.
	    </t>
	    <t>
	      Verify the STH signature.
	    </t>
	    <t>
	      Fetch all the new entries in the tree corresponding to the STH using <xref target="fetch_entries"/>. If they remain unavailable for an extended period, then this should be viewed as misbehaviour on the part of the log.
	    </t>
	    <t>
	      Either:
	      <list style="numbers">
		<t>
		  Verify that the updated list of all entries generates a tree with the same hash as the new STH.
		</t>
	      </list>
	      Or, if it is not keeping all log entries:
	      <list style="numbers">
		<t>
		  Fetch a consistency proof for the new STH with the previous STH using <xref target="fetch_consistency"/>.
		</t>
		<t>
		  Verify the consistency proof.
		</t>
		<t>
		  Verify that the new entries generate the corresponding elements in the consistency proof.
		</t>
	      </list>
	    </t>
	    <t>
	      Go to Step <xref target="monitor_loop" format='counter'/>.
	    </t>
	  </list>
	</t>
      </section>
      <section title="Auditor">
	<t>
	  Auditors take partial information about a log as input and verify that this information is consistent with other partial information they have. An auditor might be an integral component of a TLS client, it might be a standalone service or it might be a secondary function of a monitor.
	</t>
	<t>
	  Any pair of STHs from the same log can be verified by requesting a consistency proof using <xref target="fetch_consistency"/>.
	</t>
	<t>
	  A certificate accompanied by an SCT can be verified against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle Audit Proof using <xref target="fetch_proof"/>.
	</t>
	<t>
	  Auditors can fetch STHs from time to time of their own accord, of course, using <xref target="fetch_sth"/>.
	</t>
      </section>
    </section>
    <section title="IANA Considerations">
      <t>
	IANA is requested to allocate an RFC 5878 AuthorizationData Type for the CST included in an Authorization Extension. The value 182 is preferred.
      </t>
    </section>
    <section title="Security and Privacy Considerations">
      <section title="Misissued Certificates">
	<t>
	  Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, will be rejected by clients. Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD. 
	</t>
      </section>
      <section title="Detection of Misissue">
	<t>
	  The logs do not themselves detect misissued certificates, they rely instead on interested parties, such as domain owners, to monitor them and take corrective action when a misissue is detected.
	</t>
      </section>
      <section title="Misbehaving logs">
	<t>
	  A log can misbehave in two ways: (1), by failing to incorporate a certificate with an SCT in the Merkle Tree within the MMD; and (2), by violating its append-only property by presenting two different, conflicting views of the Merkle Tree at different times and/or to different parties. Both forms of violation will be promptly and publicly detectable.
	</t>
	<t>
	  Violation of the MMD contract is detected by clients requesting a Merkle audit proof for each observed SCT. These checks can be asynchronous, and need only be done once per each certificate. In order to protect the clients' privacy, these checks need not reveal the exact certificate to the log. Clients can instead request the proof from a trusted auditor (since anyone can compute the audit proofs from the log), or request Merkle proofs for a batch of certificates around the SCT timestamp. 
	</t>
	<t>
	  Violation of the append-only property is detected by global gossiping, i.e., everyone auditing logs comparing their versions of the latest signed tree heads. As soon as two conflicting signed tree heads for the same log are detected, this is cryptographic proof of the that log's misbehaviour.
	</t>
      </section>
    </section>
    <section title="Efficiency Considerations">
      <t>
	The Merkle tree design serves the purpose of keeping communication overhead low.
      </t>
      <t>
	Auditing logs for integrity does not require third parties to maintain a copy of each entire log. The Signed Tree Heads can be updated as new entries become available, without recomputing entire trees. Third party auditors need only fetch the Merkle consistency proofs against a log's existing STH to efficiently verify the append-only property of updates to their Merkle Trees, without auditing the entire tree.
      </t>
    </section>
    <section title="Future Changes">
      <t>
	This section lists things we might address in a Standards Track version of this document.
      </t>
      <t>
	Rather than forcing a log operator to create a new log in order to change the log signing key, we may allow some key roll mechanism.
      </t>
      <t>
	We may add hash and signing algorithm agility.
      </t>
      <t>
	We may describe some gossip protocols.
      </t>
    </section>
  </middle>
  <back>
    <references>

      <reference anchor='RFC2119'>

	<front>
	  <title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
	  <author initials='S.' surname='Bradner' fullname='Scott Bradner'>
	    <organization>Harvard University</organization>
	    <address>
	      <postal>
		<street>1350 Mass. Ave.</street>
		<street>Cambridge</street>
	      <street>MA 02138</street></postal>
	      <phone>- +1 617 495 3864</phone>
	  <email>sob@harvard.edu</email></address></author>
	  <date year='1997' month='March' />
	  <area>General</area>
	  <keyword>keyword</keyword>
	  <abstract>
	    <t>
	      In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  Authors who follow these guidelines should incorporate this phrase near the beginning of their document:
	      <list>
		<t>
		  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.
		</t>
	      </list>
	    </t>
	    <t>
	      Note that the force of these words is modified by the requirement
	      level of the document in which they are used.
	    </t>
	  </abstract>
	</front>

	<seriesInfo name='BCP' value='14' />
	<seriesInfo name='RFC' value='2119' />
	<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
	<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
	<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
      </reference>

      <reference anchor="RFC2560">
	<front>
	  <title abbrev="PKIX OCSP">
	    X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP
	  </title>
	  <author initials="M." surname="Myers" fullname="Michael Myers">
	    <organization>VeriSign, Inc.</organization>
	    <address>
	      <postal>
		<street>1350 Charleston Road</street>
		<city>Mountain View</city>
		<region>CA</region>
		<code>94043</code>
		<country>US</country>
	      </postal>
	      <email>mmyers@verisign.com</email>
	    </address>
	  </author>
	  <author initials="R." surname="Ankney" fullname="Rich Ankney">
	    <organization>CertCo, LLC</organization>
	    <address>
	      <postal>
		<street>13506 King Charles Dr.</street>
		<city>Chantilly</city>
		<region>VA</region>
		<code>20151</code>
		<country>US</country>
	      </postal>
	      <email>rankney@erols.com</email>
	    </address>
	  </author>
	  <author initials="A." surname="Malpani" fullname="Ambarish Malpani">
	    <organization>ValiCert, Inc.</organization>
	    <address>
	      <postal>
		<street>1215 Terra Bella Avenue</street>
		<city>Mountain View</city>
		<region>CA</region>
		<code>94043</code>
		<country>US</country>
	      </postal>
	      <phone>+1 650 567 5457</phone>
	      <email>ambarish@valicert.com</email>
	    </address>
	  </author>
	  <author initials="S." surname="Galperin" fullname="Slava Galperin">
	    <organization>My CFO, Inc.</organization>
	    <address>
	      <postal>
		<street>1945 Charleston Road</street>
		<city>Mountain View</city>
		<region>CA</region>
		<code>94043</code>
		<country>US</country>
	      </postal>
	      <email>galperin@mycfo.com</email>
	    </address>
	  </author>
	  <author initials="C." surname="Adams" fullname="Carlisle Adams">
	    <organization>Entrust Technologies</organization>
	    <address>
	      <postal>
		<street>750 Heron Road</street>
		<street>Suite E08</street>
		<city>Ottawa</city>
		<region>Ontario</region>
		<code>K1V 1A7</code>
		<country>CA</country>
	      </postal>
	      <email>cadams@entrust.com</email>
	    </address>
	  </author>
	  <date year="1999" month="June"/>
	  <abstract>
	    <t>
	      This document specifies a protocol useful in determining the current status of a digital certificate without requiring CRLs. Additional mechanisms addressing PKIX operational requirements are specified in separate documents.
	    </t>
	    <t>
	      An overview of the protocol is provided in section 2. Functional requirements are specified in section 4. Details of the protocol are in section 5. We cover security issues with the protocol in section 6. Appendix A defines OCSP over HTTP, appendix B accumulates ASN.1 syntactic elements and appendix C specifies the mime types for the messages.
	    </t>
	    <t>
	      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document (in uppercase, as shown) are to be interpreted as described in.
	    </t>
	  </abstract>
	</front>
	<seriesInfo name="RFC" value="2560"/>
	<format type="TXT" octets="43243" target="http://www.rfc-editor.org/rfc/rfc2560.txt"/>
      </reference>

      <reference anchor='RFC5246'>

	<front>
	  <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
	  <author initials='T.' surname='Dierks' fullname='T. Dierks'>
	    <organization /></author>
	  <author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
	    <organization /></author>
	  <date year='2008' month='August' />
	</front>

	<seriesInfo name='RFC' value='5246' />
      </reference>

      <reference anchor='RFC5280'>

	<front>
	  <title>Internet X.509 Public Key Infrastructure Certificate
	    and Certificate Revocation List (CRL) Profile</title>
	  <author initials='D.' surname='Cooper' fullname='D. Cooper'>
	    <organization>NIST</organization></author>
	  <author initials='S.' surname='Santesson' fullname='S. Santesson'>
	    <organization>Microsoft</organization></author>
	  <author initials='S.' surname='Farrell' fullname='S. Farrell'>
	    <organization>Trinity College Dublin</organization></author>
	  <author initials='S.' surname='Boeyen' fullname='S. Boeyen'>
	    <organization>Entrust</organization></author>
	  <author initials='R.' surname='Housley' fullname='R. Housley'>
	    <organization>Vigil Security</organization></author>
	  <author initials='W.' surname='Polk' fullname='W. Polk'>
	    <organization>NIST</organization></author>
	  <date year='2008' month='May' />
	</front>

	<seriesInfo name='RFC' value='5280' />
      </reference>

      <reference anchor='RFC5878'>

	<front>
	  <title>The Transport Layer Security (TLS) Authorization Extensions</title>
	  <author initials='M.' surname='Brown' fullname='M. Brown'>
	    <organization >RedPhone Security</organization></author>
	  <author initials='R.' surname='Housley' fullname='R. Housley'>
	    <organization>Vigil Security</organization></author>
	  <date year='2010' month='May' />
	</front>

	<seriesInfo name='RFC' value='5878' />
      </reference>

      <reference anchor="RFC6066">
	<front>
	  <title>
	    Transport Layer Security (TLS) Extensions: Extension Definitions
	  </title>
	  <author initials="D." surname="Eastlake" fullname="D. Eastlake">
	    <organization/>
	  </author>
	  <date year="2011" month="January"/>
	  <abstract>
	    <t>
	      This document provides specifications for existing TLS extensions. It is a companion document for RFC 5246, "The Transport Layer Security (TLS) Protocol Version 1.2". The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request. [STANDARDS-TRACK]
	    </t>
	  </abstract>
	</front>
	<seriesInfo name="RFC" value="6066"/>
	<format type="TXT" octets="55079" target="http://www.rfc-editor.org/rfc/rfc6066.txt"/>
      </reference>

      <reference anchor="DSS">
	<front>
	  <title>Digital Signature Standard</title>
	  <author>
	    <organization abbrev="NIST">National Institute of Standards and Technology, U.S. Department of Commerce</organization>
	  </author>
	  <date month="June" year="2009"/>
	</front>
	<seriesInfo name="FIPS" value="186-3"/>
	<format type="PDF" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"/>
      </reference>

    </references>
  </back>
</rfc>
