


HyBi Working Group                                            J. Tamplin
Internet-Draft                                                T. Yoshino
Intended status: Standards Track                            Google, Inc.
Expires: January 5, 2013                                    July 4, 2012


                A Multiplexing Extension for WebSockets
               draft-ietf-hybi-websocket-multiplexing-03

Abstract

   The WebSocket Protocol [RFC6455] requires a new transport connection
   for every WebSocket connection.  This presents a scalability problem
   when many clients connect to the same server, and is made worse by
   having multiple clients running in different tabs of the same user
   agent.  This extension provides a way for separate logical WebSocket
   connections to share an underlying transport connection.

   Please send feedback to the hybi@ietf.org mailing list.

Status of this Memo

   This Internet-Draft is submitted to IETF in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 5, 2013.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must



Tamplin & Yoshino        Expires January 5, 2013                [Page 1]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Physical Connection and Logical Channels . . . . . . . . .  3
   2.  Conformance Requirements . . . . . . . . . . . . . . . . . . .  4
   3.  Interaction with other Extensions / Framing Mechanisms . . . .  5
     3.1.  Choosing the point to apply an extension . . . . . . . . .  5
   4.  Multiplexed Connections  . . . . . . . . . . . . . . . . . . .  7
   5.  Flow Control . . . . . . . . . . . . . . . . . . . . . . . . .  8
     5.1.  New Channel Slot . . . . . . . . . . . . . . . . . . . . .  8
     5.2.  Send Quota . . . . . . . . . . . . . . . . . . . . . . . .  8
   6.  Framing  . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
   7.  Multiplex Control Blocks . . . . . . . . . . . . . . . . . . . 12
     7.1.  AddChannelRequest  . . . . . . . . . . . . . . . . . . . . 12
     7.2.  AddChannelResponse . . . . . . . . . . . . . . . . . . . . 15
     7.3.  FlowControl  . . . . . . . . . . . . . . . . . . . . . . . 16
     7.4.  DropChannel  . . . . . . . . . . . . . . . . . . . . . . . 17
     7.5.  NewChannelSlot . . . . . . . . . . . . . . . . . . . . . . 19
   8.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
   9.  Client Behavior  . . . . . . . . . . . . . . . . . . . . . . . 22
   10. Buffering  . . . . . . . . . . . . . . . . . . . . . . . . . . 23
   11. Fairness . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   12. Proxies  . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
   13. Nesting  . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   14. Timeout  . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
   15. Close the Logical Channel  . . . . . . . . . . . . . . . . . . 28
   16. Fail the Logical Channel . . . . . . . . . . . . . . . . . . . 29
   17. Fail the Physical Connection . . . . . . . . . . . . . . . . . 30
   18. Operations and Events on Multiplexed Connection  . . . . . . . 31
   19. Security Considerations  . . . . . . . . . . . . . . . . . . . 32
   20. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 33
   21. Normative References . . . . . . . . . . . . . . . . . . . . . 34
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 35













Tamplin & Yoshino        Expires January 5, 2013                [Page 2]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


1.  Overview

   This document describes a multiplexing extension for the WebSocket
   Protocol.  With this extension, one TCP connection can provide
   multiple virtual WebSocket connections by encapsulating frames taged
   with a channel ID.  A client that supports this extension will
   advertise support for it in the client's opening handshake using the
   "Sec-WebSocket-Extensions" header.  If the server supports this
   extension and supports parameters compatible with the client's
   request, it accepts the use of this extension by the
   "Sec-WebSocket-Extensions" header in the server's opening handshake.

1.1.  Physical Connection and Logical Channels

   Under use of this extension, one transport connection is shared by
   multiple application-level instances.  The WebSocket connection which
   lies directly on the TCP connection and negotiated this multiplexing
   extension is called "physical connection".  Virtual WebSocket
   connections established for each application-level instance are
   called "mutiplexed connections".  Data channels virtually established
   by ID tagging are called "logical channels".  Logical channels with
   non-zero ID exchange data for multiplexed connections.  The logical
   channel with ID of 0 exchanges multiplex control information.

   Data for different logical channels are distinguished by the channel
   ID placed at the head of the message that encapsulates the original
   frame of a multiplex connection.
























Tamplin & Yoshino        Expires January 5, 2013                [Page 3]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


2.  Conformance Requirements

   All diagrams, examples, and notes in this specification are non-
   normative, as are all sections explicitly marked non-normative.
   Everything else in this specification is normative.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC2119 [RFC2119].

   Requirements phrased in the imperative as part of algorithms (such as
   "strip any leading space characters" or "return false and abort these
   steps") are to be interpreted with the meaning of the key word
   ("must", "should", "may", etc) used in introducing the algorithm.

   Conformance requirements phrased as algorithms or specific steps MAY
   be implemented in any manner, so long as the end result is
   equivalent.  (In particular, the algorithms defined in this
   specification are intended to be easy to follow, and not intended to
   be performant.)































Tamplin & Yoshino        Expires January 5, 2013                [Page 4]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


3.  Interaction with other Extensions / Framing Mechanisms

   If any extension (e.g. compression) is placed before this extension
   in the "Sec-WebSocket-Extensions" header of the physical connection,
   that extension is applied to multiplexed connections unless otherwise
   noted in the extension's spec.

   If any extension is placed after this extension in the
   "Sec-WebSocket-Extensions" header of the physical connection, that
   extension is applied to frames after multiplexing on the sender side,
   and before demultiplexing on the receiver side unless otherwise noted
   in the extension's spec.

   A client MAY request such an extension for both the physical
   connection and multiplexed connections by placing extension entries
   before and after this multiplexing extension.  In this case, the
   server SHOULD reject at least either of them if it's useless to apply
   the same extension twice.

   For example, if we have a compression extension called foo-compress,
   the client sends

       Sec-WebSocket-Extensions: foo-compress, mux, foo-compress

   in the client's opening handshake of the physical connection to
   request use of the compression for both physical and multiplexed
   connections.  Then, the server would send back

       Sec-WebSocket-Extensions: mux, foo-compress

   to apply compression after multiplexing, or

       Sec-WebSocket-Extensions: foo-compress, mux

   to apply compression to multiplexed connections.

3.1.  Choosing the point to apply an extension

   Where to apply a compression extension makes difference to resource
   consumption and flexibility.  Compression algorithms often use some
   memory to keep its context.  Some of compression extensions may keep
   using the same context for all the messages on the same connection.

   If such an extension is applied to the physical connection,
   intermediaries that want to demultiplex or multiplex the connection
   need to decompress (before demultiplexing) and recompress (before
   multiplexing again) all the frames.




Tamplin & Yoshino        Expires January 5, 2013                [Page 5]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   If such an extension is applied to each multiplexed connection, we
   can control to which channel we apply the compression, so we can
   avoid applying compression to channels transferring incompressible
   data.  Intermediaries that want to demultiplex can forward payload
   leaving it untouched.  However, compressing each multiplexed
   connection is expensive in terms of memory consumption.













































Tamplin & Yoshino        Expires January 5, 2013                [Page 6]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


4.  Multiplexed Connections

   The multiplexing extension maintains separate logical channels, each
   of which provides fully the logical equivalent of an independent
   WebSocket connection, including separate handshake headers.  If the
   multiplexing extension is successfully negotiated, one multiplexed
   connection is automatically established, and the headers on the
   opening handshake of the physical connection are automatically taken
   to mean ones for the multiplexed connection.  It's called "Implicitly
   Opened Connection".  It's served by the logical channel with channel
   ID of 1 which is also implicitly opened on completion of the opening
   handshake.  New channels are added by the client issuing the
   AddChannelRequest multiplex control block (note that only the client
   may initiate new WebSocket connections), including any handshake
   headers which do not have the same value as the client's opening
   handshake of the physical connection.  The server's
   AddChannelResponse likewise includes any handshake headers which are
   different from the server's opening handshake of the physical
   connection Channel 0 (control channel) is reserved for multiplex
   control blocks and does not contain Payload Data from any multiplexed
   connection.  A client which attempts to add a channel to an existing
   connection that is not accepted by the server SHOULD attempt to open
   a new underlying connection and open a new WebSocket connection on
   it.

   Once the multiplexing extension is negotiated on a connection, all
   frames of multiplexed connection MUST be prefixed with a channel ID
   number and encapsulated into wrapping binary messages.  The channel
   ID is assigned by the client on issuing an AddChannelRequest.

   A receiver MAY process frames for different non-control logical
   channels in parallel.  A receiver MUST process frames for the control
   channel exclusively.

   A receiver MUST _Fail the Physical Connection_ if any of these rules
   are violated by the sender.















Tamplin & Yoshino        Expires January 5, 2013                [Page 7]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


5.  Flow Control

5.1.  New Channel Slot

   A client has a pool of slots called "new channel slots".  It's
   initialized to be empty on establishment of the physical connection.

   A NewChannelSlot multiplex control block sent by the server adds
   slots to the pool.

   Each slot has a non-negative integer value called "initial send
   quota".  Its function is explained in the later subsection.

   When sending an AddChannelRequest, the client MUST pick the oldest
   new channel slot from the pool and remove it from the pool.  If there
   are no slots in the pool, the client MUST NOT issue an
   AddChannelRequest.

   A server can regulate the rate of AddChannelRequests by not
   replenishing the pool.

5.2.  Send Quota

   For each logical channel with non-zero ID, server and client are
   respectively given a non-negative integer value called "send quota".

   For the logical channel created for the "Implicitly Opened
   Connection", the client's "send quota" is initialized to 0 on
   establishment of the physical connection.  The server's "send quota"
   for the channel is initialized on sending its opening handshake for
   the physical connection.  The "quota" extension parameter attached to
   the extension token for this multiplexing extension in the client's
   opening handshake for the physical connection specifies the initial
   value.  If the "quota" extension parameter is not specified, the
   initial value is set to 0.  The extension parameter has the initial
   value on its parameter value side as a non-negative integer in
   decimal.

   For a logical channel added by issuing an AddChannelRequest, a client
   gets "send quota" equal to the "initial send quota" value on the "new
   channel slot" picked for the AddChannelRequest on sending it.

   For a logical channel added by accepting an AddChannelRequest, a
   server gets "send quota" of 0 on sending the corresponding
   AddChannelResponse.

   When an endpoint receives a FlowControl for a logical channel, its
   "send quota" for the channel gets replenished.



Tamplin & Yoshino        Expires January 5, 2013                [Page 8]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   When sending a frame on a logical channel with non-zero ID, the
   length of the "Payload data" of the frame MUST NOT be greater than
   the "send quota" of the endpoint for the channel.  An endpoint MUST
   _Fail the Logical Channel_ when it's clear that the other peer
   violates this.

   When a frame is sent on a logical channel with non-zero ID, the
   length of the "Payload data" of the frame is subtracted from the
   "send quota" of the endpoint for the channel.

   An endpoint SHOULD NOT delay replenishment of the other peer's "send
   quota" for a logical channel when it has more room for accepting new
   data for the channel.






































Tamplin & Yoshino        Expires January 5, 2013                [Page 9]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


6.  Framing

   This extension encapsulates each frame of a multiplexed connection
   into a binary message with Payload Data obtained by concatenating the
   following data in the order they are listed:

   1.  The logical channel ID for the multiplexed connection.

   2.  FIN, RSV1, RSV2, RSV3 and opcode of the original frame.

   3.  Unmasked "Payload Data" of the original frame.

   The channel ID is encoded as a variable number of bytes, as follows:

      0 1 2 3 4 5 6 7
     +-+-------------+
     |0|Channel ID(7)|
     +-+-------------+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+---------------------------+
     |1|0|      Channel ID (14)      |
     +-+-+---------------------------+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-----------------------------------------+
     |1|1|0|             Channel ID (21)             |
     +-+-+-+-----------------------------------------+

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+---------------------------------------------------------+
     |1|1|1|                     Channel ID (29)                     |
     +-+-+-+---------------------------------------------------------+

   All frames with a non-zero channel ID MUST be delivered to the
   corresponding multiplexed connection in the order they are received.
   Control frames with a non-zero channel ID may also trigger additional
   processing by the multiplexing extension.

   This extension MAY change the fragmentation of the original message
   before encapsulation in order to insert multiplex control blocks or
   adjust the amount of data to flush along with flow control.  In doing
   this, control messages MAY also be fragmented.  Control messages
   multiplexed with fragmentation MUST be delivered to the corresponding
   multiplexed connection after receiving all fragments and



Tamplin & Yoshino        Expires January 5, 2013               [Page 10]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   defragmenting them.

   To allow for adjustment of fragmentation, this multiplexing extension
   MUST NOT be used after any extension that does any of the followings:

   o  Require frame boundary on its output to be preserved.

   o  Use the "Extension data" field or any of the reserved bits on the
      WebSocket header as per-frame attribute.

   Intermediaries MAY change the fragmentation of the encapsulating
   messages.

   If a binary message doesn't contain a valid channel ID, _Fail the
   Physical Connection_.  The cases where it's considered that a channel
   ID is invalid are:

   o  The payload of the message doesn't contain a complete channel ID.

   o  No channel has been opened for the channel ID.

   o  The channel has been closed and not reopened.

   If a binary message with a non-zero channel ID doesn't contain at
   least one octet after the channel ID, _Fail the Physical Connection_.


























Tamplin & Yoshino        Expires January 5, 2013               [Page 11]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


7.  Multiplex Control Blocks

   A binary messages with the channel ID of 0 contain zero or more
   multiplex control blocks in "Payload data".  Putting multiple control
   blocks into one WebSocket message saves framing overhead.  Unless any
   other negotiated extension defines a meaning for them, endpoints MUST
   NOT send any data frame with an opcode other than "binary frame".  If
   an endpoint received such frame, it MUST _Fail the Physical
   Connection_.

   Control blocks has fields as follows:

      0 1 2 3 4 5 6 7
     +-----+---------+
     | Opc |         |
     +-----+         :
     | Opc specific  :
     : data          :
     |               |
     +---------------+

   Opc

      A multiplex control opcode as defined in the following
      subsections.  Opc of 5-7 are Reserved for future use (TBD: do we
      need some support for quiescence?).

   Opc specific data

      Data interpreted according to that opcode.

   Each of the following subsections describes one multiplex control
   opcode and how to interpret opc specific data for that opcode.

   If any incomplete multiplex control block is found, the endpoint MUST
   _Fail the Physical Connection_.

7.1.  AddChannelRequest

   AddChannelRequest is sent only by clients to create the objective
   logical channel, as if a new connection were received on a separate
   transport connection, except for the encoding of the headers.

   Multiplex control opcode of AddChannelRequest is 0.

   AddChannelRequest has fields as follows:





Tamplin & Yoshino        Expires January 5, 2013               [Page 12]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


      0 1 2 3 4 5 6 7
     +-+-+-+-+---+---+
     |0|0|0|R|Enc|Len|
     +-+-+-+-+---+---+
     |Objective      |
     :channel ID     :
     |(8-32 bit)     |
     +---------------+
     |Size of encoded|
     :handshake      :
     |(8-32 bit)     |
     +---------------+
     |Encoded        |
     :handshake      :
     |               |
     +---------------+

   R

      Reserved for future use.

   Len

      The size of the size of the encoded handshake field in bytes minus
      1.

   Enc

      Encoding scheme type:

      0 - identity

         The client's handshake data in the encoded handshake field are
         sent as-is without any special encoding or compression applied,
         and constitute the complete set of a Request-Line and headers
         that would have been sent on opening handshake.

      1 - delta-encoded

         The client's handshake data in the encoded handshake field are
         delta-encoded, where any header that is not given is assumed to
         have the same value as that given on the current delta base.
         The delta base is initially the client's opening handshake of
         the physical connection but the "Sec-WebSocket-Extensions" in
         it is replaced with the extension entries after the one for
         this multiplexing extension.  Every time, an AddChannelRequest
         where Enc field is identity is received, the delta base is
         updated to the handshake data in the AddChannelRequest.  The



Tamplin & Yoshino        Expires January 5, 2013               [Page 13]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


         Request-Line MUST be sent regardless if it's the same as one in
         the delta base or not.  A header with an empty value means that
         the header is not inherited from the delta base.  When to send
         valueless headers, identity encoding MUST be used.

      2-3 - reserved

         Reserved for future use.

   Objective channel ID

      The channel ID of the logical channel objective to this operation.
      Encoding is the same as one used for encapsulation.

   Size of encoded handshake

      The size of the encoded handshake field in bytes in network byte
      order.

   Encoded handshake

      The client's opening handshake as defined in Section 4 of RFC 6455
      [RFC6455] for the new multiplexed connection.  This field is
      encoded as defined in the description for the Enc field.  The
      complete set of a Request-Line and headers after decoding is
      treated exactly as if it was sent on a separate connection.

   If there's already a logical channel with the same channel ID as one
   specified in this AddChannelRequest, it MUST _Fail the Physical
   Connection_.  Once the server receives an AddChannelRequest, it MUST
   decide whether to accept or reject the request.  To accept the
   request, it MUST create a new logical channel with the channel ID set
   to the objective channel ID field of the AddChannelRequest.

   Channel ID assignment is done by the client.  A client MAY use any
   algorithm to choose channel IDs for new channels.  Note that channel
   ID assignment might be changed by intermediaries, so it's not
   guaranteed that the value of channel ID is the same on the other
   peer.

   The server MUST respond to the request with the AddChannelResponse
   described later.

   Different from non-multiplexed WebSocket connection, a client MAY
   send frames of multiplexed connections except for "Implicitly Opened
   Connection" before receiving AddChannelResponse as far as there's
   sufficient send quota.  In case the AddChannelRequest fails, those
   frames are discarded by the other peer.  This doesn't mean that users



Tamplin & Yoshino        Expires January 5, 2013               [Page 14]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   of this protocol such as the WebSocket API are required to allow
   their users to send frames before receiving the server's opening
   handshake.

7.2.  AddChannelResponse

   AddChannelResponse is sent only by servers in response to the
   AddChannelRequest.

   Multiplex control opcode of the AddChannelResponse is 1.

   AddChannelResponse has fields as follows:

      0 1 2 3 4 5 6 7
     +-+-+-+-+---+---+
     |0|0|1|F|Enc|Len|
     +-+-+-+-+---+---+
     |Objective      |
     :channel ID     :
     |(8-32 bit)     |
     +---------------+
     |Size of encoded|
     :handshake      :
     |(8-32 bit)     |
     +---------------+
     |Encoded        |
     :handshake      :
     |               |
     +---------------+

   F

      If F is set, then the server has rejected the AddChannelRequest
      and this SHOULD be treated exactly the same as if a separate
      connection was attempted and the connection was closed after
      receiving the server's handshake.  Enc MUST be set to identity in
      this case.  The encoded handshake field MUST contain the response
      to an HTTP Upgrade request for the request made by the
      AddChannelRequest, for example:

        HTTP/1.1 404 Not found

        404 message body...

      If F is not set, then the server has accepted the
      AddChannelRequest.  The encoded handshake field MUST contain the
      response to an HTTP Upgrade request for the request made by the
      AddChannelRequest, for example:



Tamplin & Yoshino        Expires January 5, 2013               [Page 15]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   Len

      The size of the size of encoded handshake field in bytes minus 1.

   Enc

      Encoding scheme type the same as defined for the AddChannelRequest
      opcode (but replacing "AddChannelRequest" with
      "AddChannelResponse", and "Request-Line" with "Response-Line").

   Objective channel ID

      Same as one in the AddChannelRequest.

   Size of encoded handshake

      The size of the following encoded handshake field in bytes in
      network byte order.

   Encoded handshake

      The server's opening handshake as defined in Section 4 of RFC 6455
      [RFC6455] for this multiplexed connection.  This field is encoded
      according to Enc. The complete set of a Response-Line and headers
      after decoding is treated exactly as if it was received in
      response to a client's opening handshake on a separate connection.

   If the server's opening handshake is validated, the client MUST take
   this as _The WebSocket Connection is Established_.

7.3.  FlowControl

   FlowControl is used to replenish the other peer's send quota for the
   specified logical channel.

   Multiplex control opcode of FlowControl is 2.

   FlowControl has fields as follows.













Tamplin & Yoshino        Expires January 5, 2013               [Page 16]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


      0 1 2 3 4 5 6 7
     +-+-+-+-----+---+
     |0|1|0| RSV |Len|
     +-+-+-+-----+---+
     |Objective      |
     :channel ID     :
     |(8-32 bit)     |
     +---------------+
     |Replenished    |
     :quota          :
     |(8-32 bit)     |
     +---------------+

   RSV

      Reserved for future use.

   Len

      The size of replenished quota field in bytes minus 1.

   Objective channel ID

      Same as one in the AddChannelRequest.

   Replenished quota

      An unsigned integer in network byte order added to the quota of
      the number of bytes the receiver can have outstanding towards the
      sender of the FlowControl message.

7.4.  DropChannel

   DropChannel is used to close a logical channel.

   Multiplex control opcode of DropChannel is 3.

   DropChannel has fields as follows:













Tamplin & Yoshino        Expires January 5, 2013               [Page 17]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


      0 1 2 3 4 5 6 7
     +-+-+-+-+---+---+
     |0|1|1|F|RSV|Len|
     +-+-+-+-+---+---+
     |Objective      |
     :channel ID     :
     |(8-32 bit)     |
     +---------------+
     |Size of reason |
     :(8-32 bit)     :
     |               |
     +---------------+
     |Reason         |
     :               :
     |               |
     +---------------+

   F

      F is set when this DropChannel is due to multiplexing level error.
      F is unset when this DropChannel is sent because the multiplexed
      connection is asked to _Close the WebSocket Connection_, and the
      reason field MUST be empty for this case.

   RSV

      Reserved for future use.

   Len

      The size of the size of reason field in bytes minus 1.

   Objective channel ID

      Same as one in the AddChannelRequest.

   Size of reason

      The size of the reason field in bytes in network byte order.

   Reason

      The reason of closure.

   When an endpoint received DropChannel, the endpoint MUST remove the
   logical channel and the application instance that used the logical
   channel MUST treat this as closure of underlying transport.  Once a
   logical channel is removed by the DropChannel request, the channel ID



Tamplin & Yoshino        Expires January 5, 2013               [Page 18]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   of the logical channel becomes available again for new
   AddChannelRequest commands.

7.5.  NewChannelSlot

   NewChannelSlot is sent only by servers to adds new slots to the
   client's new channel pool.

   Multiplex control opcode of NewChannelSlot is 4.

   NewChannelSlot has fields as follows:

      0 1 2 3 4 5 6 7
     +-+-+-+-+---+---+
     |1|0|0|R|NL |QL |
     +-+-+-+-+---+---+
     |Number of slots|
     :(8-32 bit)     :
     |               |
     +---------------+
     |Initial send   |
     :quota          :
     |(8-32 bit)     |
     +---------------+

   R

      Reserved for future use.

   NL

      The size of the number of slots field in bytes minus 1.

   QL

      The size of the initial quota field in bytes minus 1.

   Number of slots

      The number of slots to add in network byte order.

   Initial quota

      The initial quota each of slots added by this NewChannelSlot gets
      in bytes in network byte order.

   When a client received a NewChannelSlot, the client MUST add new
   slots of the specified number.  Each of new slots gets the specified



Tamplin & Yoshino        Expires January 5, 2013               [Page 19]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


   initial send quota.


















































Tamplin & Yoshino        Expires January 5, 2013               [Page 20]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


8.  Examples

   _This section is non-normative._

   The examples below assume the handshake has already completed and the
   multiplexing extension was negotiated.

   Frames of encapsulating messages from client to server MUST be
   masked.  To simplify, the examples below are not masked.

   0x82 0x0d 0x01 0x81 "Hello world"

      This is a non-fragmented text message of "Hello world" on channel
      1 encapsulated into a non-fragmented message.

   0x02 0x07 0x01 0x81 "Hello" 0x80 0x06 " world"

      This is a fragmented encapsulating message converying a non-
      fragmented text frame "Hello world" on channel 1.

   0x82 0x07 0x01 0x01 "Hello" 0x82 0x05 0x02 0x81 "bye" 0x82 0x08 0x01
   0x80 " world"

      This example shows how data for two channels are interleaved.
      There're three non-fragmented encapsulating messages.  The first
      and third one convey each of two frames of a fragmented text
      message of "Hello world" on channel 1.  The second one conveys a
      non-fragmented text message of "bye" on channel 2.























Tamplin & Yoshino        Expires January 5, 2013               [Page 21]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


9.  Client Behavior

   When a client is asked to _Establish a WebSocket Connection_ by some
   WebSocket application instance, it MAY choose to reuse an existing
   WebSocket connection if all of the following are true:

   o  the multiplexing extension was successfully negotiated on that
      connection

   o  the scheme portions of the URIs match exactly

   o  the host portions of the URIs either match exactly or resolve to
      the same IP address (TBD: consider DNS rebind attacks)

   o  the port portions of the URIs (either explicit or implied by the
      scheme) match exactly

   o  the connection has an availablle logical channel ID

   If the client chooses to reuse an existing multiplexed connection, it
   sends an AddChannelRequest as described above.  If the
   AddChannelRequest is accepted, WebSocket frames may be sent over that
   channel as normal.  If the server rejects the AddChannel, the client
   SHOULD attempt to open a new physical WebSocket connection (for
   example, in a shared hosting environment a server may not be prepared
   to multiplex connections from different customers despite having a
   single IP address for them).
























Tamplin & Yoshino        Expires January 5, 2013               [Page 22]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


10.  Buffering

   There will be lots of small frames sent in this protocol
   (particularly replenishing send quotas), so a sender SHOULD attempt
   to aggregate multiplex control blocks into larger WebSocket frames.
   For data frames, a sender also SHOULD attempt to aggregate fragments
   into one packet of the underlying transport.  However, care must be
   taken to avoid introducing excessive latency - the exact heuristics
   for delaying in order to aggregate blocks is TBD.










































Tamplin & Yoshino        Expires January 5, 2013               [Page 23]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


11.  Fairness

   A multiplexing implementation MUST ensure reasonable fairness among
   the logical channels.  This is accomplished in several ways:

   Receiver side

   o  The receiver MAY limit the send quota of a logical channel by not
      replenishing it to make sure that any logical channel doesn't
      dominate the connection.

   o  Send quota for one logical channel SHOULD be determined
      considering the processing capacity (buffer size, processing
      power, throughput, etc.) of that logical channel.  For example,
      when a logical channel with excess load cannot drain data from the
      connection smoothly, the other logical channels get stuck even
      when they have room of processing capacity.  Unless there's
      special need to give such a big quota for the channel, such
      condition just makes overall performance low.

   Sender side

   o  The sender MUST use a fair mechanism for selecting which logical
      channel's data to send in the next WebSocket frame.  Simple
      implementations may choose a round-robin scheduler, while more
      advanced implementations may adjust priority based on the amount
      or frequency of data sent by each logical channel.

   o  The sender MUST fragment a large message into smaller frames to
      prevent a large message in a logical channel occupying the
      physical connection and thus delaying messages in other logical
      channels.



















Tamplin & Yoshino        Expires January 5, 2013               [Page 24]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


12.  Proxies

   Proxies which do not multiplex/demultiplex are not affected by the
   presence of this extension -- they simply process WebSocket frames as
   usual.  Proxies which filter or monitor WebSocket traffic will need
   to understand the multiplexing extension in order to extract the data
   from logical connections or to terminate individual logical
   connections when policy is violated.  Proxies which actively
   multiplex connections or demultiplex them (for example, a mobile
   network might have a proxy which aggregates WebSocket connections at
   a single cell to conserve bandwidth to the main gateway) will require
   additional configuration (perhaps including the client) that is
   outside the scope of this document.






































Tamplin & Yoshino        Expires January 5, 2013               [Page 25]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


13.  Nesting

   TBD: Should we allow nesting of multiplexed channels, or should we
   require that an intermediary multiplexing channels flatten it?  The
   advantage of nesting is it is conceptually cleaner and less work for
   an intermediary, while the disadvantage is that flow control messages
   will get amplified by nesting and the ultimate server's job is a bit
   more complicated to keep a tree of channel mappings.











































Tamplin & Yoshino        Expires January 5, 2013               [Page 26]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


14.  Timeout

   When all the logical channels are closed, each endpoint MAY _Start
   the WebSocket Closing Handshake_ on the physical connection.  Such
   _Start the WebSocket Closing Handshake_ operation SHOULD be delayed
   assuming the physical connection may be reused after some idle
   period.












































Tamplin & Yoshino        Expires January 5, 2013               [Page 27]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


15.  Close the Logical Channel

   To _Close the Logical Channel_, an endpoint MUST send a DropChannel
   multiplex control block with F bit unset.  The endpoint MAY provide
   the reason of failure in the DropChannel block.














































Tamplin & Yoshino        Expires January 5, 2013               [Page 28]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


16.  Fail the Logical Channel

   To _Fail the Logical Channel_, an endpoint MUST send a DropChannel
   multiplex control block with F bit set.  The endpoint MAY provide the
   reason of failure in the DropChannel block.














































Tamplin & Yoshino        Expires January 5, 2013               [Page 29]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


17.  Fail the Physical Connection

   To _Fail the Physical Connection_, an endpoint MUST send a
   DropChannel multiplex control block with objective channel ID of 0
   and F bit set, and then _Fail the WebSocket Connection_ on the
   physical connection with status code of 1002 (TBD).













































Tamplin & Yoshino        Expires January 5, 2013               [Page 30]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


18.  Operations and Events on Multiplexed Connection

   When an endpoint is asked to perform any operation defined in the
   WebSocket Protocol except for _Close the WebSocket Connection_ by
   some application instance, the endpoint MUST perform the operation on
   the corresponding logical channel.  If the operation involves control
   frames, they MUST be encapsulated in EncapsulatedControlFrame
   multiplex control blocks.

   Any event on a logical channel except for _The WebSocket Connection
   is Closed_, MUST be taken as one for the corresponding application
   instance.

   When an endpoint is asked to do _Close the WebSocket Connection_ by
   some application instance, it MUST perform _Close the Logical
   Channel_ on the corresponding logical channel.

   When a DropChannel is received, or the physical connection is closed,
   it MUST be taken as _The WebSocket Connection is Closed_ event for
   the corresponding application instance(s).

   What to set to _Extension In Use_ for each multiplexed connection is
   TBD.




























Tamplin & Yoshino        Expires January 5, 2013               [Page 31]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


19.  Security Considerations

   A client MUST be prepared to receive a NewChannelSlot with huge value
   on the number of slots field.

   Each message should consume quota for some fixed value to prohibit a
   channel sending lots of zero sized message to occupy the physical
   connection (TBD).

   Have upper bound for send quota.









































Tamplin & Yoshino        Expires January 5, 2013               [Page 32]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


20.  IANA Considerations

   This specification is registering a value of the Sec-WebSocket-
   Extension header field in accordance with Section 11.4 of the
   WebSocket protocol [RFC6455] as follows:

   Extension Identifier

      mux

   Extension Common Name

      Multiplexing Extension for WebSockets

   Extension Definition

      This document

   Known Incompatible Extensions

      None






























Tamplin & Yoshino        Expires January 5, 2013               [Page 33]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


21.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC6455]  Fette, I. and A. Melnikov, "The WebSocket Protocol",
              RFC 6455, December 2011.












































Tamplin & Yoshino        Expires January 5, 2013               [Page 34]

Internet-Draft   A Multiplexing Extension for WebSockets       July 2012


Authors' Addresses

   John A. Tamplin
   Google, Inc.

   Email: jat@google.com


   Takeshi Yoshino
   Google, Inc.

   Email: tyoshino@google.com







































Tamplin & Yoshino        Expires January 5, 2013               [Page 35]

