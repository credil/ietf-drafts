<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC1035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2782 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml">
  <!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
  <!ENTITY RFC4193 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4193.xml">
  <!ENTITY RFC4291 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4291.xml">
  <!ENTITY RFC4605 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4605.xml">
  <!ENTITY RFC4944 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4944.xml">
  <!ENTITY RFC5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
  <!ENTITY RFC5785 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5785.xml">
  <!ENTITY RFC5988 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml">
  <!ENTITY RFC6282 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6282.xml">
  <!ENTITY RFC6206 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6206.xml">
  <!ENTITY I-D.cheshire-dnsext-dns-sd SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.cheshire-dnsext-dns-sd.xml">
  <!ENTITY I-D.eggert-core-congestion-control SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.eggert-core-congestion-control.xml">
  <!ENTITY I-D.ietf-6man-uri-zoneid SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-6man-uri-zoneid.xml">
  <!ENTITY I-D.ietf-core-coap SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-coap.xml">
  <!ENTITY I-D.shelby-core-coap-req SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.shelby-core-coap-req.xml">
  <!ENTITY I-D.ietf-core-link-format SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-link-format.xml">
  <!ENTITY I-D.shelby-core-resource-directory SYSTEM
    "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.shelby-core-resource-directory.xml">
  <!ENTITY I-D.vanderstok-core-bc SYSTEM
  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.vanderstok-core-bc.xml">
  <!ENTITY I-D.lynn-core-discovery-mapping SYSTEM
  "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.lynn-core-discovery-mapping.xml">
  <!ENTITY I-D.lynn-dnsext-site-mdns SYSTEM
     "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.lynn-dnsext-site-mdns.xml">
  <!ENTITY I-D.ietf-core-groupcomm SYSTEM
     "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-groupcomm.xml">
   <!ENTITY I-D.shelby-core-interfaces SYSTEM
     "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.shelby-core-interfaces.xml">
   <!ENTITY I-D.jennings-http-srv SYSTEM
     "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.jennings-http-srv.xml">
]>

<!-- Use with the following tips & tools:
      http://xml.resource.org/authoring/draft-mrose-writing-rfcs.html
      http://xml.resource.org/
      http://fenron.net/~fenner/ietf/xml2rfc-valid/
      http://tools.ietf.org/rfcdiff
  -->
      
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.35) -->

<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes"?>

<!-- control the table of contents (ToC) -->
<!-- generate a ToC -->
<?rfc toc="yes"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="2"?>

<!-- control references -->
<!-- use anchors instead of numbers for refs, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="no" ?>

<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<!-- do not start each main section on a new page -->
<?rfc compact="yes" ?>
<!-- "no" to keep one blank line between list items (rfced) -->
<?rfc subcompact="yes" ?>

<!-- encourage use of "xml2rfc" tool -->
<?rfc rfcprocack="yes" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="info" ipr="trust200902" docName="draft-vanderstok-core-dna-00">
  <front>
    <title abbrev="CoRE Discovery, Naming, and Addressing"> CoRE Discovery, Naming, and Addressing </title>

  	<author initials="P.D.V." surname="van der Stok" fullname="Peter van der Stok" role="editor">
  		<organization abbrev="Philips Research">Philips Research</organization>
      <address>
      	<postal>
        	<street>High Tech Campus 34-1</street>
          <city>Eindhoven</city><region></region><code>5656 AA</code>
         	<country>The Netherlands</country>
       	</postal>
  		  <email>peter.van.der.stok@philips.com</email>		
	  	</address>
  	</author>

    <author fullname="Kerry Lynn" initials="K.E." surname="Lynn">
      <organization> Consultant </organization>
      <address>
        <phone> +1-978-460-4253 </phone>
        <email> kerlyn@ieee.org </email>
      </address>
    </author>

<author initials="A." surname="Brandt" fullname="Anders Brandt">
  		<organization abbrev="Sigma Designs">Sigma Designs</organization>
      <address>
      	<postal>
        	<street>Emdrupvej 26A, 1.</street>
          <city>Copenhagen O</city><region></region><code>2100</code>
         	<country>Denmark</country>
       	</postal>
  		  <email>Anders_Brandt@sigmadesigns.com</email>		
	  	</address>
  	</author>

    <date day="29" month="February" year="2012"/>
    <area> Applications </area>
    <workgroup> CoRE </workgroup>

    <abstract>
      <t>
      This is a working document intended to focus discussion and refine
      draft language for the CoAP protocol specification (or other proposed
      standards) in the areas of discovery, naming, and addressing.
      Engineering tradeoffs become more challenging in constrained
      environments; therefore discovery, naming, and addressing are
      considered within the context of adjacent topics that may impact or
      be impacted by design choices in the subject areas.  Special emphasis
      is placed on group definition and discovery.  Examples show how
      groups can be represented in CoAP Resource Directories or DNS-SD.
      </t>
    </abstract>

<!--
    <note title="Requirements Language">
    <t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
    &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
    &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
    &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
    interpreted as described in  <xref target="RFC2119">RFC 2119</xref>.
    </t>
    </note>
-->

  </front>
  <middle>

    <!-- section anchor="sec-1" title="Introduction" -->
    <section title="Introduction">
        <t>
        The CoRE working group is chartered to design and standardize a
        Constrained Application Protocol (CoAP) for resource constrained
        devices and networks <xref target="I-D.ietf-core-coap"/>.  The requirements
        for CoRE are documented in <xref target="I-D.shelby-core-coap-req"/>. This draft
	 discusses the requirements on service discovery for M2M and interactive applications using
	  resource constrained devices.  We propose the use of DNS-SD <xref target="I-D.cheshire-dnsext-dns-sd"/>
	  and Resource Directory (RD) <xref target="I-D.shelby-core-resource-directory"/> to satisfy the requirements.
	  The proposal relies heavily on naming and addressing conventions.  Special emphasis is placed on the
      definition, naming, and discovery of groups.
        </t>

      <!-- section anchor="sec-1.1" title="Terminology" -->
      <section title="Terminology">
        <t>
        The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
        &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
        &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
        &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
        interpreted as described in  <xref target="RFC2119">RFC 2119</xref>.
	Addtional privileged words are described below.
	  </t><t>
	  A "device" is a physical processor connected to at least one
      link through a network interface.  Each interface has at least one IP unicast address.
	  The IP address is optionally bound to a host name, which may be a Fully Qualified Domain Name (FQDN).
        </t><t>
	  An "end-point" corresponds to a "service" and is indentified by a unique {protocol, host, port} tuple.
      The identity of an endpoint may be specified by the 'scheme' and 'authority' parts of a URI <xref target="RFC3986"/>.
      'Protocol' is a label that indicates application and transport protocol bindings as well as default port (if port
      is not specified) and possibly default semantics such as <xref target="RFC5988">web-linking</xref>.  'Host'
      corresponds to the <xref target="RFC3986"/> ABNF production as updated by <xref target="I-D.ietf-6man-uri-zoneid"/>.
        </t><t>
        A "service type", e.g. _bldg-ctrl._tcp, is equivalent to the 'protocol' label described above.  It identifies
        an application protocol, typically defined by a Standards Development Organization (SDO), and is ultimately
        registered with IANA
	<xref target="I-D.cheshire-dnsext-dns-sd"/>. 
	  The SDO may additionally specify service subtypes (e.g. _light, _onoff-control, _air-flow ...) to designate
      units of functionality, the attributes of the subtypes, and the primitives acting on the attributes.
        </t><t>
	Any attribute of an end-point that can be acted upon by REST methods will be represented as a "resource"
    and must be identified by a URI, that is, an end-point plus a 'path' component <xref target="RFC3986"/>.
        </t><t>
      A "Function Set" is a service subtype with a standarized set of resources and behaviors
      that may be accessed through a REST interface.  A Function Set will typically be decribed by a base URI
      plus an interface definition as described in <xref target="I-D.shelby-core-interfaces"/>.  The interface
      definition may specify the naming patterns of subordinate resources and the methods that act on them as defined by
      the SDO.
        </t><t>
	  A "Collection" is a set of two or more homogeneous subordinate resources that may be acted upon in the aggregate
      by sending messages to their parent resource, or individually by sending messages to the collection member.
        </t><t>
	  A "Device type" describes a standardized set of function sets that satisfy a use case for a hosting device.
	  </t><t>
	  A "group" is a set of devices.
        </t><t>
	  A "multicast group" is a group of devices that share a multicast address.  The multicast address
	  is optionally bound to a FQDN that identifies the multicast group.  For the purposes of this
      document, (multicast) groups generally host the same Function Set.
	  </t><t>
      A "scope" is a possible set of devices or groups.  A scope may be realized logically, e.g. as a DNS
	  domain, or a zone which is a unit of delegation (partition) of a domain; physically, e.g. the
      local link; or administratively, e.g. as a set of links.
	  </t>  
      </section>

      <!-- section anchor="sec-1.2" title="Motivation" -->
      <section title="Motivation">
        <t>
        In this draft, we focus and expand discussions on requirements
        pertaining to discovery, naming, and addressing, including REQ8 
	of the CoRE charter:
        </t>
        <figure>
          <artwork><![CDATA[
REQ8:   A definition of how to use CoAP to advertise about or query
        for a Device's description.  This description may include the
        device name and a list of its Resources, each with a URL, an
        interface description URI (pointing e.g. to a Web Application
        Description Language (WADL) document) and an optional name or
        identifier.  The name taxonomy used for this description will
        be consistent with other IETF work, e.g.
        draft-cheshire-dnsext-dns-sd. [charter]
          ]]></artwork>
        </figure>
	<t>
	The basis of this draft originated in <xref target="I-D.vanderstok-core-bc"/>.
	</t>
      </section>

      <!-- section anchor="sec-1.3" title="Applicability" -->
      <section title="Applicability">
        <t>
        TBD
        </t>
      </section>
    </section>

    <!-- section anchor="sec-2" title="Architecture" -->
    <section title="Architecture">
      <t>	
	This section illustrates the aspects of naming
      schemes and their support by DNS-based Service Discovery (DNS-SD) <xref target="I-D.cheshire-dnsext-dns-sd"/>
	, Extended Multicast DNS (xmDNS)  <xref target="I-D.lynn-dnsext-site-mdns"/>, and the
      Resource Directory (RD) <xref target="I-D.shelby-core-resource-directory"/>
	on a set of network architectures.
      </t><t>
       The basic network for low-power nodes can be 
	 composed of low-resource nodes sharing the same IPv6 prefix and connected to low-power links like IEEE 802.15.4, ITU-T G.9959, or Powerline. 
       The "lowpan" is a good example of such a network <xref target="RFC4944"/>, <xref target="RFC6282"/>. The network can be either isolated or connected.
	This draft assumes that application profiles are defined above coap or http, for example,
	applications as specified by the ZigBee Smart Energy Profile 2.0 (SEP2), Obix, or BACnet IT working groups.
	The naming and discovery solutions presented here are applicable to multiple interconnected
	subnets.  Example network architectures are:
      </t>
	<texttable style="none">
	<ttcol> - </ttcol>      <ttcol> 
      An isolated lowpan consists of at least two lowpan devices, one of which is an edge router
      that is not connected to a backbone. A Resource Directory may be
      situated on the edge router. Alternatively, xmDNS responders may execute on
      each device.</ttcol>
      <c> - </c> <c>
      A connected lowpan consists of at least two lowpan devices, one of which is an
      edge router that is connected to a backbone.  A Resource Directory may be
      situated on an edge router. Alternatively, xmDNS responders may execute on
      each device or the DNS-SD service may be available over the
      backbone.</c>
	<c> - </c> <c>
      Interconnected lowpans consist of at least two lowpans
      connected via edge routers to the same backbone. A Resource Directory may be
      situated on each edge router. Alternatively, xmDNS responders may execute on
      each device or the DNS-SD service may be available over the
      backbone.</c>
	<c> - </c> <c>
	A site is a set of interconnected subnets that is locally administered.
	A site may include zero or more lowpans.
	Border routers may prevent some messages from passing into or out of the site.
	</c>
	</texttable>
	<t>
	In certain scenarios, the domain may correspond to the network topology.
	In the general case, the domain and network subnet structure may differ.
      </t>
    </section>

    <!-- section anchor="sec-3" title="Use Cases" -->
    <section title="Use Cases">

	<t>
	The use of service discovery is presented in two environments:
	(1) interactive service discovery, and (2) M2M service discovery.
 	From the use cases we derive
	the types of queries that service discovery should support.
	In particular, a primary motivation is the discovery of groups
 that support a given Function Set.
	</t>

<!-- section anchor="sec-3.1" title="Discovery scope" -->
    <section title="Discovery scope">

	  <t>
	  Service discovery has a scope that can be defined and realized with domain names.
        The authority part of a URI <xref target="RFC3986"/> can express the location of the device hosting the service.
	  A common example is the naming associated with the structure of a building. A device may
	  acquire a FQDN that relates directly to its location in the building. For example,
	  power-strip.office4.floor1.example.com (or shorter ps.o4.f1.example.com) refers to a power-strip
	  with device name "power-strip" (or short "ps") in office4 at floor1 in the building of the company example.com.
	  Another naming scheme can be functional like TV1.media.IT.example.com, possibly refering to TV number 1
	  maintained by the media group of the IT department of the example organisation. 
	  Domain naming can be used to express that devices are situated in the same building area or belong to the same organisational units.
	  Multiple FQDNs can identify a given device.
	 </t><t>
	  The DNS provides the mapping from Fully Qualified Domain Name (FQDN) to network address and vice-versa.
	  The binding of FQDN to a physical device (for example, assigning a given FQDN to the TV 
	  in the corner) depends on the operational conditions as described below.
	</t>
	</section>
	<!-- section anchor="sec-3.2" title="Interactive mapping" -->
    		<section title="Interactive mapping">
	<t>
	  In the residential context, naming of the device is done by the occupant of the home. After connecting
	  the device to the network, an IP-address is assigned, possibly based on the EUI-64 value of the network interface.
        The occupant can use a remote control with a graphical user interface to display all devices that provide
        a given service (e.g. a "lighting" service). The remote control prompts the occupant to identify the
        (default named) devices, possibly accompanied by on/off switching, barcode scanning, or other manual intervention.
	  The occupant can provide a meaningful name that will be bound to that device.
	  The installation steps can be as follows: Service discovery returns all
	  interfaces on which the specified service is available. The occupant, with or without additional physical support,
	  establishes the binding between an IP address (based on MAC address or other unique identifier) and the name of the
      device providing the service, plus its relationship with other devices or function sets in the system. 
	  In some cases a device has multiple names, and an additional mapping between user specified
	  name and an automatically generated DNS name is supported.
	  </t>
	  </section>
	<!-- section anchor="sec-3.3" title="M2M mapping" -->
    		<section title="M2M mapping">
	<t>
	  In the commercial context (e.g. office buildings) it is usual to employ a Comissioning Tool (CT) to
	  provide the mapping from physical device to IP network address or FQDN. The professional context is
	  more rigid than the home because the absence of devices and also the unwanted presence of devices needs to be detected.
	  Devices are named by an architect or installation contractor. Names can be generated automatically and need
	  not be human-friendly. The CT contains the names and the physical locations of the devices. At 
	  commissioning time the interfaces have acquired a network address, possibly based on the EUI-64. The physical
	  device is identified by reading in a unique identifier (e.g. EUI-64 of interface, UUID of device)
	  with a reader (e.g. barcode reader). Consequently,
	  the device name to network address binding
	  is stored into DNS (or elsewhere). Alternatives for identifying devices
	  are pushing buttons on the device or remotely switching on/off the device.
        </t>
	  </section>

      <!-- section anchor="sec-3.4" title="Device and Function Set grouping" -->
    <section title="Function Set grouping">
	<t>
	Groups can be used to express that devices are related (e.g. HVAC equipment controlled by the closest temperature sensor). 
	Grouping is also necessary when a set of Function Sets has to react together, more or less synchronously,
	to a sequence of commands sent by one or more devices. A common example is provided
	by lighting applications where a subset of lights in the building
	are dimmed to the same level, set to the same colour, or switched off simultaneously. Another
	example is provided by a power-strip supporting a set of power-outlets.
	Power-outlets are switched on/off individually or all together. Other examples concern the home, such as
 	a "sleep mode" setting of all media devices in the home when the user activates the night scene.
	</t><t>
	Group naming is done the same way as for device naming. Related devices 
	are grouped and named. The group name is constructed like a FQDN with the group name
        as prefix. Adressing the group can be done in two ways: (1)
	  by addressing each Function Set of the group individually (which requires serial access), or (2) by defining a multicast address for
	  a multicast group.  In the latter case, each hosting device must enable reception of the messages
	  sent to the multicast address. The Function Sets of the multicast group must have identical
	  port number and path, because their values are specified in a single multicast message. 
	</t><t>
	The Function Set can
        contain a collection of resources of the same subtype. The Function Set path postfixed with an identifier
	  refers to the individual resources of the collection.
	  For example: the /path/light points to the resource collection of the service subtype light.
	  Each member of the collection can be identified with /path/light/x, with x in {1,2,3,..}. Consequently,
	  the /path/light/1/onoff specifies
        the onoff resource of collection member 1 of Function Set with /path/light, and
        /path/light/onoff specifies the resource onoff of all collection members
        contained by the Function Set with /path/light.
	When /path/light/onoff is used in a multicast message, it is interpreted as a message to a single light resource
	by devices having only one, and to all members of the collection for devices having several light resources.
        </t><t>
	  It is expected that SDOs will define group naming conventions, 
	  extending the service type name conventions for individual devices.
	</t><t>
        Figure 1 illustrates some of the concepts described above. A device
        is identified with the name "Power-strip".  
	  In the example, no domain names are associated with the
        device, and the name "power-strip" resolves to a Unique Local Address (ULA)<xref target="RFC4193"/>. The device provides 
	  two end-points: one delivers a http service and the second a CoAP service.
        The http server and
        CoAP server share the same IP-address and use different ports 80
        and 61616 respectively.
	  Two different service subtypes, one identified by Function Set, ps,
	  and one identified by Function Set, pm, are supported by one end-point.
        The Function Set "Power strip" contains a collection of four resources, "Outlet 1" to "Outlet 4",
	  each one accessible via the accompanying paths /ps/1 to
        ps/4. The path /ps interfaces to the entire resource collection.
        The attribute "output" is defined
        in the service subtype specification.
	</t><t>
	  TBD...... Relation with  <xref target="I-D.shelby-core-interfaces"/>

        <vspace blankLines='100' />  <!-- page break -->
        </t>
        <figure title="Figure 1: device with end-points, Function Sets and resources" align="center">
          <artwork><![CDATA[
+-------------------------------------------------------------------+
| "Power-strip"                                                     |
| [device] has at least one NIC/IP address, may have a name         |
|                                                                   |
| +---------------------------------------------------------------+ |
| | "HTTP server"                                                 | |
| | [End-point] http://power-strip (at default TCP port 80)       | |
| +---------------------------------------------------------------+ |
|                                                                   |
| +---------------------------------------------------------------+ |
| | "CoAP server"                                                 | |
| | [End-point] coap://power-strip (at default UDP port 61616)    | |
| |                                                               | |
| | +-----------------------------------------------------------+ | |
| | | "Power Meter"                                             | | |
| | | [Function Set] coap://power-strip/pm                      | | |
| | +-----------------------------------------------------------+ | |
| |                                                               | |
| | +-----------------------------------------------------------+ | |
| | | "Power strip"                                             | | |
| | | [Function Set] coap://power-strip/ps                      | | |
| | |                                                           | | |
| | | +-------------------------------------------------------+ | | |
| | | | "Outlet 1"                                            | | | |
| | | | [Collection member] coap://power-strip/ps/1           | | | |
| | | |   [resource] coap://power-strip/ps/1/output           | | | |
| | | |   ...                                                 | | | |
| | | +-------------------------------------------------------+ | | |
| | |                                                           | | |
| | | +-------------------------------------------------------+ | | |
| | | | "Outlet 2"                                            | | | |
| | | | [Collection member] coap://power-strip/ps/2           | | | |
| | | +-------------------------------------------------------+ | | |
| | |                                                           | | |
| | | +-------------------------------------------------------+ | | |
| | | | "Outlet 3"                                            | | | |
| | | | [Collection member] coap://power-strip/ps/3           | | | |
| | | +-------------------------------------------------------+ | | |
| | |                                                           | | |
| | | +-------------------------------------------------------+ | | |
| | | | "Outlet 4"                                            | | | |
| | | | [Collection member] coap://power-strip/ps/4           | | | |
| | | +-------------------------------------------------------+ | | |
| | +-----------------------------------------------------------+ | |
| +---------------------------------------------------------------+ |
+-------------------------------------------------------------------+
          ]]></artwork>
        </figure>
	
	</section>

      <!-- section anchor="sec-3.5" title="Discovery queries" -->
    <section title="Discovery queries">
	<t>
	  Service discovery should support that a device can learn its domain and
	  all the devices within a domain providing a given service (e.g. temperature measurement).
	  Devices need to learn the groups to which they belong and learn all the members of those groups.
      This section motivates that a discovery service supports the following queries:
	</t>
	<texttable style="none">
	<ttcol> Goal </ttcol>      <ttcol> Description </ttcol>
	<c> Name_resolution </c>   <c> Resolve the group or device name to IP address and optional port number </c>
	<c> Return_device </c>              <c> Return all devices supporting a given service (sub-)type within a given domain</c>
	<c> Create_group </c>         <c> Create a group of devices possibly hosting a given service (sub-)type within a given domain </c>
	<c> Enroll_member </c>  <c> Enroll a given device as member of a given group </c>
	<c> Remove_member </c>  <c> Remove a given device as member of a given group </c>
	<c> Return_group </c>  <c> Return all groups of which a given device is a member </c>
	<c> Return_member </c>     <c> Return devices belonging to a given group </c>
	</texttable>
	<t>
	Name_resolution is supported by DNS and CoAP resource discovery. Names are required in the context of home control
    and manual setup of installations.  Names are persistent and meaningful as compared to IP addresses and are preferably 
    used in applications when IP addresses can change.
	</t><t>
	Return_device is the most common use of service discovery and was originally dsigned for interactive use. 
	The canonical IT example is finding all printers within a zone, which allows a user to select the
	desired printer from the returned list. Another example is in the context of UPnP <xref target="UPNP"/>, where all media players
	are returned on a screen and the user can select the desired media player on the screen and play the selected
	content. In M2M applications, the returned names are not displayed on a screen but
	an application uses the returned list to select a (set of) Function Set(s) to control.
	Consequently, names in M2M applications need not be human interpretable (for example, they can be unique numbers).
      </t><t>
	Create_group is useful in commissioning scenarios, where devices need to be grouped to receive the same command
	in a possibly synchronous fashion. Groups can also be created to express relations between devices
	such as ownership. The command creates a group name and creates a list of the members of the group. When
	the group is a multicast group, the command defines a unique multicast address and port, and specifies the path.
	</t><t>
	Enroll_member supports network and device reconfiguration. When the physical lay-out 
	of an installation changes because devices are added, changed or removed, the associated groups also need to be modified.
	</t><t>
	Remove_member, see motivation under Enroll_member
	</t><t>
	Return_group is needed to learn the groups of which a device is member.
	The command is necessary for commissioning purposes where a Commissioning Tool (CT) is used. The CT,
	on the basis of designs provided by architects, decorators, sound/light engineers, defines groups and group
	members and stores that information in the service discovery database. In the next phase, the members of a group need to learn
	their membership from the service discovery to enable reception of messages. 
	</t><t>
	Return_member can be used to learn which devices are member of a given group. This command is useful in connection with Return_group.
	The device knowing to which groups it belongs can establish communication with the group members. For example, 
	membership of a group instructs
	new devices, replacing faulty ones, which other devices share access rights or need to be consulted regularly.
	</t>
	
	</section>

      <!-- section anchor="sec-3.6" title="Sleeping devices" -->
    <section title="Sleeping devices">
	<t>
	This section suggests that service discovery of sleeping devices is mostly a matter of discovering the proxy.
	 It is expected that a proxy will handle communications for the sleeping device.
	The message sent to the sleeping device is directed to the proxy. The proxy will send the message on with a delay,
	or send the result of a function on the history of messages, when the sleeping device is ready. The communication protocol
	between proxy and sleeping device is currently proprietary, but efforts are under way to standardize. 
	The setting up of the proxy is preferably standardized for a large set of proxy types.
	During the setting-up process, (offline or online) the proxy will take over all the entry-points of the sleeping device.
	The entry-points of the proxy can be entered into the discovery respository and consequently discovered like any other device.
	</t><t>
	For groups, two cases need to be considered (1) sleeping device is member of a group and receives group messages,
	and (2) the sleeping device sends messages to a group.
	Ad (1), when the sleeping device needs to receive messages sent to a group, the proxy will receive those messages
	and the Function Set of the proxy is entered as group member to receive the group messages. Ad (2) When the sleeping device sends messages to a group,
	it is preferable that the sleeping device sends just one multicast message to the group to minimize energy costs. It is required
	 that when one member of the group receives the message, all other 
	group members receive it as well (unanimity), covered by the "reliability" REQ1 in <xref target="I-D.ietf-core-groupcomm"/>). 
	A simple broadcast over a lowpan will not always succceed and additional
	multicast algorithms like Trickle <xref target="RFC6206"/> need to be introduced.
	</t>

	</section>
	</section>

      <!-- section anchor="sec-4" title="DNS and RD examples" -->
    <section title="DNS and RD examples">
	<t>
	The following device configuration and environment are assumed for the examples. The devices are placed on floor-x (fx)
	in two rooms room-y (ry) and room-z (rz). Both rooms contain a powerstrip with a powermeter and four power outlets.
	In each room there are two luminaires and one presence sensor (PIR). Each luminaire contains a dimmable light and a 
	light sensor. Per floor there is a clock to set day and night time modes of the
	devices. The domains are: ry.fx.bldg.org, rz.fx.bldg.org and fx.bldg.org. The device names of the 4 luminaires are lm00203, 
	lm00204, lm00205, and lm00206. The device names of the two powerstrips are ps0057, and ps0078. The paths of the Function Sets of
	the luminaire are: /lamp with resource /lamp/dim for the dimmable light, 
	and /light with resource /light/lumen for the light sensor. The
	Function Set path for four outlets is /ps with resource /ps/output. 
	The path of each individual outlet is /ps/x with x in {1,2,3,4}, and with resource ps/x/output.
	The name of the two PIRs is pir. The entry-point path of the PIR is /occup, also being the resource.
	</t><t>
	Relating location to the domain name is a relevant example of domain naming. Multiple domain names,
	related to other application aspects, can be specified and applied simultaneously.
	</t><t>
	Separate subsections provide examples for discovery of devices and of groups. As described in section 3,
	devices do not announce themselves to the discovery repository, as usual for IT applications, but they are entered
	(partially) with the aid of a central tool, for example a Remote Control, dedicated device, IPAD or other means.
	</t>

  <!-- section anchor="sec-4.1" title="DNS-SD examples" -->
    <section title="DNS-SD examples">
	<!-- section anchor="sec-4.1.1" title="Basic Concepts" -->
    <section title="Basic Concepts">
	<t>
	In conformance with <xref target="I-D.cheshire-dnsext-dns-sd"/>, DNS-based discovery uses
    A or AAAA, PTR, SRV, and TXT Resource Records (RR). The SRV RR <xref target="RFC2782"/>
    specifies an endpoint.  An associated (identically named) TXT RR can contain a URI path.
    Together the associated SRV and TXT RRs can specify a Function Set.  An A or AAAA RR 
    <xref target="RFC1035"/> binds a device name or multicast group name to an IP address.
	The PTR RR binds a service type to an end-point, or a service subtype to a Function Set.
	</t><t>
    In cases where the end-point port may be dynamic, e.g. in the IPHC <xref target="RFC6282"/>
    compressible range, a new 'coap+srv' scheme is proposed (after <xref target="I-D.jennings-http-srv"/>).
    The authority part of a coap+srv URI specifies the name and location of an SRV record,
    which in turn contains values for host (IP address) and port. 
    </t>
	</section>

	<!-- section anchor="sec-4.1.2" title="Commissioning devices" -->
    <section title="Commissioning devices">
	<t>
	Commissioning is the process to store the relation between a FQDN and a device.
	It is assumed that either a Remote Control (RC) in the home or a Commissioning Tool (CT) in the 
	professional domain store the relation in DNS. 
	</t><t>
	In the professional domain, the CT is assumed to
	contain information about the devices as prescibed by architect or installation company. The
	information in the CT contains device name, device domain name, and location in the building, 
	but the relation with the installed processor, identified with an unique identifier (e.g. EUI-64) is
	not established. By reading a bar code (or pushing buttons, switching on/off equipment, etc.),
	the CT learns the identifier of the device to be commissioned.
	All kinds of techniques can be used to establish the relation between IP address and unique identifier.
	When the identifier is the EUI-64 value, the IP address of the device can be constructed.
	When the identifier is not the EUI-64, a proprietary procol can be used to ask a given device its identifier. Etc. etc.
	The CT can learn the Function Sets (services) available on the device by querying /.well-known/core.
	In some cases the CT already obtained the Function Sets from a configuration file.
	Given these data, the CT can enter the devices and its services into DNS.
	Either automatically, or on instructions of an operator, the CT defines the groups in the DNS.
	</t><t>
	The home domain is different from the professional domain in the sense that no configuration information exists.
	The RC can for example use xmDNS to learn the addresses of all the devices present in its site. The RC
	can query devices for the presence of a given service. The RC can query DNS for its own domain name and use that for the
	other devices in the site. Once (new) devices are named, this information can be stored in DNS for use in the network.
	</t>
	</section>


<!-- section anchor="sec-4.1.3" title="device examples" -->
    <section title="device examples">
	<t>
	The relation between device name and IP address is expressed for the example devices in the following table.
	</t>
	<texttable style="none">
	<ttcol>lm00203.ry.fx.bldg.org.          </ttcol>   <ttcol> IN AAAA </ttcol> <ttcol> fdfd::1234 </ttcol> 
	<c> lm00204.ry.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> fdfd::1235 </c> 
	<c> ps0057.ry.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> fdfd::1236 </c> 
	<c> pir.ry.fx.bldg.org.       		   </c>  <c>  IN AAAA </c>  <c> fdfd::1237 </c> 
	<c> lm00205.rz.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> fdfd::1238 </c> 
	<c> lm00206.rz.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> fdfd::1239 </c> 
	<c> ps0058.rz.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> fdfd::1240 </c> 
	<c> pir.rz.fx.bldg.org.  		   </c>  <c>  IN AAAA </c>  <c> fdfd::1241 </c> 
	<c> clock.fx.bldg.org.        		   </c>  <c>  IN AAAA </c>  <c> fdfd::1242 </c> 
	</texttable>
	<t>
	The next part defines the Function Sets related to the device names.
	The names of the SRV RRs (Function Sets) need to be unique to the DNS server.
	The names of the Function Sets are valid within the authority zone, bldg.org, of the name server.
	Consequently, lamp1 is short for lamp1.bldg.org, sensor1 for sensor1.bldg.org, etc.
	The luminaires with name "lm00xxx" host two Function Sets: a lamp and a sensor.
	</t>
	<texttable style="none">
	<ttcol> lamp1     </ttcol>   <ttcol> IN SRV </ttcol> <ttcol> 0 0 Port </ttcol>  <ttcol> lm00203.ry.fx.bldg.org          </ttcol> 
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c> 
	<c> sensor1     </c>   <c> IN SRV </c>  <c>0 0 Port </c> <c> lm00203.ry.fx.bldg.org          </c> 
	<c>        </c>  <c>  IN TXT </c>  <c> path=/light </c> <c>  </c>
	<c> lamp2     </c>   <c> IN SRV </c>  <c>0 0 Port </c>  <c> lm00204.ry.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c>	
	<c> sensor2     </c>   <c> IN SRV </c>  <c>0 0 Port </c>   <c> lm00204.ry.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/light </c> <c>  </c>
	<c> powerc1     </c>   <c> IN SRV </c>  <c>0 0 Port </c>  <c> ps0057.ry.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/ps </c> <c>  </c>
	<c> presence1     </c>   <c> IN SRV </c>  <c>0 0 Port </c>   <c> pir.ry.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/occup </c> <c>  </c>
	<c> lamp3    </c>   <c> IN SRV </c>  <c>0 0 Port </c>  <c> lm00205.rz.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c>
	<c> sensor3     </c>   <c> IN SRV </c> <c>0 0 Port </c>  <c> lm00205.rz.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/light </c> <c>  </c>
	<c> lamp4     </c>  <c> IN SRV </c> <c>0 0 Port </c>  <c> lm00206.rz.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c>
	<c> sensor4    </c>   <c> IN SRV </c>  <c>0 0 Port </c>  <c> lm00206.rz.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/light </c> <c>  </c>
	<c> powerc2    </c>  <c> IN SRV </c> <c>0 0 Port </c>  <c> ps0058.rz.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/ps </c> <c>  </c>	
	<c> presence2     </c>  <c> IN SRV </c> <c>0 0 Port </c>  <c> pir.rz.fx.bldg.org          </c>
	<c>        </c>  <c> IN TXT </c>  <c> path=/occup </c> <c>  </c>
	<c> timer     </c>  <c> IN SRV </c> <c>0 0 Port </c>   <c> clock.fx.bldg.org          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/time </c> <c>  </c>
	</texttable>
	<t>
	The above list of SRV RRs specifies the attributes of the Function Sets: devices, port numbers,
	IP addresses and path with the accompanying AAAA and TXT records. The names of the SRV records
	can be created automatically, as long as they identify the SRV records uniquely
	within the set of RR entries in the DNS zone.
	The SRV record with name powercx (x = 1,2) stands for power collection x, accessed via the
	path /ps which refers to a Function Set that contains a collection of two resources.
	</t><t>
	Assuming that the service type "_bc" has the service subtype "_lamp", the names of the SRV RRs can 
	also be created from the service subtype prefixed by the EUI-64 value.
	With the service subtype "_lamp" and EUI-64 value "1234" the SRV name 1234_lamp can be created automatically instead of lamp1.
	</t><t>
	PTR records enable the service discovery. The names of the PTR records are the names of the service
	types, defined by IANA, and they refer to the names of the SRV records. 
	To support the query "all lamps within fx.bldg.org", the following
	PTR records need to be added for service subtype:_lamp._sub._bc._udp.
	</t>
	<texttable style="none">
	<ttcol> _lamp._sub._bc._udp.bldg.org         </ttcol>   <ttcol> IN PTR </ttcol>   <ttcol> lamp1.bldg.org     </ttcol>
	<c> _lamp._sub._bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> lamp2.bldg.org     </c>
	<c> _lamp._sub._bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> lamp3.bldg.org     </c>
	<c> _lamp._sub._bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> lamp4.bldg.org     </c>
	</texttable>
	<t>
	Equally to query to all services within a domain, PTR records 
	with as name the building control service, "_bc.udp", refer to all SRV records describing Function Sets.
	</t>
	<texttable style="none">
	<ttcol> _bc._udp.bldg.org     </ttcol>   <ttcol> IN PTR </ttcol>   <ttcol> lamp1.bldg.org     </ttcol>
	<c> _bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> lamp2.bldg.org     </c>
	<c> _bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> sensor1.bldg.org     </c>
	<c> _bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> power1.bldg.org     </c>
	<c> _bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> presence1.bldg.org     </c>
	<c> _bc._udp.bldg.org     </c>   <c> IN PTR </c>   <c> etc, etc.     </c>
	</texttable>
	<t>
	It is shown above how PTR records support the queries filtered on service type. Filtering on domain
	can be done adding additional PTR records which select the devices of a given type within a given domain.
	The set of PTR records below filters on all lamps within domain ry.fx.
	</t>
	<texttable style="none">
	<ttcol> _lamp._sub._bc._udp.ry.fx.bldg.org.     </ttcol>   <ttcol> IN PTR </ttcol>   <ttcol> lamp1.bldg.org     </ttcol>
	<c> _lamp._sub._bc._udp.ry.fx.bldg.org.     </c>   <c> IN PTR </c>   <c> lamp2.bldg.org     </c>
	</texttable>
    </section>

 <!-- section anchor="sec-4.1.4" title="Group examples" -->
<section title="Group examples">

	<t>
	As an example, five multicast-groups are defined to group all lamps on floor "fx", all lamps in office "ry",
	all lamps in office  "rz",
	all power-strips on floor "fx", and all devices in the building controlled by a central timer.
	The multicast-group names are entered into DNS like the device names to enable resolution
	from multicast-group name to multicast address. 
	</t>
	<texttable style="none">
	<ttcol> lamp-fx.fx.bldg.org.          </ttcol>   <ttcol> IN AAAA </ttcol>  <ttcol> ff15::11 </ttcol> 
	<c>  lamp-ry.ry.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> ff15::12 </c>
	<c>    lamp-rz.rz.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> ff15::13 </c>
	<c>   power-fx.fx.bldg.org.          </c>  <c>  IN AAAA </c>  <c> ff15::14 </c>
	<c>   timer-bldg.bldg.org.          </c>  <c>  IN AAAA </c>  <c> ff15::15 </c>
	</texttable>
	<t>
	It is expected that SDOs will specify naming conventions for group names, extending the service (sub)type names
	for devices.
	</t><t>
	The path and port of the multicast-groups is defined with SRV and TXT RRs. (Remark lampgp1 is short for lampgp1.bldg.org, etc.)
	</t>
	<texttable style="none">
	<ttcol> lampgp1     </ttcol>   <ttcol> IN SRV </ttcol> <ttcol>0 0 Port </ttcol>  <ttcol> lamp-fx.fx.bldg.org.          </ttcol> 
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c> 
	<c> lampgp2     </c>   <c> IN SRV </c> <c> 0 0 Port </c>  <c> lamp-ry.ry.fx.bldg.org.          </c> 
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c>
	<c> lampgp3     </c>   <c> IN SRV </c> <c> 0 0 Port </c>    <c> lamp-rz.rz.fx.bldg.org.          </c> 
	<c>        </c>  <c>  IN TXT </c>  <c> path=/lamp </c> <c>  </c>
	<c> powergp    </c>  <c> IN SRV  </c> <c> 0 0 Port </c>   <c> power-fx.fx.bldg.org.          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/ps </c> <c>  </c>
	<c> timergp    </c>  <c> IN SRV  </c> <c> 0 0 Port </c>   <c> timer-bldg.bldg.org.          </c>
	<c>        </c>  <c>  IN TXT </c>  <c> path=/tm </c> <c>  </c>	
	</texttable>
	<t>
	The groups for the power strips need extra attention because the power strips include a collection of resources.
	The path to the group can be defined as /ps or as /ps/x with x in {1,2,3,4}. When using /ps/x the group contains the outlet x
	of the power strips. Using the path /ps as done in the table above refers to all outlets of a powerstrip.
	When sending a message to the power-fx group with as path /ps/x then the message will be received by Function Sets
	with path ps/x only.
	</t><t>
	The members of the groups can be stored in DNS by using the reverse DNS resolution technique.
	It is not unusual that a given IP address refers to multiple FQDNs. Extrapolating to
	group names extends the reverse DNS resolution in a natural manner. Below the members of group lamp-fx.fx.bldg.org
	with IP address ff15::11 containing all four lamps is shown.
	</t>
	<texttable style="none">
	<ttcol> 1.1.0.....0.5.1.f.f.IP6.arpa.     </ttcol>   <ttcol> IN PTR </ttcol>   <ttcol> lm00206.rz.fx.bldg.org.     </ttcol>
	<c>     1.1.0.....0.5.1.f.f.IP6.arpa.     </c>   <c> IN PTR </c>   <c> lm00205.rz.fx.bldg.org.      </c>
	<c>     1.1.0.....0.5.1.f.f.IP6.arpa.     </c>   <c> IN PTR </c>   <c> lm00204.ry.fx.bldg.org.       </c>
	<c>     1.1.0.....0.5.1.f.f.IP6.arpa.     </c>   <c> IN PTR </c>   <c> lm00203.ry.fx.bldg.org.     </c>
	<c>     1.1.0.....0.5.1.f.f.IP6.arpa.     </c>   <c> IN PTR </c>   <c> lamp-fx.fx.bldg.org.     </c>
	</texttable>
	<t>
	With the above table queries like all members of lamp-fx can be answered.
	
	</t><t>
	Additional tables are needed to specify the multicast groups to which the Function Set of
	a device belongs. A PTR RR with the name of the Function Set can refer to the name of the group. In the table below
	the Function Set "lamp1" is part of the groups "lamp-fx", "lamp-ry" and "timer-bldg":
	</t>
	<texttable style="none">
	<ttcol> lamp1.bldg.org     </ttcol>   <ttcol> IN PTR </ttcol>   <ttcol> lamp-fx.fx.bldg.org     </ttcol>
	<c> lamp1.bldg.org     </c>   <c> IN PTR </c>   <c> lamp-ry.ry.fx.bldg.org      </c>
	<c> lamp1.bldg.org     </c>   <c> IN PTR </c>   <c> timer-bldg.bldg.org         </c>
	</texttable>
	<t>
	Consequently, a device can query DNS for the groups to which its Function Sets belong, and consecutively enable the reception of the
	associated multicast messages.
	
	</t>
	</section>

	<!-- section anchor="sec-4.1.5" title="Discovery validation" -->
    <section title="Discovery validation">
	<t>
	This section describes how the disovery requirements are met with DNS-SD.
	</t>
	</section>


	</section>

	<!-- section anchor="sec-4.2" title="RD examples" -->
    <section title="RD examples">
	<t>
	Resource discovery in CoAP handles resource paths (called links) for the resources hosted on the server,
	 augmented with attributes of these resources. A well-known path "/.well-known/core" <xref target="RFC5785"/> is a default entry-point for requesting
	 the list of links on a given server <xref target="I-D.shelby-core-resource-directory"/>.
	The Resource Directory (RD) stores links to resources hosted by other servers.
	The link-format <xref target="I-D.ietf-core-link-format"/>  defines link extensions to specify
	 the service type and service instance as used by DNS-SD. When querying the Resource Directory for links, filters can be applied 
	to return only links with specified attribute values. A node learns the IP-address of the RD by for example sending a multicast request to a
	 predefined multicast address registered with IANA, or by assuming that the RD is located in the edge router.
	</t><t>
	Contrary to DNS-SD, the RD has not defined a process which permits SDOs to specify service (sub)types.
	Consequently, the same service type examples are used for DNS-SD as for RD, where service type postfixed with subtype (DNS) 
	equals "resource type" (RD),
	and Function Set (SRV) name (DNS) equals "Instance" (RD).
	</t><t>
	This draft adheres to the mapping between DNS and link-format, described in <xref target="I-D.lynn-core-discovery-mapping"/>.
	</t>

	<!-- section anchor="sec-4.2.1" title="Commissioning devices" -->
    <section title="Commissioning devices">
	<t>
	It is assumed that either a Remote Control (RC) in the home or a Commissioning Tool (CT) in the 
	professional domain is used to fill in the RD.
	devices cannot enter links into the RD contrary to the suggestion in <xref target="I-D.shelby-core-resource-directory"/>. 
	Both the RC or the CT have to fill in the RD, because at link creation
	the RD generates a location
	of the link-entry (e.g. /ed/453), that is returned to the
	creator of the link. Consequently, the CT or the RD need to create the link, because they need the location
	 to update the link with additional information.
	</t><t>
	In the professional domain, the CT learns the identity
	of the device as described earlier, reads the services of the devices with a GET to /.well-known/core on the device,
	and stores them into the RD. 
	</t><t>
	In the home domain, the RC
	can read in the EUI-64 of the device to be entered. The user types in domain names and device names on the RC.
	Consecutively, the RC follows the same procedure as the CT.
	</t>
	</section>

	<!-- section anchor="sec-4.2.2" title="Device examples" -->
    <section title="Device examples">
	<t>
	For convenience, it is assumed that DNS contains the mapping from FQDN to IP address with AAAA RRs
	 and vice-versa with PTR RRs.
	In all examples the FQDN is used and not the IP-address. It is assumed that the service type "_bc" has the subtypes:
	"_lamp", "_sensor", "_strip", "_pir", and "_clock".
	Registration is done with the following statements by CT or RC to the RD with authority: //rd.example.com/ and path /rd.
	</t>
	<figure>
<artwork><![CDATA[
	POST coap://rd.example.com/rd?h="lm00203";d="ry.fx.bldg.org"
	Etag: 0x21
	Payload:
	</lamp>;rt="_bc._lamp";ins="lamp1"
	</light>;rt="_bc._sensor";ins="sensor1"
	Res: 2.01 created
	Location: /rd/1234
 ]]></artwork>
	</figure>
	<t>
	Leaving out Etag:, Res:, and Location: lines, the other Function Sets are defined with:
</t>
	<figure>
<artwork><![CDATA[
	POST coap://rd.example.com/rd?h="lm00204";d="ry.fx.bldg.org"
	Payload:
	</lamp>;rt="_bc._lamp";ins="lamp2"
	</light>;rt="_bc._sensor";ins="sensor2"

	POST coap://rd.example.com/rd?h="lm00205";d="rz.fx.bldg.org"
	Payload:
	</lamp>;rt="_bc._lamp";ins="lamp3"
	</light>;rt="_bc._sensor";ins="sensor3"

	POST coap://rd.example.com/rd?h="lm00206";d="rz.fx.bldg.org"
	Payload:
	</lamp>;rt="_bc._lamp";ins="lamp4"
	</light>;rt="_bc._sensor";ins="sensor4"

	POST coap://rd.example.com/rd?h="ps0057";d="ry.fx.bldg.org"
	Payload:
	</ps>;rt="_bc._strip";ins="powerc1"
	</ps/1>;rt="_bc._strip";ins="outlet1"
	</ps/2>;rt="_bc._strip";ins="outlet2"
	</ps/3>;rt="_bc._strip";ins="outlet3"
	</ps/4>;rt="_bc._strip";ins="outlet4"

	POST coap://rd.example.com/rd?h="ps0058";d="rz.fx.bldg.org"
	Payload:
	</ps>;rt="_bc._strip";ins="powerc2"
	</ps/1>;rt="_bc._strip";ins="outlet5"
	</ps/2>;rt="_bc._strip";ins="outlet6"
	</ps/3>;rt="_bc._strip";ins="outlet7"
	</ps/4>;rt="_bc._strip";ins="outlet8"

	POST coap://rd.example.com/rd?h="pir";d="ry.fx.bldg.org"
	Payload:
	</occup>;rt="_bc._pir";ins="presence1"

	POST coap://rd.example.com/rd?h="pir";d="rz.fx.bldg.org"
	Payload:
	</occup>;rt="_bc._pir";ins="presence2"

	POST coap://rd.example.com/rd?h="clock";d="fx.bldg.org"
	Payload:
	</time>;rt="_bc._clock";ins="timer"
 ]]></artwork>
	</figure>
	<t>
	The "ins" value identifies the Function Set uniquely within the resources attached to the RD,
	in the same fashion as done for SRV RRs.
	It is also possible to postfix the EUI-64 value to the service subtype name, (e.g. ins="pir1241"
	instead of "presence2").
	</t>

	</section>
	<!-- section anchor="sec-4.2.3" title="Group examples" -->
    <section title="Group examples">
	<t>
	The same five multicast groups of the DNS example are used. The group name to address mapping is specified
	in DNS with AAAA RRs.
	In all examples the group name is used and not the IP-address.
	Registration is done with the following statements by CT or RC to the RD with authority: /rd.example.com/ and path /rd,
	leaving out Etag:, Res:, and Location: lines.
	</t>
	<figure>
<artwork><![CDATA[
	POST coap://rd.example.com/rd?h="lamp-fx";d="fx.bldg.org"
	Payload:
	</lamp>;rt="_bc._lamp";ins="lampgp1"

	POST coap://rd.example.com/rd?h="lamp-ry";d="ry.fx.bldg.org"
	Payload:
	</lamp>;rt="_bc._lamp";ins="lampgp2"

	POST coap://rd.example.com/rd?h="lamp-rz";d="rz.fx.bldg.org"
	Payload:
	</lamp>;rt="_bc._lamp";ins="lampgp3"

	POST coap://rd.example.com/rd?h="power-fx";d="fx.bldg.org"
	Payload:
	</ps>;rt="_bc._strip";ins="powergp"

	POST coap://rd.example.com/rd?h="timer-bldg";d="bldg.org"
	Payload:
	</time>;rt="_bc._clock";ins="timergp"
 ]]></artwork>
	</figure>
	<t>
	With the above statements the groups are defined in the RD. However, there is no straight forward mechanism
	to define the members of a multicast group, or to define the inverse: the groups to which a Function Set belongs.
	</t>
	</section>

	<!-- section anchor="sec-4.2.4" title="Discovery validation" -->
    <section title="Discovery validation">
	<t>
	This section describes how the disovery requirements are met with the RD.
	</t>
	</section>

	</section>

    </section>

    <!-- section anchor="IANA" title="IANA Considerations" -->
    <section title="IANA Considerations">
      <t>This document makes no request of IANA.</t>
      <t>Note to RFC Editor: this section may be removed on publication as an RFC.</t>
    </section>

    <!-- section anchor="Security" title="Security Considerations" -->
    <section title="Security Considerations">
      <t>
      TBD
      </t>
    </section>

    <!-- section anchor="Acknowledgements" title="Acknowledgements" -->
    <section title="Acknowledgments">
      <t>
      Zach Shelby wrote the original Discovery section in <xref target="I-D.ietf-core-coap"/>
      which forms the basis for this draft. This I-D has benefited from conversations with and comments from
      Emmanuel Frimout, Michael Verschoor, Jamie Mc Cormack, Oscar Garcia,
      Dee Denteneer, Joop Talstra, Jerald Martocci,
	Matthieu Vial, Jerome Hamel, George Yianni, and Nicolas Riou.
      </t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      &RFC1035;
	  &RFC2119;
	  &RFC2782;
      &RFC3986;
	  &RFC4193;
      &RFC4291;
      &RFC4605;
	  &RFC4944;
      &RFC5234;
      &RFC5785;
      &RFC5988;
	  &RFC6282;
	  &RFC6206;
    </references>
    
    <references title="Informative References">
      &I-D.cheshire-dnsext-dns-sd;
      &I-D.eggert-core-congestion-control;
      &I-D.ietf-6man-uri-zoneid;
      &I-D.ietf-core-coap;
	  &I-D.ietf-core-groupcomm;
      &I-D.ietf-core-link-format;
	  &I-D.lynn-core-discovery-mapping;
      &I-D.lynn-dnsext-site-mdns;
      &I-D.shelby-core-coap-req;
	  &I-D.shelby-core-interfaces;
	  &I-D.shelby-core-resource-directory;
      &I-D.vanderstok-core-bc;
      &I-D.jennings-http-srv;


      <reference anchor="ZeroConf">
        <front>
          <title>Zero Configuration Networking: The Definitive Guide</title>
          <author initials="S." surname="Cheshire" fullname="Stuart Cheshire"/>
          <author initials="D.H." surname="Steinberg" fullname="Daniel H. Steinberg"/>
          <date year="2006"/>
        </front>
        <seriesInfo name="O'Reilly Media, Inc." value=""/>
        <seriesInfo name="ISBN" value="0-596-10100-7"/>
      </reference>

     <reference anchor="UPNP">
        <front>
          <title>Universal Plug and Play</title>
		<author fullname="UPnP working group"/>
          <date year="2012"/>
        </front>
        <seriesInfo name="Web" value="http://www.upnp.org"/>
      </reference>
    </references>
  </back>
</rfc>
