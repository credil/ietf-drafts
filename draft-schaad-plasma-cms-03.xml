<?xml version="1.0" encoding="UTF-8"?><?rfc linefile="1:eps.xml"?>
<!-- automatically generated by xml2rfc v1.35 on 2013-01-12T01:09:49Z -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!-- xml2rfc-processed-entity RFC2119 -->
  <!-- xml2rfc-processed-entity RFC2630 -->
  <!-- xml2rfc-processed-entity RFC3369 -->
  <!-- xml2rfc-processed-entity RFC4262 -->
  <!-- xml2rfc-processed-entity RFC5198 -->
  <!-- xml2rfc-processed-entity RFC5321 -->
  <!-- xml2rfc-processed-entity RFC5752 -->
  <!-- xml2rfc-processed-entity RFC5890 -->
  <!-- xml2rfc-processed-entity RFC6530 -->
  <!-- xml2rfc-processed-entity RFC5084 -->

  <!-- xml2rfc-processed-entity ESS-BASE -->
  <!-- xml2rfc-processed-entity CMS -->
  <!-- xml2rfc-processed-entity CMS-ASN -->
  <!-- xml2rfc-processed-entity CMS-AED -->
  <!-- xml2rfc-processed-entity SMIME-MSG -->
  <!-- xml2rfc-processed-entity AED-RANT -->
  <!-- xml2rfc-processed-entity SMIMEv3-MSG -->
  <!-- xml2rfc-processed-entity SMIME-MSG -->


  <!-- xml2rfc-processed-entity PLASMA-WS-TRUST -->

  <!-- xml2rfc-processed-entity PLASMA-ASN -->
  <!-- xml2rfc-processed-entity PLASMA-CT -->
  <!-- xml2rfc-processed-entity PLASMA-OKA -->
  <!-- xml2rfc-processed-entity PLASMA-URL-ATTR -->
  <!-- xml2rfc-processed-entity PLASMA-HASH-ATTR -->
  <!-- xml2rfc-processed-entity PLASMA-SMIMECAP -->
  <!-- xml2rfc-processed-entity PLASMA-AUDIT -->
  <!-- xml2rfc-processed-entity PLASMA-SIGNER-INFO -->
  <!-- xml2rfc-processed-entity PLASMA-XACML-ATTR -->
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xlst' ?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc comments="yes"?>
<!-- 
Need keys in the send message URL item.
-->


<rfc category="std" docName="draft-schaad-plasma-cms-03" ipr="trust200902">
  <front>
    <title abbrev="PLASMA ASN.1">Plasma Service Cryptographic Message Syntax (CMS) Processing</title>
    <author fullname="Jim Schaad" initials="J." surname="Schaad">
      <organization>Soaring Hawk Consulting</organization>
      <address>
        <email>ietf@augustcellars.com</email>
      </address>
    </author>
    <date/>
    <abstract>
      <t>
        Secure MIME (S/MIME) defined a method of placing security labels on a Cryptographic Message Syntax (CMS) object.
        These labels are placed as part of the data signed and validated by the parties.
        This means that the message content is visible to the recipient prior to the label enforcement.
        A new model for enforcement of policy using a third party is described in RFC TBD <xref target="I.D-draft-freeman-plasma-requirements"/>.
        This is the Policy Augmented S/MIME (PLASMA) system.
        This document provides the details needed to implement the new Plasma model in the CMS infrastructure.
      </t>

      <t>
        An additional benefit of using the Plasma module is that the server, based on policy, manages who has access to the  message and how the keys are protected.
      </t>
      
      <t>
        The document details how the client encryption and decryption processes are performed, defines how to construct the CMS recipient info structure, a new content to hold the data required for the Plasma server to store the keys and policy information.
        The document does not cover the protocol between the client and the Plasma policy enforcement server.
        One example of the client/server protocol can be found in RFC TBD <xref target="plasma-token"/>.
      </t>
    </abstract>
<!--    <keywords>CMS, Plasma, S/MIME, policy</keywords> -->
  </front>
  <middle>

    <section title="Introduction">

      <t>
        In the traditional S/MIME (Secure MIME) e-mail system, the sender of a message is responsible for determining the list of recipients for a message, obtaining a valid public or group key for each recipient, applying a security label to a message, and sending the message.
        The recipient of a message is responsible for the enforcement of any security labels on the message.
        While this system works in theory, in practice it has some difficulties that have led to problems in getting S/MIME mail widely deployed.
        This document is part of an effort to provide an alternative method of allocating the responsibilities above to different entities in an attempt to make the process work better.
      </t>

      <t>
        In a Policy Augmented S/MIME (PLASMA) deployment of S/MIME, the sender of the message is still responsible for determining the list of recipients for the message and determining the security label to be applied to the message; however the Plasma server is now responsible for obtaining valid keys for recipients and checking the policy access for the recipients.  The recipient is no longer responsible for enforcement of the policy as this is off-loaded to the Plasma server component.  Doing this allows for the following changes in behavior of the system:

        <list style="symbols">
          <t>The sender is no longer responsible for finding and validating the set of public keys used for the message.  This simplifies the complexity of the sender and lowers the resources required by the sender.  This is especially true when a large number of recipients are involved.</t>
          <t>The set of recipients that can decrypt the message can be change dynamically after the message is sent, without resorting to a group keying strategy.</t>
          <t>The enforcement of the policy is done centrally, this means that updates to the policy are instantaneous and the enforcement policy can be centrally audited.</t>
          <t>The label enforcement is done before the message is decrypted; this means there are no concerns about the message contents being leaked by poor client implementations.</t>
          <t>Many of the same components used in a web-based deployment of policy enforcement in a confederation can be used for e-mail based deployment of information.  This includes using credentials other than X.509 certificates.</t>
        </list>
      </t>

      <t>
        While this document describes the processes in terms of dealing with email system, a Plasma server can be used with any number of clients that need to protected content.  Thus the same system could be used for protection of documents without having to specify in advance the individuals who should be able to open the document; it would just be allowed by the server based on the policy applied to the document.
      </t>

      <t>This document is laid out as follows:
        <list style="symbols">
          <t>In <xref target="model"/> a more complete description of the components involved in the model are discussed.</t>
          <t>In <xref target="RI"/> is description the new ASN.1 structures that are used to carry the additional information, and the way that these structures are used in a recipient info structure.</t>
          <t>In <xref target="sender"/> is a description of the modifications from the sender processing rules outlined in <xref target="SMIME-MSG"/>.</t>
          <t>In <xref target="recipient"/> is a description of the modification from the recipient processing rules outlined in <xref target="SMIME-MSG"/>.</t>
          
        </list>
      </t>

      <section title="Vocabulary">
        <t>Some of the terms used in this document include:
          <list style="hanging">
            <t hangText="Authenticated Encryption with Additional Data (AEAD):"> Are a set of encryption algorithms where an authentication method stronger than the PKCS #1 packing method is used for authentication and, optionally, a set of unencrypted attribute values are included in the authentication step.</t>
            <t hangText="Content Encryption Key (CEK):"> The symmetric key used to encryption the content of a message.</t>
            <t hangText="Key Encryption Key (KEK):"> A key, usually a symmetric key, which is used to encrypt another key, usually a content encryption key.</t>
          </list>
        </t>
      </section>
      
      <section title="Requirements Terminology">
        <t>When capitalized, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
      </section>
    </section>

    <section title="Model" anchor="model">
      <t>
        Details on the model and the requirements for the Plasma system can be found in <xref target="I.D-draft-freeman-plasma-requirements"/>.
      </t>
    </section>
      
    <section title="Recipient Info Encoding" anchor="RI">
      <t>
        In order for the Plasma system to function in CMS, a method needs to be chosen and described for how the CEK is to be protected and carried with the message, such that the recipient will be able to identified that this is a Plasma enabled message, know which Plasma server to contact and be able to get back the CEK needed to decrypt the message.
        Not all recipients of a message that has been encrypted using a Plasma server will need to contact the server in order to decrypt the message.
        There is nothing in what we are doing that prevents a message sender from building recipient info structures in a normal manner, except the possibly that the policy applied to the encrypted content could restrict it from happening.
        Additionally the Plasma server could return the standard recipient info structures to be added to the message for recipients, if it can pre-authorize them for access to the message and it can obtain the appropriate keying material.
      </t>

      <t>
        There are two distinct methods that were considered for identifying a recipient info structure as being a Plasma enabled object.  
        The first would be to define a new recipient info structure placed in the Other Recipient Info structure.
        The second option is to create a new key attribute placed in the KEK Recipient Info structure.
      </t>

      <t>
        The use of a new recipient info structure would have been the easiest to document and implement, if most major CMS implementations had kept up with the latest versions.
        However it is known that several implementations stopped with RFC 2630 <xref target="RFC2630"/> and it was not until RFC 3369 <xref target="RFC3369"/> that the Other Recipient Info choice was introduced along with the language stating that implementations need to gracefully handle unimplemented alternatives in the recipient info choice.
        This means that if a new recipient info structure was defined and adopted, the mail message would fail decoding for many recipients, even for those recipients that had a key transfer or key agreement recipient info structure.
      </t>

      <t>
        Given the current state of implementations, it was determined that the second method would be used as it will work with more implementations.
        After implementation it might be found that using the first method is the better way to go, in that case the decision can be re-visited.
      </t>


      <t>
        The use of the KEKRecipientInfo type may seem to be a stretch at first, it was defined for those situations where a symmetric key had already been distributed and either a specific key or a specific transformation on the key was to be applied in order to decrypt the KEK value.
        However, the Plasma recipient info can be thought of as a strange way to do the transformation and thus it kind of fits into the model.
        It is in a structure that will be supported by the most basic CMS implementiation and it is easy for client implementations to make the determination of a Plasma recipient info by looking at the OID for the other key attribute structure.
      </t>

      <t>
        A recipient info structure as defined in this document MUST be created by a Plasma server and MUST NOT be created by client software.
        A protocol such as the one in RFC TBD1 <xref target="plasma-token"/> is used to transport the recipient info structure between the client and the server.
      </t>

      <t>
        For the convenience of the reader we include the KEKRecipientInfo structure pieces here (copied from <xref target="CMS-ASN"/>):
      </t>

<figure><artwork>
KEKRecipientInfo ::= SEQUENCE {
    version CMSVersion,  -- always set to 4
    kekid KEKIdentifier,
    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
    encryptedKey EncryptedKey }

KEKIdentifier ::= SEQUENCE {
    keyIdentifier OCTET STRING,
    date GeneralizedTime OPTIONAL,
    other OtherKeyAttribute OPTIONAL }

OtherKeyAttribute ::= SEQUENCE {
    keyAttrId  KEY-ATTRIBUTE.
            &amp;id({SupportedKeyAttributes}),
    keyAttr    KEY-ATTRIBUTE.
            &amp;Type({SupportedKeyAttributes}{@keyAttrId})}
</artwork></figure>

      <t>
        For a Plasma KEKRecipientInfo structure, the fields are filled in as follows:

        <list style="hanging">

          <t hangText="version">is set to the value of 4.</t>

          <t hangText="kekid">is a sequence where the fields are:
            <list style="hanging">
              <t hangText="keyIdentifier"> is a binary value that has no meaning when associated with a plasma recipient structure.  Future versions of the Plasma specficiation might assign a meaning to associate multiple enveloped data structures together.
              </t>
              <t hangText="date">is not used and is omitted.</t>
              <t hangText="other">is a sequence where the fields are:
                <list style="hanging">
                  <t hangText="keyAttrId">contains the value id-keyatt-plasma-token.</t>
                  <t hangText="keyAttr">
                    contains a the value of the attribute.
                    The details of this structure are covered in <xref target="plasma-oka"/>.
                  </t>
                </list>
              </t>
            </list>
          </t>

          <t hangText="keyEncryptionAlgorithm">
            This field is not used.
          </t>

          <t hangText="encryptedKey"> is a zero length value.</t>

        </list>
      </t>

      <t>
        NOTE: As can be seen above, we have bent the model so much that it no longer really makes any sense to try and keep this as a KEK algorithm unless we completely re-design it.
        The fact that we now always work with CEK values rather than KEK values means that we no longer have a key value or a key encryption algorithm.  
        This means that we need to step back and re-examine the entire question of how we do the encoding.
        At this point in time I am leading to converting to say this is a key transport algorithm that uses a random value for the SKI.
        Clients would then need to look at both the key identifier and the algorithm in order to determine if it understands things.
        The other option is to bite the bullet and move to an Other Key Info structure.
      </t>

      <section title="PLASMA Other Key Attribute" anchor="plasma-oka">

        <t>
          The PLASMA Other Key Attribute functions as the lock box for the KEK used in encrypting the CEK.
          In addition to the KEK, the lock box also contains the information that is needed by the Plasma Server to know the policy(s) applied to the encrypted data and possible parameters for the policy and for the client to validate that the lock box applies to the encrypted content.
        </t>

        <t>
          The relevant section from the ASN.1 module which contains the content is:
        </t>

        <?rfc linefile="1:ForDraft/eps-oak.incl"?><figure><artwork>
   --  
   --  New Other Key Attribute value for Plasma
   --  This structure holds the encrypted KEK value for the server
   --  and other signed attributes used by the client for checking
   --  the structure applies in this case
   --

   keyatt-plasma-kek KEY-ATTRIBUTE ::= {
      SignedData IDENTIFIED BY id-keyatt-plasma-token
   }

   id-keyatt-plasma-token OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD2 }
</artwork></figure>
<?rfc linefile="248:eps.xml"?>

        <t>We define a new KEY-ATTRIBUTE called keyatt-plasma-kek.  This attribute is identified by the id-keyatt-plasma-token OID.  The data structure that is associated with this key attribute is the CMS SignedData structure.  The CMS SignedData structure is used directly without a CMS ContentInfo structure wrapping it.</t>

        <t>The SignedData structure fields are filled as follows (some less significant fields are omitted):
          <list style="hanging">

            <t hangText="encapContentInfo"> is a structure containing the fields:

              <list style="hanging">
                <t hangText="eContentType"> is id-ct-authEnvelopedData.</t>

                <t hangText="eContent"> is CMS AuthEnvelopedData structure with the following fields:

                  <list style="hanging">
                    <t hangText="recipientInfos"> contains the lock box(s) for the Plasma servers(s) to get access to the encrypted data.  There MUST NOT be recipient info structures added for any entity not trusted to correctly perform the policy decision processing. See below for some additional discussion on what lock boxes need to be created.</t>

                    <t hangText="authEncryptedContentInfo"> is a structure containing the following elements:

                      <list style="hanging">

                        <t hangText="contentType"> is id-ct-plasma-LockBox.</t>
                        <t hangText="contentEncryptionAlgorithm"> contains the identifier and parameters for the content encryption algorithm.  This algorithm only needs to be understood by the Plasma service.</t>
                        <t hangText="encryptedContent"> contains the encrypted PLASMA LockBox content.  Details on this type are in the next section.</t>
                      </list>
                    </t>
                  </list>
                </t>
              </list>
            </t>
            <t hangText="certificates"> SHOULD contain the set of certificates (up to but not including the trust anchor) needed to validate the set of signer info structures.</t>

            <t hangText="signerInfos"> will contain one or more signer info structures.  In each signature the signed attributes:

              <list style="symbols">
                <t>MUST contain the signing time, the message digest, the content type, the PLASMA hash attribute and the PLASMA url attributes.</t>
                <t>SHOULD contain the multiple signature attribute <xref target="RFC5752"/> if more than one signature exists.</t>
                <t>MAY contain the ESS security label attribute.</t>
                <t>other attributes can also be included.</t>
              </list>
            </t>

          </list>
        </t>

        <t>When creating the recipient info structures for the AuthEnvelopedData structure, there will normally only need to be a single entry in the sequence as the only entity that needs to decrypt the PLASMA Lockbox is the Plasma Service.  In the event that the service is distributed over multiple servers then multiple lock boxes may need to be created.  One of the implications of the fact that the originator of the message is the only recipient is that, although the signing key needs to be contained in a certificate, there is no corresponding requirement that the encryption key needs to be in a certificate.  Instead of using a certificate, a subject key identifier that is meaningful only to the Plasma Service can be used.</t>

        <t>
          There are a number of circumstances that a Plasma server would apply multiple signatures to a single lockbox.  These circumstances include during key rollover while a certificate is approaching expiration, esp. if there is going to be a change in the trust anchor being used.  Another circumstance would be if a new signature algorithm is being rolled out, having the old and the new algorithm on the message during the rollout period increases the chances that the signature can be validated.  In these circumstances, the multiple signature attribute defined in RFC 5752 <xref target="RFC5752"/> allows for a client to determine that a signature has been removed which might be attempted as part of an attack to use a more insecure algorithm.
        </t>

      </section>

      <section title="PLASMA Content Type">
        <t>The inner content type for a PLASMA Other Key Attribute is a PLASMA Lockbox.  This content is contained in an encrypted CMS object which is encrypted by and for the Plasma server itself, as such the contents and structure is known just to the Plasma server.</t>
        <t>
          The content type is designed so that the Plasma server does not need to keep any state dealing with a message on the server itself.  This allows for minimal information to be kept on the server, it only needs the state of it's current transactions, and the message can be processed by any of a number of servers without needing to replicate state about the message between them.
        </t>
        <t>The relevant section from the ASN.1 module which defines this content is:</t>

        <?rfc linefile="1:ForDraft/eps-ct.incl"?><figure><artwork>
   --
   --  PLASMA Content Type
   --

   ct-plasma-LockBox CONTENT-TYPE ::= {
       TYPE PLASMA-LockBox
       IDENTIFIED BY id-ct-plasma-LockBox
   }

   id-ct-plasma-LockBox OBJECT IDENTIFIER ::= {iso(1) member-body(2)
       us(840) rsadsi(113549) pkcs(1) pkcs7(7) TBD1}

   PLASMA-LockBox ::= SEQUENCE {
      policy       OCTET STRING,
      keyList      KeyList,
      attrList     AttributeList OPTIONAL
   }

   KeyList ::= SEQUENCE {
      namedRecipients    [0] SEQUENCE SIZE (1..MAX) OF 
                                NamedRecipient OPTIONAL,
      defaultRecipients  [1] SEQUENCE SIZE (1..MAX) OF 
                                OneCek OPTIONAL,
      ...
   }
   (WITH COMPONENTS {
        ...,
        namedRecipients         PRESENT
    } |
    WITH COMPONENTS {
        ...,
        defaultRecipients       PRESENT
    })

   NamedRecipient ::= SEQUENCE {
      recipientName       UTF8String, -- name of the recipient
      keyPolicy           [0] OCTET STRING OPTIONAL,
      keyIdentifier       OCTET STRING OPTIONAL,
      keyValue            RecipientInfo,
      ...
   }

   OneCek ::= SEQUENCE {
      keyPolicy           [0] OCTET STRING OPTIONAL,
      keyIdentifier       [1] OCTET STRING OPTIONAL,
      keyValue            OCTET STRING,
      ...
   }

   AttributeList ::= SEQUENCE SIZE (1..MAX) OF
        SingleAttribute{{PlasmaLockboxAttributes}}

   PlasmaLockboxAttributes ATTRIBUTE ::= { aa-plasma-AuditTrailIdentifier |
        aa-plasma-SignerInfo | aa-plasma-Xacml-Attribute, ... }

   PlasmaSignedAttributes ATTRIBUTE ::= {
        aa-plasma-url | aa-plasma-econtent-hash
   }
       
</artwork></figure>
<?rfc linefile="308:eps.xml"?>

        <t>In the above ASN.1, the following items are defined:
          <list style="hanging">
            
            <t hangText="ct-plasma-LockBox"> is a new CMS content type object, this object is  added to the set of content type objects in ContentSet (defined in the ASN.1 module in <xref target="CMS-ASN"/>).  The content type associates the object identifier id-ct-plasma-LockBox with the data type PLASMA-LockBox.</t>
            <t hangText="id-ct-plasma-LockBox"> is the identifier defined for the new content type.</t>
            <t hangText="PLASMA-LockBox"> is the new type defined for new content type.  This is a sequence with the following fields:
              <list style="hanging">
                <t hangText="policy"> contains the policy label that is to be applied to the KEK values in the keyList field.
                  The exact content of the field will be specific to the set of Plasma servers involved.
                  Servers MUST be able to deal with an XML encoding of the policy in this location.
                  See <xref target="CompressedPolicy"/> for some alternate encodings.
                </t>
                <t hangText="keyList"> contains the key values.</t>
                <t hangText="attrList">
                  contains a set of attributes which are considered as significant by the Plasma server internally.
                  One example of an attribute that goes into this location is the audit trail identifier attribute.
                  This attribute allows for an identifier to tagged to the message that can be used by all entities that are going to create entries in an audit log.
                  Since they all have access to a unique identifier for this message, they can all use that identifier when creating their respective log entries for creation, granting of access and refusing access.
                  The identifier can then be used to correlate all of these audit trail events back to a single message.
                  This document defines three attributes to be placed in this location:  Audit Trail Identifier <xref target="audit-id"/>, Signer Info <xref target="sign-info"/> and XACML attribute <xref target="xacml-attrib"/>.
                </t>
              </list>
            </t>
            
            <t hangText="KeyList"> is a new type that contains CEK values or KeyRecipientInfo structures.  This allows for messages to be sent with either early-binding, where a RecipientInfo structure is filled out for the receiving agent, or late-binding, where the CEK value is sent from the Plasma Service to the receiving agent.  It is required that at least one of these fields is populated.
              <list style="hanging">
                <t hangText="namedRecipients"> contains the recipient info structures for individually identified recipients.</t>
                <t hangText="defaultRecipients"> contains the CEK keys for those recipients that are not individual identified with their own recipient info structures.</t>
              </list>
            </t>
            
            <t hangText="NamedRecipient"> contains the information identifying a single named recipient along with the recipient info structures for that recipient.
              <list style="hanging">
                <t hangText="recipientName"> contains the name of the name of the recipient in the form of an RFC5321 email address.</t>
                <t hangText="keyPolicy"> contains a policy string specific to this key.
                  If present the policy MUST be evaluated as accept before this recipient info structure is released.
                  Servers MUST be able to deal with an XML encoding of the policy in this location.
                  See <xref target="CompressedPolicy"/> for some alternate encodings.
                </t>
                <t hangText="keyIdentifier"> contains the identification value for the CEK.</t>
                <t hangText="keyValue"> contains the recipient info structure for the named recipient.</t>
              </list>
              This structure is tagged as extensible; this was done because there may be a need to add additional fields such as other name types in the future.
            </t>

            <t hangText="OneCek"> contains the information that defines a single CEK to be used.  The sequence has the fields:
              <list style="hanging">
                <t hangText="keyPolicy"> contains a policy string specific to this key. 
                  If present the policy MUST be evaluated as accept before this key is released. 
                  Servers MUST be able to deal with an XML encoding of the policy in this location.
                  See <xref target="CompressedPolicy"/> for some alternate encodings.
                </t>
                <t hangText="keyIdentifier"> contains the identification value for the CEK.</t>
                <t hangText="keyValue"> contains the CEK value.</t>
              </list>
              This structure is tagged as extensible; this was done because there may be a need to add additional fields such as other name types in the future.
            </t>

            <t hangText="AttributeList"> defines a structure where a set of attributes can be included.</t>
            <t hangText="PLASMAAttributes"> defines an Object Set of attributes which can be included.
              The object set is intentionally open ended for later expansion.
              The object set is initialized with the three attributes defined in this document.
            </t>
            <t hangText="PlasmaSignedAttributes">
              defines an Object Set of attributes that are intended for use as signed attributes for CMS SignedData objects.
              This item is intended to be added to the SignedAttributesSet in the CMS module in <xref target="CMS-ASN"/>.
            </t>
          </list>
        </t>

        <t>
          The recipientName field of the NamedRecipient structure is designed so that a client can build a CMS recipient info structure targeted to a specific recipient.
          In order for the Plasma server to know which of these named recipient structure to return it requires that the sender identify the recipient for the CMS recipient info structure and that the recipient identify itself so that the Plasma server can find the correct structure.
          We are using Email names in the form of internationalized RFC 5321 <xref target="RFC5321"/> address names.
          There are a number of issues that are associated with the use of this name form for comparison purposes.
          As stated in Section 2.3.11 of RFC 5321,
          <t>
            the local-part MUST be interpreted and assigned semantics only by the host specified in the domain part of the address.
          </t>
          While many platforms do case-insensitive comparisons of mailbox names, there is not a way for an independent server to know if this is appropriate behavior.
          A similar issue exists with Unicode normalization as pointed out in Section 10.1 of RFC 6530 <xref target="RFC6530"/>.
          The server that holds the mailbox can have a consistent rule for normalization, but a Plasma server in separate domain may not know the appropriate rules to use.
        </t>
        <t>
          Plasma servers SHOULD do the following when comparing the Email addresses found in the recipientName field:
          <list style="numbers">
            <t>The domain name portion is compared using procedure in Section 2.3.2.4 of <xref target="RFC5890"/>.  The rules are:
            <list style="symbols">
              <t>
                Exact (bit-string identity) matches between pairs of U-labels.
              </t>
              <t>
                Matches between a pair of A-labels, using normal DNS case-insensitive matching rules.
              </t>
              <t>
                Equivalence between a U-label and an A-label determined by translating the U-label form into an A-label form and then testing for a match between the A-labels using normal DNS case-insensitive rules.
              </t>
            </list>
            </t>
            <t>The local name portion of the name is compared using bit-string identity.  Plasma servers MAY apply appropriate transformations for local domain names, but SHOULD NOT apply them for other domains.</t>
          </list>
        </t>
      </section>

      <section title="CMS Signed Data signed attributes">
        <section title="PLASMA URL Authenticated Attribute">
          <t>It is required that the name of the Plasma Server be securely communicated to the message recipient.  For this purpose a URL is used as this can communicate both a server name as well as additional parameters that can be used to identify a specific service on the server.</t>
          <t>The relevant section from the ASN.1 module for this attribute is:</t>
          <?rfc linefile="1:ForDraft/eps-url-attr.incl"?><figure><artwork>
   --
   --  Define the Signed Attribute to carry the 
   --       Email Policy Server URL
   --
   --  This attribute is added to the SignedAttributSet set of
   --  attributes in [CMS-ASN]
   --

   aa-plasma-url ATTRIBUTE ::= {
      TYPE UTF8String IDENTIFIED BY id-aa-plasma-url
   }

   id-aa-plasma-url OBJECT IDENTIFIER ::= { iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD3}
</artwork></figure>
<?rfc linefile="418:eps.xml"?>
          <t>From this we can see the following:
          <list>
            <t>A new attribute aa-plasma-url has been defined.</t>
            <t>The OID value of id-aa-plasma-url has been created to identify the new attribute.</t>
            <t>The type of the value associated with the attribute is a UTF8String which contains the URL for the Plasma Server.  The URL defines both the destination server and the protocol to be used.  When the schema for the URL is "plasma", then the protocol used is <xref target="plasma-token"/>.</t>
            <t>The new attribute is to appear only as a Signed Attribute in a SignedData structure.  It is therefore to be added to the attribute set SignedAttributeSet in the update ASN.1 module contained in <xref target="CMS-ASN"/>.</t>
          </list>
          </t>
          
          <t>
            The attribute structure defined for signed attributes allows for multiple values to be carried in a single attribute.
            For this attribute there MUST be at least one value.
            If there is more than one value, each value MUST be unique.
            Multiple values are allowed as there can be multiple Plasma servers that can be used to evaluate the policy.
            Since the URLs will be sorted during encoding, the order of URLs does not indicate any order of priority, any of the values may be used.
          </t>
          
          <t>This attribute is only included in a SignedData object by a Plasma Server.  There are no processing rules for the sender of a message.  The processing rules for a recipient can be found in <xref target="recipient"/>.</t>
        </section>
        <section title="PLASMA Encrypted Content Hash Attribute">
          <t>For privacy reasons, it is highly desirable that the recipient of a message can validate that the Plasma lock box embedded in a message is associated with encrypted data it is attached to.  For this reason, in addition to the requirement that a recipient validate the signature of the Plasma server over the lock box, a new attribute is defined which contains the hash of the encrypted content.</t>
          <?rfc linefile="1:ForDraft/eps-hash-attr.incl"?><figure><artwork>
   --
   -- Define the Signed Attribute to carry the
   --      hash of encrypted data
   --
   --  This attribute is added to the SignedAttributeSet set of
   --  attributes in [CMS-ASN]
   --

   aa-plasma-econtent-hash ATTRIBUTE ::= {
      TYPE HashValue IDENTIFIED BY id-aa-plasma-econtent-hash
   }

   id-aa-plasma-econtent-hash OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD4}

   HashValue ::= SEQUENCE {
       hashAlgorithm    DigestAlgorithmIdentifier,
       hashValue        OCTET STRING
   }
</artwork></figure>
<?rfc linefile="440:eps.xml"?>
          <t>The above ASN.1 fragment defines the following items:
          <list style="hanging">
            <t hangText="aa-plasma-econtent-hash"> defines a new ATTRIBUTE object describing the encrypted content hash attribute.  This attribute is always a signed object and is to be added to the SignedAttributeSet in the CMS ASN.1 mdoule contained in <xref target="CMS-ASN"/>.</t>
            <t hangText="id-aa-plasma-econtent-hash"> defines the unique identifier of the attribute.</t>
            <t hangText="HashValue"> defines the data value to be associated with the attribute.  The fields of this type are:
            <list style="hanging">
              <t hangText="hashAlgorithm"> contains the identifier and parameters of the hash function used.</t>
              <t hangText="hashValue"> contains the value of the hash operation.</t>
            </list>
            </t>
          </list>
          </t>
          <t>The hash is computed over the encrypted content, without including any of the ASN.1 wrapping around the content.  Thus this value does not cover the content type identifier, the encryption algorithm and parameters or any authenticated attributes for AEAD algorithms.</t>
        </section>
      </section>
      <section title="Plasma Lockbox Attributes">
        <section title="Audit Trail Identifier Attribute" anchor="audit-id">
          <t>
            The Audit Trail Identifier attribute allows for a unique and persistent identifier to be carried as part of a Plasma Lockbox message.
            This identifier can then be used by Plasma servers when creating log entries in the audit trail to designate a single Plasma message.
            This use of a single identifier allows for better correlation to occur by auditors, however as the identifier is hidden from all viewers except the Plasma server, the message itself is not locatable from the log entries.
          </t>
          
          <t>
            The relevant section from the ASN.1 module which defines this attribute is:
            <?rfc linefile="1:ForDraft/eps-audit.incl"?><figure><artwork>
   --
   --  Attribute to hold an Audit Trail Identifier
   --

   aa-plasma-AuditTrailIdentifier ATTRIBUTE ::= {
     TYPE OCTET STRING IDENTIFIED BY id-aa-plasma-Audit-Trail-Identifier
   }

   id-aa-plasma-Audit-Trail-Identifier OBJECT IDENTIFIER ::= {
        iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD5}

</artwork></figure>
<?rfc linefile="466:eps.xml"?>
          </t>

          <t>
            In this ASN.1, the following items are defined:
            <list style="hanging">
              <t hangText="aa-plasma-AuditTrailIdentifier">
                <vspace/>
                This is an object of type ATTRIBUTE that associates the identifier id-aa-plasma-Audit-Trail-Identifier with the type OCTET STRING.
                When used in attrList field of a PLASMA-LockBox, the values set MUST contain a single value.
                The value is the audit trail identifier value.
              </t>

              <t hangText="id-aa-plasma-Audit-Trail-Identifier">
                <vspace/>
                This is the OID used to identifier this attribute.
              </t>
            </list>
          </t>

          <t>
            The use of OCTET STRING for the content allows for the greatest flexibility for Plasma Servers in devising the value to use.
            The content of the Audit Tail Identifier is intended to be an opaque value to all entities, all Plasma servers MUST be able to ignore how the value is structured.
          </t>
        </section>

        <section title="Signer Info Attribute" anchor="sign-info">
          <t>
            Some policies require that the inner content of an encrypted message be signed as well.
            However the encrypted data stream of the message is not provided to the Plasma server for it to verify that it was done successfully.
            The only places to check is in the audit trail for the message and/or to allow the client to do the check that the signature is present.
            This attribute provides a location for the Plasma server to place the provided CMS SignerInfo structure(s) provided by the client to be carried with the message.
            The server can then push the structure(s) to the client and the client can validate that the actual signatures on the message match the signatures provided by the server.
            All servers MUST be able to parse this attribute and convert it to an appropriate XACML attribute to return to clients.
          </t>

          <t>
            The relevant section from the ASN.1 module which defines this attribute is:
            <?rfc linefile="1:ForDraft/eps-signerInfoAttr.incl"?><figure><artwork>
   --
   --  Attribute to hold a SignerInfo structure
   --

   aa-plasma-SignerInfo ATTRIBUTE ::= {
     TYPE SignerInfo IDENTIFIED BY id-aa-plasma-signerInfo
   }

   id-aa-plasma-signerInfo OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD6}

</artwork></figure>
<?rfc linefile="504:eps.xml"?>
          </t>

          <t>
            In this ASN.1, the following items are defined:
            <list style="hanging">
              <t hangText="aa-plasma-SignerInfo-">
                <vspace/>
                This is an object of type ATTRIBUTE that associates the identifier id-aa-plasma-SignerInfo with the type SignerInfo.
              </t>
              <t hangText="id-aa-plasma-SignerInfo">
                <vspace/>
                This OID is used to identify the attribute, it's associated type and it's semantics.
              </t>
            </list>
          </t>

          <t>
            There can be one or more attribute values in the attribute set.
            Each of the values is to be treated independently and returned to the client.
            The values may be returned in a single Attributes XML element.
          </t>

        </section>

        <section title="XACML Generic Attribute" anchor="xacml-attrib">
          <t>
            Many times Plasma servers be in situation where they will need to return various values to the clients.
            These decisions will frequently be taken by the originating Plasma server, since it may be the only one that has the data to be returned.
            This attribute allows for any data to be carried in the form of an XACML attribute XML structure.
            Since the content is an XACML attribute, it can be pushed to the client without the server needing to understand or evaluate the content being presented.
            The Signer Info attribute presented in the previous section could have been implemented using this attribute rather than defining it's own attribute, however the space savings was deemed sufficient to justify the creation of the new attribute.
          </t>

          <t>
            The relevant section from the ASN.1 module which defines this attribute is:
            <?rfc linefile="1:ForDraft/eps-xacmlAttr.incl"?><figure><artwork>
   --
   --  Attribute to hold an arbitrary XACML XML attribute
   --  structure
   --

   aa-plasma-Xacml-Attribute ATTRIBUTE ::= {
     TYPE OCTET STRING IDENTIFIED BY id-aa-plasma-Xacml-Attribute
   }

   id-aa-plasma-Xacml-Attribute OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD7}

</artwork></figure>
<?rfc linefile="540:eps.xml"?>
          </t>

          <t>
            In this ASN.1, the following items are defined:
            <list style="hanging">
              <t hangText="aa-plasma-Xacml-Attribute">
                <vspace/>
                This is an object of type ATTRIBUTE that associates the identifier of id-aa-plasma-Xacml-Attribute with the type OCTET STRING.
              </t>
              <t hangText="id-aa-plasma-Xacml-Attribute">
                <vspace/>
                This OID is used to identify the attribute, its associated type and it's semantics.
              </t>
            </list>
          </t>

          <t>
            There can be one or more attributes values associated with the attribute set.
            Each of the values is to be treated independently and returned as separate items to the client.
          </t>

          <t>
            The data type is an OCTET STRING to allow for alternate XML encodings to be used.
            All servers MUST be able to deal with a UTF8 string XML encoding of the policy in this location.
            See <xref target="CompressedPolicy"/> for alternate encoding methods.
            If a server cannot understand the encoding presented, the server MUST fail processing of the lockbox.
          </t>
            
        </section>
      </section>
    </section>
    <section title="Sender Processing Rules" anchor="sender">
      <section title="Flow">
        <t>This is the set of processing steps that a sender needs to do (the order of the steps is not normative):
          <list style="numbers">
            <t>Sender Agent obtains the set of policies under which it can send a message.</t>
            <t>Sender Agent composes the message content.</t>
            <t>Sender Agent determines the policy label to be applied to the message.</t>
            <t>Sender Agent determines the set of recipients for the message.</t>
            <t>Sender Agent selects the content encryption algorithm (with input from the policies chosen) and randomly creates the CEK.</t>
            <t>Sender Agent encrypts the content with the CEK and computes the encrypted hash value.</t>
            <t>Sender Agent may optionally create lock boxes for one or more message recipients. (These are for the early-bind recipients that are protected by the policy server.)</t>
            <t>Sender Agent transmits the CEK, the list of recipients, the set of policy protected recipient lock boxes, the encrypted hash value and the policy label to the PLASMA server.</t>
            <t>Sender Agent receives a set of recipient info structures from the policy server.  If the policy validation fails then the sender agent cannot send the message under the current policy label.</t>
            <t>Sender Agent verifies the signature on the signed data structure inside of the PLASMA-KEK attribute.
              <list style="letters">
                <t>Signature is current and passes cryptographic processing.</t>
                <t>Signed attributes contains the PLASMA URL attribute and  the PLASMA Encrypted Hash attribute.</t>
                <t>The certificate used to validate the signature MUST have the Plasma XXXX EKU (defined in Section X.Y of RFC XXXX).</t>
                <t>Other standard signature checks.</t>
              </list>
              The Sender Agent SHOULD validate all of the signatures if more than one signature exists.
            </t>
            <t>Sender Agent adds the recipient info structures returned from the Plasma server to those it creates for early bind recipients which are not protected by policy.</t>
            <t>Sender Agent finishes encoding the message and transmits it to the MTA.</t>p
          </list>
        </t>
      </section>
    </section>
    <section title="Recipient Processing Rules" anchor="recipient">
      <section title="Flow">
        <t>When looking at the validation steps that are given here, the results need to be the same but the order that the steps are taken can be different.  As an example, it can make sense to do the policy check in step <xref target="r_policy"/> before doing the signature validation as this would not require any network access.</t>
        <t>This is the set of processing that the recipient needs to do:
          <list style="numbers">
            <t>The Receiving Agent obtains the message from a Mail Transfer Agent using IMAP, POP or a similar protocol.</t>
            <t>The Receiving Agent recognizes that a KEK recipient info exists with a PLASMA-KEK attribute.  It is recommended that the entire list of recipient info structures be checked for one that can be processed directly before processing a Plasma receipient structure.</t>
            <t>The Receiving Agent validates the PLASMA-KEK attribute.  The following steps need to be taken for validation.
              <list style="letters">
                <t>The signature on the SignedData structure is validated.  If the validation fails then processing ends.  If more than one SignerInfo element exists on the structure, then the validation needs to succeed only on one SignerInfo element, the signed attributes from that SignerInfo structure are used.  The order of performing the validation of the SignerInfo structures may be influenced by the content of PLASMA URL attribute.</t>
                <t>The certificate used to validate the signature MUST contain the XXXX value in the EKU extension.  The certificate MUST NOT contain the anyPolicy value in the EKU extension.  Local policy can dictate that content of the Plasma URL attribute be used in selecting trust anchors for the signing certificate.</t>
                <t>If an ESS security label attribute (<xref target="ESS-BASE"/>) is present, then it must be evaluated and processing ends if the security label processing fails or is denied.</t>
                <t>If the PLASMA URL attribute is absent, then processing fails.</t>
                <t anchor="r_policy">The URL value in the PLASMA URL attribute is checked against local policy.  If the check fails then processing fails.  This check is performed so that information about the user is not given to a random Plasma server.  The schema of the URL MUST be one that the client implements.  (For example the "plasma" schema associated with RFC XXX <xref target="plasma-token"/>.)  As discussed in Section 4.5 of <xref target="I.D-draft-freeman-plasma-requirements"/>, policy can be enforced on the edge of an enterprise, this means that if multiple URLs are present in the Plasma URL attribute they all need to be checked for policy and ability to use before this step fails.</t>
                <t>The PLASMA Encrypted Hash attribute value is checked against the encrypted content.  If this attribute is absent then processing fails. If the value does not matched the computed value on the encrypted content then processing fails.</t>
              </list>
            </t>
            <t>The recipient gathers the necessary identity and attribute statements, usual certificates or SASL statements.</t>
            <t>The recipient establishing a secure connection to the Plasma server and passes in the identity and attribute statements and receives back the CEK or a lock box to allow it to obtain the CEK value.</t>
          </list>
        </t>
      </section>

      <section title="Reply  Processing">
        <t>
          In some circumstances a message recipient may be permitted to read a message sent under a certan policy, but it not permitted to send a message for that policy.
          In the event that a complex policy is used the recipient may be permitted to read under one policy, but not have any rights under a second policy.
          In both of these case a recipient of a message would be unable to either reply or forward a message using the same policy as they received it under.
          For this reason, the protocol used to communicate with the Plasma server will frequently return a single purpose policy that permits a recipient to reply to a message using the same policy as the original message.
        </t>
      </section>

    </section>

    <section title="S/MIME Capability">
      <t>The SMIMECapabilities attribute was defined by S/MIME in <xref target="SMIME-MSG"/> so that the abilities of a client can be advertised to the recipients of an S/MIME message.  This information can be advertised either directly in an S/MIME message sent from a client to a recipient, or more indirectly by publishing the information in an LDAP directory <xref target="RFC4262"/>.</t>
      <t>A new S/MIME capability is defined by this document so that a client can advertise to others that it understands how to deal with Plasma recipient information.  The ASN.1 for this attribute is:</t>
      <?rfc linefile="1:ForDraft/eps-smime-cap.incl"?><figure><artwork>
   --
   --  Create an S/MIME capability for advertising that
   --    a client can understand the PLASMA recipient info
   --   structure information
   --

   cap-Plasma-RecipientInfo SMIME-CAPS ::= {
        IDENTIFIED BY id-cap-plasma-recipientInfo 
   }

   id-cap-plasma-recipientInfo OBJECT IDENTIFIER ::= {
     id-cap TBD5
   }
</artwork></figure>
<?rfc linefile="637:eps.xml"?>
      <t>We define a new SMIME-CAPS object called cap-Plasma-RecipentInfo.  This attribute is identified by the the OID id-cap-plasma-recipientInfo and has no data structure associated with it.  When encoded as an S/MIME capability the parameters MUST to be absent and not NULL.</t>
    </section>
    <section title="Mandatory Algorithms" anchor="algs">
      <section title="Plasma Servers">
        <t>Servers MUST implement AES-GCC-128 (<xref target="RFC5084"/>) for the content encryption algorithm in section 3.1.  Other authenticated encryption algorithms MAY be implemented.</t>
        <t>Servers MUST implement RSA v1.5 as a key transport algorithm for lockboxes created in section 3.1 and for pre-authenticated lock boxes returned in step 8 of section 4.1.  Servers SHOULD implement RSA OAEP as a key transport algorithm in the same locations. Other key transport algorithms MAY be implemented.</t>
        <t>Servers MUST implement EC-DH as a key agreement algorithm for lockboxes created in section 3.1 and for pre-authenticated lock boxes returned in step 8 of section 4.1.  Servers MAY implement other key agreement algorithms.</t>
        <t>Servers MUST implement the RSA v1.5 signature algorithm with SHA-256 and SHA-512.  Servers MUST implement the EC-DSA signature algorithm with SHA-256 and SHA-512 for producing signature on the Plasma lock box.  Other signature algorithms MAY be implemented as well.</t>
      </section>
      <section title="Plasma Clients">
        <t>Clients MUST implement the mandatory algorithms defined for S/MIME <xref target="SMIME-MSG"/> for the lock boxes created in step 7 and transmitted to the server in step 8 of Section 4.  Other algorithms MAY be implemented.</t>
        <t>Clients MUST implement SHA-256 and SHA-512 for computation of the Plasma Encrypted Content Hash in section 3.4.  Other algorithms MAY be implemented, but doing so can cause clients that do not implement this algorithm to not attempt to read the message.</t>
        <t>When verifying signatures on the Plasma lock boxes, clients MUST be able to verify the RSA v1.5 signature algorithm with SHA-256 and SHA-512.  Clients MUST also be able to verify the EC-DSA signature algorithm with SHA-256 and SHA-512 signature algorithm.  Clients MAY be able to verify other signature algorithms.</t>
      </section>

    </section>
    <section title="Security Considerations">
      <t>Man in the middle attack on the protocol from the sending agent to the email policy server.</t>
      <t>Man in the middle attack on the protocol from the receiving agent to the email policy server.</t>
      <t>Still more expansion....</t>
      <t>
        The hash computed for the Plasma Encrypted Content Hash attribute has different security concerns that a hash used for signature computation.
        This hash value is used to get a degree of assurance that the encrypted content is associated with Plasma lock box.
        In the event that a collision exists, then the client will go and talk to the server to get a content encryption key when that key will not successfully decrypt the content.
        However this does not affect the privacy of the client as the client's decision to talk to the server is based on the URL(s) of the server and the validation of the server's signature.
        This means that an attacker that substitutes an encrypted content needs not only to have the hash of the encrypted content be correct, but the decrypted content needs to make sense.
        In order for an attacker to have the client talk to it, it needs to attack the certificates or signature produced on the lock box and not the encrypted content itself.
      </t>
    </section>
    <section title="IANA Considerations">
      <t>All of the object identifiers defined by this document are done so under the existing S/MIME Object Identifier arc.  No actions by IANA are required for this document.</t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <?rfc linefile="1:bibxml/reference.RFC.5911.xml"?>

<reference anchor='CMS-ASN'>

<front>
<title>New ASN.1 Modules for Cryptographic Message Syntax (CMS) and S/MIME</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<author initials='J.' surname='Schaad' fullname='J. Schaad'>
<organization /></author>
<date year='2010' month='June' />
<abstract>
<t>The Cryptographic Message Syntax (CMS) format, and many associated formats, are expressed using ASN.1.  The current ASN.1 modules conform to the 1988 version of ASN.1.  This document updates those ASN.1 modules to conform to the 2002 version of ASN.1.  There are no bits-on-the-wire changes to any of the formats; this is simply a change to the syntax.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t></abstract></front>

<seriesInfo name='RFC' value='5911' />
<format type='TXT' octets='101576' target='http://www.rfc-editor.org/rfc/rfc5911.txt' />
</reference>
<?rfc linefile="673:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5083.xml"?>

<reference anchor='RFC5083'>

<front>
<title>Cryptographic Message Syntax (CMS) Authenticated-Enveloped-Data Content Type</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This document describes an additional content type for the Cryptographic Message Syntax (CMS).  The authenticated-enveloped-data content type is intended for use with authenticated encryption modes.  All of the various key management techniques that are supported in the CMS enveloped-data content type are also supported by the CMS authenticated-enveloped-data content type. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5083' />
<format type='TXT' octets='22810' target='http://www.rfc-editor.org/rfc/rfc5083.txt' />
</reference>
<?rfc linefile="674:eps.xml"?>
      <?rfc linefile="1:bibxml3/reference.I-D.draft-eps-ws-trust.xml"?>

<reference anchor='EPS-WS-TRUST'>
<front>
<title>Using WS Trust as an EPS protocol</title>

<author initials='J' surname='Schaad' fullname='Jim Schaad'>
    <organization />
</author>

<date month='December' day='17' year='2010' />

<abstract><t>New hash algorithms are being developed and these algorithms may include parameters.  CMS has not currently defined any hash algorithms with parameters, but anecdotic evidence suggests that defining one could cause major problems.  In this document we define just such an algorithm and describe how to use it so that we can run experiments to find out how bad including hash parameters will be.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-TBD' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-TBD' />
</reference>
<?rfc linefile="675:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.2634.xml"?>

<reference anchor='ESS-BASE'>

<front>
<title>Enhanced Security Services for S/MIME</title>
<author initials='P.' surname='Hoffman' fullname='Paul Hoffman'>
<organization>Internet Mail Consortium</organization>
<address>
<postal>
<street>127 Segre Place</street>
<city>Santa Cruz</city>
<region>CA</region>
<code>95060</code>
<country>US</country></postal>
<email>phoffman@imc.org</email></address></author>
<date year='1999' month='June' /></front>

<seriesInfo name='RFC' value='2634' />
<format type='TXT' octets='131153' target='http://www.rfc-editor.org/rfc/rfc2634.txt' />
</reference>
<?rfc linefile="676:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.2119.xml"?>

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>
<?rfc linefile="677:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5751.xml"?>

<reference anchor='SMIME-MSG'>

<front>
<title>Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification</title>
<author initials='B.' surname='Ramsdell' fullname='B. Ramsdell'>
<organization /></author>
<author initials='S.' surname='Turner' fullname='S. Turner'>
<organization /></author>
<date year='2010' month='January' />
<abstract>
<t>This document defines Secure/Multipurpose Internet Mail Extensions (S/MIME) version 3.2.  S/MIME provides a consistent way to send and receive secure MIME data.  Digital signatures provide authentication, message integrity, and non-repudiation with proof of origin.  Encryption provides data confidentiality.  Compression can be used to reduce data size.  This document obsoletes RFC 3851. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5751' />
<format type='TXT' octets='98638' target='http://www.rfc-editor.org/rfc/rfc5751.txt' />
</reference>
<?rfc linefile="678:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5752.xml"?>

<reference anchor='RFC5752'>

<front>
<title>Multiple Signatures in Cryptographic Message Syntax (CMS)</title>
<author initials='S.' surname='Turner' fullname='S. Turner'>
<organization /></author>
<author initials='J.' surname='Schaad' fullname='J. Schaad'>
<organization /></author>
<date year='2010' month='January' />
<abstract>
<t>Cryptographic Message Syntax (CMS) SignedData includes the SignerInfo structure to convey per-signer information.  SignedData supports multiple signers and multiple signature algorithms per signer with multiple SignerInfo structures.  If a signer attaches more than one SignerInfo, there are concerns that an attacker could perform a downgrade attack by removing the SignerInfo(s) with the \'strong' algorithm(s).  This document defines the multiple-signatures attribute, its generation rules, and its processing rules to allow signers to convey multiple SignerInfo objects while protecting against downgrade attacks.  Additionally, this attribute may assist during periods of algorithm migration. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5752' />
<format type='TXT' octets='34502' target='http://www.rfc-editor.org/rfc/rfc5752.txt' />
</reference>
<?rfc linefile="679:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5321.xml"?>

<reference anchor='RFC5321'>

<front>
<title>Simple Mail Transfer Protocol</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2008' month='October' />
<abstract>
<t>This document is a specification of the basic protocol for Internet electronic mail transport.  It consolidates, updates, and clarifies several previous documents, making all or parts of most of them obsolete.  It covers the SMTP extension mechanisms and best practices for the contemporary Internet, but does not provide details about particular extensions.  Although SMTP was designed as a mail transport and delivery protocol, this specification also contains information that is important to its use as a "mail submission" protocol for "split-UA" (User Agent) mail reading systems and mobile environments. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5321' />
<format type='TXT' octets='225929' target='http://www.rfc-editor.org/rfc/rfc5321.txt' />
</reference>
<?rfc linefile="680:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5890.xml"?>

<reference anchor='RFC5890'>

<front>
<title>Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<date year='2010' month='August' />
<abstract>
<t>This document is one of a collection that, together, describe the protocol and usage context for a revision of Internationalized Domain Names for Applications (IDNA), superseding the earlier version.  It describes the document collection and provides definitions and other material that are common to the set. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5890' />
<format type='TXT' octets='54245' target='http://www.rfc-editor.org/rfc/rfc5890.txt' />
</reference>
<?rfc linefile="681:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.6530.xml"?>

<reference anchor='RFC6530'>

<front>
<title>Overview and Framework for Internationalized Email</title>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<author initials='Y.' surname='Ko' fullname='Y. Ko'>
<organization /></author>
<date year='2012' month='February' />
<abstract>
<t>Full use of electronic mail throughout the world requires that (subject to other constraints) people be able to use close variations on their own names (written correctly in their own languages and scripts) as mailbox names in email addresses.  This document introduces a series of specifications that define mechanisms and protocol extensions needed to fully support internationalized email addresses.  These changes include an SMTP extension and extension of email header syntax to accommodate UTF-8 data.  The document set also includes discussion of key assumptions and issues in deploying fully internationalized email.  This document is a replacement for RFC 4952; it reflects additional issues identified since that document was published. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6530' />
<format type='TXT' octets='64371' target='http://www.rfc-editor.org/rfc/rfc6530.txt' />
</reference>
<?rfc linefile="682:eps.xml"?>
      <reference anchor="I.D-draft-freeman-plasma-requirements">
        <front>
          <title>Requirements for Message Access Control</title>
          <author initials="T." surname="Freeman"/>
          <author initials="J." surname="Schaad"/>
          <author initials="P." surname="Patterson"/>
          <date month="October" year="2011"/>
        </front>
        <seriesInfo name="Work in progress" value="draft-freeman-plasma-requirements"/>
      </reference>
    </references>
    <references title="Informative References">
      <?rfc linefile="1:bibxml/reference.RFC.3369.xml"?>

<reference anchor='RFC3369'>

<front>
<title>Cryptographic Message Syntax (CMS)</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2002' month='August' /></front>

<seriesInfo name='RFC' value='3369' />
<format type='TXT' octets='113975' target='http://www.rfc-editor.org/rfc/rfc3369.txt' />
</reference>
<?rfc linefile="695:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.2630.xml"?>

<reference anchor='RFC2630'>

<front>
<title>Cryptographic Message Syntax</title>
<author initials='R.' surname='Housley' fullname='Russell Housley'>
<organization>SPYRUS</organization>
<address>
<postal>
<street>381 Elden Street</street>
<street>Suite 1120</street>
<city>Herndon</city>
<region>VA</region>
<code>20170</code>
<country>US</country></postal>
<email>housley@spyrus.com</email></address></author>
<date year='1999' month='June' />
<abstract>
<t>This document describes the Cryptographic Message Syntax. This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary messages.</t>
<t>The Cryptographic Message Syntax is derived from PKCS #7 version 1.5 as specified in . Wherever possible, backward compatibility is preserved; however, changes were necessary to accommodate attribute certificate transfer and key agreement techniques for key management.</t></abstract></front>

<seriesInfo name='RFC' value='2630' />
<format type='TXT' octets='128599' target='http://www.rfc-editor.org/rfc/rfc2630.txt' />
</reference>
<?rfc linefile="696:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.4262.xml"?>

<reference anchor='RFC4262'>

<front>
<title>X.509 Certificate Extension for Secure/Multipurpose Internet Mail Extensions (S/MIME) Capabilities</title>
<author initials='S.' surname='Santesson' fullname='S. Santesson'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document defines a certificate extension for inclusion of Secure/Multipurpose Internet Mail Extensions (S/MIME) Capabilities in X.509 public key certificates, as defined by RFC 3280.  This certificate extension provides an optional method to indicate the cryptographic capabilities of an entity as a complement to the S/MIME Capabilities signed attribute in S/MIME messages according to RFC 3851. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4262' />
<format type='TXT' octets='9801' target='http://www.rfc-editor.org/rfc/rfc4262.txt' />
</reference>
<?rfc linefile="697:eps.xml"?>
      <?rfc linefile="1:bibxml/reference.RFC.5084.xml"?>

<reference anchor='RFC5084'>

<front>
<title>Using AES-CCM and AES-GCM Authenticated Encryption in the Cryptographic Message Syntax (CMS)</title>
<author initials='R.' surname='Housley' fullname='R. Housley'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This document specifies the conventions for using the AES-CCM and the AES-GCM authenticated encryption algorithms with the Cryptographic Message Syntax (CMS) authenticated-enveloped-data content type. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5084' />
<format type='TXT' octets='21821' target='http://www.rfc-editor.org/rfc/rfc5084.txt' />
</reference>
<?rfc linefile="698:eps.xml"?>
      <reference anchor="plasma-token">
        <front>
          <title>Plasma Service Trust Processing</title>
          <author initials="J." surname="Schaad"/>
          <date month="March" year="2012"/>
        </front>
        <seriesInfo name="Work in progress" value="draft-schaad-plasma-service"/>
      </reference>
      <reference anchor="XACML" target="http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-cs-01.en.doc">
        <front>
          <title>eXtensible Access Control Markup Language (XACML) Version 3.0</title>
          <author initials="E" surname="Rissanen" role="Editor"/>
          <date month="August" day='10' year='2010'/>
        </front>
        <seriesInfo name="OASIS Standard" value="xacml-201008"/>
        <format type='HTML' target="http://docs.oasis-open.org/xacml/3.0/xacml03.0-core-spec-cs-01-en.html"/>
      </reference>

      <reference  target='http://www.w3.org/TR/2009/CR-exi-20091208' anchor='EXI'>
        <front>
          <title>Efficient XML Interchange (EXI) Format 1.0</title>
          <author fullname='Takuki Kamiya' initials='T.' surname='Kamiya'>
            <organization />
          </author>

          <author fullname='John Schneider' initials='J.' surname='Schneider'>
            <organization />
          </author>

          <date year='2009' day='8' month='December' />
        </front>

        <seriesInfo value='CR-exi-20091208' name='World Wide Web Consortium CR' />
        <format type='HTML' target='http://www.w3.org/TR/2009/CR-exi-20091208' />
      </reference>

    </references>
    <section title="2009 ASN.1 Module">
      <?rfc linefile="1:ForDraft/eps.incl"?><figure><artwork>
PolicySMime -- TBD Get a module number --
DEFINITIONS IMPLICIT TAGS ::=
BEGIN
  IMPORTS
   -- Cryptographic Message Syntax (CMS) [RFC5652]

   CONTENT-TYPE, RecipientInfo, KEY-ATTRIBUTE, SignedData,
   DigestAlgorithmIdentifier, SignerInfo
   FROM  CryptographicMessageSyntax-2010
     { iso(1) member-body(2) us(840) rsadsi(113549)
       pkcs(1) pkcs-9(9) smime(16) modules(0) id-mod-cms-2009(58) }

   -- Common PKIX structures [RFC5912]

   SMIME-CAPS
   FROM AlgorithmInformation-2009
     { iso(1) identified-organization(3) dod(6) internet(1)
       security(5) mechanisms(5) pkix(7) id-mod(0)
       id-mod-algorithmInformation-02(58)}


   ATTRIBUTE, SingleAttribute{}
   FROM PKIX-CommonTypes-2009
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-pkixCommon-02(57) }

   ESSSecurityLabel       
   FROM ExtendedSecurityServices-2009
      { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
        smime(16) modules(0) id-mod-ess-2006-02(42) }

   id-cap
   FROM SecureMimeMessage
     {  iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
       smime(16) modules(0) id-mod-msg-v3dot1-02(39) }
   ;

   --
   --  PLASMA Content Type
   --

   ct-plasma-LockBox CONTENT-TYPE ::= {
       TYPE PLASMA-LockBox
       IDENTIFIED BY id-ct-plasma-LockBox
   }

   id-ct-plasma-LockBox OBJECT IDENTIFIER ::= {iso(1) member-body(2)
       us(840) rsadsi(113549) pkcs(1) pkcs7(7) TBD1}

   PLASMA-LockBox ::= SEQUENCE {
      policy       OCTET STRING,
      keyList      KeyList,
      attrList     AttributeList OPTIONAL
   }

   KeyList ::= SEQUENCE {
      namedRecipients    [0] SEQUENCE SIZE (1..MAX) OF 
                                NamedRecipient OPTIONAL,
      defaultRecipients  [1] SEQUENCE SIZE (1..MAX) OF 
                                OneCek OPTIONAL,
      ...
   }
   (WITH COMPONENTS {
        ...,
        namedRecipients         PRESENT
    } |
    WITH COMPONENTS {
        ...,
        defaultRecipients       PRESENT
    })

   NamedRecipient ::= SEQUENCE {
      recipientName       UTF8String, -- name of the recipient
      keyPolicy           [0] OCTET STRING OPTIONAL,
      keyIdentifier       OCTET STRING OPTIONAL,
      keyValue            RecipientInfo,
      ...
   }

   OneCek ::= SEQUENCE {
      keyPolicy           [0] OCTET STRING OPTIONAL,
      keyIdentifier       [1] OCTET STRING OPTIONAL,
      keyValue            OCTET STRING,
      ...
   }

   AttributeList ::= SEQUENCE SIZE (1..MAX) OF
        SingleAttribute{{PlasmaLockboxAttributes}}

   PlasmaLockboxAttributes ATTRIBUTE ::= { aa-plasma-AuditTrailIdentifier |
        aa-plasma-SignerInfo | aa-plasma-Xacml-Attribute, ... }

   PlasmaSignedAttributes ATTRIBUTE ::= {
        aa-plasma-url | aa-plasma-econtent-hash
   }
       

   --  
   --  New Other Key Attribute value for Plasma
   --  This structure holds the encrypted KEK value for the server
   --  and other signed attributes used by the client for checking
   --  the structure applies in this case
   --

   keyatt-plasma-kek KEY-ATTRIBUTE ::= {
      SignedData IDENTIFIED BY id-keyatt-plasma-token
   }

   id-keyatt-plasma-token OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD2 }

   --
   --  Define the Signed Attribute to carry the 
   --       Email Policy Server URL
   --
   --  This attribute is added to the SignedAttributSet set of
   --  attributes in [CMS-ASN]
   --

   aa-plasma-url ATTRIBUTE ::= {
      TYPE UTF8String IDENTIFIED BY id-aa-plasma-url
   }

   id-aa-plasma-url OBJECT IDENTIFIER ::= { iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD3}

   --
   -- Define the Signed Attribute to carry the
   --      hash of encrypted data
   --
   --  This attribute is added to the SignedAttributeSet set of
   --  attributes in [CMS-ASN]
   --

   aa-plasma-econtent-hash ATTRIBUTE ::= {
      TYPE HashValue IDENTIFIED BY id-aa-plasma-econtent-hash
   }

   id-aa-plasma-econtent-hash OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD4}

   HashValue ::= SEQUENCE {
       hashAlgorithm    DigestAlgorithmIdentifier,
       hashValue        OCTET STRING
   }

   --
   --  Create an S/MIME capability for advertising that
   --    a client can understand the PLASMA recipient info
   --   structure information
   --

   cap-Plasma-RecipientInfo SMIME-CAPS ::= {
        IDENTIFIED BY id-cap-plasma-recipientInfo 
   }

   id-cap-plasma-recipientInfo OBJECT IDENTIFIER ::= {
     id-cap TBD5
   }

   --
   --  Attribute to hold an Audit Trail Identifier
   --

   aa-plasma-AuditTrailIdentifier ATTRIBUTE ::= {
     TYPE OCTET STRING IDENTIFIED BY id-aa-plasma-Audit-Trail-Identifier
   }

   id-aa-plasma-Audit-Trail-Identifier OBJECT IDENTIFIER ::= {
        iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD5}


   --
   --  Attribute to hold a SignerInfo structure
   --

   aa-plasma-SignerInfo ATTRIBUTE ::= {
     TYPE SignerInfo IDENTIFIED BY id-aa-plasma-signerInfo
   }

   id-aa-plasma-signerInfo OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD6}


   --
   --  Attribute to hold an arbitrary XACML XML attribute
   --  structure
   --

   aa-plasma-Xacml-Attribute ATTRIBUTE ::= {
     TYPE OCTET STRING IDENTIFIED BY id-aa-plasma-Xacml-Attribute
   }

   id-aa-plasma-Xacml-Attribute OBJECT IDENTIFIER ::= {iso(1) member-body(2)
        us(840) rsadsi(113549) pkcs(1) pkcs9(9) TBD7}


END
</artwork></figure>
<?rfc linefile="737:eps.xml"?>
    </section>

    <section title="Policy Encoding Techniques" anchor="CompressedPolicy">
      <t>
        This appendix is informative.
      </t>

      <t>
        The fields for encoding a policy expression is an ASN.1 OCTET STRING.
        This field type was chosen so that servers would have the widest choice of methods to encode the policy expressions.
        For stand alone servers, the only issue is that the server will be able to correctly extract and use the policy expression, as such it can be kept in XML or converted into a format that is more natural to the policy evaluation engine used by the server.
        When one wants to use multiple servers, then all of the servers involved need to be able to use the encoded format(s) and re-map them into the internal versions that are used locally.
        This is far more complicated when the servers are hosted by different organizations that might be using different local policy evaluation engines.
      </t>

      <t>
        It is RECOMMENDED that what ever encoding method is used normally, a provision exist for the XML version of the policy string as presented in RFC XXX <xref target="plasma-token"/> exist without change.
        Doing so allows for a single common format to be shared among all Plasma servers independent of the organization providing the server and the one operating the server.
        The server will be able to determine the set of other servers that will be able to process the content, as the server must be configured with that information in order to create the appropriate lock boxes for the other servers to access the encrypted content.
      </t>

      <t>
        There are two different methods that exist where the XML encoding can be compressed before placing it into the OCTET STRING.
        The first would be to use the Efficient XML Interchange (EXI) Format documented in <xref target="EXI"/>.
        A second method would be to use the standard DEFLATE algorithm either with or without a pre-defined library.
      </t>

      <t>
        A possible method of encoding would to be use the first byte to identify the encoding technique, reserving 0x3C for vanilla XML strings.
        Following bytes could be used to determine which pre-defined table was used and then the compressed encoding.
      </t>

    </section>
  </back>
</rfc>
