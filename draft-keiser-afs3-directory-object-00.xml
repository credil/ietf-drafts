<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119">

]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- used by XSLT processors -->

<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>

<!-- control the table of contents (ToC) -->
<!-- generate a ToC -->
<?rfc toc="yes" ?>

<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="4" ?>

<!-- control references -->
<?rfc symrefs="yes" ?>

<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>

<!-- sort the reference entries alphabetically -->

<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<!-- do not start each main section on a new page -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>

<!-- end of list of popular I-D processing instructions -->

<rfc
category="info"
docName="draft-keiser-afs3-directory-object-00"
ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->



  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->

    <title abbrev="AFS-3 Directory Object">AFS-3 Directory Object Type Definition</title>

    <!-- add role="editor" below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Thomas Keiser" initials="T.E.K."
            surname="Keiser">
      <organization abbrev="Sine Nomine">Sine Nomine Associates</organization>
      <address>
        <postal>
          <street>43596 Blacksmith Square</street>
          <city>Ashburn</city>
          <region>VA</region>
          <code>20147</code>
          <country>USA</country>
        </postal>
        <phone>+1 703 723 6673</phone>
        <email>tkeiser@sinenomine.net</email>
      </address>
    </author>


    <date year="2012" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>
<!--
    <workgroup>IETF</workgroup>
-->

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>afs</keyword>
    <keyword>afs3</keyword>
    <keyword>afs-3</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>

        Directory lookups in the AFS-3 distributed file system are supported by
        defining a canonical encoding for a directory object, and transmitting
        all--or part--of that object from a file server to its clients so that
        clients may resolve paths into AFS file IDs (FIDs).  This memo describes
        the AFS-3 directory object wire encoding.
      </t>
    </abstract>


    <note title="Internet Draft Comments">
      <t>
        Comments regarding this draft are solicited.  Please include the AFS-3 protocol
        standardization mailing list (afs3-standardization@openafs.org) as a recipient
        of any comments.
      </t>
    </note>

  </front>



  <middle>
    <section title="Introduction">
      <t>
        AFS-3 <xref target="AFS1"/> <xref target="AFS2"/>
        is a distributed file system that has its origins
        in the VICE project <xref target="CMU-ITC-84-020"/>
        <xref target="VICE1"/> at the Carnegie Mellon University
        Information Technology Center <xref target="CMU-ITC-83-025"/>, 
        a joint venture between CMU and IBM.  VICE later became AFS when
        CMU moved development to a new commercial venture called
        Transarc Corporation, which later became IBM
        Pittsburgh Labs.  AFS-3 is a suite of un-standardized 
        network protocols based on a remote procedure call (RPC)
        suite known as Rx <xref target="AFS3-RX"/>.
        While de jure standards for AFS-3
        fail to exist, the various AFS-3 implementations have 
        agreed upon certain de facto
        standards, largely helped by the existence of
        an open source fork called OpenAFS that has served
        the role of reference implementation.  In addition to
        using OpenAFS as a reference, IBM wrote and donated developer
        documentation that contains somewhat outdated specifications
        for the Rx protocol and all AFS-3 remote procedure calls, as
        well as a detailed description of the AFS-3 system architecture.
      </t>

      <t>
        Unlike most classical network file systems, AFS-3 explicitly
        eschews remote procedure calls to facilitate file server-assisted directory lookup
        operations.  This was a conscious decision meant to limit server load
        by placing lookup operations on the clients.  In the common cases, where
        there is significant locality of reference to directory entries, this
        results in a substantial reduction in server load (especially given the
        AFS-3 cache coherence model).  It should be noted that 23 years of 
        empirical evidence have borne out this decision as useful for many general-purpose
        workloads, while disadvantageous for certain very specific workloads (e.g.,
        large directory objects with extremely non-uniform directory entry
        reference distributions--where the server overhead of a lookup rpc would
        would inconsequential compared to the directory file transfer overhead of the
        existing model).
      </t>

      <t>
        Due to the distributed nature of AFS-3 directory objects, a canonical
        directory wire-format is an intrinsic part of the AFS-3 protocol.  This
        memo documents the directory object wire format; a future document will document
	the lookup and modification algorithms, which by the decentralized nature of
	AFS-3 directories, must be implemented in the to-be-specified manner.
      </t>

      <section title="Abbreviations">
        <t>
          <list style="hanging" hangIndent="8">

<t hangText="AFS    -">Historically, AFS stood for the Andrew File System; AFS no longer stands for anything</t>
<t hangText="RPC    -">Remote Procedure Call</t>
<t hangText="Rx     -">The Remote Procedure Call mechanism utilized by AFS-3</t>
<t hangText="XDR    -">eXternal Data Representation</t>
</list>
        </t>
      </section>
    </section>

    <section title="Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </section>


    <section title="Constants">
      <t>
	<list style="hanging" hangIndent="4">

<t hangText="AFS_PAGESIZE = 2048">
<vspace blankLines="1"/>
the size of each page in an AFS-3 directory object (in octets)
</t>
<t hangText="MAXPAGES     =  128">
<vspace blankLines="1"/>
the maximum number of pages in a legacy directory object
</t>
<t hangText="BIGMAXPAGES  = 1023">
<vspace blankLines="1"/>
the maximum number of pages in a new (circa 1988) directory object
</t>
<t hangText="NHASHENT     =  128">
<vspace blankLines="1"/>
number of hash buckets in the entry name hash table
</t>
<t hangText="RECSIZE      =   32">
<vspace blankLines="1"/>
number of octets in a record
</t>
<t hangText="LRECSIZE     =    5">
<vspace blankLines="1"/>
base-2 logarithm of RECSIZE
</t>
<t hangText="EPP          =   64">
<vspace blankLines="1"/>
number of records per page
</t>
<t hangText="LEPP         =    6">
<vspace blankLines="1"/>
base-2 logarithm of EPP
</t>
<t hangText="DHE          =   12">
<vspace blankLines="1"/>
number of records taken up in page 0 by the directory header
</t>
</list>
      </t>
    </section>

    <section title="Directory Object Structure">
      <t>
        An AFS-3 directory object consists of between 1 and BIGMAXPAGES (1023) 
        "pages" of length AFS_PAGESIZE (2048 octet).
      </t>

      <figure align="center">
        <artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          page  #0000                          |
~                         (2048 octets)                         ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                              ...                              ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          page  #1022                          |
~                         (2048 octets)                         ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ]]></artwork>
        <postamble>Directory Structure</postamble>
      </figure>
    </section>

    <section title="Page Structure">
<!--
      <t>
        Each page contains a header followed by some number of
        RECSIZE (32 octet) records.  The first page of the directory object
        is special in that it contains a larger header to accomodate a page
        allocation map, and hash chain heads.
      </t>

      <t>
        Structurally, all pages (with the caveat that the first page is
        different) consist of 64 32-octet records.  The first 32-octet record
        is special: it contains the page header.
      </t>
-->
      <t>
        All pages in a directory object are AFS_PAGESIZE (2048 octets) in
        length.  All pages are subdivided into EPP (64) records, each
        RECSIZE (32 octets) in length.
      </t>

      <figure align="center">
        <artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          record #00                           |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                              ...                              ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          record #63                           |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ]]></artwork>
        <postamble>Page Structure</postamble>
      </figure>

      <section title="Record Index" anchor="sec-record-index">
        <t>
          Each record within a directory object is referenced by an index number.
          This number represents the offset from the start of the file, in units of
          records, i.e., in multiples of RECSIZE.  A record index of 0 would thus 
          point to record 0 in page 0, and a record index of 67 would point to
          record 3 in page 1.  Computing the file offset from an index is
          simply a matter of left logical shifting the index value by LRECSIZE (5)
          bits.  Conversely, computing the index from a file offset merely
          involves a right logical shift by LRECSIZE (5) bits.
        </t>
      </section>

      <section title="Page header" anchor="sec-page-header">
        <t>
          Each 2048-octet page within an AFS-3 directory object contains a
          32-octet (RECSIZE) header at offset 0 in the following form:
        </t>

<figure align="center">
<artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            pgcount            |              tag              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   reserved    |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                       allocation bitmap                       |
+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                           reserved                            |
~                          (19 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork><postamble>Directory Page Header</postamble></figure>
        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="pgcount: 16 bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field only holds meaning for page 0.  For the modern
              (post-1988) directory format, this field holds the count of
              valid directory pages (in network byte order) within the 
              directory object.  When this value is zero, it denotes a 
              legacy directory object.  Legacy directory objects are considered
              a deprecated and historical vestige, and thus their format
              is not described in this memo.
            </t>
            <t hangText="tag: 16 bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field MUST contain the magic value 1234 in network
              byte order.
            </t>
            <t hangText="allocation bitmap: 8 octets (bit string)">
              <vspace blankLines="1"/>
              The allocation bitmap is a bit field which contains one bit per
              record slot within the page.  The bit field is thus 8
              (EPP/8) octets in length.  A bit value of zero
              indicates the entry is free; a value of 1 indicates the
              entry has been allocated.  The allocation bitmap will be discussed
              further in <xref target="sec-allocation_bitmap"/>.
            </t>
          </list>
        </t>

        <section title="Allocation Bitmap" anchor="sec-allocation_bitmap">
          <t>
            The allocation bitmap contains one bit per record.
            The least significant bit of the first octet within
            the bitmap references the page header object (which is stored at offset 0).
            The second least significant bit of the first octet within the bitmap
            references the record index 1 (offset 32 octets into the page), and
            so on and so forth...until the most significant bit of the eighth
            octet of the allocation bitmap references the 64th--and final--record
            of the page (record 63 at page offset 2016).
          </t>

          <t>
            The following invariants hold:
          </t>

          <figure align="left">
            <artwork><![CDATA[
    page_entry_offset = page_entry_index << LRECSIZE

    alloc_bitmap_index = page_entry_index >> 3

    alloc_bitmap_bit_num = page_entry_index & 0x7

    alloc_bitmap_bit = 1 << alloc_bitmap_bit_num
            ]]></artwork>
          </figure>

          <t>
            The variable page_entry_index,
            which is an unsigned integer between 0 and 63, can be derived from
            the record index (<xref target="sec-record-index"/>) by bit-wise ANDing it
            with EPP-1.
          </t>

          <t>
            The equations above are written in C pseudocode--the variables are
            all assumed to be unsigned integers, and the operators are assumed
            to be identical to the ANSI C standard.
          </t>
        </section>
      </section>
    </section>

    <section title="Page N=0 structure">
      <t>
        Page 0 is special due to the directory header.  It is structured as 
        follows:
      </t>

      <t>
        <list style="numbers">
          <t>a page header (see <xref target="sec-page-header"/>)</t>
          <t>a directory header (see <xref target="sec-dir-header"/>)</t>
          <t>51 data records (EPP-DHE-1=51)</t>
        </list>
      </t>

      <figure align="center">
        <artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          page header                          |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       directory header                        |
~                         (384 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        data record #13                        |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                              ...                              ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        data record #63                        |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ]]></artwork>
        <postamble>Directory Page N=0 Structure</postamble>
      </figure>

      <section title="Directory Header" anchor="sec-dir-header">
        <t>
          The directory header structure is a 384-octet structure that
          is stored at an offset of 32 octets from the beginning of
          the directory object (i.e., directly following the page 0
          page header--see <xref target="sec-page-header"/>).  The directory
          header layout is as follows:
        </t>

        <figure align="center">
          <artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| page   0  map | page   1  map | page   2  map | page   3  map |
~                                                               ~
| page 124  map | page 125  map | page 126  map | page 127  map |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        hash chain    0        |        hash chain    1        |
~                                                               ~
|        hash chain  126        |        hash chain  127        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          ]]></artwork>
          <postamble>Directory Header</postamble>
        </figure>

        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="page map:">
              <vspace blankLines="1"/>
              Each of the MAXPAGES page map fields corresponds to one of the
              MAXPAGES pages in a legacy directory object.  Each field
              contains the count of available entries in this directory page.  A
              value of EPP indicates that this page has not yet been allocated
              (i.e., the page header has not been initialized).
            </t>
            <t hangText="hash chain:">
              <vspace blankLines="1"/>
              Each of the NHASHENT hash chain fields contains a record index
              for the first directory entry name that hashes to this bucket
              (see <xref target="sec-record-index"/>, and
               see <xref target="sec-hash-function"/> for a description of the hash
               function)
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Page N&gt;0 structure">
      <t>
        Each page N&gt;0 is structured as follows:
        <list style="numbers">
          <t>a page header (see <xref target="sec-page-header"/>)</t>
          <t>EPP-1 (63) data records</t>
        </list>
      </t>

      <figure align="center">
        <artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            header                             |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        data record #01                        |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                              ...                              ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        data record #63                        |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ]]></artwork>
        <postamble>Directory Page N&gt;0 Structure</postamble>
      </figure>
    </section>

    <section title="Directory Entry" anchor="sec-dirent">
      <t>
        Since entry names are of variable length, directory
        entries are structured as follows:
      </t>

      <t>
        <list style="symbols">
          <t>a directory entry record (see <xref target="sec-dirent-rec"/>)</t>
          <t>zero or more directory entry extension record(s) (see <xref target="sec-dirent-ext-rec"/>)</t>
        </list>
      </t>

      <t>
        This sequence of records MUST be contiguous, and MUST NOT
        cross a directory page boundary.
      </t>

      <section title="Directory Entry Record" anchor="sec-dirent-rec">
        <t>
          A directory entry record contains the dirent entry metadata (i.e., the
          vnode number and uniquifier, the name hash table next pointer, flag bits,
          and the first twenty octets of the entry name string.  Its layout is as
          follows:
        </t>

<figure align="center">
<artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |   reserved    |             next              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             vnode                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          uniquifier                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             name                              |
~                          (20 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork><postamble>Directory Entry Record</postamble></figure>
        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="flags: 8 bits ">
              <vspace blankLines="1"/>
              This is an 8-bit wide bit vector.  Currently, only one bit is
              defined: FFIRST (0x1).  This flag bit is asserted in every record
              of this type.  There are vestiges in the OpenAFS implementation 
              suggesting that the original intention was to have a second flag
              bit FNEXT (0x2)--being asserted in the first octet of extension
              records--which would allow parsers to distinguish between
              entry records and extension records.  However, this idea was
              never implemented (in fact, the concept of a flags field in an
              extension record does not exist), and thus this flag bit has no meaning.
              It should be noted that some tools have attempted to use this bit to
              distinguish between entry records and entry extension records (under
              the assumption that 0x1 is not a valid ASCII value for a file
              name string).  This technique is obviously error-prone, and thus 
              SHOULD NOT be relied upon.
            </t>
            <t hangText="next: 16 bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field contains a record index 
              (see <xref target="sec-record-index"/>)
              pointing to the next directory entry record on this name hash
              chain.  A value of zero indicates this is the last record on
              this chain.  This entry MUST point to a record index which contains
              a data record of the directory entry type (see <xref target="sec-dirent"/>).
            </t>
            <t hangText="vnode: 32 bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field contains the target vnode number for this directory
              entry.  Together with the uniquifier field, this forms the
              equivalent of an inode number in the directory entry of a typical
              on-disk Unix file system.
            </t>
            <t hangText="uniquifier: 32 bits (unsigned integer)">
              <vspace blankLines="1"/>
              This field contains the target uniquifier for this directory
              entry.  Together with the vnode field, this forms the
              equivalent of an inode number in the directory entry of a typical
              on-disk Unix file system.
            </t>
            <t hangText="name: 20 octets (null-terminated string)">
              <vspace blankLines="1"/>
              The first 20 octets of the directory entry's name string are
              contained in this field.  If the name string (including null
              terminator) exceeds 20 octets, then this string will continue in
              a sequence of one or more directory entry extension records
              (see <xref target="sec-dirent-ext-rec"/>) 
              that MUST directly proceed this record.
            </t>
          </list>
        </t>
      </section>

      <section title="Directory Entry Extension Record" anchor="sec-dirent-ext-rec">
        <t>
          When a file name string exceeds the 20 octets set aside in an entry record,
          one or more extension records MUST be allocated contiguously following the
          base entry record in order to contain the rest of the name string.  The
          layout of an extension record is as follows:
        </t>

<figure align="center">
<artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             name                              |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork><postamble>Directory Entry Extension Record</postamble></figure>
        <t>
          <list style="hanging" hangIndent="4">
            <t hangText="name: 32 octets (string)">
              <vspace blankLines="1"/>
              This field contains part of an extended directory entry name string.
              If this is the last directory entry extension record, then this
              field MUST contain a null terminator character (octet value zero)
              within its 32 octets.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Name Hash Function" anchor="sec-hash-function">
      <t>
        The hash function is a loop over each of the octets within the
        name string.  The hash is computed using integer arithmetic on
        an unsigned 32-bit integer.  The hash MUST be initialized to zero before
        commencing iteration over the characters in the name string.  For each
        character, the hash value is multiplied by the constant 173, and then
        the value of the current character is added to the hash.  When
        the null terminator is encountered, the loop is terminated before 
        the hash is multiplied by 173.  
      </t>

      <t>
        For reasons unknown to the author, the resultant unsigned hash value is
        then compared against the value 2^31.  If the hash value is less than 
        2^31 (i.e., what would be the sign bit--if the hash value were signed--
        is not asserted), then the resultant hash value
        will be the value computed in the above loop bitwise ANDed with the constant 
        NHASHENT-1 (127).  However, if the hash value is greater than or equal to
        2^31, then the resultant hash value will first be bitwise anded with the
        constant NHASHENT-1 (127), and then the value will be subtracted from the
        constant NHASHENT (128) to yield the final hash value.
      </t>
    </section>

<!--
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        ##$#
      </t>
    </section>
-->

    <!-- Possibly a 'Contributors' section ... -->

    <section title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section title="AFS Assign Numbers Registrar Considerations">
      <t>
        This memo includes no request to the AFS Assigned Numbers Registrar.
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        Directory metadata can contain sensistive information.  This memo merely
        specifies the wire format encoding.  Any implementation which may be
        utilized to store and retrieve directories containing entries whose name
        strings might reveal sensitive information should take precautions to
        ensure that they are never transmitted in the clear, and should take
        steps to ensure that those entries are not cached on machines lacking
        appropriate physical and network security.
      </t>
    </section>
  </middle>

  <!-- BACK MATTER -->

  <back>

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2119;

    </references>

    <references title="Informative References">
      <reference anchor="CMU-ITC-84-020">
        <front>
          <title>VICE File System Services</title>

          <author initials="M.J." surname="West" fullname="MJ West">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1984" month="August" day="7" />
        </front>
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-84-020" />
      </reference>

      <reference anchor="CMU-ITC-83-025">
        <front>
          <title>The Information Technology Center</title>

          <author initials="J.H." surname="Morris" fullname="James H. Morris">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="D." surname="Van Houweling" fullname="Douglas Van Houweling">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="K." surname="Slack" fullname="Keith Slack">
            <organization abbrev="IBM">International Business Machines Corporation</organization>
          </author>

          <date year="1983"/>
        </front>
        <seriesInfo name="CMU ITC Tech. Rep." value="CMU-ITC-83-025" />
      </reference>

      <reference anchor="AFS3-RX">
        <front>
          <title>AFS-3 Programmer's Reference: Specification for the Rx Remote Procedure Call Facility</title>

          <author initials="E.R." surname="Zayas" fullname="Edward R. Zayas">
            <organization abbrev="Transarc">Transarc Corporation</organization>
          </author>

          <date year="1991" month="August" day="28" />
        </front>
        <seriesInfo name="Transarc Corp. Tech. Rep." value="FS-00-D164" />
      </reference>

      <reference anchor="VICE1">
        <front>
          <title>The ITC Distributed File System: Principles and Design</title>

          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="J.H." surname="Howard" fullname="John H. Howard">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="D.A." surname="Nichols" fullname="David A. Nichols">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="R.N." surname="Sidebotham" fullname="Robert N. Sidebotham">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="A.Z." surname="Spector" fullname="Alfred Z. Spector">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>
          <author initials="M.J." surname="West" fullname="Michael J. West">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1985" month="December"/>
        </front>
        <seriesInfo name="Proc. 10th ACM Symp. Operating Sys. Princ." value="Vol. 19, No. 5" />
      </reference>

      <reference anchor="AFS1">
        <front>
          <title>An Overview of the Andrew File System"</title>

          <author initials="J.H." surname="Howard" fullname="John H. Howard">
            <organization abbrev="CMU-ITC">Carnegie Mellon University Information Technology Center</organization>
          </author>

          <date year="1988" month="February" />
        </front>
        <seriesInfo name="Proc. 1988 USENIX Winter Tech. Conf." value="pp. 23-26" />
      </reference>

      <reference anchor="AFS2">
        <front>
          <title>Scale and Performance in a Distributed File System</title>

          <author initials="J.H." surname="Howard" fullname="John H. Howard">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="M.L." surname="Kazar" fullname="Michael L. Kazar">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="S.G." surname="Menees" fullname="Sherri G. Menees">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="D.A." surname="Nichols" fullname="David A. Nichols">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="M." surname="Satyanarayanan" fullname="M. Satyanarayanan">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="R.N." surname="Sidebotham" fullname="Robert N. Sidebotham">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author initials="M.J." surname="West" fullname="Michael J. West">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>

          <date year="1988" month="February" />
        </front>
        <seriesInfo name="ACM Trans. Comp. Sys." value="Vol. 6, No. 1, pp. 51-81" />
      </reference>

    </references>

    <section title="Example Directory Object">
      <section title="18-character name string">

<figure align="center">
<artwork><![CDATA[
(MSB)                                                       (LSB)
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           pgcount=1           |           tag=1234            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   reserved    |1|         0xfff         |1 1|                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                 +
|                             0...                              |
+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                           reserved                            |
~                          (19 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   map[0]=49   |                                               |
+-+-+-+-+-+-+-+-+                                               +
|                map[1...127]=0x40 0x40 0x40 ...                |
~                         (127 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                hash[0...127]=0x0000 0x0000 ...                |
~                         (256 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   flags=0x1   |   reserved    |          next=0x0000          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             vnode                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          uniquifier                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   name="iamexactly018chars"                   |
~                          (18 octets)                          ~
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |      nul      |       ?       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            allocated extent record full of garbage            |
~                          (32 octets)                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      unallocated garbage                      |
~                         (1568 octets)                         ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork><postamble>18-Character Name String</postamble></figure>
      </section>
    </section>

    <section title="C Implementation of Directory Hash Function">
      <figure align="left" anchor="afsvol-tlv-xdr">
        <artwork><![CDATA[
#define NHASHENT 128

unsigned int
dir_name_hash(const char * name)
{
    unsigned int hash = 0;

    while(*name++) {
        hash *= 173;
        hash += *name;
    }

    if (hash & 0x80000000) {
        return NHASHENT - (hash & (NHASHENT-1));
    } else {
        return hash & (NHASHENT-1);
    }
}
]]></artwork>
      </figure>
    </section>

    <!-- Change Log
v00 2012-04-23  TEK  Initial Version
     -->

  </back>

</rfc>
