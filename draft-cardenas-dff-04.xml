<?xml version="1.0" encoding="US-ASCII"?>
    
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->



<rfc category="exp" docName="draft-cardenas-dff-04" ipr="trust200902">
	<!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes ups="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->
	<!-- ***** FRONT MATTER ***** -->
	<front>
		<!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
		<title abbrev="DFF">Depth-First Forwarding in Unreliable Networks</title>
		<!-- add 'role="editor"' below for the editors if appropriate -->
		<!-- Another author who claims to be an editor -->
		
		<author fullname="Ulrich Herberg" initials="U.H." surname="Herberg">
			<organization>Fujitsu</organization>
			<address>
				<postal>
					<street>1240 E. Arques Avenue, M/S 345</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94085</code>
					<country>US</country>
				</postal>
				<phone>+1 408 530-4528</phone>
				<email>ulrich.herberg@us.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Alvaro A. Cardenas" initials="A.C." surname="Cardenas">
			<organization>Fujitsu</organization>
			<address>
				<postal>
					<street>1240 E. Arques Avenue, M/S 345</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94085</code>
					<country>US</country>
				</postal>
				<phone>+1 408 530-4516</phone>
				<email>alvaro.cardenas-mora@us.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Tadashige Iwao" initials="T.I." surname="Iwao">
			<organization>Fujitsu</organization>
			<address>
				<postal>
					<street>Shiodome City Center, 5-2, Higashi-shimbashi 1-chome, Minato-ku</street>
					<city>Tokyo</city>
					<region/>
					<code/>
					<country>JP</country>
				</postal>
				<phone>+81-44-754-3343</phone>
				<email>smartnetpro-iwao_std@ml.css.fujitsu.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Michael L. Dow" initials="M.L." surname="Dow">
			<organization>Freescale</organization>
			<address>
				<postal>
					<street>6501 William Cannon Drive West</street>
					<city>Austin</city>
					<region>TX</region>
					<code>78735</code>
					<country>USA</country>
				</postal>
				<phone>+1 512 895 4944</phone>
				<email>m.dow@freescale.com</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		
		<author fullname="Sandra L. Cespedes" initials="S.C." surname="Cespedes">
			<organization>U. Icesi/U. of Waterloo</organization>
			<address>
				<postal>
					<street>Calle 18 No. 122-135 Pance</street>
					<city>Cali</city>
					<region>Valle</region>
					<code/>
					<country>Colombia</country>
				</postal>
				<phone/>
				<email>slcesped@bbcr.uwaterloo.ca</email>
				<!-- uri and facsimile elements may also be added -->
			</address>
		</author>
		

		

		
		<date year="2012"/>

		<!-- Meta-data Declarations -->
		<area>General</area>
		
		<workgroup>Internet Engineering Task Force</workgroup>
		<!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->
        
		<keyword>DFF</keyword>
		<!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->
        
		<abstract>
			<t>
				This document describes the Depth-First Forwarding (DFF) protocol for IPv6 networks based on the LoWPAN adaptation layer. The protocol is a mesh-under data forwarding mechanism that increases reliability of data delivery.
			</t>
			
			<t>
				DFF forwards data frames using a network-wide "depth-first search" for the Final Destination of the frame. DFF may be used in conjunction with a mesh-under routing protocol, which provides "hints" for DFF in which order to try to send the frame to the neighbors discovered by the neighborhood discovery mechanism. In that case, DFF can be used as local repair mechanism.
			</t>
		</abstract>
	</front>
	
	
	<middle>
		<section title="Introduction">			
			<t>
				This document describes the Depth-First Forwarding (DFF) protocol for IPv6 networks based on the LoWPAN adaptation layer, as specified in <xref target="RFC4944"/>. The protocol is a mesh-under data forwarding mechanism that increases reliability of data delivery in networks with dynamic topologies.
			</t>
			
			<t>
				DFF forwards data frames using a network-wide "depth-first search" for the Final Destination of the frame. DFF relies on a neighborhood discovery mechanism which lists neighbors of a node for the next hop of a data frame. In addition, DFF may be used in conjunction with a mesh-under routing protocol, which provides "hints" for DFF in which order to try to send the frame to the neighbors discovered by the neighborhood discovery mechanism.
			</t>
			
			<t>
				If the frame makes no forward progress using the selected next hop, DFF will successively try all neighbors of the node (as determined by an additional mechanism, e.g. a mesh-under routing protocol, ND, HELLO message exchange). If none of the next hops successfully receives the frame, DFF returns the frame to the previous hop, which in turn tries to send it to alternate neighbors.
			</t>
			
			<t>
				As network topologies do not necessarily form a tree, loops can occur. Therefore, DFF contains a loop detection and avoidance mechanism.
			</t>
			
			<t>
				If DFF is used in conjunction with a mesh-under routing protocol,  the cost of routes provided by that routing protocol may be updated while rerouting the frame through alternative next hops. Thus, DFF provides an optional local route repair mechanism.
			</t>
			
			
			<section title="Motivation">
				<t>
					In networks with dynamic topologies, even frequent exchanges of control messages between nodes for updating the routing tables cannot guarantee freshness of routes: frames may not be delivered to their Final Destination because the topology has changed since the last routing protocol update.
				</t> 
				
				<t>
					While more frequent routing protocol updates could mitigate that problem to a certain extent, that requires network bandwidth (e.g. when flooding control messages through the network for route discovery). This is an issue in networks with lossy links, where further control traffic exchange can worsen the network stability because of collisions (e.g. in the case of a network-wide flood of Route Request messages or Link State Advertisements). Moreover, additional control traffic exchange drains energy from battery-driven nodes.
				</t>
				
				<t>
					The data-forwarding mechanism specified in this document allows for forwarding data frames along alternate paths for increasing reliability of data delivery, using a depth-first search. The objective is to decrease the necessary control traffic overhead in the network, and in the same time to increase delivery success rates. If a mesh-under routing protocol is used in conjunction with DFF, that protocol can be informed about the updated topology, and routes can then be repaired.
				</t>
			</section>
			
			<section title="Protocol Dependencies">
				<t>
					DFF can be used as stand-alone forwarding mechanism, but may be used in conjunction with a mesh-under routing protocol which allows for providing an order of preference to which next hops a frame should be forwarded (e.g. the frame may be forwarded first to neighbors that are listed as next hops to the Final Destination, preferring those with the lowest route cost).
				</t>
			
				<t>
					DFF requires a list of bidirectional neighbors for each node, which must be provided by an external mechanism. This specification assumes there is such a neighborhood discovery protocol in place and outlines the requirements for that protocol, as well as the interaction between DFF and a mesh-under routing protocol if such is used in conjunction with DFF.
				</t>
			</section>
    	</section>
    	
			
		<section title="Notation and Terminology">
			<t>
				The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.
       		</t>
       		
       		<t>
       			Additionally, this document uses the notation in <xref target="notation"/> and the terminology in <xref target="terminology"/>.
       		</t>
       		
       		<section anchor="notation" title="Notation">
       			<t>The following notations are used in this document:
       				<list style="hanging">
       					<t hangText="List">
       						- A list of elements is defined as [] for an empty list, [element] for a list with one element, and [element1, element2, ...] for a list with multiple elements.
       					</t>
       					
       					<t hangText="Concatenation of lists:">
       						If L1 and L2 are lists, then L1@L2 is a new list with all elements of L2 concatenated to L1. 
       					</t>
       				</list>
       			</t>
       		</section>
       		
       		<section anchor="terminology" title="Terminology">
				<t>
					All terms introduced in <xref target="RFC4944"/> are to be interpreted as described therein, in particular Originator Address, Final Destination Address, Source Address, and Destination Address.
				</t>
				
				<t>
					Additionally, this document uses the following terminology:
				
					<list style="hanging">
						<t hangText="Address">
							- An address is either a 16-bit short or a EUI-64 link layer address, as specified in <xref target="RFC4944"/>.
						</t>
					
						<t hangText="Packet">
							- An IPv6 packet.
						</t>
						
						<t hangText="Frame">
							- A MAC layer data frame, using the LoWPAN adaption layer, as specified in <xref target="RFC4944"/>.
						</t>
					</list>
				</t>
			</section>
		</section>
		
		
		<section anchor="applicability" title="Applicability Statement">
			<t>
				This protocol:
			
				<list style="symbols">
					<t>
						Is applicable for use in LoWPAN based networks, using the frame format for transmission of IPv6 packets defined in <xref target="RFC4944"/>. The LoWPAN adaption layer can be run on several MAC layer types, such as IEEE 802.15.4 <xref target="ieee802.15.4"/>.
					</t>
					
					<t>
						Assumes addresses used in the network are either 16-bit short or EUI-64 link layer address, as specified in <xref target="RFC4944"/>.
					</t>
					
					<t>
						Assumes that the underlying MAC layer provides means to detect if a frame has been successfully delivered to the next hop or not (e.g. by ACK messages).
					</t>
					
					<t>
						Operates as "mesh-under" forwarding protocol, i.e. on the link layer. While the proposed mechanism could also be used as "route-over", this is not specified in this document and thus out of scope.
					</t>
					
					<t>
						Is designed to work in networks with lossy links or with a dynamic topology.
					</t>
					
					<t>
						Relies on an external neighborhood discovery mechanism, which must provide a list of bidirectional neighbors of a node. In addition, DFF may use information from a mesh-under routing protocol used in conjunction with DFF. Such a protocol provides "hints" to DFF in which order the neighbors should be successively tried as next hop for a frame.
					</t>
					
					<t>
						Increases reliability of data delivery by trying alternative paths, using a "depth-first forwarding" approach.
					</t>
					
					<t>
						Provides a loop detection mechanism, and an optional local route repair mechanism if a mesh-under routing protocol is used in conjunction with DFF.
					</t>	
					
					<t>
						Is designed to work in a completely distributed manner, and does not depend on any central entity.
					</t>
				</list>
			</t>
		</section>
		
		
		<section anchor="overview" title="Protocol Overview and Functioning">
			<t>
				DFF is a mesh-under data forwarding mechanism responsible for finding a path to a Final Destination of a frame, using a "depth-first search" in the network. DFF operates on LoWPAN based networks (using the frame format and the transmission of IPv6 packets defined in <xref target="RFC4944"/>).
			</t>
			
			<t>
				DFF requires an external mechanism to discover the bidirectional neighborhood of a node. The specification of such a mechanism is out of scope of this document. The list of neighbors is required because DFF successively tries to forward a frame to all neighbors of a node during the depth-first search, and eventually returns it to the previous hop if the frame was not successfully received by any of the neighbors.
			</t>
			
			<t>
				In addition to the mandatory neighborhood information, DFF may use information from a mesh-under routing protocol that runs in conjunction with DFF. Such a protocol can increase the efficiency of the depth-first search, as it allows for providing an order of preference which next hops to try first (e.g. by preferring neighbors that are listed in the mesh-under routing protocol as next hops along the path to the Final Destination, and by preferring next hops with a lower route cost). If the topology as reflected by that mesh-under routing protocol represents the effective topology of the network, then DFF will forward the data frame along the path provided by the protocol. However, if the topology has changed and the routing protocol has not yet converged, then DFF will try alternate paths. Compared to the typical forwarding mechanism in LoWPAN networks, a mesh-under routing protocol thus only serves DFF to give recommendations (or "hints") where to forward a frame. That also implies that if the mesh-under routing protocol does not provide a route to a Final Destination, the data frame would not be dropped but forwarded by DFF, trying to find a path to that Final Destination.
			</t>
			
			<t>
				In order to avoid loops when forwarding a data frame towards its Final Destination, DFF stores a frame identifier (i.e. a sequence number) to detect loops. DFF lists for each recently forwarded frame which neighbors that frame has already been sent to, allowing for trying to forward the frame to all candidates for the next hop.
			</t>
			
			<t>
				DFF requires additional header information for each data frame, provided by a LoWPAN header specified in this document. This DFF header contains a sequence number used for identifying a frame uniquely, and two flags: RET and DUP. 
				If none of the transmissions of a data frame to the neighbors of a node has succeeded, the frame is returned to the previous hop, indicated by setting the return (RET) flag. The previous hop then continues to try other neighbors in turn, resulting in a depth-first search in the network.
			</t>
			
			<t>
				Whenever a frame transmission to a neighbor has failed (as determined by the underlying MAC layer, e.g., using ACKs), the duplicate (DUP) flag is set in the frame header for the following transmissions. The rationale is that the frame may have been successfully received by the neighbor and only the ACK has been lost, resulting in duplicates of the frame in the network. The DUP flag tags such a possible duplicate.
			</t>
			
			<t>
				Whenever a node receives a frame that it has already forwarded (as identified by the sequence number of the frame), and which is not a duplicate (i.e. DUP = 0), it will assume a loop and return the frame to the previous hop (with the RET flag set). Optionally, if a mesh-under routing protocol is used in conjunction with DFF, the route using the next hop which resulted in the loop may be "poisoned" (i.e. the route cost may be increased).
			</t>
		</section>
		
		
		<section title="Information Sets">
			<t>
				This section specifies the information sets used by DFF.
			</t>
			
			
			<section title="Neighbor List" anchor="neighbor_list">
				<t>
					 DFF requires access to a list of bidirectional neighbors of the node, provided by an external neighborhood discovery mechanism, which is not specified within this document.
				</t>
			</section>

			<section title="Processed Set" anchor="processed_set">
				<t>
					Each node maintains a Processed Set in order to support the loop detection functionality. The Processed Set lists sequence numbers of previously received frames, as well as a list of next hops to which the frame has been sent successively as part of the depth-first search mechanism. The set consists of Processed Tuples:
			
					<list style="hanging">
						<t hangText="">
							(P_orig_address, P_seq_number, P_prev_hop, P_next_hop_neighbor_list, P_time)
						</t>
					</list>
			
					where
			
					<list style="hanging">
						<t hangText="">
							P_orig_address is is the Originator Address of the received frame;
						</t>
				
						<t hangText="">
							P_seq_number is the Sequence Number of the received frame;
						</t>
				
						<t hangText="">
							P_prev_hop is the Source Address (i.e. the previous hop) of the frame;
						</t>
				
						<t hangText="">
							P_next_hop_neighbor_list is a list of addresses of next hops to which the frame has been sent previously, as part of the depth-first search mechanism, as explained in <xref target="frame_processing"/>;
						</t>
				
						<t hangText="">
							P_time specifies when this Tuple expires and MUST be removed.
						</t>
					</list>
				</t>
			</section>
			
		</section>
		
		<section title="Frame Buffering" anchor="frame_buffering">
			<t>
				While frames are processed by DFF, they need to be buffered in memory. The design of this buffer remains a choice of the implementation, which also depends on the implementation of the underlying MAC layer. This section provides some considerations for how to design the frame buffer, and how the DFF implementation interacts with the underlying MAC layer.
			</t>
			<t>
				If possible, it is recommended to share the memory with the underlying MAC layer, i.e. to store a frame in the same memory during processing of DFF operation (e.g. successive frame transmissions to different neighbors during the "depth-first search"), and during the actual transmission by the MAC layer. Keeping a separated copy of the frame in memory under control of DFF would require additional memory resources. 
			</t>
			<t>
				Once the underlying MAC layer has been tasked to transmit a frame, it will inform the upper layers (DFF) of success or failure (e.g., using a MAC layer acknowledgment and retransmission mechanism). Depending on the implementation of the MAC layer, the frame may be deleted from memory in either cases (transmission success or failure). However, in case of a transmission failure, DFF still needs a copy of the frame in order to resend to other neighbors. 
			</t>
			<t>
				Therefore, one of the following two implementation designs is recommended (but other implementation designs may be possible):
				<list style="symbols">
					<t>
						If the memory for the frames is shared between DFF and the MAC layer, the MAC layer must not delete frames from the buffer on its own. Instead, the MAC layer should mark the frame as ready for deletion, so that DFF can decide when to delete the frame from memory.
					</t>
					<t>
						If the memory is not shared, but instead a copy of each frame is kept in memory under control of DFF, DFF can decide independently when to delete the frame from memory.
					</t>
				</list>
			</t>
			<t>
				In either of the above cases, DFF must not delete a frame from the memory if DFF is informed by the underlying MAC layer that the transmission of that frame has failed. If the transmission has succeeded, the frame should be deleted from memory. In <xref target="generation_processing"/> (Frame Generation and Processing), the places where the frame must not be deleted from memory is explicitly stated, whereas otherwise the implementation may implicitly delete the frame from memory where appropriate.
			</t>
			<t>
				The size of the buffer should be large enough to contain all frames while they are processed by DFF. The size depends on the available memory, the expected rate of incoming frames and their size, as well as the reliability of the network; the more the network is unreliable, the longer a frame has to be kept in the buffer while the frame is successively sent to the neighbors of the node.
			</t>
			<t>
				If the buffer is exhausted, no new frames can be accepted for processing by DFF until more space is available. This memory exhaustion should be treated by the implementation in the same way as the underlying MAC layer treats buffer exhaustion.
			</t>
		</section>
		
		
		<section anchor="frame_format" title="Frame Format">
			<t>
				This document assumes that the data forwarding is based on the LoWPAN adaptation layer ("mesh-under"), and that data frames conform with the format specified in <xref target="RFC4944"/>. In particular, <xref target="RFC4944"/> states that
				
				<list style="hanging">
					<t>
						Additional mesh routing capabilities, such as specifying the mesh routing protocol, source routing, and so on may be expressed by defining additional routing headers that precede the fragmentation or addressing header in the header stack.
					</t>
				</list>
			
				Hence, all data frames to be forwarded using DFF MUST be preceded by the Mesh Addressing header defined in <xref target="RFC4944"/>, and SHOULD be preceded by a header that identifies the DFF data forwarding mechanism.
			</t>
			
			<t>
				After these two headers, any other LoWPAN header, e.g. hop-by-hop options, header compression or fragmentation, MAY also be added before the actual payload. <xref target="mesh-header"/> depicts the Mesh Addressing header defined in <xref target="RFC4944"/>, and <xref target="DFF-header"/> depicts the DFF header.
			</t>

			<figure anchor="mesh-header" title="Mesh Addressing Header">
				<artwork align="center"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 0|V|F|HopsLft| DeepHopsLeft  |orig. address, final address... 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]>
				</artwork>
			</figure>


			<figure anchor="DFF-header" title="Header for DFF data frames">
				<artwork align="center"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 1| Mesh Forw |D|R|x|    Sequence Number      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]>
				</artwork>
			</figure>
			
			<t>
				Field definitions of the Mesh Addressing header are as specified in <xref target="RFC4944"/>.
			</t>

			<t>
				Field definitions of the DFF header are as follows: 
				<list style="hanging">            		
            		<t hangText="Mesh Forw">
            			- A 6-bit identifier that allows for the use of different mesh forwarding mechanisms. As specified in <xref target="RFC4944"/>, additional mesh forwarding mechanisms should use the reserved dispatch byte values following LOWPAN_BCO; therefore, 0 1 MUST precede Mesh Forw. The value of Mesh Forw is LOWPAN_DFF.
            		</t>
            		
            		<t hangText="Duplicate frame flag (D)">
            			- This flag is included in the DFF mesh header to indicate that the frame has been re-sent as a duplicate. The flag MUST be set to 1 by the node that re-sends the frame after detecting link-layer failure to deliver through the last attempted next-hop, as specified in <xref target="frame_processing"/>. Once the flag is set to 1, it MUST NOT be modified by nodes forwarding the frame.
            		</t>
            
          			<t hangText="Return frame flag (R)">
          				- This flag is included in the DFF mesh header to indicate that the frame has been returned to the previous hop after failure to deliver to all the available next-hops. The flag MUST be set to 1 prior to forwarding the frame back to the previous hop and MUST be set to 0 prior to forwarding the frame to the selected next-hop, as specified in <xref target="frame_processing"/>. This flag is modified in a hop-by-hop basis.
          			</t>
            
           			<t hangText="Reserved flag (x)">
           				- This bit is reserved for future flag definitions.
           			</t>
           			
            
            		<t hangText="Sequence Number">
            			- A 13-bit unsigned integer sequence number generated by the Originator, unique on a node for each new generated frame, as specified in <xref target="seqno"/>. The Originator Address concatenated with the Sequence Number represents an identifier of previously seen data frames.
            			Refer to <xref target="seqno"/> for further information about the sequence numbers, in particular considerations for border gateways.
            			
            		</t>
            	</list>
            </t>
		</section>
		
				
		<section anchor="parameters" title="Protocol Parameters and Constants">
			<t>
				The parameters and constants used in this specification are described in this section.
				
				<list style="hanging">
					<t hangText="P_HOLD_TIME">
						- is the time period after which a newly created or modified Processed Tuple expires and MUST be deleted.
					</t>
					
					<t hangText="MAX_HOPS_LEFT">
						- is the initial value of Deep Hops Left in the Mesh Addressing header specified in <xref target="RFC4944"/>.
					</t>
				</list>
			</t>
			
		
		</section>
		
		
		
		<section title="Data Frame Generation and Processing" anchor="generation_processing">
			<t>
				The following sections describe the process of handling a new IPv6 packet, generated on a node (<xref target="frame_generation"/>), as well as forwarding a data frame from another node (<xref target="frame_processing"/>). When DFF is used, the following specification MUST be used instead of the default frame delivery, specified in Section 11 of <xref target="RFC4944"/>.
			</t>
			
			<t>
				In the following, it is assumed that all data frames are preceded by the Mesh Addressing header and the DFF header, as specified in <xref target="frame_format"/>. In order to allow for interoperability with nodes not using DFF as forwarding mechanism, frames that are preceded by the Mesh Addressing header but not the DFF header are treated as specified in Section 11 of <xref target="RFC4944"/>.
			</t>
			

			
			<section title="Data Frame Generation" anchor="frame_generation">
				<t>
					When a new IPv6 packet is to be sent on a node, the datagram is encapsulated into LoWPAN frames as specified in <xref target="RFC4944"/> and described in <xref target="frame_format"/>, using the Mesh Addressing header, and in addition fragmentation headers (if required) and any other header that would be added by <xref target="RFC4944"/>.
				</t>
				<t>
					For each of the resulting LoWPAN frames (denoted the "current frame"), the following steps MUST be performed before it is transmitted:
				
					<list style="numbers">
						<t>
							The following fields in the Mesh Addressing header to the current frame are set:
							
							<list style="symbols">
      							<t>
      								V and F are set according to the used address length;
      							</t>
      							<t>
      								Hops Left := 0xF (i.e. reserved value indicating that the Deep Hops Left field is following);
      							</t>
      							<t>
      								Deep Hops Left := MAX_HOPS_LEFT;
      							</t>
      							<t>
      								Originator Address := address of this node;
      							</t>
      							<t>
      								Final Destination Address := address of the Final Destination.
      							</t>
       						</list>
       					</t>
       					
       					<t>
       						Add the DFF header to the current frame (directly after the Mesh Addressing header), as specified in <xref target="frame_format"/>, with:
							<list style="symbols">
      							<t>
      								Duplicate frame flag (D) := 0;
      							</t>
      							<t>
      								Return frame flag (R) := 0;
      							</t>
      							<t>
      								Sequence Number := a new Sequence Number of the frame (as defined in <xref target="seqno"/>).
      							</t>
       						</list>
						</t>
					
						<t>
							Select the next hop (denoted "next_hop") for the current frame, as specified in <xref target="getnexthop"/>.
						</t>
					
					
						<t>
							Add a Processed Tuple to the Processed Set with:
					
							<list style="symbols">
      							<t>
      								P_orig_address := the Originator Address of the current frame;
      							</t>
      							<t>
      								P_seq_number := the Sequence Number of the current frame;
      							</t>
      							<t>
      								P_prev_hop := the Originator Address of the current frame;
      							</t>
      							<t>
      								P_next_hop_neighbor_list := [next_hop];
      							</t>
      							<t>
      								P_time := current time + P_HOLD_TIME.
      							</t>
       						</list>
       					</t>
       					
       					<t>
       						Set the Source Address in the frame header to the node's own address and the Destination Address to next_hop.
       					</t>
       					
       					<t>
       						Hand the current frame over to the underlying MAC layer for transmission. The frame should be stored in memory (as discussed in <xref target="frame_buffering"/>), until the lower layer informs DFF of transmission success or failure. If the transmission fails, the frame MUST NOT be deleted from the memory and the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       					</t>
       				
					</list>
				</t>
			</section>
		
		
		
		
			<section anchor="frame_processing" title="Data Frame Processing">
				<t>
					If a frame (denoted the "current frame") is received on the node, then the following tasks MUST be performed:

					<list style="numbers">
						<t>
							If the frame is malformed (i.e. the frame format is not as expected by this specification or the checksum does not match the frame), drop the frame.
						</t>
					
						<t>
							Otherwise, if the Final Destination Address from the Mesh Addressing header matches the address of this node, consume the frame as per normal delivery (i.e. (i) in case of a fragmented IPv6 packet, reassemble fragments as defined in Section 5 of <xref target="RFC4944"/>, and (ii) send the payload (i.e. the IPv6 packet) to upper layers).
						</t>
						
						<t>
							Otherwise, decrement the value of the Deep Hops Left field in the Mesh Addressing header. Drop the frame if Deep Hops Left is decremented to zero.
						</t>
					
					
						<t>
							If no Processed Tuple (denoted the "current tuple") exists in the Processed Set, with:

							<list style="hanging">
            					<t hangText="+">
            						P_orig_address = the Originator Address of the current frame, AND;
            					</t>

            					<t hangText="+">
            						P_seq_number = the Sequence Number of the current frame.
            					</t>
            				</list>

          					Then:
          					
          					<list style="format %d." counter="my_count1">
          						<t>
          							add a Processed Tuple (denoted the "current tuple") with:
					
									<list style="symbols">
      									<t>
      										P_orig_address := the Originator Address of the current frame;
      									</t>
      					
      									<t>
      										P_seq_number := the Sequence Number of the current frame;
      									</t>
      					
      									<t>
      										P_prev_hop := the Source Address (i.e. the previous hop) of the current frame;
      									</t>
      					
      									<t>
      										P_next_hop_neighbor_list := 	[];
      									</t>
      					
      									<t>
      										P_time := current time + P_HOLD_TIME.
      									</t>
      					
       								</list>
       							</t>
       			
       							<t>
       								Set RET to 0 in the frame DFF header.
       							</t>
       							
       							
       							<t>
       								Select the next hop (denoted "next_hop") for the current frame, as specified in <xref target="getnexthop"/>.
       							</t>
       							
       							<t>
       								P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop].
       							</t>
       							
       							<t>
       								Set the Source Address in the frame header to the node's own address and the Destination Address field to next_hop.
       							</t>
       					
       					
       							<t>
       								Hand the current frame over to the underlying MAC layer for transmission. The frame should be stored in memory (as discussed in <xref target="frame_buffering"/>), until the lower layer informs DFF of transmission success or failure. If the transmission fails, the frame MUST NOT be deleted from the memory and the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       							</t>
       							
       						</list>
          				</t>
          					
          				<t>
          					Otherwise, if a tuple exists:
					
							<list style="numbers">
								<t>
									If the return flag of the current frame is not set (RET=0) (i.e. a loop has been detected):
									<list style="numbers">
										<t>
											Set RET := 1.
										</t>
										
										<t>
											Set the Source Address in the MAC  frame header to the node's own address and the Destination Address field to the Source Address of the current frame (i.e. the previous hop).
       									</t>
       					
       									<t>
       										Hand the current frame over to the underlying MAC layer for transmission. The frame should be stored in memory (as discussed in <xref target="frame_buffering"/>), until the lower layer informs DFF of transmission success or failure. If the transmission fails, the frame MUST NOT be deleted from the memory.
       									</t>
       								</list>
       							</t>
								
								<t>
									Otherwise, if the return flag of the current frame is set (RET = 1):
								
									<list style="numbers">
										<t>
											Set RET := 0.
										</t>
      						
      									<t>
      										Execute the "poisoning" procedure specified in <xref target="poison"/>.
      									</t>
      							
      									<t>
      										Select the next hop (denoted "next_hop") for the current frame, as specified in <xref target="getnexthop"/>.
      									</t>
      							
      									<t>
      										Modify the current tuple:
      								
      										<list style="symbols">
      											<t>
      												P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];
      											</t>
      					
      											<t>
      												P_time := current time + P_HOLD_TIME.
      											</t>
       										</list>
      									</t>
      							
      									<t>
      										If the selected next hop is equal to P_prev_hop of the current tuple (i.e. all neighbors have been unsuccessfully tried), set the RET flag (RET := 1). If this node has the same address as the Originator Address of the current frame, drop the frame.
      									</t>
      							
      							
      									<t>
      										Set the Source Address in the frame header to the node's own address and the Destination Address field to next_hop.
       									</t>
       					
       					
       									<t>
       										Hand the current frame over to the underlying MAC layer for transmission. The frame should be stored in memory (as discussed in <xref target="frame_buffering"/>), until the lower layer informs DFF of transmission success or failure. If the transmission fails, the frame MUST NOT be deleted from the memory and the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       									</t>
      								</list>
       							</t>
          					</list>
          				</t>
          			</list>
				</t>
			</section>
			
			<section title="Border Gateway" anchor="border_gateway">
				<t>
					The PAN may be connected to other networks (e.g. the Internet) through a border gateway, i.e. a node with at least two interfaces, an internal one to the PAN, and an external one towards other networks.
				</t>
			
				<t>
					If such a border gateway receives an IPv6 packet on its external interface and routes the packet towards the PAN through its internal interface, the packet is treated according to <xref target="frame_processing"/>, with the Originator and Source Address of the frames being set to the address of the gateway, and with a Sequence Number created on the border gateway.
				</t>
				<t>
					If an IPv6 packet is sent from within the PAN to an address outside the PAN (e.g. in the Internet), DFF will only be used inside the PAN (until the frame(s) that contain the IPv6 datagram have reached their Final Destination, i.e. the border gateway).
				</t>
				<t>
					It is assumed in this specification that PANs are considered "stub" networks, i.e. that IPv6 packets will not transit the PAN.
				</t>
			</section>
		</section>
		


		<section anchor="missed_ACK" title="Unsuccessful Frame Transmission">
			<t>
				The proposed specification requires to be notified of successful or unsuccessful frame transmission by the underlying MAC layer (e.g. using link-layer ACKs). This information is used by DFF to try alternate paths if a transmission has failed. This section first gives one example how DFF interacts with the IEEE 802.15.4 MAC layer (a link-layer supported by the LoWPAN adaption layer), and then specifies actions upon an unsuccessful transmission by the MAC layer.
			</t>
			
			<section anchor="missed_ACK_802154" title="Example: Transmission Failure Detection by IEEE 802.15.4">
				<t>
					<xref target="ieee802.15.4">IEEE 802.15.4</xref> is one MAC layer that is supported by the LoWPAN adaption layer as specified in <xref target="RFC4944"/>. In IEEE 802.15.4, each frame is acknowledged with an ACK by the receiver (if requested so in the frame). 
				</t>
				<t>
					If DFF requests the IEEE 802.15.4 layer to transmit a frame, the frame is sent by the MAC layer, and a timer is started to wait for an ACK from the receiver of the frame. Specifically, <xref target="ieee802.15.4"/> states that:
				
					<list style="hanging">
						<t>
							"If an acknowledgment is not received within macAckWaitDuration symbols [...], the device shall conclude that the single transmission attempt has failed. [...] If a single transmission attempt has failed [...], the device shall repeat the process of transmitting the data or MAC command frame and waiting for the acknowledgment, up to a maximum of aMaxFrameRetries times. [...] If an acknowledgment is still not received after aMaxFrameRetries retransmissions, the MAC sublayer shall assume the transmission has failed and notify the next higher layer of the failure. This situation eventuality is referred to as a communications failure."
						</t>
					</list>
					
					Once the MAC layer informs DFF of such a communications failure, the following procedures are executed.
				
				</t>
			</section>
			
			<section anchor="missed_ACK_procedures" title="Procedures upon a Transmission Failure">
				<t>
					If a frame (the "current frame") has been sent to the next hop, as specified in <xref target="frame_generation"/> and <xref target="frame_processing"/>, and DFF has been notified about the communication failure by the MAC sublayer (as described above), then the following steps MUST be performed:
				
					<list style="numbers">
      					<t>
      						Set the duplicate flag (DUP) of the DFF header of the current frame to 1.
      					</t>      				
      							
      					<t>
      						Select the next hop (denoted "next_hop") for the current frame, as specified in <xref target="getnexthop"/>.
      					</t>
      				
      					<t>
      						Find the Processed Tuple (the "current tuple") in the Processed Set, with:

							<list style="hanging">
            					<t hangText="+">
            						P_orig_address = the Originator Address of the current frame, AND;
            					</t>

            					<t hangText="+">
            						P_seq_number = the Sequence Number of the current frame,
            					</t>
            				</list>
      		
      						and modify the current tuple:
      								
      						<list style="symbols">
  
      							<t>
      								P_next_hop_neighbor_list := 	P_next_hop_neighbor_list@[next_hop];
      							</t>
      					
      							<t>
      								P_time := current time + P_HOLD_TIME.
      							</t>	
       						</list>	
      					</t>
      							
      					<t>
      						If the selected next hop is equal to P_prev_hop of the current tuple, set the RET flag (RET := 1), otherwise reset it (RET := 0).
      					</t>
      							
      					<t>
      						Set the Source Address in the frame header to the node's own address and the Destination Address field to next_hop.
    					</t>
       						
    					<t>
    						Transmit the current frame. If the transmission fails (determined by missing link layer acknowledgments), the procedures in <xref target="missed_ACK"/> SHOULD be executed.
       					</t>
      			
       				</list>
				</t>
			</section>
		</section>
		
		
		<section anchor="getnexthop" title="Getting the Next Hop for a Frame">
			<t>
				Before a frame (the "current frame") is sent from a node towards the Final Destination, a valid next hop along the path has to be selected. This section describes how to select the next hop (denoted "next_hop"). As a Processed Tuple was either existing when receiving the frame, or otherwise was created, it can be assumed the a Processed Tuple for that frame (the "current tuple") is available. 
			</t>
			
			<t>
				The next hop is chosen from a list of neighbors in order of decreasing preference of the following conditions. This list is only a suggestion, any other order of priority MAY be used, however, P_prev_hop of the current tuple SHOULD be the last entry. The list SHOULD NOT contain addresses which are listed in P_next_hop_neighbor_list of the current tuple, and an address SHOULD NOT appear more than once in the list. 
				
				<list style="numbers">
					<t>
						If a mesh-under routing protocol is used in conjunction with DFF, then a next hop along the path to the Final Destination Address of the frame may be added, where next hops with lower route costs have a higher priority.
					</t>
					
					<t>
						All other neighbors from an external neighborhood discovery process can be added.
					</t>
					
					<t>
						P_prev_hop of the current tuple SHOULD be added last; this case is only used for returning the frame to the previous hop, in which case the RET flag MUST be set to 1.
					</t>
				</list>
				
			</t>
			<t>
				It is possible to exclude neighbors as candidates for the next_hop (e.g. to only select neighbors that are indicated as next hop by a mesh-under routing protocol, used in conjunction with DFF). This may limit undesired "full" depth-first searches of Final Destinations, but may also hinder successful delivery of a frame.
			</t>
		</section>
		

		<section anchor="poison" title="Poisoning">
			<t>
				When a frame is returned (i.e. a frame with RET = 1 is received by a node) or a link layer acknowledgment (ACK) has not been received for a forwarded frame, and if a mesh-under routing protocol is used in conjunction with DFF, the cost for the route MAY be increased in that routing protocol. Thus, future transmissions prefer other routes. For the case of a missing link layer ACK, in addition to increasing the route cost, the link cost to the neighbor MAY also be increased if such is supported by the neighborhood discovery process.
			</t>
			
			<t>
				It is up to the implementation to decide by how much the route and link cost should be increased, and is out of scope of this document.
			</t>
		</section>
		
		<section anchor="route_repair" title="Route Repair Mechanism">
			<t>
				If DFF is used in conjunction with a mesh-under routing protocol, route repair mechanisms of that mesh-under routing protocol MAY be disabled in order to avoid unnecessary flooding of the network. As DFF finds alternate paths for the data traffic, and in addition may "poison" unused routes of the mesh-under routing protocol, route repair mechanisms may be unnecessary and even reduce the stability of the network (e.g. because of collisions when Route Requests or Link State Advertisements are flooded in the network).
			</t>
		</section>
		
		<section anchor="seqno" title="Sequence Numbers">
			<t>
				Whenever a node generates a frame (the "Originator"), a sequence number is required in the DFF header. This sequence number needs to be unique only locally on each node. For example, a sequence number may start at 0 for the first generated frame, and then increase in steps of 1 for each new frame. The sequence number MUST not be greater than 8191 and SHOULD wrap around to 0.
			</t>
			
			<t>
				Note that the "Originator", generating the locally unique sequence number, designates the node that adds the LoWPAN frame to the IPv6 packet (after possible link-layer fragmentation), which is not necessarily the source of the IPv6 packet. For example, an IPv6 packet may be received on a border gateway from outside the PAN (e.g. from the Internet), potentially fragmented, and then each frame is encapsulated with the LoWPAN header. The sequence number is then locally generated on the border gateway, in the same way that they are for IP packets originating from the border gateway.
			</t>
		</section>
		

		
		<section anchor="proposed_values" title="Proposed Values for Parameters and Constants">
			<t>
				This section lists the parameters and constants used in the   specification of the protocol, and proposed values of each that MAY be used.
				
				<list style="symbols">
					<t>
						P_HOLD_TIME := 5 seconds
					</t>
					<t>
						MAX_HOPS_LEFT := 255
					</t>
				</list>
   			</t>
		</section>
		
		<section anchor="deployments" title="Deployment Experience">		

			<t>
				DFF has been deployed and experimented with both in real deployments and in network simulations, as described in the following.
			</t>
			
			<section anchor="Japan" title="Deployments in Japan">
				<t>
					The majority of the large Advanced Metering Infrastructure (AMI) deployments using DFF are located in Japan, but the data of these networks is property of Japanese utilities and cannot be disclosed.
				</t>
			</section>
			
			<section anchor="KitCarson" title="Kit Carson Electric Cooperative">
				<t>
					DFF has been deployed at Kit Carson Electric Cooperative (KCEC), a non-profit organization distributing electricity to about 30,000 customers in New Mexico. As described in a press release <xref target="KCEC_press_release"/>, DFF is running on currently about 400 electric meters, and will be further extended to 2,100 meters in summer 2012. All meters are connected through a mesh network using an unreliable, wireless medium. DFF is used in conjunction with a distance vector mesh-under routing protocol. Metering data from each meter is sent towards a gateway periodically every 15 minutes. The data delivery reliability is over 99%.
				</t>
			</section>
			
			
			<section anchor="Simulations" title="Simulations">
				<t>
					DFF has been evaluated in OMNEST simulations, in conjunction with a distance vector mesh-under routing protocol. The performance of DFF has been compared to using only the routing protocol without DFF. The results published in peer-reviewed academic papers (<xref target="DFF_paper1"/><xref target="DFF_paper2"/>) show significant improvements of the packet delivery ratio compared to using only the distance vector protocol.
				</t>
			</section>
			
			<section anchor="OpenSource" title="Open Source Implementation">
				<t>
					Fujitsu Laboratories of America is currently working on an open source implementation of DFF, which is to be released in summer 2012, and which allows for interoperability testings of different DFF implementations. The implementation is based on Java, and can be used both on real machines and in the Ns2 simulator.
				</t>
			</section>
			
			
		</section>
		
		
		<section anchor="Security" title="Security Considerations">
			<t>
				Based on the recommendations in <xref target="RFC3552"/>, this section describes security threats to DFF, lists which attacks are out of scope, which attacks DFF is susceptible to, and which attacks DFF protects against.
			</t>
			
			<section anchor="security_out_of_scope" title="Attacks Out of Scope">
				<t>
					As DFF is designed as mesh-under data forwarding protocol on Layer 2, any security issues concerning the payload of the frames (i.e. layers 3 and above) are not considered in this section.
				</t>
				<t>
					It is recommended to use appropriate security mechanisms, such as IPsec / TLS / etc., to protect the upper layers. As DFF does not modify the contents of IP datagrams, nor the way IP packets are exchanged between endpoints, no  special considerations for IPsec have to be addressed.
				</t>
			</section>
			
			<section anchor="security_protection" title="Protecion Mechanisms of DFF">
				<t>
					DFF itself does not provide any additional integrity, confidentiality or authentication features compared to the underlying MAC layer security. Therefore, the level of protection of DFF depends on that MAC layer security (as well as protection of the payload by upper layer security).
					Many MAC layers, such as IEEE 802.15.4 <xref target="ieee802.15.4"/>, provide link-layer (i.e. hop-by-hop) security.
				</t>
				<t>
					In the following sections, whenever encrypting or digitally signing frames is suggested for protecting DFF, it is assumed that nodes are not compromised (i.e. do not possess the credentials).
				</t>
    		
    		</section>
    		<section anchor="security_end_to_end" title="End-to-end Security">
    			<t>
    				While <xref target="RFC4944"/> defines end-to-end LoWPAN headers (e.g. the Mesh Addressing header) to be used in mesh forwarding (as specified in Section 11 of <xref target="RFC4944"/>), there is currently no specification of securing these headers other than by the underlying MAC layer security, which is hop-by-hop only.
				</t>
				<t>
					Therefore, until a mechanism is specified for signing or encrypting LoWPAN end-to-end headers, neither the DFF header nor the Mesh Addressing header used by this specification can be secured other than on a hop-by-hop basis by the MAC layer. As such a security mechanism would not be limited to DFF headers, but to all LoWPAN headers, it is out of scope to define security in this specification.
				</t>
			</section>
			
			
			<section anchor="security_in_of_scope" title="Attacks In Scope">
				<t>
					This section discusses security threats to DFF, and for each describes whether (and how) DFF is affected by the threat. 
					DFF is designed to be used in lossy and unreliable networks. Predominant examples of lossy networks are wireless networks, where nodes send frames via broadcast. The attacks listed below are easier to exploit in wireless media, but can also be observed in wired networks.
				</t>

				<section anchor="security_DoS" title="Denial of Service">
					<t>
						Denial of Service attacks are possible when using DFF by either exceeding the storage on a node, or by exceeding the available bandwidth of the channel. As DFF does not contain any algorithms with high complexity, it is unlikely that the processing power of the node could be exhausted by an attack on DFF.
					</t>
					<t>
						The storage of a node can be exhausted by increasing the size of the Processed Set, i.e. by adding new entries, or by increasing the size of each entry. New entries can be added by injecting new frames in the network, by replaying frames or by modifying frames (as described in <xref target="security_message_insertion"/>, <xref target="security_replay"/>, and <xref target="security_modification"/> respectively).
					</t>
					<t>
						Moreover, a malicious node can effectively increase the size of each entry if it has access to a mesh-under routing protocol, used in conjunction with DFF. It can advertise a large number of (non-existing) neighbors to a node by spoofing addresses and sending control messages. When forwarding a frame, a node would not only try to (unsuccessfully) forward the frame to all these neighbors, leading to reduced bandwidth and higher energy drain, but would also increase the size of the list of already tried neighbors in the Processed Tuple.
					</t>
					<t>
						Another possible attack is to send frames to a non-existing address in the network. DFF would perform a full network-wide depth-first search, with the worst possible path length.
					</t>
					<t>
						If security provided by the MAC layer is used (or LoWPAN end-to-end security), this attack can be mitigated if the malicious node does not possess valid credentials, since other nodes would not forward data through the malicious node. Moreover, any mesh-under routing protocol used in conjunction with DFF must also be protected using encryption or digital signatures.
					</t>		
				</section>
				
				
				
				<section anchor="security_modification" title="Frame Modification">
					<t>
						The Mesh Addressing header, the DFF header and the payload may be modified by a malicious node, but only modifications to the DFF header are in scope of this document.
					</t>
	
					<section anchor="security_return_flag" title="Return Flag Tampering">
						<t>
							A malicious node may tamper the "return" flag of a DFF frame, and send it back to the previous hop. This node would then try alternative neighbors, possibly leading to packets never reaching their Final Destination, as well as unnecessary depth-first search in the network (bandwidth exhaustion / energy drain).
						</t>
						<t>
							This attack can be mitigated by using appropriate security of the underlying MAC layer. As the return flag is set hop-by-hop, an end-to-end LoWPAN security layer would not help mitigating this attack.
						</t>
					</section>
				
					<section anchor="security_dup_flag" title="Duplicate Flag Tampering">
						<t>
							A malicious node may modify the Duplicate Flag of a frame that it forwards. 
						</t>
						<t>
							If it sets the flag from 0 to 1, the frame would be detected as duplicate by other nodes in the network, effectively disabling the loop protection for that frame. Otherwise, the attack has no effect.
						</t>
						<t>
							If the Duplicate Flag is set from 1 to 0, and a node receives that frame for the second time (i.e. it has already received a frame with the same Originator Address and Sequence Number before), it will wrongly detect a loop, possibly poison routing entries and return the frame back to the previous hop. This may disrupt end-to-end communication and alter the routing tables.
						</t>
						<t>
							This attack can be mitigated by using appropriate security of the underlying MAC layer. As the duplicate flag is set hop-by-hop, an end-to-end LoWPAN security layer would not help mitigating this attack.
						</t>	
					
					</section>
				</section>
				
			
				
				
				
				<section anchor="security_message_insertion" title="Frame Insertion">

					<t>
						A malicious node may inject new frames in the network. Other nodes will then use resources for storing the sequence numbers for each frame in the Processed Set, which may lead to a denial of service attack (refer to <xref target="security_DoS"/>). 
					</t>
							
					<t>
						If security provided by MAC layer is used (or LoWPAN end-to-end security), this attack can be mitigated if the malicious node does not possess valid credentials.
					</t>
				</section>
				
				
				<section anchor="security_replay" title="Frame Replay">
					<t>
						Any node can eavesdrop on frames and replay them at a later time or another place without modifying the content. Even if a node does not have the credentials to decrypt an encrypted frame, it can thus harm the network integrity, as well as exhaust in-node resources (by adding a Processed Tuple for each replayed frame). Moreover, a node receiving a replayed frame would treat it like a looped packet, and potentially poison links and routes to the destination.
					</t>
					<t>
						Compared to simply creating a new frame, replaying a frame may be more difficult to detect as attack (since the Originator Address will not be that of the malicious node), and more difficult to protect against: encryption alone is not sufficient, unless some freshness information is contained in the frame.
					</t>

				</section>
				
				
				<section anchor="security_deletion" title="Frame Deletion">
					<t>
						If a node eavesdrop frames (as described in <xref target="security_eavesdropping"/>), it may also decide to not forward them, even though the DFF specification would dictate so. In that case, the malicious node would disturb the network communication between end points.
					</t>
					<t>
						If security provided by MAC layer is used (or LoWPAN end-to-end security), this attack can be mitigated if the malicious node does not possess valid credentials, since other nodes would not forward data through the malicious node.
					</t>
				</section>
				
					
				<section anchor="security_eavesdropping" title="Eavesdropping">
					<t>
						Any node within radio range can eavesdrop frames that are exchanged using the mechanism specified in this document. If frames are not encrypted using MAC layer security, any eavesdropper may read the content of the DFF headers, the Mesh Addressing header and the payload (which in turn may be encrypted, e.g., using IPsec). Based on the information in the DFF header, the attacker can learn the sequence number, whether the frame is a duplicate and whether it is a returned frame. The attacker can, of course, also eavesdrop on the payload (IPv6 header and payload) and the Mesh Addressing header, which is out of scope for this document.
					</t>
					<t>
						If the payload of the frame is encrypted, however, DFF (as well as other LoWPAN headers and the IP payload) are protected against eavesdropping if nodes are not compromised (and acquire the credentials).
					</t>
				</section>
				

				
			
				
				<section anchor="security_poisoning" title="Route Poisoning">
					<t>
						While DFF allows to "poison" routes (<xref target="poison"/>) of a mesh-under routing protocol, used in conjunction with DFF, poisoning is only performed locally on a node. A malicious node could only poison its own routing table, which has similar effects to frame deletion described in <xref target="security_deletion"/>.
					</t>
					<t>
						However, it is recommended to protect control messages of mesh-under routing protocols, used in conjunction with DFF, in order to mitigate attacks on other nodes routing tables.
					</t>
				</section>
				
				<section anchor="security_man-in-the-middle" title="Man-in-the-Middle Attacks">
					<t>
						Man-in-the-middle attacks may affect the upper layers (i.e. the payload in frames), and are out of scope of this document.
					</t>
				</section>
			</section>
		</section>
		

		<section anchor="IANA" title="IANA Considerations">
			<t>
				IANA is requested to allocate a value from the Dispatch Type Field registry for LOWPAN_DFF.
			</t>
		</section>
		

		<section anchor="Acknowledgements" title="Acknowledgements">
			<t>
				Jari Arkko (Ericsson), Thomas Clausen (Ecole Polytechnique), Yuichi Igarashi (Hitachi), Kazuya Monden (Hitachi), Geoff Mulligan (IPSO), Hiroki Satoh (Hitachi), Ganesh Venkatesh (Mobelitix), and Jiazi Yi (Ecole Polytechnique) provided useful reviews of the draft and discussions which helped to improve this document.
			</t>
		</section>	
		
		
	</middle>
	

	<back>
	
		<references title="Normative References">
			<reference anchor='RFC2119'>
				<front>
					<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
					<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
						<organization>Harvard University</organization>
					</author>
					<date year='1997' month='March' />
				</front>
				<seriesInfo name='BCP' value='14' />
				<seriesInfo name='RFC' value='2119' />
				<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
				<format type='HTML' octets='17491' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
				<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
			</reference>

			<reference anchor='RFC4944'>
				<front>
					<title>Transmission of IPv6 Packets over IEEE 802.15.4 Networks</title>
					<author initials='G.' surname='Montenegro' fullname='G. Montenegro'>
						<organization /></author>
					<author initials='N.' surname='Kushalnagar' fullname='N. Kushalnagar'>
						<organization /></author>
					<author initials='J.' surname='Hui' fullname='J. Hui'>
						<organization /></author>
					<author initials='D.' surname='Culler' fullname='D. Culler'>
						<organization /></author>
					<date year='2007' month='September' />
				</front>

				<seriesInfo name='RFC' value='4944' />
				<format type='TXT' octets='67232' target='http://www.rfc-editor.org/rfc/rfc4944.txt' />
			</reference>

			<reference anchor='ieee802.15.4'>
				<front>
					<title>IEEE Std. 802.15.4-2003</title>
					<author initials = 'IEEE' surname='Computer Society' fullname='IEEE Computer Society'>
						<organization/>
					</author>
					<date year='2003' month='October'/>
				</front>
			</reference>

		</references>
	
	
		<references title="Informative References">
			<reference anchor='KCEC_press_release'>
				<front>
					<title>DFF deployed by KCEC (Press Release)</title>
					<author initials = '' surname='Kit Carson Electric Cooperative (KCEC)' fullname='Kit Carson Electric Cooperative'>
						<organization/>
					</author>
					<date year='2011'/>
				</front>
				<seriesInfo name='' value	='http://www.kitcarson.com/index.php?option=com_content&view=article&id=45&Itemid=1' />
			</reference>
			
			<reference anchor='DFF_paper1'>
				<front>
					<title>Comparison of Data Forwarding Mechanisms for AMI Networks</title>
					<author initials = 'S' surname='Cespedes' fullname='Sandra Cespedes'>
						<organization/>
					</author>
					<author initials = 'A' surname='Cardenas' fullname='Alvaro A. Cardenas'>
						<organization/>
					</author>
					<author initials = 'T' surname='Iwao' fullname='Tadashige Iwao'>
						<organization/>
					</author>
					<date year='2012' month='January'/>
				</front>
				<seriesInfo name='' value='2012 IEEE Innovative Smart Grid Technologies Conference (ISGT)' />
			</reference>
			
			<reference anchor='DFF_paper2'>
				<front>
					<title>Dynamic Data Forwarding in Wireless Mesh Networks</title>
					<author initials = 'T' surname='Iwao' fullname='Tadashige Iwao'>
						<organization/>
					</author>
					<author initials = 'T' surname='Iwao' fullname='Tadashige Iwao'>
						<organization/>
					</author>
					<author initials = 'M' surname='Yura' fullname='Masakazu Yura'>
						<organization/>
					</author>
					<author initials = 'Y' surname='Nakaya' fullname='Yuuta Nakaya'>
						<organization/>
					</author>
					<author initials = 'A' surname='Cardenas' fullname='Alvaro A. Cardenas'>
						<organization/>
					</author>
					<author initials = 'S' surname='Lee' fullname='Sung Lee'>
						<organization/>
					</author>
					<author initials = 'R' surname='Masuoka' fullname='Ryusuke Masuoka'>
						<organization/>
					</author>
					
					<date year='2010' month='October'/>
				</front>
				<seriesInfo name='' value='First IEEE International Conference on Smart Grid Communications (SmartGridComm)' />
			</reference>
			
			
			<reference anchor='RFC3552'>
				<front>
					<title>Guidelines for Writing RFC Text on Security Considerations</title>
					<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
						<organization /></author>
					<author initials='B.' surname='Korver' fullname='B. Korver'>
						<organization /></author>
					<date year='2003' month='July' />
				</front>
				<seriesInfo name='BCP' value='72' />
				<seriesInfo name='RFC' value='3552' />
				<format type='TXT' octets='110393' target='http://www.rfc-editor.org/rfc/rfc3552.txt' />
			</reference>

		</references>

		
		<section anchor="Appendix1" title="Examples">
			<t>In this section, some example network topologies are depicted, using the DFF mechanism for data forwarding. In these examples, it is assumed that DFF is used in conjunction with a mesh-under routing protocol. This protocol provides a list of neighbors of each node, and a routing table with one or more next hops if the topology provides a path from the node to the Final Destination.
			</t>
			
			<section anchor="example1" title="Example 1: Normal Delivery">
				<t>
					<xref target="example1_fig"/> depicts a network topology with seven nodes A to G, with links between them as indicated by lines. It is assumed that node A sends a frame to G, through B and D, according to the mesh-under routing protocol.
					
					<figure anchor="example1_fig" title="Example 1: normal delivery">
						<artwork align="center"><![CDATA[
                  +---+
              +---+ D +-----+
              |   +---+     |
      +---+   |             |
  +---+ B +---+             |
  |   +---+   |             |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					If no link fails in this topology, and no loop occurs, then DFF will not modify the usual data forwarding mechanism. Each node adds a Processed Tuple for the incoming frame, and selects the next hop according to <xref target="getnexthop"/>, i.e. it will first select the next hop for node G as determined by the mesh-under routing protocol.
				</t>
			</section>
			
			<section anchor="example2" title="Example 2: Forwarding with Link Failure">
				<t>
					<xref target="example2_fig"/> depicts the same topology as the Example 1, but both links between B and D and between B and E are unavailable (e.g. because of wireless link characteristics). 
					
					<figure anchor="example2_fig" title="Example 2: link failure">
						<artwork align="center"><![CDATA[
                  +---+
              XXX-+ D +-----+
              X   +---+     |
      +---+   X             |
  +---+ B +---+             |
  |   +---+   X             |
+-+-+         X   +---+   +-+-+
| A |         XXXX+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					When B receives the frame from node A, it adds a Processed Tuple, and then tries to forward the frame to D. Once B detects that the frame cannot be successfully delivered to D because it does not receive link layer ACKs, it will follow the procedures listed in <xref target="missed_ACK"/>, by setting the DUP flag to 1, selecting E as new next hop, adding E to the list of next hops in the Processed Tuple, and then forwarding the frame to E.
				</t>
					
				<t>
					As the link to E also fails, B will again follow the procedure in <xref target="missed_ACK"/>. As all possible next hops (D and E) are listed in the Processed Tuple, B will set the RET flag in the frame and return it to A.
				</t>
					
				<t>
					A determines that it already has a Processed Tuple for the returned frame, reset the RET flag of the frame and select a new next hop for the frame. As B is already in the list of next hops in the Processed Tuple, it will select C as next hop and forward the frame to it. C will then forward the frame to F, and F delivers the frame to its Final Destination G.
				</t>
			</section>
			
			
			<section anchor="example3" title="Example 3: Forwarding with Missed Link Layer Acknowledgment">
				<t>
					<xref target="example3_fig"/> depicts the same topology as the Example 1, but the link layer acknowledgments from C to A are lost (e.g. because the link is uni-directional). It is assumed that A prefers a path to G through C and F.
					
					<figure anchor="example3_fig" title="Example 3: missed link layer acknowledgment">
						<artwork align="center"><![CDATA[
                  +---+
              +---+ D +-----+
              |   +---+     |
      +---+   |             |
  +---+ B +---+             |
  |   +---+   |             |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  .   +---+                 |
  +...+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					While C successfully receives the frame from A, A does not receive the ACK and assumes the frame has not been delivered to C. Therefore, it sets the DUP flag of the frame to 1, in order to indicate that this frame is a duplicate. Then, it forwards the frame to B.
				</t>

			</section>
			
			
			
			<section anchor="example4" title="Example 4: Forwarding with a Loop">
				<t>
					<xref target="example4_fig"/> depicts the same topology as the Example 1, but there is a loop from D to A, and A sends the frame through B and D.
					
					<figure anchor="example4_fig" title="Example 4: loop">
						<artwork align="center"><![CDATA[
  +-----------------+
  |                 |
  |               +-+-+
  |           +---+ D +
  |           |   +---+
 \|/  +---+   |
  +---+ B +---+
  |   +---+   |
+-+-+         |   +---+   +-+-+
| A |         +---+ E +---+ G +
+-+-+             +---+   +-+-+
  |   +---+                 |
  +---+ C +---+             |
      +---+   |             |
              |   +---+     |
              +---+ F +-----+
                  +---+
]]></artwork>
					</figure>
					
					When A receives the frame through the loop from D, it will find a Processed Tuple for the frame. Node A will set the RET flag and return the frame to D, which in turn will return it to B. B will then select E as next hop, which will then forward it to G.
				</t>
			</section>
			
		</section>
		
	
	
	</back>
</rfc>
