<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC2818 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml">
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY RFC5479 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5479.xml">
<!ENTITY RFC4347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4347.xml">
<!ENTITY RFC4568 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml">
<!ENTITY RFC5763 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5763.xml">
<!ENTITY RFC5764 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5764.xml">
<!ENTITY RFC4251 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4251.xml">
<!ENTITY RFC3760 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3760.xml">
<!ENTITY RFC5705 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5705.xml">
<!ENTITY RFC6189 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6189.xml">
<!ENTITY RFC5245 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5245.xml">
<!ENTITY RFC6454 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6454.xml">
<!ENTITY RFC6455 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6455.xml">
<!ENTITY RFC4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">

<!ENTITY I-D.ietf-rtcweb-security SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-security">
<!ENTITY I-D.ietf-rtcweb-jsep SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-jsep">
<!ENTITY I-D.muthu-behave-consent-freshness SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.muthu-behave-consent-freshness">

<!ENTITY I-D.kaufman-rtcweb-security-ui SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.kaufman-rtcweb-security-ui">
<!ENTITY I-D.jennings-rtcweb-signaling SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.jennings-rtcweb-signaling">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<!-- Don't change this. It breaks stuff -->
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-ietf-rtcweb-security-arch-05"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="RTCWEB Sec. Arch.">RTCWEB Security Architecture</title>

    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>RTFM, Inc.</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <phone>+1 650 678 2350</phone>

        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date day="22" month="October" year="2012" />

    <area>RAI</area>

    <workgroup>RTCWEB</workgroup>

    <abstract>
      <t>
	The Real-Time Communications on the Web (RTCWEB) working group
        is tasked with standardizing protocols for enabling real-time
        communications within user-agents using web technologies (e.g
        JavaScript). The
	major use cases for RTCWEB technology are real-time audio and/or video calls,
	Web conferencing, and direct data transfer. Unlike most conventional real-time systems
	(e.g., SIP-based soft phones) RTCWEB communications are directly controlled
	by some Web server, which poses new security challenges.
	For instance, a Web browser might expose a JavaScript
	API which allows a server to place a video call. Unrestricted access to such
	an API would allow any site which a user visited to "bug" a user's computer,
	capturing any activity which passed in front of their camera.
	[I-D.ietf-rtcweb-security] defines the RTCWEB
	threat model. This document
	defines an architecture which provides security within that threat model.
      </t>
    </abstract>

    <note title="Legal">
      <t>THIS DOCUMENT AND THE INFORMATION CONTAINED THEREIN ARE PROVIDED ON
      AN &ldquo;AS IS&rdquo; BASIS AND THE CONTRIBUTOR, THE ORGANIZATION
      HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE
      IETF TRUST, AND THE INTERNET ENGINEERING TASK FORCE, DISCLAIM ALL
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
      WARRANTY THAT THE USE OF THE INFORMATION THEREIN WILL NOT INFRINGE ANY
      RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
      PARTICULAR PURPOSE.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction" anchor="sec.introduction">
      <t>
	The Real-Time Communications on the Web (RTCWEB) working
	group is tasked with standardizing protocols for real-time
	communications between Web browsers. The major use cases for RTCWEB
	technology are real-time audio and/or video calls, Web conferencing,
	and direct data transfer. Unlike most conventional real-time systems,
	(e.g., SIP-based<xref target="RFC3261"></xref> soft phones) RTCWEB
	communications are directly controlled by some Web server, as shown in
	<xref target="fig.simple"/>.
      </t>
      <figure title="A simple RTCWEB system" anchor="fig.simple">
	<artwork><![CDATA[
                            +----------------+
                            |                |
                            |   Web Server   |
                            |                |
                            +----------------+
                                ^        ^
                               /          \
                       HTTP   /            \   HTTP
                             /              \                               
                            /                \                               
                           v                  v
                        JS API              JS API
                  +-----------+            +-----------+
                  |           |    Media   |           |
                  |  Browser  |<---------->|  Browser  |
                  |           |            |           |                  
                  +-----------+            +-----------+
 	]]></artwork>
      </figure>
      <t>
	This system presents a number of new security challenges,
	which are analyzed in <xref target="I-D.ietf-rtcweb-security"/>.
	This document describes a security architecture for RTCWEB
	which addresses the threats and requirements described in
	that document.
      </t>
    </section>

    <section anchor="sec-term" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Trust Model" anchor="sec.proposal.trusthierarchy">
      <t>
	The basic assumption of this architecture is that network resources
	exist in a hierarchy of trust, rooted in the browser, which 
	serves as the user's TRUSTED COMPUTING BASE (TCB). Any security
	property which the user wishes to have enforced must be 
	ultimately guaranteed by the browser (or transitively by
	some property the browser verifies). Conversely, if the
	browser is compromised, then no security guarantees are possible.
	Note that there are cases (e.g., Internet kiosks) where the
	user can't really trust the browser that much. In these cases,
	the level of security provided is limited by how much they
	trust the browser.
      </t>
      <t>
	Optimally, we would not rely on trust in any entities other
	than the browser. However, this is unfortunately not possible
	if we wish to have a functional system.
	Other network elements fall into two categories: those which
	can be authenticated by the browser and thus are partly trusted--though
	to the minimum extent necessary--and
	those which cannot be authenticated and thus are untrusted.
	This is a natural extension of the end-to-end principle.
      </t>
      <section title="Authenticated Entities" anchor="sec.proposal.authenticated">
	<t>
	  There are two major classes of authenticated entities in the system:
	</t>
	<t>
	  <list style="symbols">
	    <t>Calling services: Web sites whose origin we can verify
	    (optimally via HTTPS, but in some cases because we are on
	    a topologically restricted network, such as behind a firewall).</t>
	    <t>Other users: RTCWEB peers whose origin we can verify 
	    cryptographically (optimally via DTLS-SRTP).</t>
	  </list>
	</t>
	<t>
	  Note that merely being authenticated does not make these 
	  entities trusted. For instance, just because we can verify
	  that https://www.evil.org/ is owned by Dr. Evil does not
	  mean that we can trust Dr. Evil to access our camera
	  and microphone. However, it gives the user an opportunity
	  to determine whether he wishes to trust Dr. Evil or not;
	  after all, if he desires to contact Dr. Evil (perhaps
	  to arrange for ransom payment), it's safe
	  to temporarily give him access to the camera and microphone
	  for the purpose of the call, but he doesn't want 
	  Dr. Evil to be able to access his camera and
	  microphone other than during the call. The point here is that we must
	  first identify other elements before we can determine whether
	  and how much to trust them.
	</t>
	<t>
	  It's also worth noting that there are settings where 
	  authentication is non-cryptographic, such as other machines
	  behind a firewall. Naturally, the level of trust one can
	  have in identities verified in this way depends on how 
	  strong the topology enforcement is.
	</t>

      </section>
      <section title="Unauthenticated Entities" anchor="sec.proposal.unauthenticated">
	<t>
	  Other than the above entities, we are not generally able to
	  identify other network elements, thus we cannot trust them.
	  This does not mean that it is not possible to have any interaction
	  with them, but it means that we must assume that they will
	  behave maliciously and design a system which is secure even
	  if they do so.
	</t>
      </section>
    </section>
    <!-- Not layered ? -->
    <section title="Overview" anchor="sec.proposal.overview">
      <!-- TODO: Federated -->
      <t>
	This section describes a typical RTCWeb session and shows how
	the various security elements interact and what guarantees are
	provided to the user. The example in this section is a "best case"
	scenario in which we provide the maximal amount of user
	authentication and media privacy with the minimal level of trust in
	the calling service. Simpler versions with lower levels of
	security are also possible and are noted in the text where
	applicable. It's also important to recognize the tension
	between security (or performance) and privacy. The example
	shown here is aimed towards settings where we are more concerned
	about secure calling than about privacy, but as we shall
	see, there are settings where one might wish to make different
	tradeoffs--this architecture is still compatible with those
	settings.
      </t>
      <t>
	For the purposes of this example, we assume the topology shown
	in the figure below. This topology is derived from the 
	topology shown in <xref target="fig.simple"/>, but separates
	Alice and Bob's identities from the process of signaling.
	Specifically, Alice and Bob have relationships with 
	some Identity Provider (IdP) 
	that supports a protocol such OpenID or BrowserID) that 
	can be used to attest to their identity.
	This separation isn't particularly important in "closed world"
	cases where Alice and Bob are users on the same social network and have
	identities based on that network. However, there are important
	settings where that is not the case, such as
	federation (calls from one network to another) and
	calling on untrusted sites, such as where two users who have
	a relationship via a given social network want to call each
	other on another, untrusted, site, such as a poker site. 
      </t>
      <figure title="A call with IdP-based identity" anchor="fig.proposal.idp">
	<artwork><![CDATA[
                            +----------------+
                            |                |
                            |     Signaling  |
			    |     Server     |
                            |                |
                            +----------------+
                                ^        ^
                               /          \
                       HTTPS  /            \   HTTPS
                             /              \                               
                            /                \                               
                           v                  v
                        JS API              JS API
                  +-----------+            +-----------+
                  |           |    Media   |           |
            Alice |  Browser  |<---------->|  Browser  | Bob
                  |           | (DTLS-SRTP)|           |
                  +-----------+            +-----------+
                        ^      ^--+     +--^     ^		        
                        |         |     |        |
			v         |     |         v
                  +-----------+   |     |  +-----------+
                  |           |<--------+  |           |
		  |   IdP     |   |        |    IdP    |
                  |           |   +------->|           |
                  +-----------+            +-----------+
 	]]></artwork>
      </figure>
      
      <section title="Initial Signaling">
	<t>
	  Alice and Bob are both users of a common calling service; they
	  both have approved the calling service to make calls (we 
	  defer the discussion of device access permissions till later).
	  They are both connected to the calling service via HTTPS
	  and so know the origin with some level of confidence. They also
	  have accounts with some identity provider.
	  This sort of identity service is becoming increasingly
	  common in the Web environment in technologies such
	  (BrowserID, Federated Google Login,
	  Facebook Connect, OAuth, OpenID, WebFinger), and
	  is often provided as a side effect service of your ordinary
	  accounts with some service. In this example, we show Alice and
	  Bob using a separate identity service, though they may
	  actually be using the same identity service as calling service
	  or have no identity service at all.
	</t>
	<t>
	  Alice is logged onto the calling service and decides to call Bob.
	  She can see from the calling service that he is online and the
	  calling service presents a JS UI in the form of a button 
	  next to Bob's name which says "Call". Alice clicks the button,
	  which initiates a JS callback that instantiates a PeerConnection
	  object. This does not require a security check: JS from any
	  origin is allowed to get this far.
	</t> 

	<t>
	  Once the PeerConnection is created, the calling service JS 
	  needs to set up some media. Because this is an audio/video
	  call, it creates two MediaStreams, one connected to an
	  audio input and one connected to a video input. At this
	  point the first security check is required: untrusted
	  origins are not allowed to access the camera and microphone.
	  In this case, because Alice is a long-term user of the
	  calling service, she has made a permissions grant (i.e.,
	  a setting in the browser) to
	  allow the calling service to access her camera and microphone
	  any time it wants. The browser checks this setting when the
	  camera and microphone requests are made and thus allows them.
	</t>
	<t>
	  In the current W3C API, once some streams have been added,
	  Alice's browser + JS generates a signaling message
	  <xref target="I-D.ietf-rtcweb-jsep"/> contianing:
	</t>
	<t>
	  <list style="symbols">
	    <t>Media channel information</t>
	    <t>ICE candidates</t>
	    <t>A fingerprint attribute binding the communication to Alice's public key
	    <xref target="RFC5763"/></t>
	  </list>
	</t>
	<t>
	  Prior to sending out the signaling message, the PeerConnection code
	  contacts the identity service and obtains an assertion binding
	  Alice's identity to her fingerprint. The exact details depend on
	  the identity service (though as discussed in <xref target="sec.generic.idp"/>
	  PeerConnection can be agnostic to them), but for now it's
	  easiest to think of as a BrowserID assertion.
	  The assertion may bind other information to the identity besides
	  the fingerprint, but at minimum it needs to bind
	  the fingerprint.
	</t>
	<t>
	  This message is sent to the signaling server, e.g., by XMLHttpRequest
	  <xref target="XmlHttpRequest"/> or by WebSockets <xref target="RFC6455"/>
	  The signaling server processes the message from Alice's browser,
	  determines that this is a call to Bob and sends a signaling
	  message to Bob's browser (again, the format is currently undefined).
	  The JS on Bob's browser processes it, and alerts Bob to the incoming
	  call and to Alice's identity. In this case, Alice has provided an
	  identity assertion and so Bob's browser contacts Alice's identity provider
	  (again, this is done in a generic way so the browser has no 
	  specific knowledge of the IdP) to verify the assertion. This
	  allows the browser to display a trusted element indicating that
	  a call is coming in from Alice. If Alice is in Bob's address book,
	  then this interface might also include her real name, a picture, etc.
	  The calling site will also provide
	  some user interface element (e.g., a button) to allow Bob to
	  answer the call, though this is most likely not part of the
	  trusted UI.
	</t>
	<t>
	  If Bob agrees [I am ignoring early media for now], 
	  a PeerConnection is instantiated with the message from Alice's side.
	  Then, a similar process
	  occurs as on Alice's browser: Bob's browser verifies that the calling
	  service is approved, the media streams are created, and a return
	  signaling message containing media information, ICE candidates, and
	  a fingerprint is sent back to Alice via the signaling service.
	  If Bob has a relationship with an IdP, the message will also come
	  with an identity assertion.
	</t>
	<t>
	  At this point, Alice and Bob each know that the other party wants to
	  have a secure call with them. Based purely on the interface provided
	  by the signaling server, they know that the signaling server claims
	  that the call is from Alice to Bob. Because the far end sent an identity
	  assertion along with their message, they know that this is verifiable
	  from the IdP as well. Of course, the call works perfectly well if
	  either Alice or Bob doesn't have a relationship with an IdP; they
	  just get a lower level of assurance. Moreover, Alice might wish
	  to make an anonymous call through an anonymous calling site, 
	  in which case she would of course just not provide any identity
	  assertion and the calling site would mask her identity from Bob.
	</t>
      </section>
      <section title="Media Consent Verification">
	<t>
	  As described in 
	  (<xref target="I-D.ietf-rtcweb-security"/>; Section 4.2)
	  This proposal specifies that media consent
	  verification be performed via ICE.
	  Thus, Alice and Bob perform ICE checks with each other.
	  At the completion of these checks, they are ready to
	  send non-ICE data.
	</t>
	<t>
	  At this point, Alice knows that (a) Bob (assuming he is verified
	  via his IdP) or someone else who the
	  signaling service is claiming is Bob is willing to exchange
	  traffic with her and (b) that either Bob is at the IP address
	  which she has verified via ICE or there is an attacker who
	  is on-path to that IP address detouring the traffic. Note that
	  it is not possible for an attacker who is on-path but not
	  attached to the signaling service to spoof these checks
	  because they do not have the ICE credentials. Bob's security
	  guarantees with respect to Alice are the converse of this.
	</t>
      </section>

      <section title="DTLS Handshake">
	<t>
	  Once the ICE checks have completed [more specifically, once some 
	  ICE checks have completed], Alice and Bob can set up a secure
	  channel. This is performed via DTLS <xref target="RFC4347"/>
	  (for the data channel) and DTLS-SRTP <xref target="RFC5763"/>
	  for the media channel. Specifically, Alice and Bob perform
	  a DTLS handshake on every channel which has been established
	  by ICE. The total number of channels depends on the amount of muxing;
	  in the most likely case we are using both RTP/RTCP mux and
	  muxing multiple media streams on the same channel, in which
	  case there is only one DTLS handshake. Once the DTLS handshake
	  has completed, the keys are exported
	  <xref target="RFC5705"/> and used to key SRTP
	  for the media channels.
	</t>
	<t>
	  At this point, Alice and Bob know that they share a set
	  of secure data and/or media channels with keys which are 
	  not known to any third-party attacker. If Alice and
	  Bob authenticated via their IdPs, then they also know
	  that the signaling service is not attacking them. Even
	  if they do not use an IdP, as long as
	  they have minimal trust in the signaling service not to
	  perform a man-in-the-middle attack, they know that their
	  communications are secure against the signaling service as
	  well.
	</t>
	
      </section>

      <section title="Communications and Consent Freshness">
	<t>
	  From a security perspective, everything from here on in is a
	  little anticlimactic: Alice and Bob exchange data protected by the
	  keys negotiated by DTLS. Because of the security guarantees discussed
	  in the previous sections, they know that the communications are
	  encrypted and authenticated.
	</t>
	<t>
	  The one remaining security property we need to establish is
	  "consent freshness", i.e., allowing Alice to verify that Bob
	  is still prepared to receive her communications. ICE 
	  specifies periodic STUN keepalizes but only if media is not flowing.
	  Because the consent issue is more difficult here, we 
	  require RTCWeb implementations to periodically send keepalives.
	  As described in Section 5.3, these
	  keepalives MUST be based on the consent freshness mechanism specified
	  in <xref target="I-D.muthu-behave-consent-freshness"/>.
	  If a keepalive fails and no new ICE channels can be established, then 
	  the session is terminated.
	</t>
      </section>
    </section>
    <section title="Detailed Technical Description" anchor="sec.proposal.detailed">
      <section title="Origin and Web Security Issues" anchor="sec.proposal.origin">
	<t>
	  The basic unit of permissions for RTCWEB is the origin
	  <xref target="RFC6454"/>. Because the security of the origin
	  depends on being able to authenticate content from that origin,
	  the origin can only be securely established if data is transferred
	  over HTTPS <xref target="RFC2818"/>. Thus, clients MUST treat HTTP and HTTPS origins as
	  different permissions domains. [Note: this follows directly
	  from the origin security model and is stated here merely
	  for clarity.]
	</t>
	<t>
	  Many web browsers currently forbid by default any active mixed content
	  on HTTPS pages. I.e., when JS is loaded from an HTTP origin onto
	  an HTTPS page, an error is displayed and the content is not
	  executed unless the user overrides the error. Any browser
	  which enforces such a policy will also not permit access
	  to RTCWEB functionality from mixed content pages. It is 
	  RECOMMENDED that browsers which allow active mixed content
	  nevertheless disable RTCWEB functionality in mixed content
	  settings.
	  [[ OPEN ISSUE: Should this be a 2119 MUST? It's not clear
	  what set of conditions would make this OK, other than 
	  that browser manufacturers have traditionally been permissive here
	  here.]]
	  Note that it is possible for a page which was not mixed content
	  to become mixed content during the duration of the call. 
	  Implementations MAY choose to terminate the call or display
	  a warning at that point, but it is also permissible to
	  ignore this condition. This is a deliberate implementation
	  complexity versus security tradeoff.
          [[ OPEN ISSUE:: Should we be more aggressive about this?]]
	</t>
      </section>

      <section title="Device Permissions Model" anchor="sec.proposal.device.permissions">
	<t>
	  Implementations MUST obtain explicit user consent prior to
	  providing access to the camera and/or microphone. Implementations MUST
	  at minimum support the following two permissions models for HTTPS
	  origins.
	</t>
	<t>
	  <list style="symbols">
	    <t>Requests for one-time camera/microphone access.</t>
	    <t>Requests for permanent access.</t>
	  </list>
	</t>
	<t>
	  Because HTTP origins cannot be securely established against
	  network attackers, implementations MUST NOT allow the setting
	  of permanent access permissions for HTTP origins. Implementations
	  MAY also opt to refuse all permissions grants for HTTP origins,
	  but it is RECOMMENDED that currently they support one-time
	  camera/microphone access.
	</t>
	<t>
	  In addition, they SHOULD support requests for access to 
	  a single communicating peer. E.g., "Call customerservice@ford.com".
	  Browsers servicing such requests SHOULD clearly indicate that 
	  identity to the user when asking for permission.
	</t>
	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    The API MUST provide a mechanism for the requesting JS to
	    indicate which of these forms of permissions it is 
	    requesting. This allows the browser client to know what sort
	    of user interface experience to provide to the user,
	    including what permissions to request from the user
	    and hence what to enforce later.
	    For instance,
	    browsers might display a non-invasive door hanger
	    ("some features of this site may not work..." when
	    asking for long-term permissions) but a more 
	    invasive UI ("here is your own video") for single-call
	    permissions. The API MAY grant weaker permissions than
	    the JS asked for if the user chooses to authorize only
	    those permissions, but if it intends to grant stronger
	    ones it SHOULD display the appropriate UI for those
	    permissions and MUST clearly indicate what 
	    permissions are being requested.
	  </t>
	</list></t>

	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    The API MUST provide a mechanism for the requesting JS to
	    relinquish the ability to see or modify the media (e.g., via MediaStream.record()).
	    Combined with secure authentication of the communicating peer,
	    this allows a user to be sure that the calling site is not
	    accessing or modifying their conversion.
	  </t>
	</list></t>


	<t><list style="hanging">
	  <t hangText="UI Requirement:">
	    The UI MUST clearly indicate when the user's camera
	    and microphone are in use.  This indication MUST NOT be
	    suppressable by the JS and MUST clearly indicate how to terminate
	    a call, and provide a UI means to immediately stop camera/microphone
	    input without the JS being able to prevent it.
	  </t>
	</list></t>


	<t><list style="hanging">
	  <t hangText="UI Requirement:">
	    If the UI indication of camera/microphone use are displayed
	    in the browser such that minimizing the browser window would hide the
	    indication, or the JS creating an overlapping window would hide the
	    indication, then the browser SHOULD stop camera and microphone input.
	    [Note: this may not be necessary in systems that are non-windows-based
	    but that have good notifications support, such as phones.]
	  </t>
	</list>
	</t>

	<t>
	  Clients MAY permit the formation of data channels
	  without any direct user approval. Because sites can always
	  tunnel data through the server, further restrictions on the
	  data channel do not provide any additional security.
	  (though see <xref target="sec.proposal.communications.consent"/>
	  for a related issue).
	</t>
	<t>
	  Implementations which support some form of direct user authentication
	  SHOULD also provide a policy by which a user can authorize calls 
	  only to specific counterparties. Specifically, the implementation
	  SHOULD provide the following interfaces/controls:
	</t>
	<t>
	  <list style="symbols">
	    <t>Allow future calls to this verified user.</t>
	    <t>Allow future calls to any verified user who is in my system address book
	    (this only works with address book integration, of course).</t>
	  </list>
	</t>
	<t>
	  Implementations SHOULD also provide a different user interface indication
	  when calls are in progress to users whose identities are directly verifiable.
	  <xref target="sec.proposal.comsec"/> provides more on this.
	</t>
      </section>

      <section title="Communications Consent" anchor="sec.proposal.communications.consent">
	
	<t>
	  Browser client implementations of RTCWEB MUST implement ICE.
	  Server gateway implementations which operate only at public IP
	  addresses MUST implement either full ICE or ICE-Lite.
	</t>
	<t>
	  Browser implementations MUST verify reachability via ICE 
	  prior to sending any non-ICE packets to a given destination.
	  Implementations MUST NOT provide the ICE transaction ID
	  to JavaScript during the lifetime of the transaction
          (i.e., during the period when the ICE stack would accept
          a new response for that transaction). [Note: this document takes no position on
	  the split between ICE in JS and ICE in the browser. The
	  above text is written the way it is for editorial convenience and will
	  be modified appropriately if the WG decides on ICE in the JS.]
	  The JS MUST NOT be permitted to control the local ufrag and password,
	  though it of course knows it.
	</t>
	<t>
	  While continuing consent is required, 
	  that ICE <xref target="RFC5245"/>; Section 10
	  keepalives STUN Binding Indications are one-way and
	  therefore not sufficient. 
	  The current WG consensus is to use ICE Binding Requests 
	  for continuing consent freshness. ICE already requires that
	  implementations respond to such requests, so this approach is maximally
	  compatible. A separate document will profile the ICE timers
	  to be used; see <xref target="I-D.muthu-behave-consent-freshness"/>.
	</t>
      </section>
      <section title="IP Location Privacy" anchor="sec.proposal.ip.location.privacy">
	<t>
	  A side effect of the default
	  ICE behavior is that the peer learns one's IP address, which leaks
	  large amounts of location information, especially for mobile 
	  devices. This has
	  negative privacy consequences in some circumstances. The API requirements
	  in this section are intended to mitigate this issue. Note that
	  these requirements are NOT intended to protect the user's IP address
	  from a malicious site. In general, the site will learn at least a
	  user's server reflexive address from any HTTP transaction.
	  Rather, these requirements are intended to allow a site to cooperate
	  with the user to hide the user's IP address from the other side of the
	  call. Hiding the user's IP address from the server requires some
	  sort of explicit privacy preserving mechanism on the client
	  (e.g., Torbutton [https://www.torproject.org/torbutton/]) and
	  is out of scope for this specification.
	</t>

	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    The API MUST provide a mechanism to allow the JS to
	    suppress ICE negotiation 
	    (though perhaps to allow candidate gathering) until the
	    user has decided to answer the call [note: determining
	    when the call has been answered is a question for the JS.]
	    This enables a user to prevent a peer from learning their
	    IP address if they elect not to answer a call and also
	    from learning whether the user is online.
	  </t>
	</list></t>

	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    The API MUST provide a mechanism for the calling application JS to
	    indicate that only TURN candidates are to be used. This
	    prevents the peer from learning one's IP address at all.
	  </t>
	</list>
	</t>

	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    The API MUST provide a mechanism for the calling application
	    to reconfigure an existing call to add non-TURN candidates.
	    Taken together, this and the previous requirement allow ICE negotiation to start immediately on
	    incoming call notification, thus reducing post-dial delay, but also to avoid
	    disclosing the user's IP address until they have
	    decided to answer. They also allow users to completely hide their IP address
	    for the duration of the call. Finally, they allow a mechanism for the user to
	    optimize performance by reconfiguring to allow non-turn candidates during an active call if
	    the user decides they no longer need to hide their IP address
	  </t>
	</list></t>
      </section>

      <section title="Communications Security" anchor="sec.proposal.comsec">
	<t>
	  Implementations MUST implement DTLS <xref target="RFC4347"/> 
	  and DTLS-SRTP <xref target="RFC5763"/><xref target="RFC5764"/>. All data
	  channels MUST be secured via DTLS. DTLS-SRTP MUST be offered
	  for every media channel and MUST be the default; i.e., if 
	  an implementation receives an offer for DTLS-SRTP and SDES,
	  DTLS-SRTP MUST be selected. Media traffic MUST NOT be sent
	  over plain (unencrypted) RTP.
	</t>
	<t>
	  [OPEN ISSUE: What should the settings be here? MUST?]
	  Implementations MAY support SDES for media traffic
	  for backward compatibility purposes.
	</t>
	<!-- OPEN ISSUE: DTLS-SRTP key origin scoping? -->
	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    The API MUST provide a mechanism to indicate that a fresh
	    DTLS key pair is to be generated for a specific call. 
	    This is intended to allow for unlinkability. Note that
	    there are also settings where it is attractive to use
	    the same keying material repeatedly, especially those
	    with key continuity-based authentication.
	  </t>
	</list></t>

	<t><list style="hanging">
	  <t hangText="API Requirement:">
	    When DTLS-SRTP is used, the API MUST NOT permit the
	    JS to obtain the negotiated keying material. This
	    requirement preserves the end-to-end security of the
	    media.
	  </t>
	</list></t>


	<t><list style="hanging">
	  <t hangText="UI Requirements: ">
	    A user-oriented client MUST provide an "inspector" interface which
	    allows the user to determine the security characteristics of the
	    media. [largely derived from <xref target="I-D.kaufman-rtcweb-security-ui"/>
	  </t>
	  <t>
	    The following properties SHOULD be displayed "up-front" in the browser
	    chrome, i.e., without requiring the user to ask for them:
	  </t>
	  <t>
	    <list style="symbols">
	      <t> A client MUST provide a user interface through which a user may
	      determine the security characteristics for currently-displayed
	      audio and video stream(s)</t>

	      <t> A client MUST provide a user interface through which a user may
	      determine the security characteristics for transmissions of their
	      microphone audio and camera video.</t>

	      <t> The "security characteristics" MUST include an indication as to
	      whether the cryptographic keys were delivered out-of-band
	      (from a server) or were generated as a result of a pairwise
	      negotiation.
	      </t>

	      <t>If the far endpoint was directly verified, either via a third-party
	      verifiable X.509 certificate or via a Web IdP mechanism (see <xref target="sec.generic.idp"/>)
	      the "security characteristics" MUST include the verified information.
	      X.509 identities and Web IdP identities
	      have similar semantics and should be displayed in a similar way.
	      </t>
	    </list>
	  </t>
	  <t></t>
	  <t>
	    The following properties are more likely to require some "drill-down"
	    from the user:
	  </t>
	  <t>
	    <list style="symbols">	      
	      <t> The "security characteristics" MUST indicate the cryptographic algorithms
	       in use (For example:  "AES-CBC" or "Null Cipher".)</t>

	      <t>The "security characteristics" MUST indicate whether PFS is provided.</t>

	      <t>The "security characteristics"
	      MUST include some mechanism to allow an out-of-band verification
	      of the peer, such as a certificate fingerprint or an SAS.</t>
	    </list>
	  </t>
	</list></t>
      </section>

      <section title="Web-Based Peer Authentication" anchor="sec.generic.idp">
	<t>
	  In a number of cases, it is desirable for the endpoint (i.e., the
	  browser) to be able to directly identity the endpoint on the other
	  side without trusting only the signaling service to which they
	  are connected. For instance, users may be making a call via a federated
	  system where they wish to get direct authentication of the other
	  side. Alternately, they may be making a call on a site which
	  they minimally trust (such as a poker site) but to someone who has an identity on
	  a site they do trust (such as a social network.)
	</t>
	<t>
	  Recently, a number of Web-based identity technologies (OAuth, BrowserID, Facebook
	  Connect), etc. have been developed. While the details vary, what 
	  these technologies share is that they have a Web-based (i.e., HTTP/HTTPS)
	  identity provider which attests to your identity. For instance,
	  if I have an account at example.org, I could use the example.org identity
	  provider to prove to others that I was alice@example.org.
	  The development of these technologies allows us to separate calling
	  from identity provision: I could call you on Poker Galaxy but identify
	  myself as alice@example.org.
	</t>
	<t>
	  Whatever the underlying technology, the general principle is that
	  the party which is being authenticated is NOT the signaling site
	  but rather the user (and their browser). Similarly, the relying party
	  is the browser and not the signaling site. 
	  Thus, the browser MUST securely generate the input to the IdP
	  assertion process and MUST securely display the results of
	  the verification process to the user in a way which cannot 
	  be imitated by the calling site.
	</t>
	<t>
	The mechanisms defined in this
	document do not require the browser to implement any 
	particular identity protocol or to support any particular
	IdP. Instead, this document provides a generic interface
	which any IdP can implement. Thus, new IdPs and protocols
	can be introduced without change to either the browser or the
	calling service. This avoids the need to make a commitment
	to any particular identity protocol, although browsers
	may opt to directly implement some identity protocols in
	order to provide superior performance or UI properties.
	</t>
	<section title="Trust Relationships: IdPs, APs, and RPs" anchor="sec.trust-relationships">
	  <t>
	    Any federated identity protocol has three major participants:
	  </t>
	  <t>
	    <list style="hanging">
	      <t hangText="Authenticating Party (AP):">The entity which is
	      trying to establish its identity.</t>
	      <t></t>

	      <t hangText="Identity Provider (IdP):">The entity which is
	      vouching for the AP's identity.</t>
	      
	      <t></t>

	      <t hangText="Relying Party (RP):">The entity which is trying
	      to verify the AP's identity.</t>
	    </list>
	  </t>
	  <t>
	    The AP and the IdP have an account relationship of some kind: the
	    AP registers with the IdP and is able to subsequently authenticate
	    directly to the IdP (e.g., with a password). This means that the
	    browser must somehow know which IdP(s) the user has 
	    an account relationship with. 
	    This can either be something that the user configures into
	    the browser or that is configured at the calling site and
	    then provided to the PeerConnection by the calling site.
	  </t>
	  <t>
	    At a high level there are two kinds of IdPs:
	  </t>
	  <t>
	    <list style="hanging">
	      <t hangText="Authoritative: ">IdPs which have verifiable control 
	      of some section of the identity space. For instance, in the
	      realm of e-mail, the operator of "example.com" has complete control of the
	      namespace ending in "@example.com". Thus, "alice@example.com"
	      is whoever the operator says it is. Examples of systems with
	      authoritative identity providers include DNSSEC, 
	      RFC 4474, and Facebook Connect (Facebook identities only
	      make sense within the context of the Facebook system).
	      </t>

	      <t></t>
	      <t hangText="Third-Party: ">IdPs which don't have control of 
	      their section of the identity space but instead verify 
	      user's identities via some unspecified mechanism and then
	      attest to it. Because the IdP doesn't actually control
	      the namespace, RPs need to trust that the
	      IdP is correctly verifying AP identities, and there
	      can potentially be multiple IdPs attesting to the same
	      section of the identity space. Probably the best-known example
	      of a third-party identity provider is SSL certificates,
	      where there are a large number of CAs all of whom can
	      attest to any domain name.
	      </t>
	    </list>
	  </t>

	  <t>
	    If an AP is authenticating via an authoritative IdP, then 
	    the RP does not need to explicitly trust the IdP at all:
	    as long as the RP knows how to verify that the IdP 
	    indeed made the relevant identity assertion (a function
	    provided by the mechanisms in this document), then
	    any assertion it makes about an identity for which 
	    it is authoritative is directly verifiable.
	  </t>
	  <t>
	    By contrast, if an AP is authenticating via a third-party
	    IdP, the RP needs to explicitly trust that IdP
	    (hence the need for an explicit trust anchor list
	    in PKI-based SSL/TLS clients). The list of trustable
	    IdPs needs to be configured directly into the
	    browser, either by the user or potentially by the
	    browser manufacturer. This is a significant advantage
	    of authoritative IdPs and implies that if third-party
	    IdPs are to be supported, the potential number needs
	    to be fairly small. 
	  </t>
	</section>
	<section title="Overview of Operation" anchor="sec.overview">
	  <t>
	    In order to provide security without trusting the calling
	    site, the PeerConnection component of the browser must
	    interact directly with the IdP. The details of the
	    mechanism are described in the W3C API specification,
	    but the general idea is that the PeerConnection component
	    downloads JS from a specific location on the 
	    IdP dictated by the IdP domain name. That JS (the "IdP proxy")
	    runs in
	    an isolated security context within the browser
	    and the PeerConnection
	    talks to it via a secure message passing channel.
	  </t>
	  <figure>
 <artwork><![CDATA[
      +------------------------------------+
      |  https://calling-site.example.com  |
      |                                    |
      |                                    |
      |                                    |
      |         Calling JS Code            |
      |                ^                   |
      |                | API Calls         |
      |                v                   |
      |         PeerConnection             |
      |                ^                   |
      |                | postMessage()     |
      |                v                   |
      |    +-------------------------+     |     +---------------+
      |    | https://idp.example.org |     |     |               |
      |    |                         |<--------->|   Identity    |   
      |    |        IdP JS           |     |     |   Provider    |
      |    |                         |     |     |               |
      |    +-------------------------+     |     +---------------+
      |                                    |
      +------------------------------------+
  ]]></artwork>
      </figure>
           <t>
	     When the PeerConnection object wants to interact with the
	     IdP, the sequence of events is as follows:
	   </t>
	   <t>
	     <list style="numbers">
	       <t>The browser (the PeerConnection component)
	       instantiates an IdP proxy with its source at the IdP. This allows the 
	       IdP to load whatever JS is necessary into the
	       proxy, which runs in the IdP's security context.</t>
	       <t>If the user is not already logged in, the
	       IdP does whatever is required to log them in,
	       such as soliciting a username and password.</t>
	       <t>Once the user is logged in, the IdP proxy
	       notifies the browser that
	       it is ready.</t>
	       <t>The browser and the IdP proxy communicate
	       via a standardized series of messages
	       delivered via postMessage. For instance,
	       the browser might request the IdP proxy to
	       sign or verify a given identity assertion.</t>
	     </list>
	   </t>
	   <t>
	     This approach allows us to decouple the browser from
	     any particular identity provider; the browser need
	     only know how to load the IdP's JavaScript--which
	     is deterministic from the IdP's identity--and
	     the generic protocol for requesting and verifying
	     assertions. The IdP provides whatever logic
	     is necessary to bridge the generic protocol to
	     the IdP's specific requirements. Thus, a single
	     browser can support any number of identity protocols,
	     including being forward compatible with IdPs which
	     did not exist at the time the browser was written.
	   </t>
	</section>
	
	<section title="Items for Standardization" anchor="sec.standardized">
	  <t>
	    In order to make this work, we must standardize the following 
	    items:
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		The precise information from the signaling message that
		must be cryptographically bound to the user's identity
		and a mechanism for carrying assertions in JSEP
		messages. <xref target="sec.jsep-binding"/>
	      </t>
	      
	      <t>
		The interface to the IdP. <xref target="sec.protocol-details"/>
		specifies a specific protocol mechanism which allows the
		use of any identity protocol without requiring specific
		further protocol support in the browser 
	      </t>
	      <t>
		The JavaScript interfaces which the calling application can
		use to specify the IdP to use to generate assertions and
		to discover what assertions were received. 
	      </t>
	    </list>
	  </t>
	  <t>
	    The first two items are defined in this document. The final one
	    is defined in the companion W3C WebRTC API specification [TODO:REF]
	  </t>
	</section>
	<section title="Binding Identity Assertions to JSEP Offer/Answer Transactions" anchor="sec.jsep-binding">

	  <section title="Input to Assertion Generation Process">
	    <t>
	      As discussed above, an identity assertion binds the user's
	      identity (as asserted by the IdP) to the JSEP offer/exchange
	      transaction and specifically to the media. In order to 
	      achieve this, the PeerConnection must provide the DTLS-SRTP
	      fingerprint to be bound to the identity. This is provided
	      in a JSON structure for extensibility, as shown below:
	    </t>
	     <figure>
 <artwork><![CDATA[
 {
   "fingerprint" : 
   {
            "algorithm":"SHA-1",
            "digest":"4A:AD:B9:B1:3F:...:E5:7C:AB"
    }
 }
  ]]>
 </artwork>
 </figure>
	    <t>
	      The "algorithm" and digest values correspond directly to the
	      algorithm and digest in the a=fingerprint line of the SDP.
	    </t>
	    <t>
	      Note: this structure does not need to be interpreted by the
	      IdP or the IdP proxy. It is consumed solely by the RP's browser.
	      The IdP merely treats it as an opaque value to be 
	      attested to.
	      Thus, new parameters can be added to the assertion without
	      modifying the IdP.
	    </t>
	  </section>
	  <section title="Carrying Identity Assertions">
	    <t>
	      Once an IdP has generated an assertion,
	      the JSEP message. This is done by adding a new a-line to the
	      SDP, of the form a=identity. The sole contents of this value
	      are a base-64-encoded version of the identity assertion.
	      For example:
	    </t>
	    <figure>
		<artwork><![CDATA[
   v=0
   o=- 1181923068 1181923196 IN IP4 ua1.example.com
   s=example1
   c=IN IP4 ua1.example.com
   a=setup:actpass
   a=fingerprint: SHA-1 \
     4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
   a=identity: \
     ImlkcCI6eyJkb21haW4iOiAiZXhhbXBsZS5vcmciLCAicHJvdG9jb2wiOiAiYm9n \
     dXMifSwiYXNzZXJ0aW9uIjpcIntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5v \
     cmdcIixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIs \
     XCJzaWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9Cg==
   t=0 0
   m=audio 6056 RTP/AVP 0
   a=sendrecv
   a=tcap:1 UDP/TLS/RTP/SAVP RTP/AVP
   a=pcfg:1 t=1
]]>
		</artwork>
	    </figure>
	    <t>
	      Each identity attribute should be paired (and attests to) with an a=fingerprint 
	      attribute and therefore can exist either at the session or media level.
	      Multiple identity attributes may appear at either level, though implementations
	      are discouraged from doing this unless they have a clear idea of what
	      security claim they intend to be making.
	    </t>
	    </section>
	</section>
	<section title="IdP Interaction Details" anchor="sec.protocol-details">
	  <section title="General Message Structure">
	    <t>
	      Messages between the PeerConnection object and the
	      IdP proxy are formatted using JSON <xref target="RFC4627"/>.
	      For instance, the PeerConnection would request a 
	      signature with the following "SIGN" message:
	    </t>
	    <figure>
	      <artwork><![CDATA[
	      { 
	        "type":"SIGN",
	        "id": "1",
		"origin":"https://calling-site.example.com",
	        "message":"012345678abcdefghijkl"
	      }
	      ]]></artwork>
	    </figure>
	    <t>
	      All messages MUST contain a "type" field which indicates
	      the general meaning of the message.
	    </t>
	    <t>
	      All requests from the PeerConnection object MUST contain
	      an "id" field which MUST be unique for that PeerConnection
	      object. Any responses from the IdP proxy MUST contain
	      the same id in response, which allows the PeerConnection
	      to correlate requests and responses.
	    </t>
	    <t>
	      All requests from the PeerConnection object MUST contain
	      an "origin" field containing the origin of the JS which
	      initiated the PC (i.e., the URL of the calling site).
	      This origin value can be used by the IdP to make access
	      control decisions. For instance, an IdP might
	      only issue identity assertions for certain calling
	      services in the same way that some IdPs require that
	      relying Web sites have an API key before learning user
	      identity.
	    </t>
	    <t>
	      Any message-specific data is carried in a "message"
	      field. Depending on the message type, this may
	      either be a string or a richer JSON object.
	    </t>
	    <section title="Errors">
	      <t>
		If an error occurs, the IdP sends a message of
		type "ERROR". The message MAY have an
		"error" field containing freeform
		text data which containing additional
		information about what happened. For instance:
	      </t>
	      <figure title="Example error" anchor="fig.example-error">
		<artwork><![CDATA[
		{
		  "type":"ERROR",
		  "error":"Signature verification failed"
		}
		]]></artwork>
	      </figure>
	    </section>
	  </section>
	  <section title="IdP Proxy Setup" anchor="sec.iframe-setup">
	      <t>
		In order to perform an identity transaction, the PeerConnection
		must first create an IdP proxy. While the details
		of this are specified in the W3C API document, from the 
		perspective of this specification, however, the relevant
		facts are:
	      </t>
	      <t>
		<list style="symbols">
		  <t>The JS runs in the IdP's security context with the
		  base page retrieved from the URL specified in
		  <xref target="sec.idp-uri"/></t>
		  <t>The usual browser sandbox isolation mechanisms MUST
		  be enforced with respect to the IdP proxy.</t>
		  <t>JS running in the IdP proxy MUST be able to
		  send and receive messages to the PeerConnection
		  and the PC and IdP proxy
		  are able to verify the source and destination of
		  these messages.</t>
		</list>
	      </t>
	      <t>
		Initially the IdP proxy is in an unready state; the 
		IdP JS must be loaded and there may be several round 
		trips to the IdP server, for instance to log the user
		in. When the IdP proxy is ready to receive commands,
		it delivers a "ready" message. As this
		message is unsolicited, it simply contains:
	      </t>
	      <figure>
		<artwork><![CDATA[
		{ "type":"READY" }
		]]></artwork>
	      </figure>
	     <t>
	       [[ OPEN ISSUE: if the W3C half of this converges on WebIntents, then
	       the READY message will not be necessary.]]</t>
	      <t>
		Once the PeerConnection object receives the ready message,
		it can send commands to the IdP proxy.
	      </t>
	      <section title="Determining the IdP URI" anchor="sec.idp-uri">
		<t>
		  Each IdP proxy instance is associated with two values:
		</t>
		<t>
		  <list style="hanging">
		    <t hangText="domain name:">The IdP's domain name</t>
		    <t hangText="protocol:">The specific IdP protocol
		    which the IdP is using. This is a completely IdP-specific
		    string, but allows an IdP to implement two protocols
		    in parallel. This value may be the empty string.</t>
		  </list>
		</t>
		<t>
		  Each IdP MUST serve its initial entry page
		  (i.e., the one loaded by the IdP proxy) from
		  the well-known URI specified in 
		  "/.well-known/idp-proxy/&lt;protocol&gt;" on
		  the IdP's web site. This URI MUST be loaded
		  via HTTPS <xref target="RFC2818"/>.
		  For example, for the IdP "identity.example.com"
		  and the protocol "example", the URL
		  would be:
		</t>
		<figure>
		  <artwork><![CDATA[
  https://example.com/.well-known/idp-proxy/example
		  ]]></artwork>
		</figure>
		<section title="Authenticating Party">
		  <t>
		    How an AP determines the appropriate IdP domain is
		    out of scope of this specification. In general, 
		    however, the AP has some actual account relationship 
		    with the IdP, as this identity is what the IdP is 
		    attesting to. Thus, the AP somehow supplies the
		    IdP information to the browser. Some potential
		    mechanisms include:
		  </t>
		  <t>
		    <list style="symbols">
		      <t>Provided by the user directly.</t>
		      <t>Selected from some set of IdPs known to the calling site.
		      E.g., a button that shows "Authenticate via Facebook Connect"</t>
		    </list>
		  </t>
		</section>
		<section title="Relying Party">
		  <t>
		    Unlike the AP, the RP need not have any particular
		    relationship with the IdP. Rather, it needs to be able
		    to process whatever assertion is provided by the AP.
		    As the assertion contains the IdP's identity,
		    the URI can be constructed directly from the 
		    assertion, and thus the RP can directly verify
		    the technical validity of the assertion with no user 
		    interaction. Authoritative assertions need only
		    be verifiable. Third-party assertions also MUST be
		    verified against local policy, as described in
		    <xref target="sec.id-format"/>.
		  </t>
		</section>
	    </section>
	    <section title="Requesting Assertions" anchor="sec.request-assert">
	      <t>
		In order to request an assertion, the PeerConnection
		sends a "SIGN" message. Aside from the mandatory fields,
		this message has a "message" field containing a string.
		The contents of this string are defined above, but are
		opaque from the perspective of the IdP.
	      </t>
	      <t>
		A successful response to a "SIGN" message contains
		a message field which is a JS dictionary 
		dictionary consisting of two fields:
	      </t>
	      <t>
		<list style="hanging">
		  <t hangText="idp:">A dictionary containing the domain name of the provider
		  and the protocol string</t>
		  <t hangText="assertion:">An opaque field containing the
		  assertion itself. This is only interpretable by the
		  idp or its proxy.</t>
		</list>
	      </t>
	      <t>
	  <xref target="fig.assert-request"/> shows an
	  example transaction, with the message 
	  "abcde..." (remember, the messages are opaque at this layer) being signed and bound to identity
	  "ekr@example.org". In this case, the message has presumably
	  been
	  digitally signed/MACed in some way that the IdP can
	  later verify it, but this is an implementation detail
	  and out of scope of this document. Line breaks are inserted
	  solely for readability.</t>
	      
	      <figure title="Example assertion request" anchor="fig.assert-request">
		<artwork><![CDATA[
    PeerConnection -> IdP proxy:
      {
        "type":"SIGN",
         "id":1,
         "origin":"https://calling-service.example.com/",
         "message":"abcdefghijklmnopqrstuvwyz"
      }
      
    IdPProxy -> PeerConnection:
      {
        "type":"SUCCESS",
        "id":1,
        "message": {
	  "idp":{
	    "domain": "example.org"
	    "protocol": "bogus"
 	  },
	  "assertion":\"{\"identity\":\"bob@example.org\",
	                 \"contents\":\"abcdefghijklmnopqrstuvwyz\",
                         \"request_origin\":\"rtcweb://peerconnection\",
                         \"signature\":\"010203040506\"}"
        }
      }
		]]>
		</artwork>
	      </figure>
	    </section>

	    <section title="Verifying Assertions" anchor="sec.verify-assert">
	      <t>
		In order to verify an assertion, an RP sends a "VERIFY"
		message to the IdP proxy containing the assertion 
		supplied by the AP in the "message" field.
	      </t>
	      <t>
		The IdP proxy verifies the assertion. Depending on the
		identity protocol, this may require one or more round
		trips to the IdP. For instance, an OAuth-based protocol
		will likely require using the IdP as an oracle,
		whereas with BrowserID the IdP proxy can likely
		verify the signature on the assertion without
		contacting the IdP, provided that it has cached
		the IdP's public key.
	      </t>
	      <t>
		Regardless of the mechanism,
		if verification succeeds, a successful response from
		the IdP proxy MUST contain a message field consisting
		of a dictionary/hash with the following fields:
	      </t>
	      <t>
		<list style="hanging">
		  <t hangText="identity">The identity of the AP from the
		  IdP's perspective. Details of this are provided in
		  <xref target="sec.id-format"/></t>
		  <t hangText="contents">The original unmodified string
		  provided by the AP in the original SIGN request.</t>
		  <t hangText="request_origin">The original origin of
		  the SIGN request on the AP side as determined by
		  the origin of the PostMessage call. The IdP MUST somehow
		  arrange to propagate this information as part of the
		  assertion. The receiving PeerConnection MUST verify that
		  this value is "rtcweb://peerconnection" (which implies
		  that PeerConnection must arrange that its messages to the
		  IdP proxy are from this origin.)
		  [[ OPEN ISSUE: Can a URI person help make a better URI.]]
		  </t>
		</list>
	      </t>
	      <t>
		<xref target="fig.verify-request"/> shows
		an example transaction. Line breaks are inserted
		solely for readability. 
	      </t>

	      <figure title="Example verification request" anchor="fig.verify-request">
		<artwork>
		  <![CDATA[
      PeerConnection -> IdP Proxy:
        {
          "type":"VERIFY",
          "id":2,
          "origin":"https://calling-service.example.com/",
	  "message":\"{\"identity\":\"bob@example.org\",
	               \"contents\":\"abcdefghijklmnopqrstuvwyz\",
                       \"request_origin\":\"rtcweb://peerconnection\",
                       \"signature\":\"010203040506\"}"
        }

      IdP Proxy -> PeerConnection:
        {
         "type":"SUCCESS",
         "id":2,
         "message": {
	   "identity" : {
	     "name" : "bob@example.org",
	     "displayname" : "Bob"
	   },
           "request_origin":"rtcweb://peerconnection",
	   "contents":"abcdefghijklmnopqrstuvwyz"
	 }
        }
]]>
		</artwork>
	      </figure>
	      
	      <section title="Identity Formats" anchor="sec.id-format">
		<t>
		  Identities passed from the IdP proxy to the PeerConnection
		  are structured as JSON dictionaries with one mandatory
		  field: "name". This field MUST consist of an
		  RFC822-formatted string representing the user's identity.
		  [[ OPEN ISSUE: Would it be better to have a typed field? ]]
		  The PeerConnection API MUST check this string as
		  follows:
		</t>
		<t>
		  <list style="numbers">
		    <t>If the RHS of the string is equal to the domain name
		    of the IdP proxy, then the assertion is valid,
		    as the IdP is authoritative for this domain.</t>
		    <t>If the RHS of the string is not equal to the domain
		    name of the IdP proxy, then the PeerConnection object
		    MUST reject the assertion unless (a) the 
		    IdP domain is listed as an acceptable third-party
		    IdP and (b) local policy is configured to trust
		    this IdP domain for the RHS of the identity string.
		    </t>
		  </list>
		</t>
		<t>
		  Sites which have identities that do not fit
		  into the RFC822 style (for instance, Facebook
		  ids are simple numeric values) SHOULD 
		  convert them to this form by appending their
		  IdP domain (e.g., 12345@identity.facebook.com),
		  thus ensuring that they are authoritative for
		  the identity.
		</t>
		<t>
		  The IdP proxy MAY also include a "displayname" field
		  which contains a more user-friendly identity assertion.
		  Browsers SHOULD take care in the UI to distinguish the
		  "name" assertion which is verifiable directly from the
		  "displayname" which cannot be verified and thus
		  relies on trust in the IdP. In future,
		  we may define other fields to allow the IdP to
		  provide more information to the browser.
		  [[OPEN ISSUE: Should this field exist? Is it
		  confusing? ]]
		</t>
	      </section>
	      
	  </section>
	  </section>
	</section>
	</section>
  
  <section title="Security Considerations" anchor="sec.sec-cons">
    <t>
      Much of the security analysis of this problem is contained in
      <xref target="I-D.ietf-rtcweb-security"/> or in the discussion
      of the particular issues above. In order to avoid
      repetition, this section focuses on (a) residual threats
      that are not addressed by this document and (b) threats
      produced by failure/misbehavior of one of the components
      in the system.
    </t>
    <section title="Communications Security">
      <t>
	While this document favors DTLS-SRTP, it permits a variety
	of communications security mechanisms and thus the level
	of communications security actually provided varies
	considerably. Any pair of implementations which have
	multiple security mechanisms in common are subject to
	being downgraded to the weakest of those common
	mechanisms by any attacker who can modify the signaling
	traffic. If communications are over HTTP, this means
	any on-path attacker. If communications are over HTTPS,
	this means the signaling server. Implementations which
	wish to avoid downgrade attack should only offer
	the strongest available mechanism, which is DTLS/DTLS-SRTP.
	Note that the implication of this choice will be that
	interop to non-DTLS-SRTP devices will need to happen through
	gateways.
      </t>
      <t>
	Even if only DTLS/DTLS-SRTP are used, the signaling server
	can potentially mount a man-in-the-middle attack unless
	implementations have some mechanism for independently
	verifying keys. The UI requirements in <xref target="sec.proposal.comsec"/>
	are designed to provide such a mechanism for motivated/security
	conscious users, but are not suitable for general use.
	The identity service mechanisms in <xref target="sec.generic.idp"/>
	are more suitable for general use. Note, however, that
	a malicious signaling service can strip off any such
	identity assertions, though it cannot forge new ones.
	Note that all of the third-party security mechanisms available
	(whether X.509 certificates or a third-party IdP) rely on
	the security of the third party--this is of course also true
	of your connection to the Web site itself. Users who wish to
	assure themselves of security against a malicious identity
	provider can only do so by verifying peer credentials directly, e.g., by
	checking the peer's fingerprint against a value delivered out
	of band.
      </t>
    </section>
    
    <section title="Privacy">
      <t>
	The requirements in this document are intended to allow:
      </t>
      <t>
	<list style="symbols">
	  <t>Users to participate in calls without revealing their location.</t>
	  <t>Potential callees to avoid revealing their location and even
	  presence status prior to agreeing to answer a call.</t>
	</list>
      </t>
      <t>
	However, these privacy protections come at a performance cost 
	in terms of using TURN relays and, in the latter case, delaying
	ICE. Sites SHOULD make users aware of these tradeoffs.
      </t>
      <t>
	Note that the protections provided here assume a non-malicious
	calling service. As the calling service always knows the users
	status and (absent the use of a technology like Tor) their
	IP address, they can violate the users privacy at will.
	Users who wish privacy against the calling sites they
	are using must use separate privacy enhancing technologies
	such as Tor. Combined RTCWEB/Tor implementations SHOULD
	arrange to route the media as well as the signaling through
	Tor. [Currently this will produce very suboptimal performance.]
      </t>
    </section>

    <section title="Denial of Service">
      <t>
	The consent mechanisms described in this document are intended to
	mitigate denial of service attacks in which an attacker uses
	clients to send large amounts of traffic to a victim without
	the consent of the victim. While these mechanisms are sufficient
	to protect victims who have not implemented RTCWEB at all,
	RTCWEB implementations need to 
	be more careful.
      </t>
      <t>
	Consider the case of a call center which accepts calls via
	RTCWeb. An attacker proxies the call center's front-end
	and arranges for multiple clients to initiate calls to
	the call center. Note that this requires user consent
	in many cases but because the data channel does not need
	consent, he can use that directly. Since ICE will
	complete, browsers can then be induced to send large
	amounts of data to the victim call center if it supports
	the data channel at all. Preventing
	this attack requires that automated RTCWEB implemementations
	implement sensible flow control and have the ability to
	triage out (i.e., stop responding to ICE probes on)
	calls which are behaving badly, and especially to
	be prepared to remotely throttle the data channel in
	the absence of plausible audio and video (which
	the attacker cannot control).
      </t>
      <t>
	Another related attack is for the signaling service to 
	swap the ICE candidates for the audio and video streams,
	thus forcing a browser to send video to the sink that 
	the other victim expects will contain audio
	(perhaps it is only expecting audio!)
	potentially causing overload.
	Muxing multiple media flows over a single transport makes 
	it harder to individually suppress a single flow by denying
	ICE keepalives. Either media-level (RTCP) mechanisms must be
	used or the implementation must deny responses entirely,
	thus termnating the call.
      </t>
      <t>
	Yet another attack, suggested by Magnus Westerlund,
	is for the attacker to cross-connect offers and answers
	as follows. It induces the victim to make a call
	and then uses its control of other users browsers
	to get them to attempt a call to someone. It then 
	translates their offers into apparent answers to
	the victim, which looks like large-scale parallel forking.
	The victim still responds to ICE responses and 
	now the browsers all try to send media to the victim.
	Implementations can defend themselves from this attack
	by only responding to ICE Binding Requests for a limited
	number of remote ufrags (this is the reason for
	the requirement that the JS not be able to control
	the ufrag and password).
      </t>
      <t>
	Note that attacks based on confusing one end or the other about
	consent are possible even in the face of the
	third-party identity mechanism as long as major parts of 
	the signaling messages are not signed. On the other hand,
	signing the entire message severely restricts the capabilities
	of the calling application, so there are difficult tradeoffs here.
      </t>	
    </section>
    <section title="IdP Authentication Mechanism">
      <t>
	This mechanism relies for its security on the IdP and on
	the PeerConnection correctly enforcing the security 
	invariants described above. At a high level, the IdP
	is attesting that the user identified in the assertion
	wishes to be associated with the assertion. Thus,
	it must not be possible for arbitrary third parties to
	get assertions tied to a user or to produce assertions
	that RPs will accept.
      </t>

      <section title="PeerConnection Origin Check" anchor="sec.pc-origin">
	<t>
	  Fundamentally, the IdP proxy is just a piece of HTML and JS
	  loaded by the browser, so nothing stops a Web attacker o
	  from creating their own IFRAME, loading the IdP proxy HTML/JS,
	  and requesting a signature. In order to prevent this attack,
	  we require that all signatures be tied to a specific 
	  origin ("rtcweb://...") which cannot be produced by
	  a page tied to a Web attacker. Thus, while an attacker
	  can instantiate the IdP proxy, they cannot send messages
	  from an appropriate origin and so cannot create acceptable
	  assertions. This origin check is enforced on the relying
	  party side, not on the authenticating party side. The reason
	  for this is to take the burden of knowing which origins
	  are valid off of the IdP, thus making this mechanism
	  extensible to other applications besides RTCWEB. The
	  IdP simply needs to gather the origin information
	  (from the posted message) and attach it to the assertion.
	</t>
      </section>

      <section title="IdP Well-known URI" anchor="sec.sec-idp-uri">
	<t>
	  As described in <xref target="sec.idp-uri"/> the IdP proxy
	  HTML/JS landing page is located at a well-known URI based on
	  the IdP's domain name. This requirement prevents an attacker
	  who can write some resources at the IdP (e.g., on one's
	  Facebook wall) from being able to impersonate the IdP.
	</t>
      </section>

      <section title="Privacy of IdP-generated identities and the hosting site">
	<t>
	  Depending on the structure of the IdP's assertions, the calling
	  site may learn the user's identity from the perspective of the IdP.
	  In many cases this is not an issue because the user is authenticating
	  to the site via the IdP in any case, for instance when the user
	  has logged in with Facebook Connect and is then authenticating their
	  call with a Facebook identity. 
	  However, in other case, the user
	  may not have already revealed their identity to the site.
	  In general, IdPs SHOULD either verify that the user is willing
	  to have their identity revealed to the site (e.g., through
	  the usual IdP permissions dialog) or arrange that the identity
	  information is only available to known RPs (e.g., social graph
	  adjacencies) but not to the calling site. The "origin" field
	  of the signature request can be used to check that the 
	  user has agreed to disclose their identity to the calling
	  site; because it is supplied by the PeerConnection it can
	  be trusted to be correct.
	</t>
      </section>
      <section title="Security of Third-Party IdPs" anchor="sec.sec-third-party">
	<t>
	  As discussed above, each third-party IdP represents a new universal trust
	  point and therefore the number of these IdPs needs to be 
	  quite limited. Most IdPs, even those which issue unqualified
	  identities such as Facebook, can be recast as authoritative
	  IdPs (e.g., 123456@facebook.com). However, in such cases,
	  the user interface implications are not entirely desirable.
	  One intermediate approach is to have special (potentially user
	  configurable) UI for large authoritative IdPs, thus allowing
	  the user to instantly grasp that the call is being authenticated
	  by Facebook, Google, etc.
	</t>
      </section>
    <section title="Web Security Feature Interactions">
	<t>
	  A number of optional Web security features have the potential
	  to cause issues for this mechanism, as discussed below.
	</t>
	<section title="Popup Blocking" anchor="sec.popup-blocking">
	  <t>
	    If the user is not already logged into the IdP, the 
	    IdP proxy may need to pop up a top level window in order
	    to prompt the user for their authentication information
	    (it is bad practice to do this in an IFRAME inside the
	    window because then users have no way to determine the
	    destination for their password). If the user's browser
	    is configured to prevent popups, this may fail
	    (depending on the exact algorithm that the popup blocker
	    uses to suppress popups). It may be necessary to provide
	    a standardized mechanism to allow the IdP proxy to
	    request popping of a login window. Note that
	    care must be taken here to avoid PeerConnection becoming
	    a general escape hatch from popup blocking. One possibility
	    would be to only allow popups when the user has explicitly
	    registered a given IdP as one of theirs (this is only relevant
	    at the AP side in any case). This is what WebIntents does, and
	    the problem would go away if WebIntents is used.
	  </t>
	</section>

	<section title="Third Party Cookies" anchor="sec.3rd-party-cookies">
	  <t>
	    Some browsers allow users to block third party cookies (cookies associated
	    with origins other than the top level page) for privacy reasons.
	    Any IdP which uses cookies to persist logins will be broken
	    by third-party cookie blocking. One option is to accept this
	    as a limitation; another is to have the PeerConnection object
	    disable third-party cookie blocking for the IdP proxy.
	  </t>
	</section>

      </section>
    </section>
  </section>
      </section>
  <section title="Acknowledgements">
    <t>
      Bernard Aboba, Harald Alvestrand, Dan Druta,
      Cullen Jennings, Hadriel Kaplan, Matthew Kaufman,
      Jim McEachern, Martin Thomson, Magnus Westerland.
    </t>
  </section>

  <section title="Changes since -03">
    <t>Version -04 was a version control mistake. Please ignore.</t>
    <t>
      The following changes have been made since the -04 draft.	
    </t>
    <t>
    <list style="symbols">
      <t>Move origin check from IdP to RP per discussion in YVR.</t>
      <t>Clarified treatment of X.509-level identities.</t>
      <t>Editorial cleanup.</t>
    </list>
    </t>
  </section>

  <section title="Changes since -03">
  </section>
  
  <section title="Changes since -02">
    <t>
      The following changes have been made since the -02 draft.
    </t>
    <t>
      <list style="symbols">
	<t>Forbid persistent HTTP permissions.</t>
	<t>Clarified the text in S 5.4 to clearly refer to requirements on the API to provide functionality to the site.</t>
	<t>Fold in the IETF portion of draft-rescorla-rtcweb-generic-idp</t>
	<t>Retarget the continuing consent section to assume Binding Requests</t>
	<t>Editorial improvements</t>
      </list>
    </t>
  </section>

  </middle>

  <back>


    <references title="Normative References">
      &RFC2119;
      &RFC2818;
      &RFC6454;
      &RFC5245;
      &RFC4347;
      &RFC5763;
      &RFC5764;
      &RFC4627;

      &I-D.ietf-rtcweb-security;
      &I-D.muthu-behave-consent-freshness;
    </references>
    <references title="Informative References">
      &RFC3261;
      &RFC5705;
      &RFC6455;
      &I-D.kaufman-rtcweb-security-ui;
      &I-D.jennings-rtcweb-signaling;
      &I-D.ietf-rtcweb-jsep;


      <reference anchor="XmlHttpRequest">
	<front>
	  <title>XMLHttpRequest Level 2</title>
	  
	  <author initials="A." surname="van Kesteren">
	    <organization></organization>
	  </author>
	</front>
	<format target="http://www.w3.org/TR/XMLHttpRequest/" type="TXT"/>
      </reference>


    </references>

    <section title="Example IdP Bindings to Specific Protocols">
      <t>
	This section provides some examples of how the
	mechanisms described in this document could be used
	with existing authentication protocols such as
	BrowserID or OAuth. Note that this does not
	require browser-level support for either protocol.
	Rather, the protocols can be fit into the generic
	framework. (Though BrowserID in particular works
	better with some client side support).
      </t>
	<section title="BrowserID">
	  <t>
	    BrowserID [https://browserid.org/] is a technology which 
	    allows a user with a verified email address to generate
	    an assertion (authenticated by their identity provider) 
	    attesting to their identity (phrased as an email address).
	    The way that this is used in practice is that the relying
	    party embeds JS in their site which talks to the BrowserID
	    code (either hosted on a trusted intermediary or embedded
	    in the browser). That code generates the assertion which is
	    passed back to the relying party for verification.
	    The assertion can be verified directly or with a Web
	    service provided by the identity provider.
	    It's relatively easy to extend this functionality to 
	    authenticate RTCWEB calls, as shown below.
	  </t>
      <figure>
	<artwork><![CDATA[
+----------------------+                     +----------------------+
|                      |                     |                      |
|    Alice's Browser   |                     |     Bob's Browser    |
|                      | OFFER ------------> |                      |
|   Calling JS Code    |                     |    Calling JS Code   |
|          ^           |                     |          ^           |
|          |           |                     |          |           |
|          v           |                     |          v           |
|    PeerConnection    |                     |    PeerConnection    |			       
|       |      ^       |                     |       |      ^       |			       
| Finger|      |Signed |	             |Signed |      |       |
| print |      |Finger |                     |Finger |      |"Alice"|
|       |      |print  |	    	     |print  |      |       |
|       v      |       |	    	     |       v      |       |
|   +--------------+   |	    	     |   +---------------+  |
|   |  IdP Proxy   |   |                     |   |  IdP Proxy    |  |
|   |     to       |   |                     |   |     to        |  |
|   |  BrowserID   |   |	    	     |   |  BrowserID    |  |
|   |  Signer      |   |	    	     |   |  Verifier     |  |
|   +--------------+   |	    	     |   +---------------+  | 
|           ^          |	    	     |          ^           |
+-----------|----------+                     +----------|-----------+
            |                                           |
            | Get certificate                           |
	    v                                           | Check 
+----------------------+                                | certificate
|                      |                                |
|       Identity       |/-------------------------------+
|       Provider       |
|                      |
+----------------------+            
 	]]></artwork>
      </figure>
      <t>
	The way this mechanism works is as follows. On Alice's side, Alice
	goes to initiate a call.
      </t>
      <t><list style="numbers">
	<t>The calling JS instantiates a PeerConnection
	and tells it that it is interested in having it authenticated 
	via BrowserID (i.e., it provides "browserid.org" as the
	IdP name.)</t>
	<t>The PeerConnection instantiates the BrowserID signer in
	the IdP proxy
	</t>
	<t>The BrowserID signer contacts Alice's identity provider,
	authenticating as Alice (likely via a cookie).</t>
	<t>The identity provider returns a short-term certificate
	attesting to Alice's identity and her short-term public key.</t>
	<t>The Browser-ID code signs the fingerprint and returns the
	signed assertion + certificate to the PeerConnection. </t>
	<t>The PeerConnection returns the signed information to the
	calling JS code.</t>
	<t>The signed assertion gets sent over the wire to Bob's
	browser (via the signaling service) as part of the call setup.</t>
      </list>
      </t>
      <t>
	Obviously, the format of the signed assertion varies depending
	on what signaling style the WG ultimately adopts. However, for
	concreteness, if something like ROAP were adopted, then the
	entire message might look like:
      </t>
      <figure>
	<artwork><![CDATA[
   {
     "messageType":"OFFER",
     "callerSessionId":"13456789ABCDEF",
     "seq": 1
     "sdp":"
   v=0\n
   o=- 2890844526 2890842807 IN IP4 192.0.2.1\n
   s= \n
   c=IN IP4 192.0.2.1\n
   t=2873397496 2873404696\n
   m=audio 49170 RTP/AVP 0\n
   a=fingerprint: SHA-1 \
   4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n",
    "identity":{
         "idp":{     // Standardized
	    "domain":"browserid.org",
	    "method":"default"
         },
	 "assertion":   // Contents are browserid-specific
	   "\"assertion\": {
             \"digest\":\"<hash of the contents from the browser>\",
             \"audience\": \"[TBD]\"
             \"valid-until\": 1308859352261,
            }, 
            \"certificate\": {
              \"email\": \"rescorla@example.org\",
              \"public-key\": \"<ekrs-public-key>\",
              \"valid-until\": 1308860561861,
            }" // certificate is signed by example.org
	 }
   }
 	]]></artwork>
      </figure>
      <t>
	<!-- [TODO: Need to talk about Audience a bit.] -->
	Note that while the IdP here is specified as "browserid.org",
	the actual certificate is signed by example.org. This is because
	BrowserID is a combined authoritative/third-party system in
	which browserid.org delegates the right to be authoritative
	(what BrowserID calls primary) to individual domains.
      </t>
      <t>
	On Bob's side, he receives the signed assertion as part of the call
	setup message and a similar procedure happens to verify it.
      </t>
      <t><list style="numbers">
	<t>The calling JS instantiates a PeerConnection
	and provides it the relevant signaling information, including the
	signed assertion.</t>
	<t>The PeerConnection instantiates the IdP proxy which examines 
	the IdP name and brings up the BrowserID verification code.</t>
	<t>The BrowserID verifier contacts the identity provider to
	verify the certificate and then uses the key to verify the
	signed fingerprint.</t>
	<t>Alice's verified identity is returned to the PeerConnection
	(it already has the fingerprint).</t>
	<t>At this point, Bob's browser can display a trusted UI indication
	that Alice is on the other end of the call.</t>
      </list>
      </t>
      <t>
	When Bob returns his answer, he follows the converse procedure, which
	provides Alice with a signed assertion of Bob's identity and keying
	material.
      </t>
      </section>

	<section title="OAuth">
	  <t>
	    While OAuth is not directly designed for user-to-user authentication,
	    with a little lateral thinking it can be made to serve. We use the
	    following mapping of OAuth concepts to RTCWEB concepts:
	  </t>
	    <texttable anchor="oauth-rtcweb">
	      <ttcol align="left">OAuth</ttcol>
	      <ttcol align="left">RTCWEB</ttcol>
	      <c>Client</c><c>Relying party</c>
	      <c>Resource owner</c><c>Authenticating party</c>
	      <c>Authorization server</c><c>Identity service</c>
	      <c>Resource server</c><c>Identity service</c>
	    </texttable>
	  <t>
	    The idea here is that when Alice wants to authenticate to Bob (i.e., for
	    Bob to be aware that she is calling). In order to do this, she allows
	    Bob to see a resource on the identity provider that is bound to the
	    call, her identity, and her public key. Then Bob retrieves the resource
	    from the identity provider, thus verifying the binding between Alice
	    and the call.
	  </t>
      <figure>
	<artwork><![CDATA[
	Alice                       IdP                       Bob
	---------------------------------------------------------
        Call-Id, Fingerprint  ------->
        <------------------- Auth Code
	Auth Code ---------------------------------------------->
  	                             <----- Get Token + Auth Code
				     Token --------------------->
				     <------------- Get call-info 
				     Call-Id, Fingerprint ------>
 	]]></artwork>
      </figure>
      <t>
	This is a modified version of a common OAuth flow, but
	omits the redirects required to have the client point the
	resource owner to the IdP, which is acting as both 
	the resource server and the authorization server, since
	Alice already has a handle to the IdP.
      </t>
      <t>
	Above, we have referred to "Alice", but really what we mean
	is the PeerConnection. Specifically, the PeerConnection will
	instantiate an IFRAME with JS from the IdP and will use
	that IFRAME to communicate with the IdP, authenticating
	with Alice's identity (e.g., cookie). Similarly, Bob's
	PeerConnection instantiates an IFRAME to talk to the IdP.
      </t>
      </section>
    </section>
</back>
<!--

On Thu, Sep 22, 2011 at 5:45 AM, Magnus Westerlund <magnus.westerlund@ericsson.com> wrote:
> Hi EKR,
>
> (As an individual)
>
> Thanks for posting the draft.
>
> I am missing a few security issues that I think should be considered.
>
> 1. The attempt to overload the links in an domain by concentrating
> traffic on the domain by choosing peer-pairs. Not that I think there is
> any real protection against this other than limit the flows to their
> "fair" share.
>
> 2. Configuring RTCP or other automatically sent traffic to high
> bit-rates. Especially under conditions where continued consent can't be
> determined.
>
						> Cheers
>
> Magnus Westerlund
>
>
>



-->

	    <!-- drill down -->
</rfc>


<!-- Continuing consent per Magnus -->

<!-- TODO: Require key destruction -->
