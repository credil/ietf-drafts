<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" ipr="trust200902" docName="draft-ietf-websec-key-pinning-04">
<front>
<title>Public Key Pinning Extension for HTTP</title>

<author initials="C." surname="Evans" fullname="Chris Evans">
<organization>Google, Inc.</organization>
<address>
<postal>
<street>1600 Amphitheatre Pkwy</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country>
</postal>
<email>cevans@google.com</email>
</address>
</author>

<author initials="C." surname="Palmer" fullname="Chris Palmer">
<organization>Google, Inc.</organization>
<address>
<postal>
<street>1600 Amphitheatre Pkwy</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country>
</postal>
<email>palmer@google.com</email>
</address>
</author>

<author initials="R." surname="Sleevi" fullname="Ryan Sleevi">
<organization>Google, Inc.</organization>
<address>
<postal>
<street>1600 Amphitheatre Pkwy</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043</code>
<country>US</country>
</postal>
<email>sleevi@google.com</email>
</address>
</author>

<date month="December" year="2012" />

<area>General</area>
<workgroup>Web Security</workgroup>

<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>Certificate</keyword>
<keyword>Public key</keyword>
<keyword>X.509</keyword>
<keyword>Certification authority</keyword>
<keyword>Public key pinning</keyword>
<keyword>HTTPS</keyword>
<keyword>TLS</keyword>
<keyword>SSL</keyword>

<abstract>

<t>This memo describes an extension to the HTTP protocol allowing web host
operators to instruct user agents (UAs) to remember ("pin") the hosts'
cryptographic identities for a given period of time. During that time, UAs
will require that the host present a certificate chain including at least
one Subject Public Key Info structure whose fingerprint matches one of the
pinned fingerprints for that host. By effectively reducing the number of
authorities who can authenticate the domain during the lifetime of the pin,
pinning may reduce the incidence of man-in-the-middle attacks due to
compromised Certification Authorities.</t>

</abstract>

</front>

<middle>

<section anchor="introduction" title="Introduction">

<t>We propose a new HTTP header to enable a web host to express to user
agents (UAs) which Subject Public Key Info (SPKI) structure(s) UAs SHOULD
expect to be present in the host's certificate chain in future connections
using TLS (see <xref target="RFC5246"/>). We call this "public key pinning".
At least one UA (Google Chrome) has experimented with shipping with a
user-extensible embedded set of pins. Although effective, this does not
scale. This proposal addresses the scale problem.</t>

<t>Deploying public key pinning safely will require operational and
organizational maturity due to the risk that hosts may make themselves
unavailable by pinning to a SPKI that becomes invalid. (See <xref
target="security-considerations"/>.) We believe that, with care, host
operators can greatly reduce the risk of MITM attacks and other
false-authentication problems for their users without incurring undue
risk.</t>

<t>We intend for hosts to use public key pinning together with HSTS (<xref
target="RFC6797"/>), but is possible to pin keys without requiring HSTS.</t>

<t>This draft is being discussed on the WebSec Working Group mailing
list, websec@ietf.org.</t>

<section anchor="requirements-language" title="Requirements Language">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119">RFC
2119</xref>.</t>

</section><!-- requirements-language -->

</section><!-- introduction -->

<section anchor="server-client-behavior" title="Server and Client
Behavior">

<section anchor="header-syntax" title="Response Header Field Syntax">

<t>The Public-Key-Pins HTTP response header field (PKP header field)
indicates to a UA that it SHOULD perform Pin Validation (<xref
target="validating-pinned-connections"/>) in regards to the host emitting
the response message containing this header field, and provides the
necessary information for the UA to do so.</t>

<t><xref target="header-abnf"/> describes the ABNF (Augmented Backus-Naur
Form) syntax of the header field. It is based on the Generic Grammar defined
in Section 2 of <xref target="RFC2616"/> (which includes a notion of
"implied linear whitespace", also known as "implied *LWS").</t>

<figure anchor="header-abnf" title="HPKP Header Syntax">
<artwork>
Public-Key-Pins =
    "Public-Key-Pins" ":" [ directive ] *( ";" [ directive ] )
Public-Key-Pins-Report-Only =
    "Public-Key-Pins-Report-Only" ":" [ directive ] *( ";" [ directive ] )

directive        = simple-directive
                   / pin-directive

simple-directive = directive-name [ "=" directive-value ]
directive-name   = token
directive-value  = token
                   / quoted-string

pin-directive    = "pin-" token "=" quoted-string
</artwork>
</figure>

<t>token and quoted-string are used as defined in <xref target="RFC2616"/>,
Section 2.2.</t>

<t>The directives defined in this specification are described below. The
overall requirements for directives are:</t>

<t><list style="numbers">
<t>The order of appearance of directives is not significant.</t>

<t>All simple-directives MUST appear only once in a PKP header field.
Directives are either optional or required, as stipulated in their
definitions.</t>

<t>Directive names are case-insensitive.</t>

<t>UAs MUST ignore any PKP header fields containing directives, or other
header field value data, that do not conform to the syntax defined in this
specification.</t>

<t>If a PKP header field contains any directive(s) the UA does not
recognize, the UA MUST ignore the those directives.</t>

<t>If the PKP header field otherwise satisfies the above requirements (1
through 5), the UA MUST process the directives it recognizes.</t>
</list></t>

<t>Additional directives extending the semantic functionality of the PKP
header field can be defined in other specifications, with a registry (having
an IANA policy definition of IETF Review <xref target="RFC2616"/>) defined
for them at such time. Such future directives will be ignored by UAs
implementing only this specification, as well as by generally non-conforming
UAs.</t>

<t>In the pin-directive, the token is the name of a cryptographic hash
algorithm, and MUST be either "sha1" or "sha256". The quoted-string is a
sequence of base 64 digits: the base 64-encoded SPKI Fingerprint. See <xref
target="pin-semantics"/>.</t>

<section anchor="max-age" title="The max-age Directive">

<t>The REQUIRED "max-age" directive specifies the number of seconds, after
the reception of the PKP header field, during which the UA SHOULD regard the
host (from whom the message was received) as a Known Pinned Host. The
delta-seconds production is specified in <xref target="RFC2616"/>.</t>

<t>The syntax of the max-age directive's REQUIRED value (after quoted-
string unescaping, if necessary) is defined as:</t>

<figure anchor="max-age-value-syntax" title="max-age Value Syntax">
<artwork>
max-age-value = delta-seconds
delta-seconds = 1*DIGIT
</artwork>
</figure>

<t>delta-seconds is used as defined in <xref target="RFC2616"/>, Section
3.3.2.</t>

<t>NOTE: A max-age value of zero (i.e., "max-age=0") signals the UA to cease
regarding the host as a Known Pinned Host, including the includeSubDomains
directive (if asserted for that Known Pinned Host). See <xref
target="header-field-processing"/>.</t>

</section><!-- max-age -->

<section anchor="includesubdomains" title="The includeSubDomains Directive">

<t>The OPTIONAL "includeSubDomains" directive is a valueless directive
which, if present (i.e., it is "asserted"), signals to the UA that the
Pinning Policy applies to this Pinned Host as well as any subdomains of the
host's domain name.</t>

</section><!-- includesubdomains -->

<section anchor="report-uri" title="The report-uri Directive">

<t>The OPTIONAL "report-uri" directive indicates the URI to which the UA
SHOULD report Pin Validation failures (<xref
target="validating-pinned-connections"/>). The UA POSTs the reports to the
given URI as described in <xref
target="reporting-pin-validation-failure"/>.</t>

<t>TODO: Describe the meaning of Public-Key-Pins-Report-Only and the
interaction between it and report-uri. In particular, describe how it is
possible to be in enforcement mode (i.e. not -Report-Only) and still POST
reports to the report-uri.</t>

</section><!-- report-uri -->

<section anchor="strict" title="The strict Directive">

<t>The OPTIONAL "strict" directive is a valueless directive which, if
present (i.e., it is "asserted"), signals to the UA that the Pinning Policy
contained should be applied to the Pinned Host exactly as specified, ignoring
local client policy.</t>

</section><!-- strict -->

<section anchor="grammar-examples" title="Examples">

<t><xref target="pins-examples"/> shows some example response header fields
using the pins extension (folded for clarity).</t>

<figure anchor="pins-examples" title="HPKP Header Examples">
<artwork>
Public-Key-Pins: max-age=500;
    pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha1="IvGeLsbqzPxdI0b0wuj2xVTdXgc="

Public-Key-Pins: max-age=31536000;
    pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ="

Public-Key-Pins: pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha1="qvTGHdzF6KLavt4PO0gs2a6pQ00=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=";
    max-age=2592000

Public-Key-Pins: pin-sha1="4n972HfV354KP560yw4uqe/baXc=";
    pin-sha1="qvTGHdzF6KLavt4PO0gs2a6pQ00=";
    pin-sha256="LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=";
    max-age=2592000; includeSubDomains
</artwork>
</figure>

</section><!-- grammar-examples -->

</section><!-- header-syntax -->

<section anchor="server-processing-model" title="Server Processing Model">

<t>This section describes the processing model that Pinned Hosts implement.
The model comprises two facets: the processing rules for HTTP request
messages received over a secure transport (e.g. TLS <xref
target="RFC5246"/>); and the processing rules for HTTP request messages
received over non-secure transports, such as TCP.</t>

<section anchor="https-request-type" title="HTTP-over-Secure-Transport
Request Type">

<t>When replying to an HTTP request that was conveyed over a secure
transport, a Pinned Host SHOULD include in its response exactly one PKP
header field that MUST satisfy the grammar specified above in <xref
target="header-syntax"/>. If the Pinned Host does not include the PKP header
field, and if the connection passed Pin Validation, UAs MUST treat the host
as if it had set its max-age to 0 (see <xref
target="header-field-processing"/>).</t>

<t>Establishing a given host as a Known Pinned Host, in the context of a
given UA, MAY be accomplished over the HTTP protocol, which is in turn
running over secure transport, by correctly returning (per this
specification) at least one valid PKP header field to the UA. Other
mechanisms, such as a client-side pre-loaded Known Pinned Host list MAY also
be used.</t>

</section><!-- https-request-type -->

<section anchor="http-request-type" title="HTTP Request Type">

<t>Pinned Hosts SHOULD NOT include the PKP header field in HTTP responses
conveyed over non-secure transport. UAs MUST ignore any PKP header received
in an HTTP response conveyed over non-secure transport.</t>

</section><!-- http-request-type -->

</section><!-- server-processing-model -->

<section anchor="server-ua-model" title="User Agent Processing Model">

<t>This section describes the HTTP Public Key Pinning processing model for
UAs.</t>

<t>TODO: Add a note referring to the HSTS RFC's discussion of IDNs.</t>

<section anchor="header-field-processing" title="Public-Key-Pins Response
Header Field Processing">

<t>If the UA receives, over a secure transport, an HTTP response that
includes a PKP header field conforming to the grammar specified in <xref
target="header-syntax"/>, and there are no underlying secure transport
errors or warnings (see <xref target="noting-pins"/>), the UA MUST
either:</t>

<t><list style="symbols">
<t>Note the host as a Known HSTS Host if it is not already so noted (see
<xref target="storage-model"/>),</t>
</list></t>

<t>or,</t>

<t><list style="symbols">

<t>Update the UA's cached information for the Known Pinned Host if any of of
the max-age, includeSubDomains, strict, or report-uri header field value
directives convey information different than that already maintained by the
UA.</t>

<t>The max-age value is essentially a "time to live" value relative to the
time of the most recent observation of the PKP header field.</t>

<t>If the max-age header field value token has a value of 0, the UA MUST
remove its cached Pinning Policy information (including the
includeSubDomains and strict directives, if asserted) if the Pinned Host is
Known, or, MUST NOT note this Pinned Host if it is not yet Known.</t>

<t>If a UA receives more than one PKP header field in an HTTP response
message over secure transport, then the UA MUST process only the first such
header field.</t>

</list></t>

<t>Otherwise:</t>

<t><list style="symbols">
<t>If the UA receives the HTTP response over insecure transport, or if the
PKP header is not a Valid Pinning Header (see <xref target="noting-pins"/>),
the UA MUST ignore any present PKP header field(s).</t>

<t>The UA MUST ignore any PKP header fields not conforming to the grammar
specified in <xref target="header-syntax"/>.</t>
</list></t>

</section><!-- header-field-processing -->

<section anchor="storage-model" title="Noting a Pinned Host - Storage
Model">

<t>If the substring matching the host production from the Request-URI (of
the message to which the host responded) syntactically matches the
IP-literal or IPv4address productions from Section 3.2.2 of <xref
target="RFC3986"/>, then the UA MUST NOT note this host as a Known Pinned
Host.</t>

<t>Otherwise, if the substring does not congruently match a Known Pinned
Host's domain name, per the matching procedure specified in Section 8.2 of
<xref target="RFC6797"/>, then the UA MUST note this host as a Known Pinned
Host, caching the Pinned Host's domain name and noting along with it the
expiry time of this information, as effectively stipulated per the given
max-age value, as well as whether or not the includeSubDomains or strict
directives are asserted, the value of the report-uri directive (if present),
and any other metadata from optional or future PKP header directives.</t>

<t>The UA MUST NOT modify the expiry time nor the includeSubDomains
directive of any superdomain matched Known Pinned Host.</t>

<t>A Known Pinned Host is "expired" if its cache entry has an expiry date in
the past. The UA MUST evict all expired Known Pinned Hosts from its cache,
if at any time, an expired Known Pinned Host exists in the cache.</t>

</section><!-- storage-model -->

<section anchor="http-equiv" title="HTTP-Equiv &lt;Meta&gt; Element
Attribute">

<t>UAs MUST NOT heed http-equiv="Public-Key-Pins" attribute settings on
&lt;meta&gt; elements <xref target="W3C.REC-html401-19991224"/> in
received content.</t>

</section><!-- http-equiv -->

<section anchor="ua-processing-examples" title="UA Processing Examples">

<t>TODO.</t>

</section><!-- ua-processing-examples -->

</section><!-- ua-processing-model -->

<section anchor="pin-semantics" title="Semantics of Pins">

<t>An SPKI Fingerprint is defined as the output of a known cryptographic
hash algorithm whose input is the DER-encoded ASN.1 representation of the
SubjectPublicKeyInfo (SPKI) field of an X.509 certificate. A Pin is defined
as the combination of the known algorithm identifier and the SPKI
Fingerprint computed using that algorithm.</t>

<t>The SPKI Fingerprint is encoded in base 64 for use in an HTTP header.
(See <xref target="RFC4648"/>.)</t>

<t>In this version of the specification, the known cryptographic hash
algorithms are SHA-1, identified as "sha1", and SHA-256, identified as
"sha256". (Future versions of this specification may add new algorithms and
deprecate old ones.) UAs MUST ignore Pins for which they do not recognize
the algorithm identifier. UAs MUST continue to process the rest of a PKP
response header field and note Pins for algorithms they do recognize; UAs
MUST recognize "sha1" and "sha256".</t>

<t><xref target="spki-definition"/> reproduces the definition of
the SubjectPublicKeyInfo structure in <xref target="RFC5280"/>.</t>

<figure anchor="spki-definition" title="SPKI Definition">
<artwork>
SubjectPublicKeyInfo  ::=  SEQUENCE  {
    algorithm            AlgorithmIdentifier,
    subjectPublicKey     BIT STRING  }

AlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm            OBJECT IDENTIFIER,
    parameters           ANY DEFINED BY algorithm OPTIONAL  }
</artwork>
</figure>

<t>If the SubjectPublicKeyInfo of a certificate is incomplete when taken in
isolation, such as when holding a DSA key without domain parameters, a
public key pin cannot be formed.</t>

<t>We pin public keys, rather than entire certificates, to enable operators
to generate new certificates containing old public keys (see <xref
target="why-pin-key" />).</t>

<t>See <xref target="fingerprint-generation" /> for an example non-normative
program that generates SPKI Fingerprints from SubjectPublicKeyInfo fields in
certificates.</t>

</section><!-- pin-semantics -->

<section anchor="noting-pins" title="Noting Pins">

<t>Upon receipt of the Public-Key-Pins response header field, the UA notes
the host as a Pinned Host, storing the Pins and their associated directives
in non-volatile storage (for example, along with the HSTS metadata). The
Pins and their associated directives collectively known as Pinning
Metadata.</t>

<t>The UA MUST observe these conditions when noting a Host:</t>

<t><list style="symbols">
<t>The UA MUST note the Pins if and only if it received the Public-Key-Pins
response header field over an error-free TLS connection. If the host is a
Pinned Host, this includes the validation added in <xref
target="validating-pinned-connections" />.</t>

<t>The UA MUST note the Pins if and only if the TLS connection was
authenticated with a certificate chain containing at least one of the SPKI
structures indicated by at least one of the given SPKI Fingerprints. (See
<xref target="validating-pinned-connections"/>.)</t>

<t>The UA MUST note the Pins if and only if the given set of Pins contains
at least one Pin that does NOT refer to an SPKI in the certificate chain.
(That is, the host must set a Backup Pin; see <xref
target="backup-pins"/>.)</t>
</list></t>

<t>If the Public-Key-Pins response header field does not meet all three of
these criteria, the UA MUST NOT note the host as a Pinned Host. A
Public-Key-Pins response header field that meets all these critera is known
as a Valid Pinning Header.</t>

<t>The UA MUST ignore Public-Key-Pins response header fields received on
connections that do not meet the first criterion.</t>

<t>TODO: Consider whether or not this requirement makes sense: If the UA
receives a Public-Key-Pins header from a Pinned Host that meets the first
criterion, but not the following two, the UA MUST discard any previously set
Pinning Metadata for that host in its non-volatile store. Whether or not the
Known Pinned Host is in strict mode, should the UA note new pins when Pin
Validation is disabled per local policy?</t>

<t>Whenever a UA receives a Valid Pinning Header, it MUST set its Pinning
Metadata to the exact Pins, max-age, and (if any) report-uri and strict mode
given in the most recently received Valid Pinning Header.</t>

<t>For forward compatibility, the UA MUST ignore any unrecognized
Public-Key-Pins header directives, while still processing those directives
it does recognize. <xref target="header-syntax" /> specifies the directives
max-age, pins, includeSubDomains, report-uri, and strict, but future
specifications and implementations might use additional directives.</t>

</section><!-- noting-pins -->

<section anchor="validating-pinned-connections" title="Validating Pinned
Connections">

<t>When a UA connects to a Pinned Host, if the TLS connection has errors,
the UA MUST terminate the connection without allowing the user to proceed
anyway. (This behavior is the same as that required by <xref
target="RFC6797"/>.)</t>

<t>If the connection has no errors, then the UA will determine whether to
apply a new, additional correctness check: Pin Validation. A UA SHOULD
perform Pin Validation whenever connecting to a Known Pinned Host, but MAY
allow Pin Validation to be disabled for Hosts according to local policy. For
example, a UA may disable Pin Validation for Pinned Hosts whose validated
certificate chain terminates at a user-defined trust anchor, rather than a
trust anchor built-in to the UA. However, if the Pinned Host Metadata
indicates that the Pinned Host is operating in "strict mode" (see
<xref target="strict"/>), then the UA MUST perform Pin Validation.</t>

<t>To perform Pin Validation, the UA will compute the SPKI Fingerprints for
each certificate in the Pinned Host's validated certificate chain, using
each supported hash algorithm for each certificate. (For the purposes of Pin
Validation, the UA MUST ignore certificates whose SPKI cannot be taken in
isolation and superfluous certificates in the chain that do not form part of
the validating chain.) The UA will then check that the set of these SPKI
Fingerprints intersects the set of SPKI Fingerprints in that Pinned Host's
Pinning Metadata. If there is set intersection, the UA continues with the
connection as normal. Otherwise, the UA MUST treat this Pin Failure as a
non-recoverable error. Any procedure that matches the results of this Pin
Validation procedure is considered equivalent.</t>

<t>Note that, although the UA has previously received Pins at the HTTP
layer, it can and MUST perform Pin Validation at the TLS layer, before
beginning an HTTP conversation over the TLS channel. The TLS layer thus
evaluates TLS connections with pinning information the UA received
previously, regardless of mechanism: statically preloaded, via HTTP header,
or some other means (possibly in the TLS layer itself).</t>

</section><!-- validating-pinned-connections -->

<section anchor="interactions-built-in" title="Interactions With
Preloaded Pin Lists">

<t>UAs MAY choose to implement built-in public key pins, alongside any
built-in HSTS opt-in list. UAs MUST allow users to override a built-in pin
list, including turning it off.</t>

<t>UAs MUST use the newest information — built-in or set via Valid Pinning
Header — when performing Pin Validation for the host. If the result of
noting a Valid Pinning Header is to disable pinning for the host (such as
because the host set a max-age directive with a value of 0), UAs MUST allow
this new information to override any built-in pins. That is, a host must be
able to un-pin itself even from built-in pins.</t>

</section><!-- interactions-built-in -->

<section anchor="pinning-self-signed" title="Pinning Self-Signed End
Entities">

<t>If UAs accept hosts that authenticate themselves with self-signed end
entity certificates, they MAY also allow hosts to pin the public keys in
such certificates. The usability and security implications of this practice
are outside the scope of this specification.</t>

</section><!-- pinning-self-signed -->

</section><!-- server-client-behavior -->

<section anchor="reporting-pin-validation-failure" title="Reporting Pin
Validation Failure">

<t>When a Known Pinned Host has set the report-uri directive, the UA SHOULD
report Pin Validation failures to the indicated URI. The UA does this by
POSTing a JSON message to the URI; the JSON message takes this form:</t>

<figure anchor="json-report-format" title="JSON Report Format">
<artwork>
{
  "date-time": date-time,
  "hostname": hostname,
  "port": port,
  "certificate-chain": [
    pem1, ... pemN
  ],
  "known-pins": [
    known-pin1, ... known-pinN
  ]
}
</artwork>
</figure>

<t>Whitespace outside of quoted strings is not significant. The key/value
pairs may appear in any order, but each SHOULD appear only once.</t>

<t>The date-time indicates the time the UA observed the Pin Validation
failure. It is provided as a string formatted according to Section 5.6,
"Internet Date/Time Format", of <xref target="RFC3339"/>.</t>

<t>The hostname is the hostname to which the UA made the original request
that failed Pin Validation. It is provided as a string.</t>

<t>The port is the port to which the UA made the original request that
failed Pin Validation. It is provided either as a string or as an
integer.</t>

<t>The certificate-chain is the certificate chain, as constructed by the UA
during certificate chain verification. (This may differ from the certificate
chain as served by the Known Pinned Host, of course.) It is provided as an
array of strings; each string pem1, ... pemN is the PEM representation of
each X.509 certificate as described in <xref target="I-D.josefsson-pkix-textual"/>.</t>

<t>The known-pins are the Pins that the UA has noted for the Known Pinned
Host. They are provided as an array of strings with the syntax:</t>

<figure anchor="known-pin-syntax" title="Known Pin Syntax">
<artwork>
known-pin = token "=" quoted-string
</artwork>
</figure>

<t>As in <xref target="pin-semantics"/>, the token refers to the algorithm
name, and the quoted-string refers to the base 64 encoding of the SPKI
Fingerprint.</t>

</section><!-- reporting-pin-validation-failure -->

<section anchor="security-considerations" title="Security Considerations">

<t>Pinning public keys helps hosts strongly assert their cryptographic
identity even in the face of issuer error, malfeasance or compromise. But
there is some risk that a host operator could lose or lose control of their
host's private key (such as by operator error or host compromise). If the
operator had pinned only the key of the host's end entity certificate, the
operator would not be able to serve their web site or application in a way
that UAs would trust for the duration of their pin's max-age. (Recall that
UAs MUST close the connection to a host upon Pin Failure.)</t>

<t>Therefore, there is a necessary trade-off between two competing goods:
pin specificity and maximal reduction of the scope of issuers on the one
hand; and flexibility and resilience of the host's cryptographic identity on
the other hand. One way to resolve this trade-off is to compromise by
pinning to the key(s) of the issuer(s) of the host's end entity
certificate(s). Often, a valid certificate chain will have at least two
certificates above the end entity certificate: the intermediate issuer, and
the trust anchor. Operators can pin any one or more of the public keys in
this chain, and indeed could pin to issuers not in the chain (as, for
example, a Backup Pin). Pinning to an intermediate issuer, or even to a
trust anchor or root, still significantly reduces the number of issuers who
can issue end entity certificates for the Known Pinned Host, while still
giving that host flexibility to change keys without a disruption of
service.</t>

<section anchor="backup-pins" title="Backup Pins">

<t>The primary way to cope with the risk of inadvertant Pin Failure is to
keep a Backup Pin. A Backup Pin is a fingerprint for the public key of a
secondary, not-yet-deployed key pair. The operator keeps the backup key pair
offline, and sets a pin for it in the Public-Key-Pins header. Then, in case
the operator loses control of their primary private key, they can deploy the
backup key pair. UAs, who have had the backup key pair pinned (when it was
set in previous Valid Pinning Headers), can connect to the host without
error.</t>

<t>Because having a backup key pair is so important to recovery, UAs MUST
require that hosts set a Backup Pin. (See <xref target="noting-pins"/>.)</t>

</section><!-- backup-pins -->

</section><!-- security-considerations -->

<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no actions for IANA.</t>

</section><!-- iana-considerations -->

<section anchor="usability" title="Usability Considerations">

<t>When pinning works to detect impostor Pinned Hosts, users will experience
denial of service. UAs MUST explain the reason why, i.e. that it was
impossible to verify the confirmed cryptographic identity of the host.</t>

<t>UAs MUST have a way for users to clear current pins for Pinned Hosts.
UAs SHOULD have a way for users to query the current state of Pinned
Hosts.</t>

</section><!-- usability -->

<section anchor="acknowledgements" title="Acknowledgements">

<t>Thanks to Tobias Gondrom, Jeff Hodges, Adam Langley, Nicolas Lidzborski,
SM, James Manger, and Yoav Nir for suggestions and edits that clarified the
text.  Thanks to Trevor Perrin for suggesting a mechanism to affirmatively
break pins (<xref target="pin-break-codes"/>). Adam Langley provided the
SPKI fingerprint generation code.</t>

</section><!-- acknowledgements -->

<section anchor="what-changed" title="What's Changed">

<t>Removed the section "Pin Validity Times", which was intended to be in
harmony with <xref target="I-D.perrin-tls-tack"/>. Now using max-age purely as
specified in <xref target="RFC6797"/>.</t>

<t>Added new directives: includeSubDomains, report-uri and strict.</t>

<t>Added, but have not yet described, a new variant of the PKP Header:
Public-Key-Pins-Report-Only.</t>

<t>Removed the section on pin break codes and verifiers, in favor the of
most-recently-received policy (<xref target="noting-pins"/>).</t>

<t>Now using a new header field, Public-Key-Pins, separate from HSTS. This
allows hosts to use pinning separately from Strict Transport Security.</t>

<t>Explicitly requiring that UAs perform Pin Validation before the HTTP
conversation begins.</t>

<t>Backup Pins are now required.</t>

<t>Separated normative from non-normative material. Removed tangential and
out-of-scope non-normative discussion.</t>

</section><!-- what-changed -->

</middle>

<back>

<references title="Normative References">

<?rfc include="reference.RFC.6797.xml"?>
<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.2616.xml"?>
<?rfc include="reference.RFC.3339.xml"?>
<?rfc include="reference.RFC.3986.xml"?>
<?rfc include="reference.RFC.4648.xml"?>
<?rfc include="reference.RFC.5226.xml"?>
<?rfc include="reference.RFC.5246.xml"?>
<?rfc include="reference.RFC.5280.xml"?>
<?rfc include="reference.I-D.josefsson-pkix-textual.xml"?>
<?rfc include="reference.W3C.REC-html401-19991224.xml"?>

</references>

<references title="Informative References">

<?rfc include="reference.I-D.perrin-tls-tack.xml"?>

<reference anchor="why-pin-key"
target="http://www.imperialviolet.org/2011/05/04/pinning.html">
<front>
<title>Public Key Pinning</title>
<author initials="A." surname="Langley" fullname="Adam Langley" />
<date month="May" year="2011" />
</front>
</reference>

<reference anchor="pin-break-codes" target="http://trevp.net/SAKP/">
<front>
<title>Self-Asserted Key Pinning</title>
<author initials="T." surname="Perrin" fullname="Trevor Perrin" />
<date month="September" year="2011" />
</front>
</reference>

</references>

<section anchor="fingerprint-generation" title="Fingerprint Generation">

<t>This Go program generates SPKI Fingerprints, suitable for use in pinning,
from PEM-encoded certificates. It is non-normative.</t>

<figure anchor="fingerprint-generation-figure" title="Example SPKI
Fingerprint Generation Code">
<artwork>
package main

import (
       "io/ioutil"
       "os"
       "crypto/sha1"
       "crypto/x509"
       "encoding/base64"
       "encoding/pem"
       "fmt"
)

func main() {
       if len(os.Args) &lt; 2 {
               fmt.Printf("Usage: %s PEM-filename\n", os.Args[0])
               os.Exit(1)
       }
       pemBytes, err := ioutil.ReadFile(os.Args[1])
       if err != nil {
               panic(err.String())
       }
       block, _ := pem.Decode(pemBytes)
       if block == nil {
               panic("No PEM structure found")
       }
       derBytes := block.Bytes
       certs, err := x509.ParseCertificates(derBytes)
       if err != nil {
               panic(err.String())
       }
       cert := certs[0]
       h := sha1.New()
       h.Write(cert.RawSubjectPublicKeyInfo)
       digest := h.Sum()

       fmt.Printf("Hex: %x\nBase64: %s\n", digest,
               base64.StdEncoding.EncodeToString(digest))
}
</artwork>
</figure>

</section><!-- fingerprint-generation -->

<section anchor="deployment-guidance" title="Deployment Guidance">

<t>This section is non-normative guidance which may smooth the adoption of
public key pinning.</t>

<t><list style="symbols">

<t>Operators SHOULD get the backup public key signed by a different (root
and/or intermediary) CA than their primary certificate, and store the backup
key pair safely offline. The semantics of an SPKI Fingerprint do not require
the issuance of a certificate to construct a valid Pin. However, in many
deployment scenarios, in order to make a Backup Pin operational the server
operator will need to have a certificate to deploy TLS on the host. Failure
to obtain a certificate through prior arrangement will leave clients that
recognize the site as a Known Pinned Host unable to successfully perform Pin
Validation until such a time as the operator can obtain a new certificate
from their desired certificate issuer.</t>

<t>It is most economical to have the backup certificate signed by a
completely different signature chain than the live certificate, to maximize
recoverability in the event of either root or intermediary signer
compromise.</t>

<t>Operators SHOULD periodically exercise their Backup Pin plan — an
untested backup is no backup at all.</t>

<t>Operators SHOULD start small. Operators SHOULD first deploy public key
pinning by using the report-only mode together with a report-uri directive
that points to a reliable report collection endpoint. When moving out of
report-only mode, operators should start by setting a max-age of minutes or
a few hours, and gradually increase max-age as they gain confidence in their
operational capability.</t>

</list></t>

</section><!-- deployment-guidance -->

</back>
</rfc>

