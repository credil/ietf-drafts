<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY pandocMiddle PUBLIC "" "middle.xml">
<!ENTITY abstract PUBLIC "" "abstract.xml">
<!ENTITY appendix PUBLIC "" "appendix.xml">
<!-- normative --><!ENTITY RFC1034 PUBLIC "" "bib/reference.RFC.1034">
<!ENTITY RFC2065 PUBLIC "" "bib/reference.RFC.2065">
<!ENTITY RFC2308 PUBLIC "" "bib/reference.RFC.2308">
<!ENTITY RFC4033 PUBLIC "" "bib/reference.RFC.4033">
<!ENTITY RFC4034 PUBLIC "" "bib/reference.RFC.4034">
<!ENTITY RFC4035 PUBLIC "" "bib/reference.RFC.4035">
<!ENTITY RFC4592 PUBLIC "" "bib/reference.RFC.4592">
<!ENTITY RFC4648 PUBLIC "" "bib/reference.RFC.4648">
<!ENTITY RFC5155 PUBLIC "" "bib/reference.RFC.5155">
<!ENTITY RFC6672 PUBLIC "" "bib/reference.RFC.6672">
<!-- informative --><!ENTITY RFC2535 PUBLIC "" "bib/reference.RFC.2535">
<!ENTITY RFC3655 PUBLIC "" "bib/reference.RFC.3655">
<!ENTITY RFC3755 PUBLIC "" "bib/reference.RFC.3755">
<!ENTITY RFC4956 PUBLIC "" "bib/reference.RFC.4956">
<!ENTITY draftdnsnr PUBLIC "" "bib/reference.I-D.arends-dnsnr.xml">
<!ENTITY draftnsec2v2 PUBLIC "" "bib/reference.I-D.laurie-dnsext-nsec2v2.xml">
<!ENTITY draftexist PUBLIC "" "bib/reference.I-D.ietf-dnsext-not-exsiting-rr.xml">
<!ENTITY RFC5155Errata PUBLIC "" "bib/reference.RFC.5155.errata.xml">
]>
<rfc ipr="trust200902" submissionType="independent" category="info" docName="draft-gieben-auth-denial-of-existence-dns-02" obsoletes="" updates="" xml:lang="en">
  <?rfc toc="yes"?>
  <!--generate a table of contents -->
  <?rfc tocompact="no"?>
  <?rfc tocdepth="6"?>
  <?rfc symrefs="yes"?>
  <!--use anchors instead of numbers for references -->
  <?rfc sortrefs="yes" ?>
  <!--alphabetize the references -->
  <?rfc rfcedstyle="yes"?>
  <?rfc strict="yes"?>
  <?rfc autobreaks="yes"?>
  <?rfc compact="yes" ?>
  <!--conserve vertical whitespace -->
  <?rfc subcompact="no" ?>
  <!--but keep a blank line between list items -->
  <front>
    <title abbrev="Authenticated Denial in DNS">Authenticated Denial of Existence in the DNS</title>
    <author initials="R." surname="Gieben" fullname="R. (Miek) Gieben">
      <organization>SIDN Labs</organization>
      <address>
        <postal>
          <street>Meander 501</street>
          <street/>
          <city>Arnhem</city>
          <region/>
          <code>6825 MD</code>
          <country>NL</country>
        </postal>
        <phone/>
        <email>miek.gieben@sidn.nl</email>
        <uri>https://sidn.nl/</uri>
      </address>
    </author>
    <author initials="W." surname="Mekking" fullname="W. (Matthijs) Mekking">
      <organization>NLnet Labs</organization>
      <address>
        <postal>
          <street>Science Park 400</street>
          <street/>
          <city>Amsterdam</city>
          <region/>
          <code>1098 XH</code>
          <country>NL</country>
        </postal>
        <phone/>
        <email>matthijs@nlnetlabs.nl</email>
        <uri>http://www.nlnetlabs.nl/</uri>
      </address>
    </author>
    <date day="07" month="January" year="2013"/>
    <area>Internet</area>
    <keyword>DNSSEC</keyword>
    <keyword>Denial of Existance</keyword>
    <keyword>NSEC</keyword>
    <keyword>NSEC3</keyword>
    <abstract><!--This document was prepared using Pandoc2rfc --><!--https://github.com/miekg/pandoc2rfc --><t>Authenticated denial of existence allows a resolver to validate that a certain domain name does not exist. It is also used to signal that a domain name exists, but does not have the specific RR type you were asking for. When returning a negative DNSSEC response, a name server usually includes up to two NSEC records. With NSEC3 this amount is three. This document provides additional background commentary and some context for the NSEC and NSEC3 mechanisms used by DNSSEC to provide authenticated denial of existence responses </t> </abstract>
  </front>
  <middle><!--This document was prepared using Pandoc2rfc --><!--https://github.com/miekg/pandoc2rfc --><section title="Introduction" anchor="introduction" toc="default"><t>DNSSEC can be somewhat of a complicated matter, and there are certain areas of the specification that are more difficult to comprehend than others. One such area is "authenticated denial of existence".  </t><t>Denial of existence is a mechanism that informs a resolver that a certain domain name does not exist. It is also used to signal that a domain name exists, but does not have the specific RR type you were asking for.  </t><t>The first is referred to as an NXDOMAIN (non-existent domain) (<xref target="RFC2308" pageno="false" format="default"/> Section 2.1) and the latter a NODATA (<xref target="RFC2308" pageno="false" format="default"/> Section 2.2) response. Both are also known as negative responses.  </t><t>Authenticated denial of existence uses cryptography to sign the negative response. However, if there is no answer, what is it that needs to be signed? To further complicate this matter, there is the desire to pre-generate negative responses that are applicable for all queries for non-existent names in the signed zone. See <xref target="secure-denial-of-existence" pageno="false" format="default"/> for the details.  </t><t>In this document, we will explain how authenticated denial of existence works. We begin by explaining the current technique in the DNS and work our way up to DNSSEC. We explain the first steps taken in DNSSEC and describe how NSEC and NSEC3 work. The NXT, NO, NSEC2 and DNSNR records also briefly make their appearance, as they have paved the way for NSEC and NSEC3.  </t><t>To complete the picture, we also need to explain DNS wildcards as these complicate matters, especially combined with CNAME records.  </t><t>Note: In this document, domain names in zone file examples will have a trailing dot, in the running text they will not. This text is written for people who have a fair understanding of DNSSEC. The following RFCs are not required reading, but they help in understanding the problem space.  </t><t><list style="symbols"><t>RFC 5155 <xref target="RFC5155" pageno="false" format="default"/> - Hashed Authenticated Denial of Existence; </t><t>RFC 4592 <xref target="RFC4592" pageno="false" format="default"/> - The Role of Wildcards in the DNS.  </t></list></t><t>And these provide some general DNSSEC information.  </t><t><list style="symbols"><t>RFC 4033, RFC 4034, RFC 4035 <xref target="RFC4033" pageno="false" format="default"/>, <xref target="RFC4034" pageno="false" format="default"/>, <xref target="RFC4035" pageno="false" format="default"/> - DNSSEC Specification; </t><t>RFC 4956 <xref target="RFC4956" pageno="false" format="default"/> - DNS Security (DNSSEC) Opt-In. This RFC has experimental status, but is a good read.  </t></list></t><t>These three drafts give some background information on the NSEC3 development.  </t><t><list style="symbols"><t>The NO record <xref target="I-D.ietf-dnsext-not-existing-rr" pageno="false" format="default"/>; </t><t>The NSEC2 record <xref target="I-D.laurie-dnsext-nsec2v2" pageno="false" format="default"/>; </t><t>The DNSNR record <xref target="I-D.arends-dnsnr" pageno="false" format="default"/>.  </t></list></t></section><section title="Denial of Existence" anchor="denial-of-existence" toc="default"><t>We start with the basics and take a look at NXDOMAIN handling in the DNS. To make it more visible we are going to use a small DNS zone, with 3 names (<spanx style="verb" xml:space="preserve">example.org</spanx>, <spanx style="verb" xml:space="preserve">a.example.org</spanx> and <spanx style="verb" xml:space="preserve">d.example.org</spanx>) and 3 types (SOA, A and TXT). For brevity, the class is not shown (defaults to IN), the NS records are left out and the SOA record is shortened, resulting in the following zone file: </t><figure anchor="fig:the-unsign" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
a.example.org.      A 192.0.2.1
                    TXT "a record"
d.example.org.      A 192.0.2.1
                    TXT "d record"
</artwork><postamble>The unsigned "example.org" zone.  </postamble></figure><section title="NXDOMAIN Responses" anchor="nxdomain-responses" toc="default"><t>If a resolver asks for the TXT type belonging to <spanx style="verb" xml:space="preserve">a.example.org</spanx> to the name server serving this zone, it sends the following question: <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx> </t><t>The name server looks in its zone data and generates an answer. In this case a positive one: "Yes it exists and this is the data", resulting in this reply: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 28203

;; ANSWER SECTION:
a.example.org.      TXT "a record"

;; AUTHORITY SECTION:
example.org.        NS a.example.org.
</artwork></figure><t>The <spanx style="verb" xml:space="preserve">status: NOERROR</spanx> signals that everything is OK, <spanx style="verb" xml:space="preserve">id</spanx> is an integer used to match questions and answers. In the ANSWER section, we find our answer. The AUTHORITY section holds the names of the name servers that have information concerning the <spanx style="verb" xml:space="preserve">example.org</spanx> zone.  Note that including this information is optional.  </t><t>If a resolver asks for <spanx style="verb" xml:space="preserve">b.example.org TXT</spanx> it gets an answer that this name does not exist: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NXDOMAIN, id: 7042

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
</artwork></figure><t>In this case, we do not get an ANSWER section and the status is set to NXDOMAIN. From this the resolver concludes that <spanx style="verb" xml:space="preserve">b.example.org</spanx> does not exist. The AUTHORITY section holds the SOA record of <spanx style="verb" xml:space="preserve">example.org</spanx> that the resolver can use to cache the negative response.  </t></section><section title="NODATA Responses" anchor="nodata-responses" toc="default"><t>It is important to realize that NXDOMAIN is not the only type of does-not-exist. A name may exist, but the type you are asking for may not. This occurrence of non-existence is called a NODATA response. Let us ask our name server for <spanx style="verb" xml:space="preserve">a.example.org AAAA</spanx>, and look at the answer: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 7944

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
</artwork></figure><t>The status NOERROR shows that the <spanx style="verb" xml:space="preserve">a.example.org</spanx> name exists, but the reply does not contain an ANSWER section.  This differentiates a NODATA response from an NXDOMAIN response, the rest of the packet is very similar. The resolver has to put these pieces of information together and conclude that <spanx style="verb" xml:space="preserve">a.example.org</spanx> exists, but it does not have an <spanx style="verb" xml:space="preserve">AAAA</spanx> record.  </t></section></section><section title="Secure Denial of Existence" anchor="secure-denial-of-existence" toc="default"><t>The above has to be translated to the security aware world of DNSSEC. But there are a few requirements DNSSEC brings to the table: </t><t><list style="numbers"><t>There is no online signing defined in DNSSEC. Although a name server is free to compute the answer and signature(s) on-the-fly, the protocol is written with a "first sign, then load" attitude in mind. It is rather asymmetrical, but a lot of the design in DNSSEC stems from fact that you need to accommodate authenticated denial of existence. If the DNS did not have NXDOMAIN, DNSSEC would be a lot simpler, but a lot less useful! </t><t>The DNS packet header is not signed. This means that a <spanx style="verb" xml:space="preserve">status: NXDOMAIN</spanx> can not be trusted. In fact the entire header may be forged, including the AD bit (AD stands for Authentic Data, see RFC 3655 <xref target="RFC3655" pageno="false" format="default"/>), which may give some food for thought; </t><t>DNS wildcards and CNAME records complicate matters significantly. More about this in later sections (<xref target="wildcards-in-the-dns" pageno="false" format="default"/> and <xref target="cname-records" pageno="false" format="default"/>).  </t></list></t><t>The first requirement implies that all denial of existence answers need to be pre-computed, but it is impossible to pre-compute (all conceivable) non-existence answers. A generic denial record which can be used in all denial of existence proofs is not an option: such a record is susceptible to replay attacks. When you are querying a name server for a record that actually exists, a man-in-the-middle may replay that generic denial record and it would be impossible to tell whether the response was genuine or spoofed.  </t><t>This has been solved by introducing a record that defines an interval between two existing names. Or to put it another way: it defines the holes (non-existing names) in the zone. This record can be signed beforehand and given to the resolver.  </t><t><list style="hanging" hangIndent="3"><t>Given all these troubles, why didn't the designers of DNSSEC go for the (easy) route and allowed for online signing? Well, at that time (pre 2000), online signing was not feasible with the then current hardware. Keep in mind that the larger servers get between 2000 and 6000 queries per second (qps), with peaks up to 20,000 qps or more. Scaling signature generation to these kind of levels is always a challenge. Another issue was (and is) key management, for online signing to work you need access to the private key(s).  This is considered a security risk.  </t></list></t><t>The road to the current solution (NSEC/NSEC3) was long. It started with the NXT (next) record. The NO (not existing) record was introduced, but never made it to RFC. Later on, NXT was superseded by the NSEC (next secure) record. From there it went through NSEC2/DNSNR to finally reach NSEC3 (next secure, version 3) in RFC 5155.  </t><section title="NXT" anchor="nxt" toc="default"><t>The first attempt to specify authenticated denial of existence was NXT (RFC 2535 <xref target="RFC2535" pageno="false" format="default"/>). Section 5.1 of that RFC introduces the record: </t><t><list style="hanging" hangIndent="3"><t>"The NXT resource record is used to securely indicate that RRs with an owner name in a certain name interval do not exist in a zone and to indicate what RR types are present for an existing name." </t></list></t><t>By specifying what you do have, you implicitly tell what you don't have. NXT is superseded by NSEC. In the next section we explain how NSEC (and thus NXT) works.  </t></section><section title="NSEC" anchor="nsec" toc="default"><t>In RFC 3755 <xref target="RFC3755" pageno="false" format="default"/> all the DNSSEC types were given new names, SIG was renamed RRSIG, KEY became DNSKEY and NXT was renamed to NSEC and a minor issue was fixed in the process, namely the type bitmap was redefined to allow more than 127 types to be listed (<xref target="RFC2535" pageno="false" format="default"/>, Section 5.2).  </t><t>Just as NXT, NSEC is used to describe an interval between names: it indirectly tells a resolver which names do not exist in a zone.  </t><t>For this to work, we need our <spanx style="verb" xml:space="preserve">example.org</spanx> zone to be sorted in canonical order (<xref target="RFC4034" pageno="false" format="default"/>, Section 6.1), and then create the NSECs. We add three NSEC records, one for each name, and each one "covers" a certain interval. The last NSEC record points back to the first as required by the RFC, and depicted in <xref target="fig:the-nsec-r" pageno="false" format="default"/>.  </t><t><list style="numbers"><t>The first NSEC covers the interval between <spanx style="verb" xml:space="preserve">example.org</spanx> and <spanx style="verb" xml:space="preserve">a.example.org</spanx>; </t><t>The second NSEC covers <spanx style="verb" xml:space="preserve">a.example.org</spanx> to <spanx style="verb" xml:space="preserve">d.example.org</spanx>; </t><t>The third NSEC points back to <spanx style="verb" xml:space="preserve">example.org</spanx>, and covers <spanx style="verb" xml:space="preserve">d.example.org</spanx> to <spanx style="verb" xml:space="preserve">example.org</spanx> (i.e. the end of the zone).  </t></list></t><t>As we have defined the intervals and put those in resource records, we now have something that can be signed.  </t><figure anchor="fig:the-nsec-r" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
                    example.org
                       **
                   +-- ** &lt;--+
              (1) /  .    .   \ (3)
                 /  .      .   \
                |  .        .  |
                v .          . |
                **    (2)     **
  a.example.org ** ---------&gt; ** d.example.org
  </artwork><postamble>The NSEC records of "example.org". The arrows represent NSEC records, starting from the apex.  </postamble></figure><t>This signed zone is loaded into the name server. It looks like this: </t><figure anchor="fig:the-signed" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
                    DNSKEY ( ... )
                    NSEC a.example.org. SOA NSEC DNSKEY RRSIG
                    RRSIG(SOA) ( ... )
                    RRSIG(DNSKEY) ( ... )
                    RRSIG(NSEC) ( ... )
a.example.org.      A 192.0.2.1
                    TXT "a record"
                    NSEC d.example.org. A TXT NSEC RRSIG
                    RRSIG(A) ( ... )
                    RRSIG(TXT) ( ... )
                    RRSIG(NSEC) ( ... )
d.example.org.      A 192.0.2.1
                    TXT "d record"
                    NSEC example.org. A TXT NSEC RRSIG
                    RRSIG(A) ( ... )
                    RRSIG(TXT) ( ... )
                    RRSIG(NSEC) ( ... )
</artwork><postamble>The signed and sorted "example.org" zone with the added NSEC records (and signatures).  For brevity, the class is not shown (defaults to IN), the NS records are left out and the SOA, DNSKEY and RRSIG records are shortened.  </postamble></figure><t>If a DNSSEC aware resolver asks for <spanx style="verb" xml:space="preserve">b.example.org</spanx>, it gets back a <spanx style="verb" xml:space="preserve">status: NXDOMAIN</spanx> packet, which by itself is meaningless (remember that the DNS packet header is not signed and thus can be forged). To be able to securely detect that <spanx style="verb" xml:space="preserve">b</spanx> does not exist, there must also be a signed NSEC record which covers the name space where <spanx style="verb" xml:space="preserve">b</spanx> lives. The record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
a.example.org.      NSEC d.example.org. A TXT NSEC RRSIG
</artwork></figure><t>does precisely that: <spanx style="verb" xml:space="preserve">b</spanx> should come after <spanx style="verb" xml:space="preserve">a</spanx>, but the next owner name is <spanx style="verb" xml:space="preserve">d.example.org</spanx>, so <spanx style="verb" xml:space="preserve">b</spanx> does not exist.  </t><t>Only by making that calculation, is a resolver able to conclude that the name <spanx style="verb" xml:space="preserve">b</spanx> does not exist. If the signature of the NSEC record is valid, <spanx style="verb" xml:space="preserve">b</spanx> is proven not to exist. We have authenticated denial of existence.  </t><t>Note that a man-in-the-middle may still replay this NXDOMAIN response when you're querying for, say, <spanx style="verb" xml:space="preserve">c.example.org</spanx>. But it would not do any harm since it is provably the proper response to the query. In the future, there may be data published for <spanx style="verb" xml:space="preserve">c.example.org</spanx>. Therefore, the RRSIGs RDATA include a validity period (not visible in the zone above), so that an attacker cannot replay this NXDOMAIN response for <spanx style="verb" xml:space="preserve">c.example.org</spanx> forever.  </t></section><section title="NODATA Responses" anchor="nodata-responses-1" toc="default"><t>NSEC records are also used in NODATA responses. In that case we need to look more closely at the type bitmap. The type bitmap in an NSEC record tells which types are defined for a name. If we look at the NSEC record of <spanx style="verb" xml:space="preserve">a.example.org</spanx>, we see the following types in the bitmap: A, TXT, NSEC and RRSIG. So for the name <spanx style="verb" xml:space="preserve">a</spanx> this indicates we must have an A, TXT, NSEC and RRSIG record in the zone.  </t><t>With the type bitmap of the NSEC record, a resolver can establish that a name is there, but the type is not. For example, if a resolver asks for <spanx style="verb" xml:space="preserve">a.example.org AAAA</spanx>, the reply that comes back is: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 44638

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
example.org.        RRSIG(SOA) ( ... )
a.example.org.      NSEC d.example.org. A TXT NSEC RRSIG
a.example.org.      RRSIG(NSEC) ( ... )
</artwork></figure><t>The resolver should check the AUTHORITY section and conclude that: </t><t><list style="format (%d)"><t><spanx style="verb" xml:space="preserve">a.example.org</spanx> exists (because of the NSEC with that owner name) and; </t><t>the type (AAAA) does not as it is not listed in the type bitmap.  </t></list></t><t>The techniques used by NSEC form the basics of authenticated denial of existence in DNSSEC.  </t></section><section title="Drawbacks of NSEC" anchor="drawbacks-of-nsec" toc="default"><t>There were two issues with NSEC (and NXT). The first is that it allows for zone walking. NSEC records point from one name to another, in our example: <spanx style="verb" xml:space="preserve">example.org</spanx>, points to <spanx style="verb" xml:space="preserve">a.example.org</spanx> which points to <spanx style="verb" xml:space="preserve">d.example.org</spanx> which points back to <spanx style="verb" xml:space="preserve">example.org</spanx>. So we can reconstruct the entire <spanx style="verb" xml:space="preserve">example.org</spanx> zone, thus defeating attempts to administratively block zone transfers (<xref target="RFC2065" pageno="false" format="default"/> Section 5.5).  </t><t>The second issue is that when a large, delegation-centric (<xref target="RFC5155" pageno="false" format="default"/>, Section 1.1), zone deploys DNSSEC, every name in the zone gets an NSEC plus RRSIG. So this leads to a huge increase in the zone size (when signed). This would in turn mean that operators of such zones who are deploying DNSSEC, face up front costs. This could hinder DNSSEC adoption.  </t><t>These two issues eventually lead to NSEC3 which: </t><t><list style="symbols"><t>Adds a way to garble the next owner name, thus thwarting zone-walking; </t><t>Makes it possible to skip names for the next owner name. This feature is called Opt-Out (See <xref target="opt-out" pageno="false" format="default"/>). It means not all names in your zone get an NSEC3 plus ditto signature, making it possible to "grow into" your DNSSEC deployment.  </t></list></t><t>But before we delve into NSEC3, let us first take a look at its predecessors: NO, NSEC2 and, DNSNR.  </t></section></section><section title="Experimental and Deprecated Mechanisms: NO, NSEC2 and DNSNR" anchor="experimental-and-deprecated-mechanisms-no-nsec2-and-dnsnr" toc="default"><t>Long before NSEC was defined, the NO record was introduced. It was the first record to use the idea of hashed owner names, to fix the issue of zone walking that was present with the NXT record. It also fixed the type bitmap issue of the NXT record, but not in a space efficient way. At that time (around 2000) zone walking was not considered important enough to warrant the new record. People were also worried that DNSSEC deployment would be hindered by developing an alternate means of denial of existence. Thus the effort was shelved and NXT remained.  </t><t>When the new DNSSEC specification <xref target="RFC4034" pageno="false" format="default"/> was written, people were still not convinced that zone walking was a problem that should be solved. So NSEC saw the light and inherited the two issues from NXT.  </t><t>Several years after, NSEC2 was introduced as a way to solve the two issues of NSEC. The NSEC2 draft contains the following paragraph: </t><t><list style="hanging" hangIndent="3"><t>"This document proposes an alternate scheme which hides owner names while permitting authenticated denial of existence of non-existent names. The scheme uses two new RR types: NSEC2 and EXIST." </t></list></t><t>When an authenticated denial of existence scheme starts to talk about EXIST records, it is worth paying extra attention. The EXIST record was defined as a record without RDATA that would be used to signal the presence of a domain name. From the draft: </t><t><list style="hanging" hangIndent="3"><t>"In order to prove the nonexistence of a record that might be covered by a wildcard, it is necessary to prove the existence of its closest encloser. This record does that. Its owner is the closest encloser. It has no RDATA. If there is another RR that proves the existence of the closest encloser, this SHOULD be used instead of an EXIST record." </t></list></t><t>The introduction of this record led to questions on what wildcards actually means (especially in the context of DNSSEC). It is probably not a coincidence that "The Role of Wildcards in the Domain Name System" (<xref target="RFC4592" pageno="false" format="default"/>) was standardized before NSEC3.  </t><t>NSEC2 solved the zone walking issue by hashing (with SHA1 and a salt) the "next owner name" in the record, thereby making it useless for zone walking. But it did not have Opt-Out.  </t><t>The DNSNR record was another attempt that used hashed names to foil zone walking and it also introduced the concept of opting out (called "Authoritative Only Flag") which limited the use of DNSNR in delegation-centric zones.  </t><t>All these proposals didn't make it, but did provide valuable insights. To summarize: </t><t><list style="symbols"><t>The NO record introduced hashing, but this idea lingered in the background for a long time; </t><t>The NSEC2 record made it clear that wildcards were not completely understood; </t><t>The DNSNR record used a new flag field in the RDATA to signal Opt-Out; </t></list></t></section><section title="NSEC3" anchor="nsec3" toc="default"><t>From the experience gained with NSEC2 and DNSNR, NSEC3 was forged.  It incorporates both Opt-Out and the hashing of names. NSEC3 solves any issues people might have with NSEC, but it introduces some additional complexity.  </t><t>NSEC3 did not supersede NSEC, they are both defined for DNSSEC. So DNSSEC is blessed with two different means to perform authenticated denial of existence: NSEC and NSEC3. In NSEC3 every name is hashed, including the owner name. This means that NSEC3 chain is sorted in hash order, instead of canonical order. Because the owner names are hashed, the next owner name for <spanx style="verb" xml:space="preserve">example.org</spanx> is unlikely to be <spanx style="verb" xml:space="preserve">a.example.org</spanx>. Because the next owner name is hashed, zone walking becomes more difficult.  </t><t>To make it even more difficult to retrieve the original names, the hashing can be repeated several times each time taking the previous hash as input. To prevent the reuse of pre-generated hash values between zones a (per zone) salt can also be added. In the NSEC3 for <spanx style="verb" xml:space="preserve">example.org</spanx> we have hashed the names thrice (<xref target="RFC5155" pageno="false" format="default"/>, Section 5) and use the salt <spanx style="verb" xml:space="preserve">DEAD</spanx>. Lets look at typical NSEC3 record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
   NSEC3 1 0 2 DEAD A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84
        SOA RRSIG DNSKEY NSEC3PARAM )
</artwork></figure><t>On the first line we see the hashed owner name: <spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h.example.org</spanx>, this is the hashed name of the fully qualified domain name (FQDN) <spanx style="verb" xml:space="preserve">example.org</spanx> encoded as Base32 (<xref target="RFC4648" pageno="false" format="default"/>). Note that even though we hashed <spanx style="verb" xml:space="preserve">example.org</spanx>, the zone's name is added to make it look like a domain name again. In our zone, the basic format is <spanx style="verb" xml:space="preserve">Base32(SHA1(FQDN)).example.org</spanx>. The next hashed owner name <spanx style="verb" xml:space="preserve">A6EDKB6V8VL5OL8JNQQLT74QMJ7HEB84</spanx> (line 2) is the hashed version of <spanx style="verb" xml:space="preserve">d.example.org</spanx>, represented as Base32. Note that <spanx style="verb" xml:space="preserve">.example.org</spanx> is not added to the next hashed owner name, as this name always falls in the current zone.  </t><t>The "1 0 2 DEAD" section of the NSEC3 states: </t><t><list style="symbols"><t>Hash Algorithm = 1 (SHA1, this is the default, no other hash algorithms are currently defined for use in NSEC3); </t><t>Opt-Out = 0 (disabled); </t><t>Hash Iterations = 2, this yields three iterations, as a zero value is already one iteration; </t><t>Salt = "DEAD".  </t></list></t><t>At the end we see the type bitmap, which is identical to NSEC's bitmap, that lists the types present at the original owner name.  Note that the type NSEC3 is absent from the list in the example above. This is due to the fact that the original owner name (<spanx style="verb" xml:space="preserve">example.org</spanx>) does not have the NSEC3 type. It only exists for the hashed name.  </t><t>Names like <spanx style="verb" xml:space="preserve">1.h.example.org</spanx> hash to one label in NSEC3, <spanx style="verb" xml:space="preserve">1.h.example.org</spanx> becomes: <spanx style="verb" xml:space="preserve">117gercprcjgg8j04ev1ndrk8d1jt14k.example.org</spanx> when used as an owner name. This is an important observation. By hashing the names you lose the depth of a zone - hashing introduces a flat space of names, as opposed to NSEC.  </t><t>The domain name used above (<spanx style="verb" xml:space="preserve">1.h.example.org</spanx>) creates an empty non-terminal. Empty non-terminals are domain names that have no RRs associated with them, and exist only because they have one or more subdomains that do (<xref target="RFC5155" pageno="false" format="default"/>, Section 1.3). The record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
    1.h.example.org.    TXT "1.h record"
</artwork></figure><t>creates two names: </t><t><list style="numbers"><t><spanx style="verb" xml:space="preserve">1.h.example.org</spanx> that has the type: TXT; </t><t><spanx style="verb" xml:space="preserve">h.example.org</spanx> which has no types. This is the empty non-terminal.  </t></list></t><t>An empty non-terminal will get an NSEC3 record, but not an NSEC record. In <xref target="the-closest-encloser-nsec3-record" pageno="false" format="default"/> is shown how the resolver uses these NSEC3 records to validate the denial of existence proofs.  </t><section title="Opt-Out" anchor="opt-out" toc="default"><t>Hashing mitigates the zone walking issue of NSEC. The other issue, the high costs of securing a delegation to an insecure zone, is tackled with Opt-Out. When using Opt-Out, names that are an insecure delegation (and empty non-terminals that are only derived from insecure delegations) don't require an NSEC3 record. For each insecure delegation, the zone size can be decreased (compared with a fully signed zone without using Opt-Out) with at least two records: one NSEC3 record and one corresponding RRSIG record. If the insecure delegation would introduce empty non-terminals, even more records can be omitted from the zone.  </t><t>Opt-Out NSEC3 records are not able to prove or deny the existence of the insecure delegations. In other words, those delegation do not benefit from the cryptographic security that DNSSEC provides.  </t><t>A recently discovered corner case (<xref target="RFC5155-errata3441" pageno="false" format="default"/>) shows that not only those delegations remain insecure, also the empty non-terminal space that is derived from those delegations are insecure. Because the names in this empty non-terminal space do exist according to the definition in <xref target="RFC4592" pageno="false" format="default"/>, the server should respond to queries for these names with a NODATA response.  However, the validator requires an NSEC3 record proving the NODATA response (<xref target="RFC5155" pageno="false" format="default"/>, Section 8.5): </t><t><list style="hanging" hangIndent="3"><t>"The validator MUST verify that an NSEC3 RR that matches QNAME is present and that both the QTYPE and the CNAME type are not set in its Type Bit Maps field." </t></list></t><t>A way to resolve this contradiction in the specification is to always provide empty non-terminals with an NSEC3 record, even if it is only derived from an insecure delegation.  </t></section><section title="Loading an NSEC3 Zone" anchor="loading-an-nsec3-zone" toc="default"><t>Whenever an authoritative server receives a query for a non-existing record, it has to hash the incoming query name to determine into which interval between two existing hashes it falls. To do that it needs to know the zone's specific NSEC3 parameters (hash iterations and salt).  </t><t>One way to learn them is to scan the zone during loading for NSEC3 records and glean the NSEC3 parameters from them. However, it would need to make sure that there is at least one complete set of NSEC3 records for the zone using the same parameters. Therefore, it would need to inspect all NSEC3 records.  </t><t>A more graceful solution was designed. The solution was to create a new record, NSEC3PARAM, which must be placed at the apex of the zone. Its role is to provide a fixed place where an authoritative name server can directly see the NSEC3 parameters used, and by putting it in the zone it allows for easy transfer to the secondaries. If NSEC3 were designed in the early days of DNS (+/- 1984) this information would probably have been put in the SOA record.  </t></section><section title="Wildcards in the DNS" anchor="wildcards-in-the-dns" toc="default"><t>So far, we have only talked about denial of existence in negative responses. However, denial of existence may also occur in positive responses, i.e., where the ANSWER section of the response is not empty. This can happen because of wildcards.  </t><t>Wildcards have been part of the DNS since the first DNS RFCs. They allow to define all names for a certain type in one go. In our <spanx style="verb" xml:space="preserve">example.org</spanx> zone we could for instance add a wildcard record: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
*.example.org.      TXT "wildcard record"
</artwork></figure><t>For completeness, our (unsigned) zone now looks like this: </t><figure anchor="fig:the-exampl" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
*.example.org.      TXT "wildcard record"
a.example.org.      A 192.0.2.1
                    TXT "a record"
d.example.org.      A 192.0.2.1
                    TXT "d record"
</artwork><postamble>The example.org zone with a wildcard record.  </postamble></figure><t>If a resolver asks for <spanx style="verb" xml:space="preserve">z.example.org TXT</spanx>, the name server will respond with an expanded wildcard, instead of an NXDOMAIN: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 13658

;; ANSWER SECTION:
z.example.org.      TXT "wildcard record"
</artwork></figure><t>Note however that the resolver can not detect that this answer came from a wildcard. It just sees the answer as-is. How will this answer look with DNSSEC? </t><figure anchor="fig:a-response" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 51790

;; ANSWER SECTION:
z.example.org.      TXT "wildcard record"
z.example.org.      RRSIG(TXT) ( ... )

;; AUTHORITY SECTION:
d.example.org.      NSEC example.org. A TXT RRSIG NSEC
d.example.org.      RRSIG(NSEC) ( ... )
</artwork><postamble>A response with an expanded wildcard and with DNSSEC.  </postamble></figure><t>The RRSIG of the <spanx style="verb" xml:space="preserve">z.example.org</spanx> TXT record indicates there is a wildcard configured. The RDATA of the signature lists a label count <xref target="RFC4034" pageno="false" format="default"/>, Section 3.1.3., of two (not visible in the answer above), but the owner name of the signature has three labels. This mismatch indicates there is a wildcard <spanx style="verb" xml:space="preserve">*.example.org</spanx> configured.  </t><t><list style="hanging" hangIndent="3"><t>An astute reader may notice that it appears as if a <spanx style="verb" xml:space="preserve">z.example.org</spanx> RRSIG(TXT) is created out of thin air. This is not the case. The signature for <spanx style="verb" xml:space="preserve">z.example.org</spanx> does not exist. The signature you are seeing is the one for <spanx style="verb" xml:space="preserve">*.example.org</spanx> which does exist, only the owner name is switched to <spanx style="verb" xml:space="preserve">z.example.org</spanx>. So even with wildcards, no signatures have to be created on the fly.  </t></list></t><t>The DNSSEC standard mandates that an NSEC (or NSEC3) is included in such responses. If it wasn't, an attacker could mount a replay attack and poison the cache with false data: Suppose that the resolver has asked for <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx>. An attacker could modify the packet in such way that it looks like the response was generated through wildcard expansion, even though there exists a record for <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx>.  </t><t>The tweaking simply consists of adjusting the ANSWER section to: </t><figure anchor="fig:a-forged-r" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 31827

;; ANSWER SECTION
a.example.org.      TXT "wildcard record"
a.example.org.      RRSIG(TXT) ( ... )
</artwork><postamble>A forged response without the expanded wildcard.  </postamble></figure><t>Note the subtle difference from <xref target="fig:a-response" pageno="false" format="default"/> in the owner name. In this response we see a <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx> record, for which a record with different RDATA (See <xref target="fig:the-exampl" pageno="false" format="default"/>) exist in the zone.  </t><t>Which would be a perfectly valid answer if we would not require the inclusion of an NSEC or NSEC3 record in the wildcard answer response. The resolver believes that <spanx style="verb" xml:space="preserve">a.example.org TXT</spanx> is a wildcard record, and the real record is obscured. This is bad and defeats all the security DNSSEC can deliver. Because of this, the NSEC or NSEC3 must be present.  </t><t>Another way of putting this is that DNSSEC is there to ensure the name server has followed the steps as outlined in <xref target="RFC1034" pageno="false" format="default"/>, Section 4.3.2 for looking up names in the zone. It explicitly lists wildcard look up as one of these steps (3c), so with DNSSEC this must be communicated to the resolver: hence the NSEC(3) record.  </t></section><section title="CNAME Records" anchor="cname-records" toc="default"><t>So far, the maximum number of NSEC records a response will have is two: one for the denial of existence and another for the wildcard.  We say maximum, because sometimes a single NSEC can prove both.  With NSEC3, this is three (as to why, we will explain in the next section).  </t><t>When we take CNAME wildcard records into account, we can have more NSEC(3) records. For every wildcard expansion, we need to prove that the expansion was allowed. Lets add some CNAME wildcard records to our zone: </t><figure anchor="fig:a-wildcard" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
*.example.org.      TXT "wildcard record"
a.example.org.      A 192.0.2.1
                    TXT "a record"
*.a.example.org.    CNAME w.b
*.b.example.org.    CNAME w.c
*.c.example.org.    A 192.0.2.1
d.example.org.      A 192.0.2.1
                    TXT "d record"
w.example.org.      CNAME w.a
</artwork><postamble>A wildcard CNAME chain added to the "example.org" zone.  </postamble></figure><t>A query for <spanx style="verb" xml:space="preserve">w.example.org A</spanx> will result in the following response: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
;; status: NOERROR, id: 4307

;; ANSWER SECTION:
w.example.org.      CNAME w.a.example.org.
w.example.org.      RRSIG(CNAME) ( ... )
w.a.example.org.    CNAME w.b.example.org.
w.a.example.org.    RRSIG(CNAME) ( ... )
w.b.example.org.    CNAME w.c.example.org.
w.b.example.org.    RRSIG(CNAME) ( ... )
w.c.example.org.    A 192.0.2.1
w.c.example.org.    RRSIG(A) ( ... )

;; AUTHORITY SECTION:
*.a.example.org.    NSEC *.b.example.org. CNAME RRSIG NSEC
*.a.example.org.    RRSIG(NSEC) ( ... )
*.b.example.org.    NSEC *.c.example.org. CNAME RRSIG NSEC
*.b.example.org.    RRSIG(NSEC) ( ... )
*.c.example.org.    NSEC d.example.org. A RRSIG NSEC
*.c.example.org.    RRSIG(NSEC) ( ... )
</artwork></figure><t>The NSEC record <spanx style="verb" xml:space="preserve">*.a.example.org</spanx> proves that wildcard expansion to <spanx style="verb" xml:space="preserve">w.a.example.org</spanx> was appropriate: <spanx style="verb" xml:space="preserve">w.a.</spanx> falls in the gap <spanx style="verb" xml:space="preserve">*.a</spanx> to <spanx style="verb" xml:space="preserve">*.b</spanx>. Similar, the NSEC record <spanx style="verb" xml:space="preserve">*.b.example.org</spanx> proves that there was no direct match for <spanx style="verb" xml:space="preserve">w.b.example.org</spanx> and <spanx style="verb" xml:space="preserve">*.c.example.org</spanx> denies the direct match for <spanx style="verb" xml:space="preserve">w.c.example.org</spanx>.  </t><t>DNAME records and wildcard names should not be used as reiterated in <xref target="RFC6672" pageno="false" format="default"/> Section 3.3.  </t></section><section title="The Closest Encloser NSEC3 Record" anchor="the-closest-encloser-nsec3-record" toc="default"><t>We can have one or more NSEC3 records that deny the existence of the requested name and one NSEC3 record that deny wildcard synthesis. What do we miss? </t><t>The short answer is that, due to the hashing in NSEC3 you loose the depth of your zone: Everything is hashed into a flat plane. To make up for this loss of information you need an extra record.  </t><t>To understand NSEC3, we will need two definitions: </t><t><list style="hanging"><t hangText="Closest encloser:">Introduced in <xref target="RFC4592" pageno="false" format="default"/>, "The closest encloser is the node in the zone's tree of existing domain names that has the most labels matching the query name (consecutively, counting from the root label downward)." In our example, if the query name is <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> then <spanx style="verb" xml:space="preserve">example.org</spanx> is the <spanx style="verb" xml:space="preserve">closest encloser</spanx>; </t><t hangText="Next closer name:">Introduced in the NSEC3 RFC, this is the closest encloser with one more label added to the left. So if <spanx style="verb" xml:space="preserve">example.org</spanx> is the closest encloser for the query name <spanx style="verb" xml:space="preserve">x.2.example.org</spanx>, <spanx style="verb" xml:space="preserve">2.example.org</spanx> is the <spanx style="verb" xml:space="preserve">next closer name</spanx>.  </t></list></t><t>An NSEC3 <spanx style="verb" xml:space="preserve">closest encloser proof</spanx> consists of: </t><t><list style="numbers"><t>An NSEC3 record that <spanx style="strong" xml:space="preserve">matches</spanx> the <spanx style="verb" xml:space="preserve">closest encloser</spanx>. This means the unhashed owner name of the record is the closest encloser. This bit of information tells a resolver: "The name you are asking for does not exist, the closest I have is this".  </t><t>An NSEC3 record that <spanx style="strong" xml:space="preserve">covers</spanx> the <spanx style="verb" xml:space="preserve">next closer name</spanx>. This means it defines an interval in which the <spanx style="verb" xml:space="preserve">next closer name</spanx> falls. This tells the resolver: "The next closer name falls in this interval, and therefore the name in your question does not exist. In fact, the closest encloser is indeed the closest I have".  </t></list></t><t>These two records already deny the existence of the requested name, so we do not need an NSEC3 record that covers the actual queried name: By denying the existence of the next closer name, you also deny the existence of the queried name.  </t><t>For a given query name, there is one (and only one) place where wildcard expansion is possible. This is the <spanx style="verb" xml:space="preserve">source of synthesis</spanx>, and is defined (<xref target="RFC4592" pageno="false" format="default"/>, Section 2.1.1 and Section 3.3.1) as: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
&lt;asterisk label&gt;.&lt;closest encloser&gt;
</artwork></figure><t>In other words, to deny wildcard synthesis, the resolver needs to know the hash of the source of synthesis. Since it does not know beforehand what the closest encloser of the query name is, it must be provided in the answer.  </t><t>Take the following example. We take our zone, and put two TXT records to it. The records added are <spanx style="verb" xml:space="preserve">1.h.example.org</spanx> and <spanx style="verb" xml:space="preserve">3.3.example.org</spanx>. It is signed with NSEC3, resulting in the following unsigned zone.  </t><figure anchor="fig:the-added-" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
1.h.example.org.    TXT "1.h record"
3.3.example.org.    TXT "3.3 record"
</artwork><postamble>The added TXT records in example.org. These records create two empty non-terminals: `h.example.org` and `3.example.org`.  </postamble></figure><t>The resolver asks the following: <spanx style="verb" xml:space="preserve">x.2.example.org TXT</spanx>. This leads to an NXDOMAIN response from the server, which contains three NSEC3 records. A list of hashed owner names can be found in <xref target="list-of-hashed-owner-names" pageno="false" format="default"/>. Also see <xref target="fig:x.2.exampl" pageno="false" format="default"/> the numbers in that figure correspond with the following NSEC3 records: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
15bg9l6359f5ch23e34ddua6n1rihl9h.example.org. (
 NSEC3 1 0 2 DEAD 1AVVQN74SG75UKFVF25DGCETHGQ638EK SOA RRSIG 
        DNSKEY NSEC3PARAM )

75b9id679qqov6ldfhd8ocshsssb6jvq.example.org. (
 NSEC3 1 0 2 DEAD 8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ TXT RRSIG )

1avvqn74sg75ukfvf25dgcethgq638ek.example.org. (
    NSEC3 1 0 2 DEAD 75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ )
</artwork></figure><t>If we would follow the NSEC approach, the resolver is only interested in one thing. Does the hash of <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> fall in any of the intervals of the NSEC3 records it got? </t><figure anchor="fig:x.2.exampl" align="center" title="" suppress-title="false" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
                    example.org
                       ** 
                   +-- ** . . . . . . . . . . .
              (1) /  . /\ .                    .
                 /  .  |   .                    .
                |  .   |    .                    .
                v .    |     .                    . 
                **     |      **                  --
  h.example.org ** ----+----&gt; ** 3.example.org    -- 2.example.org
                .     /   (3)  . |                .
                .    /         . | (2)            . 
                .   /          . |                .
                .  /           . v                .
1.h.example.org **            **                  -- 
                ** &lt;--------- ** 3.3.example.org  -- x.2.example.org
</artwork><postamble>x.2.example.org does not exist. The arrows represent the NSEC3 records, the ones numbered (1), (2) and (3) are the NSEC3s returned in our answer.  </postamble></figure><t>The hash of <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> is <spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx>. Checking this hash on the first NSEC3 yields that it does not fall in between the interval: <spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx> and <spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx>. For the second NSEC3 the answer is also negative: the hash sorts outside the interval described by <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx> and <spanx style="verb" xml:space="preserve">8555t7qegau7pjtksnbchg4td2m0jnpj</spanx>. And the last NSEC3 also isn't of any help. What is a resolver to do? It has been given the maximum amount of NSEC3s and they all seem useless.  </t><t>So this is where the closest encloser proof comes into play. And for the proof to work, the resolver needs to know what the closest encloser is. There must be an existing ancestor in the zone: a name must exist that is shorter than the query name. The resolver keeps hashing increasingly shorter names from the query name until an owner name of an NSEC3 matches. This owner name is the closest encloser.  </t><t>When the resolver has found the closest encloser, the next step is to construct the next closer name. This is the closest encloser with the last chopped label from query name prepended to it: "&lt;last chopped label&gt;.&lt;closest encloser&gt;".  The hash of this name should be covered by the interval set in any of the NSEC3 records.  </t><t>Then the resolver needs to check the presence of a wildcard. It creates the wildcard name by prepending the asterisk label to the closest encloser: "*.&lt;closest encloser&gt;", and uses the hash of that.  </t><t>Going back to our example, the resolver must first detect the NSEC3 that matches the closest encloser. It does this by chopping up the query name, hashing each instance (with the same number of iterations and hash as the zone it is querying) and comparing that to the answers given. So it has the following hashes to work with: </t><t><list style="hanging"><t hangText="x.2.example.org:"><spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx>, last chopped label: "&lt;empty&gt;"; </t><t hangText="2.example.org:"><spanx style="verb" xml:space="preserve">7t70drg4ekc28v93q7gnbleopa7vlp6q</spanx>, last chopped label: "x"; </t><t hangText="example.org:"><spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx>, last chopped label: "2"; </t></list></t><t>Of these hashes only one matches the owner name of one of the NSEC3 records: <spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx>. This must be the closest encloser (unhashed: <spanx style="verb" xml:space="preserve">example.org</spanx>).  That's the main purpose of that NSEC3 record: tell the resolver what the closest encloser is.  </t><t>When using Opt-Out, it is possible that the actual closest encloser to the QNAME does not have an NSEC3 record. If so, we will have to do with the closest provable encloser, which is the closest enclosing authoritative name that does have a NSEC3 record. In the worst case, this is the NSEC3 record corresponding to the apex, this name must always have an NSEC3 record.  </t><t>With the closest (provable) encloser, the resolver constructs the next closer, which in this case is: <spanx style="verb" xml:space="preserve">2.example.org</spanx>; <spanx style="verb" xml:space="preserve">2</spanx> is the last label chopped, when <spanx style="verb" xml:space="preserve">example.org</spanx> is the closest encloser. The hash of this name should be covered in any of the other NSEC3s. And it is, <spanx style="verb" xml:space="preserve">7t70drg4ekc28v93q7gnbleopa7vlp6q</spanx> falls in the interval set by: <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx> and <spanx style="verb" xml:space="preserve">8555t7qegau7pjtksnbchg4td2m0jnpj</spanx> (this is our second NSEC3).  </t><t>So what does the resolver learn from this? </t><t><list style="symbols"><t><spanx style="verb" xml:space="preserve">example.org</spanx> exists; </t><t><spanx style="verb" xml:space="preserve">2.example.org</spanx> does not exist.  </t></list></t><t>And if <spanx style="verb" xml:space="preserve">2.example.org</spanx> does not exist, there is also no direct match for <spanx style="verb" xml:space="preserve">x.2.example.org</spanx>. The last step is to deny the existence of the source of synthesis, to prove that no wildcard expansion was possible.  </t><t>The resolver hashes <spanx style="verb" xml:space="preserve">*.example.org</spanx> to <spanx style="verb" xml:space="preserve">22670trplhsr72pqqmedltg1kdqeolb7</spanx> and checks that it is covered: in this case by the last NSEC3 (see <xref target="fig:x.2.exampl" pageno="false" format="default"/>), the hash falls in the interval set by <spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx> and <spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx>. This means there is no wildcard record directly below the closest encloser and <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> definitely does not exist.  </t><t>When we have validated the signatures, we reached our goal: authenticated denial of existence.  </t></section><section title="Three To Tango" anchor="three-to-tango" toc="default"><t>One extra NSEC3 record plus additional signature may seem a lot just to deny the existence of the wildcard record, but we cannot leave it out. If the standard would not mandate the closest encloser NSEC3 record, but instead required two NSEC3 records: one to deny the query name and one to deny the wildcard record. An attacker could fool the resolver that the source of synthesis does not exist, while it in fact does.  </t><t>Suppose the wildcard record does exist, so our unsigned zone looks like this: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
example.org.        SOA ( ... )
*.example.org.      TXT "wildcard record"
1.h.example.org.    TXT "1.h record"
3.3.example.org.    TXT "3.3 record"
</artwork></figure><t>The query <spanx style="verb" xml:space="preserve">x.2.example.org TXT</spanx> should now be answered with: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
x.2.example.org.    TXT "wildcard record"
</artwork></figure><t>An attacker can deny this wildcard expansion by calculating the hash for the wildcard name <spanx style="verb" xml:space="preserve">*.2.example.org</spanx> and searching for an NSEC3 record that covers that hash. The hash of <spanx style="verb" xml:space="preserve">*.2.example.org</spanx> is <spanx style="verb" xml:space="preserve">fbq73bfkjlrkdoqs27k5qf81aqqd7hho</spanx>. Looking through the NSEC3 records in our zone we see that the NSEC3 record of <spanx style="verb" xml:space="preserve">3.3</spanx> covers this hash: </t><figure title="" suppress-title="false" align="left" alt="" width="" height=""><artwork xml:space="preserve" name="" type="" align="left" alt="" width="" height="">
8555t7qegau7pjtksnbchg4td2m0jnpj.example.org. (
    NSEC3 1 0 2 DEAD 15BG9L6359F5CH23E34DDUA6N1RIHL9H TXT RRSIG )
</artwork></figure><t>This record also covers the query name <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> (<spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx>).  </t><t>Now an attacker adds this NSEC3 record to the AUTHORITY section of the reply to deny both <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> and any wildcard expansion. The net result is that the resolver determines that <spanx style="verb" xml:space="preserve">x.2.example.org</spanx> does not exist, while in fact it should have been synthesized via wildcard expansion. With the NSEC3 matching the closest encloser <spanx style="verb" xml:space="preserve">example.org</spanx>, the resolver can be sure that the wildcard expansion should occur at <spanx style="verb" xml:space="preserve">*.example.org</spanx> and nowhere else.  </t><t>Coming back to the original question: why do we need up to three NSEC3 records to deny a requested name? The resolver needs to be explicitly told what the <spanx style="verb" xml:space="preserve">closest encloser</spanx> is and this takes up a full NSEC3 record. Then, the next closer name needs to be covered in an NSEC3 record, and finally an NSEC3 must say something about whether wildcard expansion was possible. That makes three to tango.  </t></section></section><section title="Security Considerations" anchor="security-considerations" toc="default"><t>DNSSEC does not protect against denial of service attacks, nor does it provide confidentiality. For more general security considerations related to DNSSEC, please see RFC 4033, RFC 4034, RFC 4035 and RFC 5155 (<xref target="RFC4033" pageno="false" format="default"/>, <xref target="RFC4034" pageno="false" format="default"/>, <xref target="RFC4035" pageno="false" format="default"/> and <xref target="RFC5155" pageno="false" format="default"/>).  </t><t>These RFCs are concise about why certain design choices have been made in the area of authenticated denial of existence.  Implementations that do not correctly handle this aspect of DNSSEC, create a severe hole in the security DNSSEC adds. This is specifically troublesome for secure delegations: If an attacker is able to deny the existence of a DS record, the resolver cannot establish a chain of trust, and the resolver has to fall back to insecure DNS for the remainder of the query resolution.  </t><t>This document aims to fill this "documentation gap" and provide would-be implementors and other interested parties with enough background knowledge to better understand authenticated denial of existence.  </t></section><section title="IANA Considerations" anchor="iana-considerations" toc="default"><t>This document has no actions for IANA.  </t></section><section title="Acknowledgments" anchor="acknowledgments" toc="default"><t>This document would not be possible without the help of Ed Lewis, Roy Arends, Wouter Wijngaards, Olaf Kolkman, Carsten Strotmann, Jan-Piet Mens, Peter van Dijk, Marco Davids, Esther Makaay, Antoin Verschuren, Lukas Wunner, Joe Abley and Geoff Huston. Also valuable was the source code of Unbound (<spanx style="verb" xml:space="preserve">validator/val_nsec3.c</spanx>).  </t><t>Extensive feedback for early versions was received from Karst Koymans.  </t></section> </middle>
  <back><references title="Normative References"><reference anchor="RFC1034"><front><title abbrev="Domain Concepts and Facilities">Domain names - concepts and facilities</title><author initials="P." surname="Mockapetris" fullname="P. Mockapetris"><organization>Information Sciences Institute (ISI)</organization></author><date year="1987" day="1" month="November"/></front><seriesInfo name="STD" value="13"/><seriesInfo name="RFC" value="1034"/><format type="TXT" octets="129180" target="http://www.rfc-editor.org/rfc/rfc1034.txt"/></reference> <reference anchor="RFC2065"><front><title abbrev="DNS Security Extensions">Domain Name System Security Extensions</title><author initials="D.E." surname="Eastlake" fullname="Donald E. Eastlake 3rd"><organization>CyberCash, Inc.</organization><address><postal><street>318 Acton Street</street><city>Carlisle</city><region>MA</region><code>01741</code><country>US</country></postal><phone>+1 508 287 4877</phone><facsimile>+1 508 371 7148</facsimile><email>dee@cybercash.com</email></address></author><author initials="C." surname="Kaufman" fullname="Charles W. Kaufman"><organization>Iris Associates</organization><address><postal><street>1 Technology Park Drive</street><city>Westford</city><region>MA</region><code>01886</code><country>US</country></postal><phone>+1 508 392 5276</phone><email>charlie_kaufman@iris.com</email></address></author><date year="1997" month="January"/><abstract><t>The Domain Name System (DNS) has become a critical operational part of the Internet infrastructure yet it has no strong security mechanisms to assure data integrity or authentication.  Extensions to the DNS are described that provide these services to security aware resolvers or applications through the use of cryptographic digital signatures.  These digital signatures are included in secured zones as resource records.  Security can still be provided even through non-security aware DNS servers in many cases.</t><t>The extensions also provide for the storage of authenticated public keys in the DNS.  This storage of keys can support general public key distribution service as well as DNS security.  The stored keys enable security aware resolvers to learn the authenticating key of zones in addition to those for which they are initially configured.  Keys associated with DNS names can be retrieved to support other protocols.  Provision is made for a variety of key types and algorithms.</t><t>In addition, the security extensions provide for the optional authentication of DNS protocol transactions.</t></abstract></front><seriesInfo name="RFC" value="2065"/><format type="TXT" octets="97718" target="http://www.rfc-editor.org/rfc/rfc2065.txt"/></reference> <reference anchor="RFC2308"><front><title abbrev="DNS NCACHE">Negative Caching of DNS Queries (DNS NCACHE)</title><author initials="M." surname="Andrews" fullname="Mark Andrews"><organization>CSIRO - Mathematical and Information Sciences</organization><address><postal><street>Locked Bag 17</street><street>North Ryde NSW 2113</street><country>AUSTRALIA</country></postal><phone>+61 2 9325 3148</phone><email>Mark.Andrews@cmis.csiro.au</email></address></author><date year="1998" month="March"/><area>Applications</area><keyword>domain name system</keyword><keyword>DNS</keyword><abstract><t>[RFC1034] provided a description of how to cache negative responses.  It however had a fundamental flaw in that it did not allow a name server to hand out those cached responses to other resolvers, thereby greatly reducing the effect of the caching.  This document addresses issues raise in the light of experience and replaces [RFC1034 Section 4.3.4].  </t><t>Negative caching was an optional part of the DNS specification and deals with the caching of the non-existence of an RRset [RFC2181] or domain name.  </t><t>Negative caching is useful as it reduces the response time for negative answers.  It also reduces the number of messages that have to be sent between resolvers and name servers hence overall network traffic.  A large proportion of DNS traffic on the Internet could be eliminated if all resolvers implemented negative caching.  With this in mind negative caching should no longer be seen as an optional part of a DNS resolver.  </t></abstract></front><seriesInfo name="RFC" value="2308"/><format type="TXT" octets="41428" target="http://www.rfc-editor.org/rfc/rfc2308.txt"/><format type="HTML" octets="50045" target="http://xml.resource.org/public/rfc/html/rfc2308.html"/><format type="XML" octets="41491" target="http://xml.resource.org/public/rfc/xml/rfc2308.xml"/></reference> <reference anchor="RFC4033"><front><title>DNS Security Introduction and Requirements</title><author initials="R." surname="Arends" fullname="R. Arends"><organization/></author><author initials="R." surname="Austein" fullname="R. Austein"><organization/></author><author initials="M." surname="Larson" fullname="M. Larson"><organization/></author><author initials="D." surname="Massey" fullname="D. Massey"><organization/></author><author initials="S." surname="Rose" fullname="S. Rose"><organization/></author><date year="2005" month="March"/><abstract><t>The Domain Name System Security Extensions (DNSSEC) add data origin authentication and data integrity to the Domain Name System.  This document introduces these extensions and describes their capabilities and limitations.  This document also discusses the services that the DNS security extensions do and do not provide.  Last, this document describes the interrelationships between the documents that collectively describe DNSSEC. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="4033"/><format type="TXT" octets="52445" target="http://www.rfc-editor.org/rfc/rfc4033.txt"/></reference> <reference anchor="RFC4034"><front><title>Resource Records for the DNS Security Extensions</title><author initials="R." surname="Arends" fullname="R. Arends"><organization/></author><author initials="R." surname="Austein" fullname="R. Austein"><organization/></author><author initials="M." surname="Larson" fullname="M. Larson"><organization/></author><author initials="D." surname="Massey" fullname="D. Massey"><organization/></author><author initials="S." surname="Rose" fullname="S. Rose"><organization/></author><date year="2005" month="March"/><abstract><t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of resource records and protocol modifications that provide source authentication for the DNS. This document defines the public key (DNSKEY), delegation signer (DS), resource record digital signature (RRSIG), and authenticated denial of existence (NSEC) resource records. The purpose and format of each resource record is described in detail, and an example of each resource record is given.&lt;/t&gt;&lt;t&gt; This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="4034"/><format type="TXT" octets="63879" target="http://www.rfc-editor.org/rfc/rfc4034.txt"/></reference> <reference anchor="RFC4035"><front><title>Protocol Modifications for the DNS Security Extensions</title><author initials="R." surname="Arends" fullname="R. Arends"><organization/></author><author initials="R." surname="Austein" fullname="R. Austein"><organization/></author><author initials="M." surname="Larson" fullname="M. Larson"><organization/></author><author initials="D." surname="Massey" fullname="D. Massey"><organization/></author><author initials="S." surname="Rose" fullname="S. Rose"><organization/></author><date year="2005" month="March"/><abstract><t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC). The DNS Security Extensions are a collection of new resource records and protocol modifications that add data origin authentication and data integrity to the DNS. This document describes the DNSSEC protocol modifications. This document defines the concept of a signed zone, along with the requirements for serving and resolving by using DNSSEC. These techniques allow a security-aware resolver to authenticate both DNS resource records and authoritative DNS error indications.&lt;/t&gt;&lt;t&gt; This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="4035"/><format type="TXT" octets="130589" target="http://www.rfc-editor.org/rfc/rfc4035.txt"/></reference> <reference anchor="RFC4592"><front><title>The Role of Wildcards in the Domain Name System</title><author initials="E." surname="Lewis" fullname="E. Lewis"><organization/></author><date year="2006" month="July"/><abstract><t>This is an update to the wildcard definition of RFC 1034.  The interaction with wildcards and CNAME is changed, an error condition is removed, and the words defining some concepts central to wildcards are changed.  The overall goal is not to change wildcards, but to refine the definition of RFC 1034. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="4592"/><format type="TXT" octets="43991" target="http://www.rfc-editor.org/rfc/rfc4592.txt"/></reference> <reference anchor="RFC4648"><front><title>The Base16, Base32, and Base64 Data Encodings</title><author initials="S." surname="Josefsson" fullname="S. Josefsson"><organization/></author><date year="2006" month="October"/><abstract><t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="4648"/><format type="TXT" octets="35491" target="http://www.rfc-editor.org/rfc/rfc4648.txt"/></reference> <reference anchor="RFC5155"><front><title>DNS Security (DNSSEC) Hashed Authenticated Denial of Existence</title><author initials="B." surname="Laurie" fullname="B. Laurie"><organization/></author><author initials="G." surname="Sisson" fullname="G. Sisson"><organization/></author><author initials="R." surname="Arends" fullname="R. Arends"><organization/></author><author initials="D." surname="Blacka" fullname="D. Blacka"><organization/></author><date year="2008" month="March"/><abstract><t>The Domain Name System Security (DNSSEC) Extensions introduced the NSEC resource record (RR) for authenticated denial of existence.  This document introduces an alternative resource record, NSEC3, which similarly provides authenticated denial of existence.  However, it also provides measures against zone enumeration and permits gradual expansion of delegation-centric zones. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="5155"/><format type="TXT" octets="112338" target="http://www.rfc-editor.org/rfc/rfc5155.txt"/></reference> <reference anchor="RFC6672"><front><title>DNAME Redirection in the DNS</title><author initials="S." surname="Rose" fullname="S. Rose"><organization/></author><author initials="W." surname="Wijngaards" fullname="W. Wijngaards"><organization/></author><date year="2012" month="June"/><abstract><t>The DNAME record provides redirection for a subtree of the domain name tree in the DNS.  That is, all names that end with a particular suffix are redirected to another part of the DNS.  This document obsoletes the original specification in RFC 2672 as well as updates the document on representing IPv6 addresses in DNS (RFC 3363). [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="6672"/><format type="TXT" octets="45704" target="http://www.rfc-editor.org/rfc/rfc6672.txt"/></reference> </references><references title="Informative References"><reference anchor="RFC2535"><front><title abbrev="DNS Security Extensions">Domain Name System Security Extensions</title><author initials="D." surname="Eastlake" fullname="Donald E. Eastlake 3rd"><organization>IBM</organization><address><postal><street>65 Shindegan Hill Road</street><street>RR #1</street><city>Carmel</city><region>NY</region><code>10512</code><country>US</country></postal><phone>+1 914 784 7913</phone><facsimile>+1 914 784 3833</facsimile><email>dee3@us.ibm.com</email></address></author><date year="1999" month="March"/><abstract><t>Extensions to the Domain Name System (DNS) are described that provide data integrity and authentication to security aware resolvers and applications through the use of cryptographic digital signatures. These digital signatures are included in secured zones as resource records.  Security can also be provided through non-security aware DNS servers in some cases.</t><t>The extensions provide for the storage of authenticated public keys in the DNS.  This storage of keys can support general public key distribution services as well as DNS security.  The stored keys enable security aware resolvers to learn the authenticating key of zones in addition to those for which they are initially configured. Keys associated with DNS names can be retrieved to support other protocols.  Provision is made for a variety of key types and algorithms.</t><t>In addition, the security extensions provide for the optional authentication of DNS protocol transactions and requests.</t><t>This document incorporates feedback on RFC 2065 from early implementers and potential users.</t></abstract></front><seriesInfo name="RFC" value="2535"/><format type="TXT" octets="110958" target="http://www.rfc-editor.org/rfc/rfc2535.txt"/></reference> <reference anchor="RFC3655"><front><title>Redefinition of DNS Authenticated Data (AD) bit</title><author initials="B." surname="Wellington" fullname="B. Wellington"><organization/></author><author initials="O." surname="Gudmundsson" fullname="O. Gudmundsson"><organization/></author><date year="2003" month="November"/><abstract><t>This document alters the specification defined in RFC 2535.  Based on implementation experience, the Authenticated Data (AD) bit in the DNS header is not useful.  This document redefines the AD bit such that it is only set if all answers or records proving that no answers exist in the response has been cryptographically verified or otherwise meets the server's local security policy.</t></abstract></front><seriesInfo name="RFC" value="3655"/><format type="TXT" octets="15646" target="http://www.rfc-editor.org/rfc/rfc3655.txt"/></reference> <reference anchor="RFC3755"><front><title>Legacy Resolver Compatibility for Delegation Signer (DS)</title><author initials="S." surname="Weiler" fullname="S. Weiler"><organization/></author><date year="2004" month="May"/><abstract><t>As the DNS Security (DNSSEC) specifications have evolved, the syntax and semantics of the DNSSEC resource records (RRs) have changed.  Many deployed nameservers understand variants of these semantics.  Dangerous interactions can occur when a resolver that understands an earlier version of these semantics queries an authoritative server that understands the new delegation signer semantics, including at least one failure scenario that will cause an unsecured zone to be unresolvable.  This document changes the type codes and mnemonics of the DNSSEC RRs (SIG, KEY, and NXT) to avoid those interactions. [STANDARDS-TRACK]</t></abstract></front><seriesInfo name="RFC" value="3755"/><format type="TXT" octets="19812" target="http://www.rfc-editor.org/rfc/rfc3755.txt"/></reference> <reference anchor="RFC4956"><front><title>DNS Security (DNSSEC) Opt-In</title><author initials="R." surname="Arends" fullname="R. Arends"><organization/></author><author initials="M." surname="Kosters" fullname="M. Kosters"><organization/></author><author initials="D." surname="Blacka" fullname="D. Blacka"><organization/></author><date year="2007" month="July"/><abstract><t>In the DNS security (DNSSEC) extensions, delegations to unsigned subzones are cryptographically secured.  Maintaining this cryptography is not always practical or necessary.  This document describes an experimental "Opt-In" model that allows administrators to omit this cryptography and manage the cost of adopting DNSSEC with large zones.  This memo defines an Experimental Protocol for the Internet community.</t></abstract></front><seriesInfo name="RFC" value="4956"/><format type="TXT" octets="32033" target="http://www.rfc-editor.org/rfc/rfc4956.txt"/></reference> <reference anchor="I-D.arends-dnsnr"><front><title>DNSSEC Non-Repudiation Resource Record</title><author initials="R" surname="Arends" fullname="Roy Arends"><organization/></author><date month="July" day="13" year="2004"/><abstract><t>This document describes the DNSNR Resource Record (RR) for the Non-Repudiation (NR) of Existence service in the context of the DNS Security Extensions (DNSSEC). The DNSNR is an alternative to NSEC or "Authenticated Denial of Existence" Resource Records. A signed DNSNR RR protects security-aware DNS components against false denial of existence of RRsets by providing the RR types that exist for its ownername, which optionally includes a non-authoritative delegation point NS RR type. Labels in the ownername and the RDATA may be a hash-value as a defense against zone traversal.</t></abstract></front><seriesInfo name="Internet-Draft" value="draft-arends-dnsnr-00"/><format type="TXT" target="http://tools.ietf.org/id/draft-arends-dnsnr-00.txt"/></reference> <reference anchor="I-D.laurie-dnsext-nsec2v2"><front><title>DNSSEC NSEC2 Owner and RDATA Format</title><author initials="B" surname="Laurie" fullname="Ben Laurie"><organization/></author><date month="December" day="9" year="2004"/><abstract><t>The DNS Security (DNSSEC) NSEC resource record (RR) is intended to be used to provide authenticated denial of existence of DNS owner names and types; however, it also permits any user to obtain a listing of all DNS owner names in a zone. This can accomplished via successive DNS queries for all NSEC RRs in that zone.</t></abstract></front><seriesInfo name="Internet-Draft" value="draft-laurie-dnsext-nsec2v2-00"/><format type="TXT" target="http://tools.ietf.org/id/draft-laurie-dnsext-nsec2v2-00.txt"/></reference> <reference anchor="I-D.ietf-dnsext-not-existing-rr"><front><title>Authenticating denial of existence in DNS with minimum disclosure</title><author initials="S" surname="Josefsson" fullname="Simon Josefsson"><organization/></author><date month="November" day="29" year="2000"/><abstract><t>This draft present an alternative to NXT records, used to achieve authenticated denial of existence of a domain name, class and type. Problems with NXT records, as specified in RFC 2535, are identified. One solution, the NO record, is presented. The NO record differ from the NXT record by using a cryptographic hash value instead of the domain name. This prevent an adversery from collecting information by 'chaining' through a zone. It also remove delegation point concerns in NXT records. The document also describe hash truncation and record merging that reduces storage/network load.  </t></abstract></front><seriesInfo name="Internet-Draft" value="draft-ietf-dnsext-not-existing-rr-01"/><format type="TXT" target="http://tools.ietf.org/id/draft-ietf-dnsext-not-existing-rr-01.txt"/></reference> <reference anchor="RFC5155-errata3441"><front><title>Technical Errata against RFC 5155 (not acknowledged)</title><author initials="E" surname="Lewis" fullname="Edward Lewis"><organization/></author><date month="January" day="1" year="2013"/></front><format type="Errata submission" target="http://www.rfc-editor.org/errata_search.php?rfc=5155&amp;eid=3441"/></reference> </references><!--This document was prepared using Pandoc2rfc --><!--https://github.com/miekg/pandoc2rfc --><section title="List of Hashed Owner Names" anchor="list-of-hashed-owner-names" toc="default"><t>The following owner names are used in this document. The origin for these names is <spanx style="verb" xml:space="preserve">example.org</spanx>.  </t><texttable anchor="tab:hashed-own" title="" suppress-title="false" align="center" style="full"><ttcol align="left">Original Name </ttcol><ttcol align="left">Hashed Name </ttcol><c><spanx style="verb" xml:space="preserve">a</spanx> </c><c><spanx style="verb" xml:space="preserve">04sknapca5al7qos3km2l9tl3p5okq4c</spanx> </c><c><spanx style="verb" xml:space="preserve">1.h</spanx> </c><c><spanx style="verb" xml:space="preserve">117gercprcjgg8j04ev1ndrk8d1jt14k</spanx> </c><c><spanx style="verb" xml:space="preserve">@</spanx> </c><c><spanx style="verb" xml:space="preserve">15bg9l6359f5ch23e34ddua6n1rihl9h</spanx> </c><c><spanx style="verb" xml:space="preserve">h</spanx> </c><c><spanx style="verb" xml:space="preserve">1avvqn74sg75ukfvf25dgcethgq638ek</spanx> </c><c><spanx style="verb" xml:space="preserve">*</spanx> </c><c><spanx style="verb" xml:space="preserve">22670trplhsr72pqqmedltg1kdqeolb7</spanx> </c><c><spanx style="verb" xml:space="preserve">3</spanx> </c><c><spanx style="verb" xml:space="preserve">75b9id679qqov6ldfhd8ocshsssb6jvq</spanx> </c><c><spanx style="verb" xml:space="preserve">2</spanx> </c><c><spanx style="verb" xml:space="preserve">7t70drg4ekc28v93q7gnbleopa7vlp6q</spanx> </c><c><spanx style="verb" xml:space="preserve">3.3</spanx> </c><c><spanx style="verb" xml:space="preserve">8555t7qegau7pjtksnbchg4td2m0jnpj</spanx> </c><c><spanx style="verb" xml:space="preserve">d</spanx> </c><c><spanx style="verb" xml:space="preserve">a6edkb6v8vl5ol8jnqqlt74qmj7heb84</spanx> </c><c><spanx style="verb" xml:space="preserve">*.2</spanx> </c><c><spanx style="verb" xml:space="preserve">fbq73bfkjlrkdoqs27k5qf81aqqd7hho</spanx> </c><c><spanx style="verb" xml:space="preserve">b</spanx> </c><c><spanx style="verb" xml:space="preserve">iuu8l5lmt76jeltp0bir3tmg4u3uu8e7</spanx> </c><c><spanx style="verb" xml:space="preserve">x.2</spanx> </c><c><spanx style="verb" xml:space="preserve">ndtu6dste50pr4a1f2qvr1v31g00i2i1</spanx> </c><postamble>Hashed owner names for "example.org" in hash order.  </postamble></texttable></section><section title="Changelog" anchor="changelog" toc="default"><t>[This section should be removed by the RFC editor before publishing] </t><section title="-00" anchor="section" toc="default"><t><list style="numbers"><t>Initial document.  </t></list></t></section><section title="-01" anchor="section-1" toc="default"><t><list style="numbers"><t>Style and language changes; </t><t>Figure captions; </t><t>Security considerations added; </t><t>Fix erroneous NSEC3 RR; </t><t>Section on CNAMEs added; </t><t>More detailed text on closest encloser proof.  </t></list></t></section><section title="-02" anchor="section-2" toc="default"><t><list style="numbers"><t>Lowercase NSEC3 hashed ownernames and add reference to Base32; </t><t>Process the comments from Joe Abley and Geoff Huston.  <list style="symbols"><t>Added section about Opt-Out; </t><t>Move experimental records in their own section; </t><t>Added DNAME reference with respect to wildcards; </t><t>Clarify the difference between the wildcard answers; </t><t>Add more context about the NO record; </t><t>Elaborate more about the EXIST records and its problems; </t><t>Added more text about the NSEC3PARAM records; </t><t>Apply assorted fixes throughout the document; </t><t>Moved table with hashed owner names to appendix.  </t></list> </t></list></t></section></section> </back>
</rfc>
