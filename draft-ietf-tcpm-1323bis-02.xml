<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced. 
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC0793 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC1191 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!-- update to latest TCP congestion control RFC -->
<!ENTITY RFC2581 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2581.xml">
<!ENTITY RFC5681 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5681.xml">
<!ENTITY RFC2675 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2675.xml">
<!ENTITY RFC1122 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC2883 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2883.xml">
<!ENTITY RFC3517 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3517.xml">
<!ENTITY RFC4963 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4963.xml">
<!ENTITY RFC1072 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1072.xml">
<!ENTITY RFC1185 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1185.xml">
<!ENTITY RFC1323 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1323.xml">
<!ENTITY RFC2018 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2018.xml">
<!ENTITY RFC1110 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1110.xml">
<!ENTITY RFC0896 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0896.xml">


]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" 
     docName="draft-ietf-tcpm-1323bis-02" 
	ipr="trust200902">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->
 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

   <title>TCP Extensions for High Performance</title>
   
   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

    <author fullname="David Borman" 
    	      initials="D." 
    	      surname="Borman">
    	<organization>Quantum Corporation</organization>
    	<address>
    		<postal>
    			<street></street>
    			<city>Mendota Heights</city>
    			<code>MN 55120</code>
    			<country>USA</country>
    		</postal>
    		<email>david.borman@quantum.com</email>
    	</address>
    </author>
    
    <author fullname="Bob Braden" 
    	      initials="B." 
    	      surname="Braden">
    	<organization>University of Southern California</organization>
    	<address>
    		<postal>
    			<street>4676 Admiralty Way</street>
    			<city>Marina del Rey</city>
    			<code>CA 90292</code>
    			<country>USA</country>
    		</postal>
    		<email>braden@isi.edu</email>
    	</address>
    </author>
    
    <author fullname="Van Jacobson" 
    	      initials="V." 
    	      surname="Jacobson">
    	<organization>Packet Design</organization>
    	<address>
    		<postal>
    			<street>2465 Latham Street</street>
    			<city>Mountain View</city>
    			<code>CA 94040</code>
    			<country>USA</country>
    		</postal>
    		<email>van@packetdesign.com</email>
    	</address>
    </author>
    
    
    
    <author fullname="Richard Scheffenegger" 
    	      initials="R."
            surname="Scheffenegger" 
            role="editor">
     <organization>NetApp, Inc.</organization>
     <address>
       <postal>
         <street>Am Euro Platz 2</street>
         <code>1120</code>
         <city>Vienna</city>
         <region></region>
         <country>Austria</country>
       </postal>
       <email>rs@netapp.com</email>
     </address>
    </author>

   <date year="2012" />


   <area>Transport</area>

   <workgroup>TCP Maintenance (TCPM)</workgroup>

   <keyword>Internet-Draft</keyword>
   <keyword>I-D</keyword>
  
   <abstract>
   	 <t>This memo presents a set of TCP extensions to improve performance
     over large bandwidth*delay product paths and to provide reliable
     operation over very high-speed paths.  It defines TCP options for
     scaled windows and timestamps, which are designed to provide
     compatible interworking with TCP's that do not implement the
     extensions.  The timestamps are used for two distinct mechanisms:
     RTTM (Round Trip Time Measurement) and PAWS (Protection Against
     Wrapped Sequences).  Selective acknowledgments are not included in
     this memo.
     </t>
     <t>This memo updates and obsoletes RFC 1323.
     </t>
   </abstract>
 </front>

 <middle>
	<section anchor="sec1" title="Introduction">
		<t>The TCP protocol <xref target="RFC0793"/> was designed to operate reliably over
		almost any transmission medium regardless of transmission rate,
    delay, corruption, duplication, or reordering of segments.
    Production TCP implementations currently adapt to transfer rates in
    the range of 100 bps to 10^10 bps and round-trip delays in the range
    1 ms to 100 seconds.  Work on TCP performance has shown that TCP
    without the extensions described in this memo can work well over a
    variety of Internet paths, ranging from 800 Mbit/sec I/O channels to
    300 bit/sec dial-up modems <!--<xref target="Jacobson88a"/-->.
    </t>
    <t>Over the years, advances in networking technology has resulted in
    ever-higher transmission speeds, and the fastest paths are well
    beyond the domain for which TCP was originally engineered.  This memo
    defines a set of modest extensions to TCP to extend the domain of its
    application to match this increasing network capability.  It is an
    update to and obsoletes 
    <xref target="RFC1323"/><!--xref target="Jacobson92d"/-->, 
    which in turn is based upon and obsoletes 
    <xref target="RFC1072"/><!--xref target="Jacobson88b"/--> and 
    <xref target="RFC1185"/><!--xref target="Jacobson90b"/-->.
    </t>
    <t>There is no one-line answer to the question: "How fast can TCP go?".
    There are two separate kinds of issues, performance and reliability,
    and each depends upon different parameters.  We discuss each in turn.
    </t>
    <section anchor="sec11" title="TCP Performance">
    	<t>TCP performance depends not upon the transfer rate itself, but
      rather upon the product of the transfer rate and the round-trip
      delay.  This "bandwidth*delay product" measures the amount of data
      that would "fill the pipe"; it is the buffer space required at
      sender and receiver to obtain maximum throughput on the TCP
      connection over the path, i.e., the amount of unacknowledged data
      that TCP must handle in order to keep the pipeline full.  TCP
      performance problems arise when the bandwidth*delay product is
      large.  We refer to an Internet path operating in this region as a
      "long, fat pipe", and a network containing this path as an "LFN"
      (pronounced "elephan(t)").
      </t>
      <t>High-capacity packet satellite channels are LFN's.  For example, a
      DS1-speed satellite channel has a bandwidth*delay product of 10^6
      bits or more; this corresponds to 100 outstanding TCP segments of
      1200 bytes each.  Terrestrial fiber-optical paths will also fall
      into the LFN class; for example, a cross-country delay of 30 ms at
      a DS3 bandwidth (45Mbps) also exceeds 10^6 bits.
      </t>
      <t>There are three fundamental performance problems with the current
      TCP over LFN paths:
        <list style="format (%d)">
        	<t>Window Size Limit<vspace blankLines="1"/>
            The TCP header uses a 16 bit field to report the receive
            window size to the sender.  Therefore, the largest window
           that can be used is 2^16 = 65K bytes.
           <vspace blankLines="1"/>
           To circumvent this problem, Section 2 of this memo defines a
           new TCP option, "Window Scale", to allow windows larger than
           2^16.  This option defines an implicit scale factor, which
           is used to multiply the window size value found in a TCP
           header to obtain the true window size.
          </t>
          <t>Recovery from Losses<vspace blankLines="1"/>
           Packet losses in an LFN can have a catastrophic effect on
           throughput.  In the past, properly-operating TCP
           implementations would cause the data pipeline to drain with
           every packet loss, and require a slow-start action to
           recover.  The Fast Retransmit and Fast Recovery algorithms
           <xref target="Jacobson90c"/>, <xref target="RFC2581"/> and 
           <xref target="RFC5681"/> were 
           introduced, and their combined
           effect was to recover from one packet loss per window,
           without draining the pipeline.  However, more than one packet
           loss per window typically resulted in a retransmission
           timeout and the resulting pipeline drain and slow start.
           <vspace blankLines="1"/>
           Expanding the window size to match the capacity of an LFN
           results in a corresponding increase of the probability of
           more than one packet per window being dropped.  This could
           have a devastating effect upon the throughput of TCP over an
           LFN.  In addition, since the publication of RFC 1323,
           congestion control mechanism based upon some form of random
           dropping have been introduced into gateways, and randomly
           spaced packet drops have become common; this increases the
           probability of dropping more than one packet per window.
           <vspace blankLines="1"/>
           To generalize the Fast Retransmit/Fast Recovery mechanism to
           handle multiple packets dropped per window, selective
           acknowledgments are required.  Unlike the normal cumulative
           acknowledgments of TCP, selective acknowledgments give the
           sender a complete picture of which segments are queued at the
           receiver and which have not yet arrived.
           <vspace blankLines="1"/>
           Since the publication of <xref target="RFC1323"/>, selective 
           acknowledgments (SACK) have become important in the LFN 
           regime.  SACK has been published as a 
           <xref target="RFC2018"/>, "TCP Selective Acknowledgment Options".<!--xref target="Mathis96"/-->.  
           Additional information about SACK can be found in 
           <xref target="RFC2883"/><!--xref target="Floyd00"/-->, "An 
           Extension to the Selective Acknowledgement (SACK) option for 
           TCP" and <xref target="RFC3517"/><!--xref target="Blanton03"/-->,
           "A Conservative Selective Acknowledgment (SACK)-based
           Loss Recovery Algorithm for TCP".
          </t>
          <t>Round-Trip Measurement<vspace blankLines="1"/>
           TCP implements reliable data delivery by retransmitting
           segments that are not acknowledged within some retransmission
           timeout (RTO) interval.  Accurate dynamic determination of an
           appropriate RTO is essential to TCP performance.  RTO is
           determined by estimating the mean and variance of the
           measured round-trip time (RTT), i.e., the time interval
           between sending a segment and receiving an acknowledgment for
           it <xref target="Jacobson88a"/>.
           <vspace blankLines="1"/>
           <xref target="sec32"/> introduces a new TCP option, 
           "Timestamps", and then
           defines a mechanism using this option that allows nearly
           every segment, including retransmissions, to be timed at
           negligible computational cost.  We use the mnemonic RTTM
           (Round Trip Time Measurement) for this mechanism, to
           distinguish it from other uses of the Timestamps option.
          </t>
        </list>
      </t>
    </section>
    <section anchor="sec12" title="TCP Reliability">
    	<t>Now we turn from performance to reliability.  High transfer rate
      enters TCP performance through the bandwidth*delay product.
      However, high transfer rate alone can threaten TCP reliability by
      violating the assumptions behind the TCP mechanism for duplicate
      detection and sequencing.
      </t>
      <t>An especially serious kind of error may result from an accidental
      reuse of TCP sequence numbers in data segments.  Suppose that an
      "old duplicate segment", e.g., a duplicate data segment that was
      delayed in Internet queues, is delivered to the receiver at the
      wrong moment, so that its sequence numbers falls somewhere within
      the current window.  There would be no checksum failure to warn of
      the error, and the result could be an undetected corruption of the
      data.  Reception of an old duplicate ACK segment at the
      transmitter could be only slightly less serious: it is likely to
      lock up the connection so that no further progress can be made,
      forcing an RST on the connection.
      </t>
      <t>TCP reliability depends upon the existence of a bound on the
      lifetime of a segment: the "Maximum Segment Lifetime" or MSL.  An
      MSL is generally required by any reliable transport protocol,
      since every sequence number field must be finite, and therefore
      any sequence number may eventually be reused.  In the Internet
      protocol suite, the MSL bound is enforced by an IP-layer
      mechanism, the "Time-to-Live" or TTL field.
      </t>
      <t>Duplication of sequence numbers might happen in either of two
      ways:
        <list style="format (%d)">
        	<t>Sequence number wrap-around on the current connection<vspace blankLines="1"/>
           

           A TCP sequence number contains 32 bits.  At a high enough
           transfer rate, the 32-bit sequence space may be "wrapped"
           (cycled) within the time that a segment is delayed in queues.
          </t>
          <t>Earlier incarnation of the connection<vspace blankLines="1"/>
           

           Suppose that a connection terminates, either by a proper
           close sequence or due to a host crash, and the same
           connection (i.e., using the same pair of sockets) is
           immediately reopened.  A delayed segment from the terminated
           connection could fall within the current window for the new
           incarnation and be accepted as valid.
          </t>

        </list>
      </t>  
      <t>Duplicates from earlier incarnations, Case (2), are avoided by
      enforcing the current fixed MSL of the TCP spec, as explained in
      <xref target="sec43"/> and <xref target="AppB"/>.   
      However, case (1), avoiding the
      reuse of sequence numbers within the same connection, requires an
      MSL bound that depends upon the transfer rate, and at high enough
      rates, a new mechanism is required.
      </t>
      <t>More specifically, if the maximum effective bandwidth at which TCP
      is able to transmit over a particular path is B bytes per second,
      then the following constraint must be satisfied for error-free
      operation:
      <figure align="center">
        <artwork align="center"><![CDATA[
2^31 / B  > MSL (secs)                     [1]
        ]]></artwork>
      </figure>
      </t>
      <t>The following table shows the value for Twrap = 2^31/B in
      seconds, for some important values of the bandwidth B:
      </t>
        <texttable  title="">
          <ttcol align='center'>Network</ttcol>
          <ttcol align='center'>bits/sec</ttcol>
          <ttcol align='center'>B bytes/sec</ttcol>
          <ttcol align='center'>Twrap secs</ttcol>
          <c>Dialup</c>
          <c>&nbsp;56kbps</c>
          <c>&nbsp;&nbsp; 7kBps</c>
          <c>3*10^5 (~3.6 days)</c>
    
          <c>DS1</c>
          <c>1.5Mbps</c>
          <c>&nbsp;190kBps</c>
          <c>10^4 (~3 hours)</c>
    
          <c>10MBit Ethernet</c>
          <c>&nbsp;10Mbps</c>
          <c>1.25MBps</c>
          <c>1700 (~0.5 hours)</c>
    
          <c>DS3</c>
          <c>&nbsp;45Mbps</c>
          <c>&nbsp;5.6MBps</c>
          <c>380</c>
    
          <c>100MBit Ethernet</c>
          <c>100Mbps</c>
          <c>12.5MBps</c>
          <c>170</c>
    
          <c>Gigabit Ethernet</c>
          <c>&nbsp; 1Gbps</c>
          <c>&nbsp;125MBps</c>
          <c>17</c>
    
          <c>10Gig Ethernet</c>
          <c>&nbsp;10Gbps</c>
          <c>1.25GBps</c>
          <c>1.7</c>
        </texttable>
      
      <t>It is clear that wrap-around of the sequence space is not a
      problem for 56kbps packet switching or even 10Mbps Ethernets.  On
      the other hand, at DS3 and 100mbit speeds, Twrap is comparable to
      the 2 minute MSL assumed by the TCP specification <xref target="RFC0793"/>.
      Moving towards and beyond gigabit speeds, Twrap becomes too small
      for reliable enforcement by the Internet TTL mechanism.
      </t>
      <t>The 16-bit window field of TCP limits the effective bandwidth B to
      2^16/RTT, where RTT is the round-trip time in seconds
      <xref target="RFC1110"/><!--xref target="McKenzie89"/-->.  
      If the RTT is large enough, this limits B to a
      value that meets the constraint [1] for a large MSL value.  For
      example, consider a transcontinental backbone with an RTT of 60ms
      (set by the laws of physics).  With the bandwidth*delay product
      limited to 64KB by the TCP window size, B is then limited to
      1.1MBps, no matter how high the theoretical transfer rate of the
      path.  This corresponds to cycling the sequence number space in
      Twrap = 2000 secs, which is safe in today's Internet.
      </t>
      <t>It is important to understand that the culprit is not the larger
      window but rather the high bandwidth.  For example, consider a
      (very large) FDDI LAN with a diameter of 10km.  Using the speed of
      light, we can compute the RTT across the ring as
      (2*10^4)/(3*10^8) = 67 microseconds, and the delay*bandwidth
      product is then 833 bytes.  A TCP connection across this LAN using
      a window of only 833 bytes will run at the full 100mbps and can
      wrap the sequence space in about 3 minutes, very close to the MSL
      of TCP.  Thus, high speed alone can cause a reliability problem
      with sequence number wrap-around, even without extended windows.
      </t>
      <t>Watson's Delta-T protocol <xref target="Watson81"/> includes network-layer
      mechanisms for precise enforcement of an MSL.  In contrast, the IP
      mechanism for MSL enforcement is loosely defined and even more
      loosely implemented in the Internet.  Therefore, it is unwise to
      depend upon active enforcement of MSL for TCP connections, and it
      is unrealistic to imagine setting MSL's smaller than the current
      values (e.g., 120 seconds specified for TCP).
      </t>
      <t>A possible fix for the problem of cycling the sequence space would
      be to increase the size of the TCP sequence number field.  For
      example, the sequence number field (and also the acknowledgment
      field) could be expanded to 64 bits.  This could be done either by
      changing the TCP header or by means of an additional option.
      </t>
      <t><xref target="sec4"/> presents a different mechanism, which we call PAWS
      (Protect Against Wrapped Sequence numbers), to extend TCP
      reliability to transfer rates well beyond the foreseeable upper
      limit of network bandwidths.  PAWS uses the TCP Timestamps option
      defined in <xref target="sec32"/> to protect against old duplicates from the
      same connection.
      </t>
    </section>
    <section anchor="sec13" title="Using TCP options">
    	<t>The extensions defined in this memo all use new TCP options.  We
      must address two possible issues concerning the use of TCP
      options: (1) compatibility and (2) overhead.
      </t>
      <t>We must pay careful attention to compatibility, i.e., to
      interoperation with existing implementations.  The only TCP option
      defined previously, MSS, may appear only on a SYN segment.  Every
      implementation should (and we expect that most will) ignore
      unknown options on SYN segments.  When RFC 1323 was published,
      there was concern that some buggy TCP implementation might be
      crashed by the first appearance of an option on a non-SYN segment.
      However, bugs like that can lead to DOS attacks against a TCP, so
      it is now expected that most TCP implementations will properly
      handle unknown options on non-SYN segments.  But it is still
      prudent to be conservative in what you send, and avoiding buggy
      TCP implementation is not the only reason for negotiating TCP
      options on SYN segments.  Therefore, for each of the extensions
      defined below, TCP options will be sent on non-SYN segments only
      after an exchange of options on the the SYN segments has indicated
      that both sides understand the extension.  Furthermore, an
      extension option will be sent in a &lt;SYN,ACK&gt; segment only if the
      corresponding option was received in the initial &lt;SYN&gt; segment.
      </t>
      <t>A question may be raised about the bandwidth and processing
      overhead for TCP options.  Those options that occur on SYN
      segments are not likely to cause a performance concern.  Opening a
      TCP connection requires execution of significant special-case
      code, and the processing of options is unlikely to increase that
      cost significantly.
      </t>
      <t>On the other hand, a Timestamps option may appear in any data or
      ACK segment, adding 12 bytes to the 20-byte TCP header.  We
      believe that the bandwidth saved by reducing unnecessary
      retransmissions will more than pay for the extra header bandwidth.
      </t>
      <t>There is also an issue about the processing overhead for parsing
      the variable byte-aligned format of options, particularly with a
      RISC-architecture CPU.  <xref target="AppA"/> contains a recommended layout
      of the options in TCP headers to achieve reasonable data field
      alignment.  In the spirit of Header Prediction, a TCP can quickly
      test for this layout and if it is verified then use a fast path.
      Hosts that use this canonical layout will effectively use the
      options as a set of fixed-format fields appended to the TCP
      header.  However, to retain the philosophical and protocol
      framework of TCP options, a TCP must be prepared to parse an
      arbitrary options field, albeit with less efficiency.
      </t>
      <t>Finally, we observe that most of the mechanisms defined in this
      memo are important for LFN's and/or very high-speed networks.  For
      low-speed networks, it might be a performance optimization to NOT
      use these mechanisms.  A TCP vendor concerned about optimal
      performance over low-speed paths might consider turning these
      extensions off for low-speed paths, or allow a user or
      installation manager to disable them.
      </t>
    </section>
	</section>
	
	<section anchor="sec2" title="TCP Window Scale Option">
		<section anchor="sec21" title="Introduction">
			<t>The window scale extension expands the definition of the TCP
      window to 32 bits and then uses a scale factor to carry this
      32-bit value in the 16-bit Window field of the TCP header (SEG.WND
      in RFC 793).  The scale factor is carried in a new TCP option,
      Window Scale.  This option is sent only in a SYN segment (a
      segment with the SYN bit on), hence the window scale is fixed in
      each direction when a connection is opened.  (Another design
      choice would be to specify the window scale in every TCP segment.
      It would be incorrect to send a window scale option only when the
      scale factor changed, since a TCP option in an acknowledgement
      segment will not be delivered reliably (unless the ACK happens to
      be piggy-backed on data in the other direction).  Fixing the scale
      when the connection is opened has the advantage of lower overhead
      but the disadvantage that the scale factor cannot be changed
      during the connection.)
      </t>
      <t>The maximum receive window, and therefore the scale factor, is
      determined by the maximum receive buffer space.  In a typical
      modern implementation, this maximum buffer space is set by default
      but can be overridden by a user program before a TCP connection is
      opened.  This determines the scale factor, and therefore no new
      user interface is needed for window scaling.
      </t>
		</section>
		<section anchor="sec22" title="Window Scale Option">
			<t>The three-byte Window Scale option may be sent in a SYN segment by
      a TCP.  It has two purposes: (1) indicate that the TCP is prepared
      to do both send and receive window scaling, and (2) communicate a
      scale factor to be applied to its receive window.  Thus, a TCP
      that is prepared to scale windows should send the option, even if
      its own scale factor is 1.  The scale factor is limited to a power
      of two and encoded logarithmically, so it may be implemented by
      binary shift operations.
      </t>
      <t>TCP Window Scale Option (WSopt):
      <figure align="center">
        <artwork align="center"><![CDATA[
Kind: 3

Length: 3 bytes

       +---------+---------+---------+
       | Kind=3  |Length=3 |shift.cnt|
       +---------+---------+---------+
        ]]></artwork>
      </figure>
      </t>
      <t>This option is an offer, not a promise; both sides must send
         Window Scale options in their SYN segments to enable window
         scaling in either direction.  If window scaling is enabled,
         then the TCP that sent this option will right-shift its true
         receive-window values by 'shift.cnt' bits for transmission in
         SEG.WND.  The value 'shift.cnt' may be zero (offering to scale,
         while applying a scale factor of 1 to the receive window).
       </t>
       <t>This option may be sent in an initial &lt;SYN&gt; segment (i.e., a
         segment with the SYN bit on and the ACK bit off).  It may also
         be sent in a &lt;SYN,ACK&gt; segment, but only if a Window Scale
         option was received in the initial &lt;SYN&gt; segment.  A Window
         Scale option in a segment without a SYN bit should be ignored.
       </t>
       <t>The Window field in a SYN (i.e., a &lt;SYN&gt; or &lt;SYN,ACK&gt;) 
       	segment itself is never scaled.
       </t>
      
		</section>
		<section anchor="sec23" title="Using the Window Scale Option">
			<t>A model implementation of window scaling is as follows, using the
      notation of <xref target="RFC0793"/><!--xref target="Postel81"/-->:
        <list style="symbols">
        	<t>All windows are treated as 32-bit quantities for storage in
           the connection control block and for local calculations.
           This includes the send-window (SND.WND) and the receive-
           window (RCV.WND) values, as well as the congestion window.
          </t>
          <t>The connection state is augmented by two window shift counts,
           Snd.Wind.Scale and Rcv.Wind.Scale, to be applied to the
           incoming and outgoing window fields, respectively.
          </t>
          <t>If a TCP receives a &lt;SYN&gt; segment containing a Window Scale
           option, it sends its own Window Scale option in the &lt;SYN,ACK&gt;
           segment.
          </t>
          <t>The Window Scale option is sent with shift.cnt = R, where R
           is the value that the TCP would like to use for its receive
           window.
          </t>
          <t>Upon receiving a SYN segment with a Window Scale option
           containing shift.cnt = S, a TCP sets Snd.Wind.Scale to S and
           sets Rcv.Wind.Scale to R; otherwise, it sets both
           Snd.Wind.Scale and Rcv.Wind.Scale to zero.
          </t>
          <t>The window field (SEG.WND) in the header of every incoming
           segment, with the exception of SYN segments, is left-shifted
           by Snd.Wind.Scale bits before updating SND.WND:
           <figure align="center">
            <artwork align="center"><![CDATA[
SND.WND = SEG.WND << Snd.Wind.Scale            	
            ]]></artwork>
           </figure>
           (assuming the other conditions of RFC 793 are met, and using
           the "C" notation "&lt;&lt;" for left-shift).
          </t>
          <t>The window field (SEG.WND) of every outgoing segment, with
           the exception of SYN segments, is right-shifted by
           Rcv.Wind.Scale bits:
           <figure align="center">
            <artwork align="center"><![CDATA[
SND.WND = RCV.WND >> Rcv.Wind.Scale            	
            ]]></artwork>
           </figure>
          </t>
        </list>
      </t>
      <t>TCP determines if a data segment is "old" or "new" by testing
      whether its sequence number is within 2^31 bytes of the left edge
      of the window, and if it is not, discarding the data as "old".  To
      insure that new data is never mistakenly considered old and vice-
      versa, the left edge of the sender's window has to be at most
      2^31 away from the right edge of the receiver's window.
      Similarly with the sender's right edge and receiver's left edge.
      Since the right and left edges of either the sender's or
      receiver's window differ by the window size, and since the sender
      and receiver windows can be out of phase by at most the window
      size, the above constraints imply that 2 * the max window size
      must be less than 2^31, or
      <figure align="center">
        <artwork align="center"><![CDATA[
max window < 2^30
        ]]></artwork>
      </figure>
      </t>
      <t>Since the max window is 2^S (where S is the scaling shift count)
      times at most 2^16 - 1 (the maximum unscaled window), the maximum
      window is guaranteed to be &lt; 2*30 if S &lt;= 14.  Thus, the shift
      count must be limited to 14 (which allows windows of 2^30 = 1
      Gbyte).  If a Window Scale option is received with a shift.cnt
      value exceeding 14, the TCP should log the error but use 14
      instead of the specified value.
      </t>
      <t>The scale factor applies only to the Window field as transmitted
      in the TCP header; each TCP using extended windows will maintain
      the window values locally as 32-bit numbers.  For example, the
      "congestion window" computed by Slow Start and Congestion
      Avoidance is not affected by the scale factor, so window scaling
      will not introduce quantization into the congestion window.
      </t>
    </section>
    <section anchor="sec24" title="Addressing Window Retraction">
      <t>When a non-zero scale factor is in use, there are instances when a
      retracted window can be offered <xref target="Mathis08"/>.  
      The end of the window
      will be on a boundary based on the granularity of the scale factor
      being used.  If the sequence number is then updated by a number of
      bytes smaller than that granularity, the TCP will have to either
      advertise a new window that is beyond what it previously advertised
      (and perhaps beyond the buffer), or will have to advertise a
      smaller window, which will cause the TCP window to shrink.
      Implementations should ensure that they handle a shrinking window,
      as specified in section 4.2.2.16 of 
      <xref target="RFC1122"/><!--xref target="Braden89"/-->.
      </t>
      <t>For the receiver, this implies that:
      	<list style="format %d)" counter="WinRetract">
      		<t>The receiver MUST honor, as in-window, any segment that 
      			would have been in-window for any ACK sent by the receiver.
      		</t>
      		<t>When window scaling is in effect, the receiver SHOULD 
      			track the actual maximum window sequence number (which is 
      			likely to be greater than the window announced by the most 
      			recent ACK, if more than one segment has arrived since the 
      			application consumed any data in the receive buffer).
      		</t>
        </list>
      On the sender side:
        <list style="format %d)" counter="WinRetract">
       	  <t>The initial transmission MUST honor window on most recent ACK.
        	</t>
        	<t>On first retransmission, or if it is out-of-window by less 
       	  	than (2^Rcv.Wind.Scale) then do normal retransmission(s) without 
       	  	regard to receiver window as long as the original segment was in 
        	 	window when it was sent.
        	</t>
       	  <t>On subsequent retransmissions, treat it as zero window probes.
        	</t>
        </list>
      </t>
		</section>
	</section>
	
	<section anchor="sec3" title="RTTM -- Round-Trip Time Measurement">
		<section anchor="sec31" title="Introduction">
			<t>Accurate and current RTT estimates are necessary to adapt to
      changing traffic conditions and to avoid an instability known as
      "congestion collapse" 
      <xref target="RFC0896"/><!--xref target="Nagle84"/--> 
      in a busy network.  However,
      accurate measurement of RTT may be difficult both in theory and in
      implementation.
      </t>
      <t>Many TCP implementations base their RTT measurements upon a sample
      of one packet per window or less.  While this yields an adequate
      approximation to the RTT for small windows, it results in an
      unacceptably poor RTT estimate for an LFN.  If we look at RTT
      estimation as a signal processing problem (which it is), a data
      signal at some frequency, the packet rate, is being sampled at a
      lower frequency, the window rate.  This lower sampling frequency
      violates Nyquist's criteria and may therefore introduce "aliasing"
      artifacts into the estimated RTT <xref target="Hamming77"/>.
      </t>
      <t>A good RTT estimator with a conservative retransmission timeout
      calculation can tolerate aliasing when the sampling frequency is
      "close" to the data frequency.   For example, with a window of 8
      packets, the sample rate is 1/8 the data frequency -- less than an
      order of magnitude different.  However, when the window is tens or
      hundreds of packets, the RTT estimator may be seriously in error,
      resulting in spurious retransmissions.
      </t>
      <t>If there are dropped packets, the problem becomes worse.  Zhang
      <xref target="Zhang86"/>, Jain <xref target="Jain86"/> 
      and Karn <xref target="Karn87"/> have shown that it is
      not possible to accumulate reliable RTT estimates if retransmitted
      segments are included in the estimate.  Since a full window of
      data will have been transmitted prior to a retransmission, all of
      the segments in that window will have to be ACKed before the next
      RTT sample can be taken.  This means at least an additional
      window's worth of time between RTT measurements and, as the error
      rate approaches one per window of data (e.g., 10^-6 errors per
      bit for the Wideband satellite network), it becomes effectively
      impossible to obtain a valid RTT measurement.
      </t>
      <t>A solution to these problems, which actually simplifies the sender
      substantially, is as follows: using TCP options, the sender places
      a timestamp in each data segment, and the receiver reflects these
      timestamps back in ACK segments.  Then a single subtract gives the
      sender an accurate RTT measurement for every ACK segment (which
      will correspond to every other data segment, with a sensible
      receiver).  We call this the RTTM (Round-Trip Time Measurement)
      mechanism.
      </t>
      <t>It is vitally important to use the RTTM mechanism with big
      windows; otherwise, the door is opened to some dangerous
      instabilities due to aliasing.  Furthermore, the option is
      probably useful for all TCP's, since it simplifies the sender.
      </t>
		</section>
		<section anchor="sec32" title="TCP Timestamps Option">
			<t>TCP is a symmetric protocol, allowing data to be sent at any time
      in either direction, and therefore timestamp echoing may occur in
      either direction.  For simplicity and symmetry, we specify that
      timestamps always be sent and echoed in both directions.  For
      efficiency, we combine the timestamp and timestamp reply fields
      into a single TCP Timestamps Option.
      </t>
      <t>TCP Timestamps Option (TSopt):
      	<figure align="center">
        <artwork align="center"><![CDATA[
Kind: 8

Length: 10 bytes

 +-------+-------+---------------------+---------------------+
 |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
 +-------+-------+---------------------+---------------------+
     1       1              4                     4
        ]]></artwork>
      </figure>
    </t>  
    <t>The Timestamps option carries two four-byte timestamp fields.
         The Timestamp Value field (TSval) contains the current value of
         the timestamp clock of the TCP sending the option.
    </t>
    <t>The Timestamp Echo Reply field (TSecr) is valid if the ACK bit
         is set in the TCP header; if it is valid, it echos a timestamp
         value that was sent by the remote TCP in the TSval field of a
         Timestamps option.  When TSecr is not valid, its value must be
         zero. However, a value of zero does not imply TSecr being 
         invalid. The TSecr value will generally be from the most recent
         Timestamp option that was received; however, there are
         exceptions that are explained below.
     </t>
     <t>A TCP may send the Timestamps option (TSopt) in an initial
         &lt;SYN&gt; segment (i.e., a segment containing a SYN bit and no ACK
         bit). <!--, and may send a TSopt in other segments only if it
         received a TSopt in the initial &lt;SYN&gt; or &lt;SYN,ACK&gt; segment for
         the connection.-->  Once a TSopt has been sent or received in a
         non &lt;SYN&gt; segment, it must be sent in all segments.  Once a
         TSopt has been received in a non &lt;SYN&gt; segment, then any
         successive segment that is received without the RST bit and
         without a TSopt may be dropped without further processing, and an
         ACK of the current SND.UNA generated.
     </t>
     <t>In the case of crossing SYN packets where one SYN contains a
         TSopt and the other doesn't, both sides should put a TSopt in
         the &lt;SYN,ACK&gt; segment.
     </t>
    
		</section>
		<section anchor="sec33" title="The RTTM Mechanism">
			<t>RTTM places a Timestamps option in every segment, with a TSval
      that is obtained from a (virtual) "timestamp clock".  Values of
      this clock values must be at least approximately proportional to
      real time, in order to measure actual RTT.
      </t>
      <t>These TSval values are echoed in TSecr values in the reverse
      direction.  The difference between a received TSecr value and the
      current timestamp clock value provides an RTT measurement.
      </t>
      <t>When timestamps are used, every segment that is received will
      contain a TSecr value; however, these values cannot all be used to
      update the measured RTT.  The following example illustrates why.
      It shows a one-way data flow with segments arriving in sequence
      without loss.  Here A, B, C... represent data blocks occupying
      successive blocks of sequence numbers, and ACK(A),...  represent
      the corresponding cumulative acknowledgments.  The two timestamp
      fields of the Timestamps option are shown symbolically as 
      &lt;TSval=x,TSecr=y&gt;.  Each TSecr field contains the value most recently
      received in a TSval field.
      </t>
     	<figure align="center">
        <artwork align="center"><![CDATA[
TCP  A                                          TCP B

              <A,TSval=1,TSecr=120> ------>

    <---- <ACK(A),TSval=127,TSecr=1>

              <B,TSval=5,TSecr=127> ------>

    <---- <ACK(B),TSval=131,TSecr=5>

  . . . . . . . . . . . . . . . . . . . . . .

             <C,TSval=65,TSecr=131> ------>

    <---- <ACK(C),TSval=191,TSecr=65>

                    (etc)
        ]]></artwork>
      </figure>
      <t>The dotted line marks a pause (60 time units long) in which A had
      nothing to send.  Note that this pause inflates the RTT which B
      could infer from receiving TSecr=131 in data segment C.  Thus, in
      one-way data flows, RTTM in the reverse direction measures a value
      that is inflated by gaps in sending data.  However, the following
      rule prevents a resulting inflation of the measured RTT:
      <list style="empty">
      	<t>RTTM Rule: A TSecr value received in a segment is used to
           update the averaged RTT measurement only if 
           <list style="format %c)">
           	 <t>the segment acknowledges some new data, i.e., only if 
           	 	it advances the left edge of the send window, and
           	 </t>
           	 <t>the segment does not indicate any loss or reordering,
           	 	i.e. contains SACK options
           	 </t>
           </list>
        </t>
      </list>
      </t>
      <t>Since TCP B is not sending data, the data segment C does not
      acknowledge any new data when it arrives at B.  Thus, the inflated
      RTTM measurement is not used to update B's RTTM measurement.
      </t>
      <t>Implementors should note that with Timestamps multiple RTTMs can
      be taken per RTT.  Many RTO estimators have a weighting factor
      based on an implicit assumption that at most one RTTM will be
      gotten per RTT.  When using multiple RTTMs per RTT to update the
      RTO estimator, the weighting factor needs to be decreased to take
      into account the more frequent RTTMs.  For example, an
      implementation could choose to just use one sample per RTT to
      update the RTO estimator, or or vary the gain based on the
      congestion window, or take an average of all the RTTM measurements
      received over one RTT, and then use that value to update the RTO
      estimator.  This document does not prescribe any particular method
      for modifying the RTO estimator, the important point is that the
      implementation should do something more than just feeding
      additional RTTM samples from one RTT into the RTO estimator.
      </t>

		</section>
		<section anchor="sec34" title="Which Timestamp to Echo">
			<!--<t>### Add text for SACK synergy?</t>-->
			<t>If more than one Timestamps option is received before a reply
      segment is sent, the TCP must choose only one of the TSvals to
      echo, ignoring the others.  To minimize the state kept in the
      receiver (i.e., the number of unprocessed TSvals), the receiver
      should be required to retain at most one timestamp in the
      connection control block.
      </t>
      <t>There are three situations to consider:
        <list style="format (%C)">
        	<t>Delayed ACKs.
        		<vspace blankLines="1"/>
           Many TCP's acknowledge only every Kth segment out of a group
           of segments arriving within a short time interval; this
           policy is known generally as "delayed ACKs".  The data-sender
           TCP must measure the effective RTT, including the additional
           time due to delayed ACKs, or else it will retransmit
           unnecessarily.  Thus, when delayed ACKs are in use, the
           receiver should reply with the TSval field from the earliest
           unacknowledged segment.
          </t>
          <t>A hole in the sequence space (segment(s) have been lost).
          	<vspace blankLines="1"/>
           The sender will continue sending until the window is filled,
           and the receiver may be generating ACKs as these out-of-order
           segments arrive (e.g., to aid "fast retransmit").
           <vspace blankLines="1"/>
           The lost segment is probably a sign of congestion, and in
           that situation the sender should be conservative about
           retransmission.  Furthermore, it is better to overestimate
           than underestimate the RTT.  An ACK for an out-of-order
           segment should therefore contain the timestamp from the most
           recent segment that advanced the window.
           <vspace blankLines="1"/>
           The same situation occurs if segments are re-ordered by the
           network.
          </t>
          <t>A filled hole in the sequence space.
          	<vspace blankLines="1"/>
           The segment that fills the hole represents the most recent
           measurement of the network characteristics.  On the other
           hand, an RTT computed from an earlier segment would probably
           include the sender's retransmit time-out, badly biasing the
           sender's average RTT estimate.  Thus, the timestamp from the
           latest segment (which filled the hole) must be echoed.
          </t>
        </list>
      </t>
      <t>An algorithm that covers all three cases is described in the
      following rules for Timestamps option processing on a synchronized
      connection:
        <list style="format (%d)">
        	<t>The connection state is augmented with two 32-bit slots:
        		<vspace blankLines="1"/>
           TS.Recent holds a timestamp to be echoed in TSecr whenever a
           segment is sent, and Last.ACK.sent holds the ACK field from
           the last segment sent.  Last.ACK.sent will equal RCV.NXT
           except when ACKs have been delayed.
         </t>
         <t>If:
						<figure align="center">
        			<artwork align="center"><![CDATA[
SEG.TSval >= TSrecent and SEG.SEQ <= Last.ACK.sent
              ]]></artwork>
            </figure>
           then SEG.TSval is copied to TS.Recent; otherwise, it is
           ignored.
         </t>
         <t>When a TSopt is sent, its TSecr field is set to the current
           TS.Recent value.
         </t>
       </list>
     </t>
     <t>The following examples illustrate these rules.  Here A, B, C...
      represent data segments occupying successive blocks of sequence
      numbers, and ACK(A),...  represent the corresponding
      acknowledgment segments.  Note that ACK(A) has the same sequence
      number as B.  We show only one direction of timestamp echoing, for
      clarity.
      <list style="symbols">
      	<t>Packets arrive in sequence, and some of the ACKs are delayed.
      		<vspace blankLines="1"/>
					 By Case (A), the timestamp from the oldest unacknowledged
           segment is echoed.
						<figure align="center">
        			<artwork align="center"><![CDATA[

                                  TS.Recent
<A, TSval=1> ------------------->
                                      1
<B, TSval=2> ------------------->
                                      1
<C, TSval=3> ------------------->
                                      1
         <---- <ACK(C), TSecr=1>
(etc)
              ]]></artwork>
            </figure>
        </t>
        <t>Packets arrive out of order, and every packet is
           acknowledged.
        	<vspace blankLines="1"/>
           By Case (B), the timestamp from the last segment that
           advanced the left window edge is echoed, until the missing
           segment arrives; it is echoed according to Case (C).  The
           same sequence would occur if segments B and D were lost and
           retransmitted..
						<figure align="center">
        			<artwork align="center"><![CDATA[
                                  TS.Recent
<A, TSval=1> ------------------->
                                      1
         <---- <ACK(A), TSecr=1>
                                      1
<C, TSval=3> ------------------->
                                      1
         <---- <ACK(A), TSecr=1>
                                      1
<B, TSval=2> ------------------->
                                      2
         <---- <ACK(C), TSecr=2>
                                      2
<E, TSval=5> ------------------->
                                      2
         <---- <ACK(C), TSecr=2>
                                      2
<D, TSval=4> ------------------->
                                      4
         <---- <ACK(E), TSecr=4>
(etc)
              ]]></artwork>
            </figure>
          </t>
        </list>
      </t>


		</section>
	</section>
	
	<section anchor="sec4" title="PAWS -- Protection Against Wrapped Sequence Numbers">
	  <section anchor="sec41" title="Introduction">
	  	<t><xref target="sec42"/>describes a simple mechanism to reject old duplicate
      segments that might corrupt an open TCP connection; we call this
      mechanism PAWS (Protection Against Wrapped Sequence numbers).
      PAWS operates within a single TCP connection, using state that is
      saved in the connection control block.  <xref target="sec43"/> and 
      <xref target="AppC"/>
      discuss the implications of the PAWS mechanism for avoiding old
      duplicates from previous incarnations of the same connection.
      </t>
	  </section>
	  <section anchor="sec42" title="The PAWS Mechanism">
	  	<t>PAWS uses the same TCP Timestamps option as the RTTM mechanism
      described earlier, and assumes that every received TCP segment
      (including data and ACK segments) contains a timestamp SEG.TSval
      whose values are monotonically non-decreasing in time.  The basic
      idea is that a segment can be discarded as an old duplicate if it
      is received with a timestamp SEG.TSval less than some timestamp
      recently received on this connection.
      </t>
      <t>In both the PAWS and the RTTM mechanism, the "timestamps" are
      32-bit unsigned integers in a modular 32-bit space.  Thus, "less
      than" is defined the same way it is for TCP sequence numbers, and
      the same implementation techniques apply.  If s and t are
      timestamp values, 
      
	   			<figure align="center">
      			<artwork align="center"><![CDATA[
s < t  if 0 < (t - s) < 2^31, 
           ]]></artwork>
          </figure>
      computed in unsigned 32-bit arithmetic.
      </t>
      <t>The choice of incoming timestamps to be saved for this comparison
      must guarantee a value that is monotonically increasing.  For
      example, we might save the timestamp from the segment that last
      advanced the left edge of the receive window, i.e., the most
      recent in-sequence segment.  Instead, we choose the value
      TS.Recent introduced in <xref target="sec34"/> for the RTTM mechanism, since
      using a common value for both PAWS and RTTM simplifies the
      implementation of both.  As <xref target="sec34"/> explained, TS.Recent
      differs from the timestamp from the last in-sequence segment only
      in the case of delayed ACKs, and therefore by less than one
      window.  Either choice will therefore protect against sequence
      number wrap-around.
      </t>
      <t>RTTM was specified in a symmetrical manner, so that TSval
      timestamps are carried in both data and ACK segments and are
      echoed in TSecr fields carried in returning ACK or data segments.
      PAWS submits all incoming segments to the same test, and therefore
      protects against duplicate ACK segments as well as data segments.
      (An alternative non-symmetric algorithm would protect against old
      duplicate ACKs: the sender of data would reject incoming ACK
      segments whose TSecr values were less than the TSecr saved from
      the last segment whose ACK field advanced the left edge of the
      send window.  This algorithm was deemed to lack economy of
      mechanism and symmetry.)
      </t>
      <t>TSval timestamps sent on &gt;SYN&lt; and &gt;SYN,ACK&lt; segments are used to
      initialize PAWS.  PAWS protects against old duplicate non-SYN
      segments, and duplicate SYN segments received while there is a
      synchronized connection.  Duplicate &gt;SYN&lt; and &gt;SYN,ACK&lt; segments
      received when there is no connection will be discarded by the
      normal 3-way handshake and sequence number checks of TCP.
      </t>
      <t>RFC 1323 recommended that RST segments NOT carry timestamps, and
      that they be acceptable regardless of their timestamp.  At that
      time, the thinking was that old duplicate RST segments should be
      exceedingly unlikely, and their cleanup function should take
      precedence over timestamps.  More recently, discussion about
      various blind attacks on TCP connections have raised the
      suggestion that if the Timestamps option is present, SEG.TSecr
      could be used to provide stricter acceptance tests for RST
      packets.  While still under discussion, to enable research into
      this area it is now recommended that when generating a RST, that
      if the packet causing the RST to be generated contained a
      Timestamps option that the RST also contain a Timestamps option.
      In the RST segment, SEG.TSecr should be set to SEG.TSval from the
      incoming packet and SEG.TSval should be set to zero.  If a RST is
      being generated because of a user abort, and Snd.TS.OK is set,
      then a Timestamps option should be included in the RST.  When a
      RST packet is received, it must not be subjected to PAWS checks,
      and information from the Timestamps option must not be use to
      update connection state information.  SEG.TSecr may be used to
      provide stricter RST acceptance checks.
      </t>

	  	<section anchor="sec421" title="Basic PAWS Algorithm">
	  		<t>The PAWS algorithm requires the following processing to be
         performed on all incoming segments for a synchronized
         connection:
          <list style="format R%d)">
          	<t>If there is a Timestamps option in the arriving segment,
              SEG.TSval &lt; TS.Recent, TS.Recent is valid (see later
              discussion) and the RST bit is not set, then treat the
              arriving segment as not acceptable:
              <list style="empty">
              	<t>Send an acknowledgement in reply as specified in RFC
                   793 page 69 and drop the segment.
                </t>
                <t>Note: it is necessary to send an ACK segment in order
                   to retain TCP's mechanisms for detecting and
                   recovering from half-open connections.  For example,
                   see Figure 10 of RFC 793.
                </t>
              </list>
            </t>
            <t>If the segment is outside the window, reject it (normal
              TCP processing)
            </t>
            <t>If an arriving segment satisfies: SEG.SEQ &lt;= Last.ACK.sent
              (see <xref target="sec34"/>), then record its timestamp in 
              TS.Recent.
            </t>
            <t>If an arriving segment is in-sequence (i.e., at the left
              window edge), then accept it normally.
            </t>
            <t>Otherwise, treat the segment as a normal in-window, out-
              of-sequence TCP segment (e.g., queue it for later delivery
              to the user).
            </t>
          </list>
        </t>
        <t>Steps R2, R4, and R5 are the normal TCP processing steps
         specified by RFC 793.
        </t>
        <t>It is important to note that the timestamp is checked only when
         a segment first arrives at the receiver, regardless of whether
         it is in-sequence or it must be queued for later delivery.
        </t>
        <t>Consider the following example.
        	<list style="empty">
        		<t>Suppose the segment sequence: A.1, B.1, C.1, ..., Z.1 has
              been sent, where the letter indicates the sequence number
              and the digit represents the timestamp.  Suppose also that
              segment B.1 has been lost.  The timestamp in TS.TStamp is
              1 (from A.1), so C.1, ..., Z.1 are considered acceptable
              and are queued.  When B is retransmitted as segment B.2
              (using the latest timestamp), it fills the hole and causes
              all the segments through Z to be acknowledged and passed
              to the user.  The timestamps of the queued segments are
              *not* inspected again at this time, since they have
              already been accepted.  When B.2 is accepted, TS.Stamp is
              set to 2.
            </t>
          </list>
        </t>
        <t>This rule allows reasonable performance under loss.  A full
         window of data is in transit at all times, and after a loss a
         full window less one packet will show up out-of-sequence to be
         queued at the receiver (e.g., up to ~2^30 bytes of data); the
         timestamp option must not result in discarding this data.
        </t>
        <t>In certain unlikely circumstances, the algorithm of rules R1-R5
         could lead to discarding some segments unnecessarily, as shown
         in the following example:
          <list style="empty">
          	<t>Suppose again that segments: A.1, B.1, C.1, ..., Z.1 have
              been sent in sequence and that segment B.1 has been lost.
              Furthermore, suppose delivery of some of C.1, ... Z.1 is
              delayed until AFTER the retransmission B.2 arrives at the
              receiver.  These delayed segments will be discarded
              unnecessarily when they do arrive, since their timestamps
              are now out of date.
            </t>
          </list>
        </t>
        <t>This case is very unlikely to occur.  If the retransmission was
         triggered by a timeout, some of the segments C.1, ... Z.1 must
         have been delayed longer than the RTO time.  This is presumably
         an unlikely event, or there would be many spurious timeouts and
         retransmissions.  If B's retransmission was triggered by the
         "fast retransmit" algorithm, i.e., by duplicate ACKs, then the
         queued segments that caused these ACKs must have been received
         already.
        </t>
        <t>Even if a segment were delayed past the RTO, the Fast
         Retransmit mechanism <xref target="Jacobson90c"/> will cause the delayed
         packets to be retransmitted at the same time as B.2, avoiding
         an extra RTT and therefore causing a very small performance
         penalty.
        </t>
        <t>We know of no case with a significant probability of occurrence
         in which timestamps will cause performance degradation by
         unnecessarily discarding segments.
        </t>
	  	</section>
	  	<section anchor="sec422" title="Timestamp Clock">
	  		<t>It is important to understand that the PAWS algorithm does not
         require clock synchronization between sender and receiver.  The
         sender's timestamp clock is used to stamp the segments, and the
         sender uses the echoed timestamp to measure RTT's.  However,
         the receiver treats the timestamp as simply a monotonically
         increasing serial number, without any necessary connection to
         its clock.  From the receiver's viewpoint, the timestamp is
         acting as a logical extension of the high-order bits of the
         sequence number.
        </t>
        <t>The receiver algorithm does place some requirements on the
         frequency of the timestamp clock.
          <list style="format (%c)">
          	<t>The timestamp clock must not be "too slow".
          		<vspace blankLines="1"/>
              It must tick at least once for each 2^31 bytes sent.  In
              fact, in order to be useful to the sender for round trip
              timing, the clock should tick at least once per window's
              worth of data, and even with the window extension defined
              in <xref target="sec22"/>, 2^31 bytes must be at least two 
              windows.
          		<vspace blankLines="1"/>
              To make this more quantitative, any clock faster than 1
              tick/sec will reject old duplicate segments for link
              speeds of ~8 Gbps.  A 1ms timestamp clock will work at
              link speeds up to 8 Tbps (8*10^12) bps!
            </t>
            <t>The timestamp clock must not be "too fast".
          		<vspace blankLines="1"/>
              Its recycling time must be greater than MSL seconds.
              Since the clock (timestamp) is 32 bits and the worst-case
              MSL is 255 seconds, the maximum acceptable clock frequency
              is one tick every 59 ns.
          		<vspace blankLines="1"/>
              However, it is desirable to establish a much longer
              recycle period, in order to handle outdated timestamps on
              idle connections (see <xref target="sec423"/>), and to 
              relax the MSL
              requirement for preventing sequence number wrap-around.
              With a 1 ms timestamp clock, the 32-bit timestamp will
              wrap its sign bit in 24.8 days.  Thus, it will reject old
              duplicates on the same connection if MSL is 24.8 days or
              less.  This appears to be a very safe figure; an MSL of
              24.8 days or longer can probably be assumed by the gateway
              system without requiring precise MSL enforcement by the
              TTL value in the IP layer.
            </t>
          </list>
        </t>
        <t>Based upon these considerations, we choose a timestamp clock
         frequency in the range 1 ms to 1 sec per tick.  This range also
         matches the requirements of the RTTM mechanism, which does not
         need much more resolution than the granularity of the
         retransmit timer, e.g., tens or hundreds of milliseconds.
        </t>
        <t>The PAWS mechanism also puts a strong monotonicity requirement
         on the sender's timestamp clock.  The method of implementation
         of the timestamp clock to meet this requirement depends upon
         the system hardware and software.
          <list style="symbols">
          	<t>Some hosts have a hardware clock that is guaranteed to be
              monotonic between hardware resets.
            </t>
            <t>A clock interrupt may be used to simply increment a binary
              integer by 1 periodically.
            </t>
            <t>The timestamp clock may be derived from a system clock
              that is subject to being abruptly changed, by adding a
              variable offset value.  This offset is initialized to
              zero.  When a new timestamp clock value is needed, the
              offset can be adjusted as necessary to make the new value
              equal to or larger than the previous value (which was
              saved for this purpose).
            </t>
          </list>
        </t>
	  	</section>
	  	<section anchor="sec423" title="Outdated Timestamps">
	  		<t>If a connection remains idle long enough for the timestamp
         clock of the other TCP to wrap its sign bit, then the value
         saved in TS.Recent will become too old; as a result, the PAWS
         mechanism will cause all subsequent segments to be rejected,
         freezing the connection (until the timestamp clock wraps its
         sign bit again).
        </t>
        <t>With the chosen range of timestamp clock frequencies (1 sec to
         1 ms), the time to wrap the sign bit will be between 24.8 days
         and 24800 days.  A TCP connection that is idle for more than 24
         days and then comes to life is exceedingly unusual.  However,
         it is undesirable in principle to place any limitation on TCP
         connection lifetimes.
        </t>
        <t>We therefore require that an implementation of PAWS include a
         mechanism to "invalidate" the TS.Recent value when a connection
         is idle for more than 24 days.  (An alternative solution to the
         problem of outdated timestamps would be to send keep-alive
         segments at a very low rate, but still more often than the
         wrap-around time for timestamps, e.g., once a day.  This would
         impose negligible overhead.  However, the TCP specification has
         never included keep-alives, so the solution based upon
         invalidation was chosen.)
        </t>
        <t>Note that a TCP does not know the frequency, and therefore, the
         wraparound time, of the other TCP, so it must assume the worst.
         The validity of TS.Recent needs to be checked only if the basic
         PAWS timestamp check fails, i.e., only if SEG.TSval &lt;
         TS.Recent.  If TS.Recent is found to be invalid, then the
         segment is accepted, regardless of the failure of the timestamp
         check, and rule R3 updates TS.Recent with the TSval from the
         new segment.
        </t>
        <t>To detect how long the connection has been idle, the TCP may
         update a clock or timestamp value associated with the
         connection whenever TS.Recent is updated, for example.  The
         details will be implementation-dependent.
        </t>
	  	</section>
	  	<section anchor="sec424" title="Header Prediction">
	  		<t>"Header prediction" <xref target="Jacobson90a"/> is 
	  		a high-performance
         transport protocol implementation technique that is most
         important for high-speed links.  This technique optimizes the
         code for the most common case, receiving a segment correctly
         and in order.  Using header prediction, the receiver asks the
         question, "Is this segment the next in sequence?"  This
         question can be answered in fewer machine instructions than the
         question, "Is this segment within the window?"
        </t>
        <t>Adding header prediction to our timestamp procedure leads to
         the following recommended sequence for processing an arriving
         TCP segment:
          <list style="format H%d)">
          	<t>Check timestamp (same as step R1 above)
            </t>
            <t>Do header prediction: if segment is next in sequence and
              if there are no special conditions requiring additional
              processing, accept the segment, record its timestamp, and
              skip H3.
            </t>
            <t>Process the segment normally, as specified in RFC 793.
              This includes dropping segments that are outside the
              window and possibly sending acknowledgments, and queueing
              in-window, out-of-sequence segments.
            </t>
          </list>
        </t>
        <t>Another possibility would be to interchange steps H1 and H2,
         i.e., to perform the header prediction step H2 FIRST, and
         perform H1 and H3 only when header prediction fails.  This
         could be a performance improvement, since the timestamp check
         in step H1 is very unlikely to fail, and it requires unsigned
         modulo arithmetic, a relatively expensive operation.  To
         perform this check on every single segment is contrary to the
         philosophy of header prediction.  We believe that this change
         might produce a measurable reduction in CPU time for TCP
         protocol processing on high-speed networks.
        </t>
        <t>However, putting H2 first would create a hazard: a segment from
         2^32 bytes in the past might arrive at exactly the wrong time
         and be accepted mistakenly by the header-prediction step.  The
         following reasoning has been introduced in <xref target="RFC1185"/>
         <!--xref target="Jacobson90b"/--> to show
         that the probability of this failure is negligible.
         <list style="empty">
         	 <t>If all segments are equally likely to show up as old
              duplicates, then the probability of an old duplicate
              exactly matching the left window edge is the maximum
              segment size (MSS) divided by the size of the sequence
              space.  This ratio must be less than 2^-16, since MSS
              must be &lt; 2^16; for example, it will be (2^12)/(2^32) =
              2^-20 for a FDDI link.  However, the older a segment is,
              the less likely it is to be retained in the Internet, and
              under any reasonable model of segment lifetime the
              probability of an old duplicate exactly at the left window
              edge must be much smaller than 2^-16.
           </t>
           <t>The 16 bit TCP checksum also allows a basic unreliability
              of one part in 2^16.  A protocol mechanism whose
              reliability exceeds the reliability of the TCP checksum
              should be considered "good enough", i.e., it won't
              contribute significantly to the overall error rate.  We
              therefore believe we can ignore the problem of an old
              duplicate being accepted by doing header prediction before
              checking the timestamp.
           </t>
         </list>
       </t>
       <t>However, this probabilistic argument is not universally
         accepted, and the consensus at present is that the performance
         gain does not justify the hazard in the general case.  It is
         therefore recommended that H2 follow H1.
       </t>
	  	</section>
	  	<section anchor="sec425" title="IP Fragmentation">
	  		<t>At high data rates, the protection against old packets provided
         by PAWS can be circumvented by errors in IP fragment reassembly
         (see <xref target="RFC4963"/><!--xref target="Heffner07"/-->).  
         The only way to protect against incorrect IP
         fragment reassembly is to not allow the packets to be
         fragmented.  This is done by setting the Don't Fragment (DF)
         bit in the IP header.  Setting the DF bit implies the use of
         Path MTU Discovery as described in 
         <xref target="RFC1191"/><!--xref target="Mogul90"/-->, thus any
         TCP implementation that implements PAWS must also implement
         Path MTU Discovery.
        </t>

	  	</section>
	  </section>
	  <section anchor="sec43" title="Duplicates from Earlier Incarnations of Connection">
	  	<t>The PAWS mechanism protects against errors due to sequence number
      wrap-around on high-speed connection.  Segments from an earlier
      incarnation of the same connection are also a potential cause of
      old duplicate errors.  In both cases, the TCP mechanisms to
      prevent such errors depend upon the enforcement of a maximum
      segment lifetime (MSL) by the Internet (IP) layer (see Appendix of
      RFC 1185 for a detailed discussion).  Unlike the case of sequence
      space wrap-around, the MSL required to prevent old duplicate
      errors from earlier incarnations does not depend upon the transfer
      rate.  If the IP layer enforces the recommended 2 minute MSL of
      TCP, and if the TCP rules are followed, TCP connections will be
      safe from earlier incarnations, no matter how high the network
      speed.  Thus, the PAWS mechanism is not required for this case.
      </t>
      <t>We may still ask whether the PAWS mechanism can provide additional
      security against old duplicates from earlier connections, allowing
      us to relax the enforcement of MSL by the IP layer.  <xref target="AppB"/>
      explores this question, showing that further assumptions and/or
      mechanisms are required, beyond those of PAWS.  This is not part
      of the current extension.
      </t>
	  </section>
	</section>
	
	<section anchor="sec5" title="Conclusions and Acknowledgements">
		<t>This memo presented a set of extensions to TCP to provide efficient
   operation over large-bandwidth*delay-product paths and reliable
   operation over very high-speed paths.  These extensions are designed
   to provide compatible interworking with TCP's that do not implement
   the extensions.
   </t>
   <t>These mechanisms are implemented using new TCP options for scaled
   windows and timestamps.  The timestamps are used for two distinct
   mechanisms: RTTM (Round Trip Time Measurement) and PAWS (Protect
   Against Wrapped Sequences).
   </t>
   <t>The Window Scale option was originally suggested by Mike St. Johns of
   USAF/DCA.  The present form of the option was suggested by Mike
   Karels of UC Berkeley in response to a more cumbersome scheme defined
   by Van Jacobson.  Lixia Zhang helped formulate the PAWS mechanism
   description in RFC 1185.
   </t>
   <t>Finally, much of this work originated as the result of discussions
   within the End-to-End Task Force on the theoretical limitations of
   transport protocols in general and TCP in particular.  Task force
   members and other on the end2end-interest list have made valuable
   contributions by pointing out flaws in the algorithms and the
   documentation.  Continued discussion and development since the
   publication of RFC 1323 originally occurred in the IETF TCP Large
   Windows Working Group, later on in the End-to-End Task Force, and
   most recently in the IETF TCP Maintenance Working Group.  The authors
   are grateful for all these contributions.
   </t>

	</section>
	
	<section anchor="sec6" title="Security Considerations">
		<t>The TCP sequence space is a fixed size, and as the window becomes
   larger it becomes easier for an attacker to generate forged packets
   that can fall within the TCP window, and be accepted as valid
   packets.  While use of Timestamps and PAWS can help to mitigate this,
   when using PAWS, if an attacker is able to forge a packet that is
   acceptable to the TCP connection, a timestamp that is in the future
   would cause valid packets to be dropped due to PAWS checks.  Hence,
   implementors should take care to not open the TCP window drastically
   beyond the requirements of the connection.
   </t>
   <t>Middle boxes and options If a middle box removes TCP options from the
   SYN, such as TSopt, a high speed connection that needs PAWS would not
   have that protection.  In this situation, an implementor could
   provide a mechanism for the application to determine whether or not
   PAWS is in use on the connection, and chose to terminate the
   connection if that protection doesn't exist.
   </t>
   <t>Mechanisms to protect the TCP header from modification should also
   protect the TCP options.
   </t>
   <t>Expanding the TCP window beyond 64K for IPv6 allows Jumbograms
   <xref target="RFC2675"/><!--xref target="Borman99"/--> to be used when 
   the local network supports packets larger
   than 64K.  When larger TCP packets are used, the TCP checksum becomes
   weaker.
   </t>
	</section>
	
	<section anchor="sec7" title="IANA Considerations">
		<t>This document has no actions for IANA.
		</t>
	</section>
	
 </middle>
 
 <back>
 	<references title="Normative References">
 		&RFC0793;
 		&RFC1191;
 	</references>
 	
 	<references title="Informative References">
 		&RFC2581;
 		&RFC2675;
 		&RFC1122;
 		&RFC2883;
 		&RFC3517;
 		&RFC4963;
 		&RFC1072;
 		&RFC1185;
 		&RFC1323;
 		&RFC2018;
 		&RFC1110;
 		&RFC0896;
 		&RFC5681;
 		
 		<reference anchor="Garlick77" target="http://www.rfc-editor.org/ien/ien12.txt">
        <front>
            <title>Issues in Reliable Host-to-Host Protocols</title>
            <author initials="L." surname="Garlick"/>
            <author initials="R." surname="Rom"/>
            <author initials="J." surname="Postel"/>	
            <date month="May" year="1977" />
        </front>
        <seriesInfo name="Proc. Second Berkeley Workshop
      on Distributed Data Management and Computer Networks" value="" />
    </reference>
    
    <reference anchor="Hamming77" target="">
    	<front>
    		<title>Digital Filters</title>
    		<author initials="R." surname="Hamming"/>
    		<date year="1977"/>
    	</front>
    	<seriesInfo name="Prentice Hall, Englewood Cliffs, N.J." 
    		value="ISBN 0-13-212571-4"/>
    </reference>
    
    <reference anchor="Jacobson88a" target="http://ee.lbl.gov/papers/congavoid.pdf">
    	<front>
    		<title>Congestion Avoidance and Control</title>
    		<author initials="V." surname="Jacobson"/>
    		<date month="August" year="1988"/>
    	</front>
    	<seriesInfo name="SIGCOMM '88, Stanford, CA." value=""/>
    </reference>
    
    <reference anchor="Jacobson90a" target="">
    	<front>
    		<title>4BSD Header Prediction</title>
    		<author initials="V." surname="Jacobson"/>
    		<date month="April" year="1990"/>
    	</front>
    	<seriesInfo name="ACM Computer Communication Review" value=""/>
    </reference>
    
    <reference anchor="Jacobson90c" target="ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail">
    	<front>
    		<title>Modified TCP congestion avoidance algorithm</title>
    		<author initials="V." surname="Jacobson"/>
    		<date month="April" year="1990" day="30"/>
    	</front>
    	<seriesInfo name="Message to end2end-interest mailing list" value=""/>
    </reference>
    
    <reference anchor="Jain86" target="http://arxiv.org/ftp/cs/papers/9809/9809097.pdf">
    	<front>
    		<title>Divergence of Timeout Algorithms for Packet
      Retransmissions</title>
    		<author initials="R." surname="Jain"/>
    		<date month="March" year="1986"/>
    	</front>
    	<seriesInfo name="Proc. Fifth Phoenix Conf. on Comp. and Comm.,
      Scottsdale, Arizona" value=""/>
    </reference>
    
    <reference anchor="Karn87" target="">
    	<front>
    		<title>Estimating Round-Trip Times
      in Reliable Transport Protocols</title>
    		<author initials="P." surname="Karn"/>
    		<author initials="C." surname="Partridge"/>
    		<date month="August" year="1987"/>
    	</front>
    	<seriesInfo name="Proc. SIGCOMM '87" value=""/>
    </reference>
    
    <reference anchor="Martin03" target="http://www.ietf.org/mail-archive/web/tsvwg/current/msg04435.html">
    	<front>
    		<title>[Tsvwg] RFC 1323.bis</title>
    		<author initials="D." surname="Martin"/>
    		<date month="September" year="2003" day="30"/>
    	</front>
    	<seriesInfo name="Message to the tsvwg
      mailing list" value=""/>
    </reference>
    
    <reference anchor="Mathis08" target="http://www.ietf.org/mail-archive/web/tcpm/current/msg03564.html">
    	<front>
    		<title>[tcpm] Example of 1323 window retraction
      problemPer my comments at the microphone at TCPM...</title>
    		<author initials="M." surname="Mathis"/>
    		<date month="March" year="2008" day="11"/>
    	</front>
    	<seriesInfo name="Message to the tcpm mailing list" value=""/>
    </reference>
    
    <reference anchor="Watson81" target="">
    	<front>
    		<title>Timer-based Mechanisms in Reliable
      Transport Protocol Connection Management</title>
    		<author initials="R." surname="Watson"/>
    		<date year="1981"/>
    	</front>
    	<seriesInfo name="Computer Networks, Vol. 5" value=""/>
    </reference>
    
    <reference anchor="Zhang86" target="">
    	<front>
    		<title>Why TCP Timers Don't Work Well</title>
    		<author initials="L." surname="Zhang"/>
    		<date month="August" year="1986"/>
    	</front>
    	<seriesInfo name="Proc. SIGCOMM '86, Stowe, VT" value=""/>
    </reference>

 	</references>
 	
 	<section anchor="AppA" title="Implementation Suggestions">
 		<t>TCP Option Layout
 			<list>
   			<t>The following layouts are recommended for sending options on
        non-SYN segments, to achieve maximum feasible alignment of
        32-bit and 64-bit machines.
	   			<figure align="center">
      			<artwork align="center"><![CDATA[
+--------+--------+--------+--------+
|   NOP  |  NOP   |  TSopt |   10   |
+--------+--------+--------+--------+
|           TSval  timestamp        |
+--------+--------+--------+--------+
|           TSecr  timestamp        |
+--------+--------+--------+--------+
           ]]></artwork>
          </figure>
        </t>
      </list>
   	</t>
   	<t>Interaction with the TCP Urgent Pointer
   		<list>
   			<t>The TCP Urgent pointer, like the TCP window, is a 16 bit value.
        Some of the original discussion for the TCP Window Scale option
        included proposals to increase the Urgent pointer to 32 bits.
        As it turns out, this is unnecessary.  There are two
        observations that should be made:
        <list style="format (%d)">
        	<t>With IP Version 4, the largest amount of TCP data that can
             be sent in a single packet is 65495 bytes (64K - 1 - size
             of fixed IP and TCP headers).
          </t>
          <t>Updates to the urgent pointer while the user is in "urgent
             mode" are invisible to the user.
          </t>
        </list>
      </t>
      <t>This means that if the Urgent Pointer points beyond the end of
        the TCP data in the current packet, then the user will remain in
        urgent mode until the next TCP packet arrives.  That packet will
        update the urgent pointer to a new offset, and the user will
        never have left urgent mode.
      </t>
      <t>Thus, to properly implement the Urgent Pointer, the sending TCP
        only has to check for overflow of the 16 bit Urgent Pointer
        field before filling it in.  If it does overflow, than a value
        of 65535 should be inserted into the Urgent Pointer.
      </t>
      <t>The same technique applies to IP Version 6, except in the case
        of IPv6 Jumbograms.  When IPv6 Jumbograms are supported, 
        <xref target="RFC2675"/><!--xref target"Borman99"/--> requires 
        additional steps for dealing with the
        Urgent Pointer, these are described in section 5.2 of 
        <xref target="RFC2675"/>.
      </t>
      </list>
   	</t>
	</section>
	<section anchor="AppB" title="Duplicates from Earlier Connection Incarnations">
	  <t>There are two cases to be considered:  (1) a system crashing (and
   losing connection state) and restarting, and (2) the same connection
   being closed and reopened without a loss of host state.  These will
   be described in the following two sections.
    </t>
    <section anchor="AppB1" title="System Crash with Loss of State">
    	<t>TCP's quiet time of one MSL upon system startup handles the loss
      of connection state in a system crash/restart.  For an
      explanation, see for example "When to Keep Quiet" in the TCP
      protocol specification <xref target="RFC0793"/><!--xref target="Postel81"/-->.  The MSL that is required here
      does not depend upon the transfer speed.  The current TCP MSL of 2
      minutes seems acceptable as an operational compromise, as many
      host systems take this long to boot after a crash.
      </t>
      <t>However, the timestamp option may be used to ease the MSL
      requirements (or to provide additional security against data
      corruption).  If timestamps are being used and if the timestamp
      clock can be guaranteed to be monotonic over a system
      crash/restart, i.e., if the first value of the sender's timestamp
      clock after a crash/restart can be guaranteed to be greater than
      the last value before the restart, then a quiet time will be
      unnecessary.
      </t>
      <t>To dispense totally with the quiet time would require that the
      host clock be synchronized to a time source that is stable over
      the crash/restart period, with an accuracy of one timestamp clock
      tick or better.  We can back off from this strict requirement to
      take advantage of approximate clock synchronization.  Suppose that
      the clock is always re-synchronized to within N timestamp clock
      ticks and that booting (extended with a quiet time, if necessary)
      takes more than N ticks.  This will guarantee monotonicity of the
      timestamps, which can then be used to reject old duplicates even
      without an enforced MSL.
      </t>
    </section>
    <section anchor="AppB2" title="Closing and Reopening a Connection">
    	<t>When a TCP connection is closed, a delay of 2*MSL in TIME-WAIT
      state ties up the socket pair for 4 minutes (see Section 3.5 of
      <xref target="RFC0793"/><!--xref target="Postel81"/-->.  Applications built upon TCP that close one connection
      and open a new one (e.g., an FTP data transfer connection using
      Stream mode) must choose a new socket pair each time.  The TIME-
      WAIT delay serves two different purposes:
        <list style="format (%c)">
        	<t>Implement the full-duplex reliable close handshake of TCP.
      		<vspace blankLines="1"/>
        	 The proper time to delay the final close step is not really
           related to the MSL; it depends instead upon the RTO for the
           FIN segments and therefore upon the RTT of the path.  (It
           could be argued that the side that is sending a FIN knows
           what degree of reliability it needs, and therefore it should
           be able to determine the length of the TIME-WAIT delay for
           the FIN's recipient.  This could be accomplished with an
           appropriate TCP option in FIN segments.)
       		<vspace blankLines="1"/>
           Although there is no formal upper-bound on RTT, common
           network engineering practice makes an RTT greater than 1
           minute very unlikely.  Thus, the 4 minute delay in TIME-WAIT
           state works satisfactorily to provide a reliable full-duplex
           TCP close.  Note again that this is independent of MSL
           enforcement and network speed.
          <vspace blankLines="1"/>
           The TIME-WAIT state could cause an indirect performance
           problem if an application needed to repeatedly close one
           connection and open another at a very high frequency, since
           the number of available TCP ports on a host is less than
           2^16.  However, high network speeds are not the major
           contributor to this problem; the RTT is the limiting factor
           in how quickly connections can be opened and closed.
           Therefore, this problem will be no worse at high transfer
           speeds.
          </t>
          <t>Allow old duplicate segments to expire.
          <vspace blankLines="1"/>
           To replace this function of TIME-WAIT state, a mechanism
           would have to operate across connections.  PAWS is defined
           strictly within a single connection; the last timestamp
           (TS.Recent) is kept in the connection control block, and
           discarded when a connection is closed.
      		<vspace blankLines="1"/>
           An additional mechanism could be added to the TCP, a per-host
           cache of the last timestamp received from any connection.
           This value could then be used in the PAWS mechanism to reject
           old duplicate segments from earlier incarnations of the
           connection, if the timestamp clock can be guaranteed to have
           ticked at least once since the old connection was open.  This
           would require that the TIME-WAIT delay plus the RTT together
           must be at least one tick of the sender's timestamp clock.
           Such an extension is not part of the proposal of this RFC.
          <vspace blankLines="1"/>
           Note that this is a variant on the mechanism proposed by
           Garlick, Rom, and Postel <xref target="Garlick77"/>, 
           which required each
           host to maintain connection records containing the highest
           sequence numbers on every connection.  Using timestamps
           instead, it is only necessary to keep one quantity per remote
           host, regardless of the number of simultaneous connections to
           that host.          
          </t>
        </list>
      </t>
    </section>
	</section>
	<section anchor="AppC" title="Changes from RFC 1072, RFC 1185, and RFC 1323">
		<t>The protocol extensions defined in RFC 1323 document differ in
   several important ways from those defined in RFC 1072 and RFC 1185.
      <list style="format (%c)">
      	<t>SACK has been split off into a separate document, 
      		<xref target="RFC2018"/><!--xref target="Mathis96"/-->.
        </t>
        <t>The detailed rules for sending timestamp replies (see 
        	<xref target="sec34"/>) differ in important ways.  The earlier 
        	rules could result in an under-estimate of the RTT in certain 
        	cases (packets dropped or out of order).
        </t>
        <t>The same value TS.Recent is now shared by the two distinct
        mechanisms RTTM and PAWS.  This simplification became possible
        because of change (b).
        </t>
        <t>An ambiguity in RFC 1185 was resolved in favor of putting
        timestamps on ACK as well as data segments.  This supports the
        symmetry of the underlying TCP protocol.
        </t>
        <t>The echo and echo reply options of RFC 1072 were combined into a
        single Timestamps option, to reflect the symmetry and to
        simplify processing.
        </t>
        <t>The problem of outdated timestamps on long-idle connections,
        discussed in <xref target="sec422"/>, was realized and resolved.
        </t>
        <t>RFC 1185 recommended that header prediction take precedence over
        the timestamp check.  Based upon some skepticism about the
        probabilistic arguments given in <xref target="sec424"/>, 
        it was decided
        to recommend that the timestamp check be performed first.
        </t>
        <t>The spec was modified so that the extended options will be sent
        on &lt;SYN,ACK&gt; segments only when they are received in the
        corresponding &lt;SYN&gt; segments.  This provides the most
        conservative possible conditions for interoperation with
        implementations without the extensions.
        </t>
      </list>
    </t>
    <t>In addition to these substantive changes, the present RFC 
    	attempts to specify the algorithms unambiguously by presenting 
    	modifications to the Event Processing rules of RFC 793; 
    	see <xref target="AppF"/>.
    </t>
    <t>There are additional changes in this document from RFC 1323.  These
   changes are:
      <list style="format (%c)">
      	<t>The description of which TSecr values can be used to update the
        measured RTT has been clarified.  Specifically, with Timestamps,
        the Karn algorithm <xref target="Karn87"/> is disabled.  
        The Karn algorithm
        disables all RTT measurements during retransmission, since it is
        ambiguous whether the ACK is is for the original packet, or the
        retransmitted packet.  With Timestamps, that ambiguity is
        removed since the TSecr in the ACK will contain the TSval from
        whichever data packet made it to the destination.
        </t>
        <t>In RFC1323, section 3.4, step (2) of the algorithm to control
        which timestamp is echoed was incorrect in two regards:
          <list style="format (%d)">
          	<t>It failed to update TSrecent for a retransmitted segment
             that resulted from a lost ACK.
            </t>
            <t>It failed if SEG.LEN = 0.
            </t>
          </list>
        In the new algorithm, the case of SEG.TSval = TSrecent is
        included for consistency with the PAWS test.
        </t>
        <t>One correction was made to the Event Processing Summary in
        <xref target="AppF"/>.  In SEND CALL/ESTABLISHED STATE, 
        RCV.WND is used to
        fill in the SEG.WND value, not SND.WND.
        </t>
        <t>New pseudo-code summary has been added in <xref target="AppE"/>.
        </t>
        <t><xref target="AppA"/> has been expanded with information 
        	about the TCP MSS option and the TCP Urgent Pointer.
        </t>
        <t>It is now recommended that Timestamps options be included in RST
        packets if the incoming packet contained a Timestamps option.
        </t>
        <t>RST packets are explicitly excluded from PAWS processing.
        </t>
        <t>Snd.TSoffset and Snd.TSclock variables have been added.
        Snd.TSclock is the sum of my.TSclock and Snd.TSoffset.  This
        allows the starting points for timestamps to be randomized on a
        per-connection basis.  Setting Snd.TSoffset to zero yields the
        same results as <xref target="RFC1323"/>.
        </t>
        <t>RTTM update processing explicitly excludes packets containing
        	SACK options. This addresses inflation of the RTT during episodes of
        	packet loss in both directions.
        </t>
        <t>In <xref target="sec32"/> the if-clause allowing sending of
          timestamps only when received in a &lt;SYN&gt; or &lt;SYN,ACK&gt; was
          removed, to allow for late timestamp negotiation.
        </t>
        <t><xref target="sec24"/> was added describing the unavoidable 
          window retraction issue, and explicitly describing the mitigation
          steps necessary.
        </t>
      </list>
    </t>
	</section>
	<section anchor="AppD" title="Summary of Notation">
<?rfc subcompact="yes" ?>
		<t>The following notation has been used in this document.
		</t>
		<t>Options
			<list><t>
			<list hangIndent="18" style="hanging">
				<t hangText="WSopt:">TCP Window Scale Option</t>
				<t hangText="TSopt:">TCP Timestamps Option</t>
		  </list></t>
		  </list>
		</t>
		<t>Option Fields
			<list><t>
			<list hangIndent="18" style="hanging">
				<t hangText="shift.cnt:">Window scale byte in WSopt</t>
				<t hangText="TSval:">32-bit Timestamp Value field in TSopt</t>
				<t hangText="TSecr:">32-bit Timestamp Reply field in TSopt</t>
			</list></t>
			</list>
		</t>
		<t>Option Fields in Current Segment
			<list><t>
			<list hangIndent="18" style="hanging">
				<t hangText="SEG.TSval:">TSval field from TSopt in current segment</t>
				<t hangText="SEG.TSecr:">TSecr field from TSopt in current segment</t>
				<t hangText="SEG.WSopt:">8-bit value in WSopt</t>
			</list></t>
			</list>
		</t>
		<t>Clock Values
			<list><t>
			<list hangIndent="18" style="hanging">
				<t hangText="my.TSclock:">System wide source of 32-bit timestamp values</t>
				<t hangText="my.TSclock.rate:">Period of my.TSclock (1 ms to 1 sec)</t>
				<t hangText="Snd.TSoffset:">A offset for randomizing Snd.TSclock</t>
				<t hangText="Snd.TSclock:">my.TSclock + Snd.TSoffset</t>
			</list></t>
			</list>
		</t>	
		<t>Per-Connection State Variables
			<list><t>
			<list hangIndent="18" style="hanging">
				<t hangText="TS.Recent:">Latest received Timestamp</t>
				<t hangText="Last.ACK.sent:">Last ACK field sent</t>
				<t hangText="Snd.TS.OK:">1-bit flag</t>
				<t hangText="Snd.WS.OK:">1-bit flag</t>
				<t hangText="Rcv.Wind.Scale:">Receive window scale power</t>
				<t hangText="Snd.Wind.Scale:">Send window scale power</t>
				<t hangText="Start.Time:">Snd.TSclock value when segment being
					timed was sent (used by pre-1323 code).</t>
			</list></t>
			</list>
		</t>
		<t>Procedure
			<list><t>
			<list hangIndent="18" style="hanging">
				<t hangText="Update_SRTT(m)">Procedure to update the smoothed RTT
					and RTT variance estimates, using the rules of
					<xref target="Jacobson88a"/>, given m, a new RTT measurement</t>
			</list></t>
			</list>
		</t>
<?rfc subcompact="no" ?>
	</section>
	<section anchor="AppE" title="Pseudo-code Summary">
		<t>
  		<figure align="left">
   			<artwork align="left"><![CDATA[
   Create new TCB => {
       Rcv.wind.scale =
             MIN( 14, MAX(0, floor(log2(receive buffer space)) - 15) );
       Snd.wind.scale = 0;
       Last.ACK.sent = 0;
       Snd.TS.OK = Snd.WS.OK = FALSE;
       Snd.TSoffset = random 32 bit value
   }

   Send initial <SYN> segment => {
       SEG.WND = MIN( RCV.WND, 65535 );
       Include in segment: TSopt(TSval=Snd.TSclock, TCecr=0);
       Include in segment: WSopt = Rcv.wind.scale;
   }

   Send <SYN,ACK> segment => {
       SEG.ACK = Last.ACK.sent = RCV.NXT;
       SEG.WND = MIN( RCV.WND, 65535 );
       if (Snd.TS.OK) then
             Include in segment:
                   TSopt(TSval=Snd.TSclock, TSecr=TS.Recent);
       if (Snd.WS.OK) then
             Include in segment: WSopt = Rcv.wind.scale;
   }

   Receive <SYN> or <SYN,ACK> segment => {
       if (Segment contains TSopt) then {
             TS.Recent = SEG.TSval;
             Snd.TS.OK = TRUE;
             if (is <SYN,ACK> segment) then
                   Update_SRTT(
                          (Snd.TSclock - SEG.TSecr)/my.TSclock.rate);
       }
       if (Segment contains WSopt) then {
             Snd.wind.scale = SEG.WSopt;
             Snd.WS.OK = TRUE;
             if (the ACK bit is not set, and Rcv.wind.scale has not been
               initialized by the user) then
                   Rcv.wind.scale = Snd.wind.scale;
       }
       else
             Rcv.wind.scale = Snd.wind.scale = 0;
   }

   Send non-SYN segment => {
       SEG.ACK = Last.ACK.sent = RCV.NXT;
       SEG.WND = MIN( RCV.WND >> Rcv.wind.scale, 65535 );
       if (Snd.TS.OK) then
             Include in segment:
                   TSopt(TSval=Snd.TSclock, TSecr=TS.Recent);
   }

   Receive non-SYN segment in (state >= ESTABLISHED) => {
       Window = (SEG.WND << Snd.wind.scale);
             /* Use 32-bit 'Window' instead of 16-bit 'SEG.WND'
              * in rest of processing.
              */
       if (Segment contains TSopt) then {
             if (SEG.TSval < TS.Recent && Idle less than 24 days) then {
                   if (Send.TS.OK AND (NOT RST) ) then {
                               /* Timestamp too old =>
                                *    segment is unacceptable.
                                */
                         Send ACK segment;
                         Discard segment and return;
                   }
             }
             else {
                   if (SEG.SEQ =< Last.ACK.sent) then
                               TS.Recent = SEG.TSval;
             }
       }
       if (SEG.ACK > SND.UNA) then {
                    /* (At least part of) first segment in
                     * retransmission queue has been ACKd
                     */
             if (Segment contains TSopt) then
                   Update_SRTT(
                          (Snd.TSclock - SEG.TSecr)/my.TSclock.rate);
             else
                   Update_SRTT( /* for compatibility */
                          (Snd.TSclock - Start.Time)/my.TSclock.rate);
       }
   }
        ]]></artwork>
      </figure>
		</t>
	</section>
	<section anchor="AppF" title="Event Processing Summary">
		<t>OPEN Call
			<list>
				<t>...
				</t>
				<t>An initial send sequence number (ISS) is selected.  
					Send a SYN segment of the form:
      		<figure align="center">
   	    		<artwork align="center"><![CDATA[
<SEQ=ISS><CTL=SYN><TSval=Snd.TSclock><WSopt=Rcv.Wind.Scale>
            ]]></artwork>
          </figure>
        </t>
        <t>...
        </t>
      </list>
    </t>
    <t>SEND Call
    	<list>
    		<t>CLOSED STATE (i.e., TCB does not exist)
    			<list>
    				<t>...
    				</t>
    			</list>
    		</t>
    		<t>LISTEN STATE
    			<list>
    				<t>If the foreign socket is specified, then change 
    					the connection from passive to active, select an ISS.  
    					Send a SYN segment containing the options: 
    					&lt;TSval=Snd.TSclock&gt; and &lt;WSopt=Rcv.Wind.Scale&gt;.  
    					Set SND.UNA to ISS, SND.NXT to ISS+1. Enter SYN-SENT state. 
    					...
            </t>
          </list>
        </t>
        <t>SYN-SENT STATE<vspace blankLines="0"/>
          SYN-RECEIVED STATE
        	<list>
        		<t>...
        		</t>
        	</list>
        </t>
        <t>ESTABLISHED STATE<vspace blankLines="0"/>
        	CLOSE-WAIT STATE
        	<list>
        		<t>Segmentize the buffer and send it with a piggybacked
              acknowledgment (acknowledgment value = RCV.NXT).  ...
            </t>
            <t>If the urgent flag is set ...
            </t>
            <t>If the Snd.TS.OK flag is set, then include the TCP 
            	Timestamps option 
            	&lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in each 
            	data segment.
            </t>
            <t>Scale the receive window for transmission in the 
            	segment header:
            	<figure align="center">
            		<artwork align="center"><![CDATA[
SEG.WND = (RCV.WND >> Rcv.Wind.Scale).
                ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </list>
    </t>
    <t>SEGMENT ARRIVES
    	<list>
    		<t>...
    		</t>
    		<t>If the state is LISTEN then
    			<list>
    				<t>first check for an RST
    					<list>
        				<t>...
        			  </t>
        			</list>
        		</t>
    			  <t>second check for an ACK
    			    <list>
    			    	<t>...
    			    	</t>
    			    </list>
    			  </t>
    			  <t>third check for a SYN
    			  	<list>
    			  		<t>if the SYN bit is set, check the security.  If the ...
    			  			<list>
    			  				<t>...
    			  				</t>
    			  		  </list>
    			  		</t>
    			  		<t>if the SEG.PRC is less than the TCB.PRC then continue.
    			  		</t>
    			  		<t>Check for a Window Scale option (WSopt); if one is 
    			  			found, save SEG.WSopt in Snd.Wind.Scale and set 
    			  			Snd.WS.OK flag on. Otherwise, set both Snd.Wind.Scale 
    			  			and Rcv.Wind.Scale to zero and clear Snd.WS.OK flag.
    			  		</t>
    			  		<t>Check for a TSopt option; if one is found, save 
    			  			SEG.TSval in the variable TS.Recent and turn on the 
    			  			Snd.TS.OK bit.
    			  		</t>
    			  		<t>Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ and 
    			  			any other control or text should be queued for 
    			  			processing later.  ISS should be selected and a SYN 
    			  			segment sent of the form:
    			  			<figure align="center">
            		    <artwork align="center"><![CDATA[
<SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
                    ]]></artwork>
                  </figure>
                </t>
                <t>If the Snd.WS.OK bit is on, include a WSopt option
                	&lt;WSopt=Rcv.Wind.Scale&gt; in this segment.  If the 
                	Snd.TS.OK bit is on, include a TSopt 
                	&lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in this 
                	segment.  Last.ACK.sent is set to RCV.NXT.
                </t>
                <t>SND.NXT is set to ISS+1 and SND.UNA to ISS.  The 
                	connection state should be changed to SYN-RECEIVED.  
                	Note that any other incoming control or data (combined 
                	with SYN) will be processed in the SYN-RECEIVED state, 
                	but processing of SYN and ACK should not be repeated.  
                	If the listen was not fully specified (i.e., the foreign 
                	socket was not fully specified), then the unspecified 
                	fields should be filled in now.
                </t>
              </list>
            </t>
            <t>fourth other text or control
            	<list>
            		<t>...
            		</t>
            	</list>
            </t>
          </list>
        </t>
        <t>If the state is SYN-SENT then
        	<list>
        		<t>first check the ACK bit
        			<list>
        				<t>...
        				</t>
        			</list>
        		</t>
        		<t>...
        		</t>
        		<t>fourth check the SYN bit
        			<list>
        				<t>...
        				</t>
        				<t>If the SYN bit is on and the security/compartment and 
        					precedence are acceptable then, RCV.NXT is set to 
        					SEG.SEQ+1, IRS is set to SEG.SEQ, and any 
        					acknowledgements on the retransmission queue which 
        					are thereby acknowledged should be removed.
        				</t>
        				<t>Check for a Window Scale option (WSopt); if it<!--[###]--> 
        					is found, save SEG.WSopt in Snd.Wind.Scale; otherwise, 
        					set both Snd.Wind.Scale and Rcv.Wind.Scale to zero.
        				</t>
        				<t>Check for a TSopt option; if one is found, save 
        					SEG.TSval in variable TS.Recent and turn on the 
        					Snd.TS.OK bit in the connection control block.  If 
        					the ACK bit is set, use Snd.TSclock - SEG.TSecr as 
        					the initial RTT estimate.
        				</t>
        				<t>If SND.UNA > ISS (our SYN has been ACKed), change the 
        					connection state to ESTABLISHED, form an ACK segment:
        					<figure align="center">
            		    <artwork align="center"><![CDATA[
<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
                    ]]></artwork>
                  </figure>
                  and send it.  If the Snd.Echo.OK bit is on, include 
                  a TSopt option &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt;
                  in this ACK segment. Last.ACK.sent is set to RCV.NXT.
                </t>
                <t>Data or controls which were queued for transmission 
                	may be included.  If there are other controls or text 
                	in the segment then continue processing at the sixth 
                	step below where the URG bit is checked, otherwise 
                	return.
                </t>
                <t>Otherwise enter SYN-RECEIVED, form a SYN,ACK segment:
                  <figure align="center">
            		    <artwork align="center"><![CDATA[
<SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
                    ]]></artwork>
                  </figure>	
                  and send it.  If the Snd.Echo.OK bit is on, include 
                  a TSopt option &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; 
                  in this segment.  If the Snd.WS.OK bit is on, include 
                  a WSopt option &lt;WSopt=Rcv.Wind.Scale&gt; in this 
                  segment.  Last.ACK.sent is set to RCV.NXT.
                </t>
                <t>If there are other controls or text in the segment, 
                	queue them for processing after the ESTABLISHED state 
                	has been reached, return.
                </t>
              </list>
            </t>
            <t>fifth, if neither of the SYN or RST bits is set then 
            	drop the segment and return.
            </t>
          </list>
        </t>
        <t>Otherwise,
        </t>
        <t>First, check sequence number
        	<list>
        		<t>SYN-RECEIVED STATE<vspace blankLines="0"/>
              ESTABLISHED STATE<vspace blankLines="0"/>
              FIN-WAIT-1 STATE<vspace blankLines="0"/>
              FIN-WAIT-2 STATE<vspace blankLines="0"/>
              CLOSE-WAIT STATE<vspace blankLines="0"/>
              CLOSING STATE<vspace blankLines="0"/>
              LAST-ACK STATE<vspace blankLines="0"/>
              TIME-WAIT STATE
              <list>
              	<t>Segments are processed in sequence.  Initial tests 
              		on arrival are used to discard old duplicates, but 
              		further processing is done in SEG.SEQ order.  If a 
              		segment's contents straddle the boundary between old 
              		and new, only the new parts should be processed.
              	</t>
              	<t>Rescale the received window field:
              		<figure align="center">
            		    <artwork align="center"><![CDATA[
TrueWindow = SEG.WND << Snd.Wind.Scale,
                    ]]></artwork>
                  </figure>
                  and use "TrueWindow" in place of SEG.WND in the 
                  following steps.
                </t>
                <t>Check whether the segment contains a Timestamps 
                	option and bit Snd.TS.OK is on.  If so:
                	<list>
                		<t>If SEG.TSval &lt; TS.Recent and the RST bit 
                			is off, then test whether connection has been 
                			idle less than 24 days; if all are true, then 
                			the segment is not acceptable; follow steps 
                			below for an unacceptable segment.
                		</t>
                		<t>If SEG.SEQ is equal to Last.ACK.sent, then 
                			save SEG.TSval <!--[###]--> in variable TS.Recent.
                		</t>
                	</list>
                </t>
                <t>There are four cases for the acceptability test 
                	for an incoming segment:
                	<list>
                		<t>...
                		</t>
                	</list>
                </t>
                <t>If an incoming segment is not acceptable, an 
                	acknowledgment should be sent in reply (unless 
                	the RST bit is set, if so drop the segment and 
                	return):
                	<figure align="center">
            		    <artwork align="center"><![CDATA[
<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
                    ]]></artwork>
                  </figure>
                </t>
                <t>Last.ACK.sent is set to SEG.ACK of the 
                	acknowledgment.  If the Snd.Echo.OK bit is on, 
                	include the Timestamps option 
                	&lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in this 
                	ACK segment.  Set Last.ACK.sent to SEG.ACK and send 
                	the ACK segment.  After sending the acknowledgment, 
                	drop the unacceptable segment and return.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>...
        </t>
        <t>fifth check the ACK field.
        	<list>
        		<t>if the ACK bit is off drop the segment and return.
        		</t>
        		<t>if the ACK bit is on
        			<list>
        				<t>...
        				</t>
        				<t>ESTABLISHED STATE
        					<list>
        						<t>If SND.UNA &lt; SEG.ACK &lt;= SND.NXT then, set 
        							SND.UNA &lt;-<!--[###]--> SEG.ACK. Also compute a new estimate 
        							of round-trip time.  If Snd.TS.OK bit is on, use 
        							Snd.TSclock - SEG.TSecr; otherwise use the
        							elapsed time since the first segment in the 
        							retransmission queue was sent.  Any segments on 
        							the retransmission queue which are thereby entirely 
        							acknowledged...
        						</t>
        					</list>
        				</t>
        			</list>
        		</t>
        	</list>
        </t>
        <t>...
        </t>
        <t>Seventh, process the segment text.
        	<list>
        		<t>ESTABLISHED STATE<vspace blankLines="0"/>
              FIN-WAIT-1 STATE<vspace blankLines="0"/>
              FIN-WAIT-2 STATE
              <list>
              	<t>...
              	</t>
              	<t>Send an acknowledgment of the form:
                	<figure align="center">
            		    <artwork align="center"><![CDATA[
<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
	                    ]]></artwork>
                  </figure>
                </t>
                <t>If the Snd.TS.OK bit is on, include Timestamps 
                	option &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; 
                	in this ACK segment. Set Last.ACK.sent to SEG.ACK 
                	of the acknowledgment, and send it. This 
                	acknowledgment should be piggy-backed on a segment 
                	being transmitted if possible without incurring 
                	undue delay.
                </t>
                <t>...
                </t>
              </list>
            </t>
          </list>
        </t>
      </list>
    </t>
	</section>
	<section anchor="AppG" title="Timestamps Edge Cases">
		<t>While the rules laid out for when to calculate RTTM produce the
   correct results most of the time, there are some edge cases where an
   incorrect RTTM can be calculated.  All of these situations involve
   the loss of packets.  It is felt that these scenarios are rare, and
   that if they should happen, they will cause a single RTTM measurement
   to be inflated, which mitigates its effects on RTO calculations.
    </t>
    <t><xref target="Martin03"/> cites two similar cases when the 
    	returning ACK is lost,
   and before the retransmission timer fires, another returning packet
   arrives, which ACKs the data.  In this case, the RTTM calculated will
   be inflated:
  		<figure align="center">
   			<artwork align="center"><![CDATA[
clock
  tc=1   <A, TSval=1> ------------------->

  tc=2   (lost) <---- <ACK(A), TSecr=1, win=n>
      (RTTM would have been 1)

         (receive window opens, window update is sent)
  tc=5        <---- <ACK(A), TSecr=1, win=m>
         (RTTM is calculated at 4)
        ]]></artwork>
      </figure>
    </t>
    <t>One thing to note about this situation is that it is somewhat bounded
   by RTO + RTT, limiting how far off the RTTM calculation will be.
   While more complex scenarios can be constructed that produce larger
   inflations (e.g., retransmissions are lost), those scenarios involve
   multiple packet losses, and the connection will have other more
   serious operational problems than using an inflated RTTM in the RTO
   calculation.
    </t>
	</section>
	

	
 	
 </back>
</rfc>