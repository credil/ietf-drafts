<?xml version = '1.0'?>
<?rfc rfcedstyle='yes'?>
<?rfc rfcprocack='yes'?>
<?rfc toc='yes'?>
<?rfc symrefs='yes'?>
<!DOCTYPE rfc SYSTEM "../xml2rfc-1.36/rfc2629.dtd" [
      <!ENTITY rfc2119     PUBLIC '' '../rfc-bib/reference.RFC.2119.xml'>
      <!ENTITY rfc2782     PUBLIC '' '../rfc-bib/reference.RFC.2782.xml'>
      <!ENTITY rfc2865     PUBLIC '' '../rfc-bib/reference.RFC.2865.xml'>
      <!ENTITY rfc2866     PUBLIC '' '../rfc-bib/reference.RFC.2866.xml'>
      <!ENTITY rfc5176     PUBLIC '' '../rfc-bib/reference.RFC.5176.xml'>
      <!ENTITY rfc3958     PUBLIC '' '../rfc-bib/reference.RFC.3958.xml'>
      <!ENTITY rfc5280     PUBLIC '' '../rfc-bib/reference.RFC.5280.xml'>
      <!ENTITY rfc5580     PUBLIC '' '../rfc-bib/reference.RFC.5580.xml'>
      <!ENTITY rfc5891     PUBLIC '' '../rfc-bib/reference.RFC.5891.xml'>
      <!--ENTITY rfc4282     PUBLIC '' '../rfc-bib/reference.RFC.4282.xml'> -->
      <!ENTITY dtls        PUBLIC '' '../i-d-bib/reference.I-D.ietf-radext-dtls.xml'>
      <!ENTITY nai         PUBLIC '' '../i-d-bib/reference.I-D.draft-ietf-radext-nai-03.xml'>
      <!ENTITY rfc6613     PUBLIC '' '../rfc-bib/reference.RFC.6613.xml'>
      <!ENTITY rfc6614     PUBLIC '' '../rfc-bib/reference.RFC.6614.xml'>
    ]>
<rfc ipr='trust200902' docName='draft-ietf-radext-dynamic-discovery-08'
category='exp'>
  <front>
	  <title abbrev="RADIUS Peer Discovery" >NAI-based Dynamic Peer
Discovery for RADIUS/TLS and RADIUS/DTLS</title>
    <author fullname="Stefan Winter" initials="S." surname="Winter" >
	<organization abbrev="RESTENA" >
		  Fondation RESTENA
	</organization>
	<address>
		<postal>
			<street>6, rue Richard Coudenhove-Kalergi</street>
			<city>Luxembourg</city>
			<code>1359</code>
			<country>LUXEMBOURG</country>
		</postal>
		<phone>+352 424409 1</phone>
		<facsimile>+352 422473</facsimile>
		<email>stefan.winter@restena.lu</email>
		<uri>http://www.restena.lu.</uri>
	</address>
    </author>
    <author fullname="Mike McCauley" initials="M." surname="McCauley" >
	    <organization abbrev="OSC" >
		    Open Systems Consultants
	    </organization>
	    <address>
		    <postal>
			    <street>9 Bulbul Place</street>
			    <city>Currumbin Waters</city>
			    <code>QLD 4223</code>
			    <country>AUSTRALIA</country>
		    </postal>
		    <phone>+61 7 5598 7474</phone>
		    <facsimile>+61 7 5598 7070</facsimile>
		    <email>mikem@open.com.au</email>
		    <uri>http://www.open.com.au.</uri>
	    </address>
    </author>
    <date day="16" month="October" year="2013" />
    <area>Operations and Management Area</area>
    <workgroup>RADIUS Extensions Working Group</workgroup>
    <keyword>RADIUS</keyword>
    <keyword>AAA</keyword>
    <keyword>Security</keyword>
    <keyword>Reliability</keyword>
    <keyword>DNS</keyword>
    <abstract>
	    <t>This document specifies a means to find authoritative RADIUS servers
for a given realm. It is used in conjunction with either RADIUS/TLS and
RADIUS/DTLS.</t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction" anchor="intro">
<t>
	RADIUS in all its current transport variants (RADIUS/UDP, RADIUS/TLS, RADIUS/DTLS)
requires manual configuration of all peers (clients, servers).</t>
<t>     Where RADIUS forwarding 
servers are in use, the number of realms to be forwarded and the corresponding number of
servers to configure may be significant. Where new realms with new servers are added or details
of existing servers change on a regular basis, maintaining a single monolithic configuration file
for all these details may prove too cumbersome to be useful.</t>
<t>Furthermore, in cases where a roaming consortium consists of independently working branches, each with
their own forwarding servers, and who add or change their realm lists at their own discretion, there
is additional complexity in synchronising the changed data across all branches.</t>
<t>
These situations can benefit significantly from a distributed mechanism for storing realm and
server reachability information. This document describes one such mechanism: storage of realm-to-server
mappings in DNS.
</t>
<t>
This document also specifies various approaches for verifying that server information which was retrieved from DNS
was from an authorised party; e.g. an organisation which is not at all part of a given roaming
consortium may alter its own DNS records to yield a result for its own realm.
</t>
	<section title="Requirements Language" anchor="reqlang">
		<t>In this document, several words are used to signify the
requirements of the specification.  The key words "MUST", "MUST NOT",
"REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY",
and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.
<xref target="RFC2119" /></t>
	</section>
	<section title="Terminology" anchor="terms">
		<t>RADIUS/TLS Client: a RADIUS/TLS <xref target="RFC6614" />
instance which initiates a new connection.</t>
		<t>RADIUS/TLS Server: a RADIUS/TLS <xref target="RFC6614" />
instance which listens on a RADIUS/TLS port and accepts new connections</t>
		<t>RADIUS/TLS node: a RADIUS/TLS client or server</t>
	</section>
    </section>
<section title="Definitions" anchor="definitions"> <!-- DEFS-->
        <section title="DNS RR definition" anchor="rr-def"> <!-- DEFS-RR-->
            <t>
                    DNS definitions of RADIUS/TLS servers can be either S-NAPTR
records (see <xref target="RFC3958" />) or SRV records. When both are defined, the resolution algorithm prefers
S-NAPTR results (see <xref target="algo" /> below). </t>
<section title="S-NAPTR" anchor="S-NAPTR"> <!--DEFS-RR-NAPTR-->
<section title="Registration of Application Service and Protocol Tags" anchor="NAPTR-tags"><!--DEFS-RR-NAPTR-TAGS-->
<t>This specification defines three S-NAPTR service tags:
<figure anchor="service-tags" title="List of Service Tags"><artwork>
<![CDATA[
+-----------------+-----------------------------------------+
| Service Tag     | Use                                     |
+-----------------+-----------------------------------------+
| aaa+auth        | RADIUS Authentication, i.e. traffic as  |
|                 | defined in [RFC2865]                    |
| - - - - - - - - | - - - - - - - - - - - - - - - - - - - - |
| aaa+acct        | RADIUS Accounting, i.e. traffic as      |
|                 | defined in [RFC2866]                    |
| - - - - - - - - | - - - - - - - - - - - - - - - - - - - - |
| aaa+dynauth     | RADIUS Dynamic Authorisation, i.e.      |
|                 | traffic as defined in [RFC5176]         |
+--------------- --+-----------------------------------------+
]]></artwork></figure>
</t>
<t>This specification defines two S-NAPTR protocol tags:
<figure anchor="protocol-tags" title="List of Protocol Tags"><artwork>
<![CDATA[
+-----------------+-----------------------------------------+
| Protocol Tag    | Use                                     |
+-----------------+-----------------------------------------+
| radius.tls      | RADIUS transported over TLS as defined  |
|                 | in [RFC6614]                            |
| - - - - - - - - | - - - - - - - - - - - - - - - - - - - - |
| radius.dtls     | RADIUS transported over DTLS as defined |
|                 | in [I-D.ietf-radext-dtls]               |
+-----------------+-----------------------------------------+
]]></artwork></figure>
</t>
<t>Note well:
        <list style="empty">
          <t>The S-NAPTR service and protocols are unrelated to the IANA Service Name and Transport Protocol Number registry</t>
          <t>The delimiter '.' in the protocol tags is only a separator for human reading convenience - not for structure or namespacing; it MUST NOT be parsed in any way by the querying application or resolver.</t>
          <t>The use of the separator '.' is common also in other protocols' protocol tags. This is coincidence and does not imply a shared semantics with such protocols.</t>
        </list>
</t>
</section><!--DEFS-RR-NAPTR-TAGS-->
<section title="Definition of Conditions for Retry/Failure" anchor="NAPTR-conditions"><!--DEFS-RR-NAPTR-COND-->
<t>
RADIUS is a time-critical protocol; RADIUS clients which do not receive an answer after a configurable, but short, amount of time, will consider the request failed. Due to this, there is little leeway for extensive retries.
</t>
<t>
As a general rule, only error conditions which generate an immediate response from the other end are eligible for a retry of a discovered target. Any error condition involving time-outs, or the absence of a reply for more than one second during the connection setup phase is to be considered a failure; the next target in the set of discovered NAPTR targets is to be tried.
</t>
<t>Note that <xref target="RFC3958" /> already defines that a failure to identify the server as being authoritative for the realm is always considered a failure; so even if a discovered target returns a wrong credential instantly, it is not eligible for retry.</t>
<t>
Furthermore, the contacted RADIUS/TLS server verifies during connection setup whether or not it finds the connecting RADIUS/TLS client authorized or not. If the connecting RADIUS/TLS client is not found acceptable, the server will close the TLS connection immediately with an appropriate alert. Such TLS handshake failures are permanently fatal and not eligible for retry.
</t>
<t>
If the TLS session setup to a discovered target does not succeed, that target (as identified by IP address and port number) SHOULD be ignored from the result set of any subsequent executions of the discovery algorithm at least until the target's Effective TTL has expired or until the entity which executes the algorithm changes its TLS context to either send a new client certificate or expect a different server certificate.
</t>
</section><!--DEFS-RR-NAPTR-COND-->
<section title="Server Identification and Handshake" anchor="NAPTR-handshake"><!--DEFS-RR-NAPTR-HANDSHAKE-->
<t>
After the algorithm in this document has been executed, a RADIUS/TLS session as per <xref target="RFC6614"/> is established. Since the algorithm does not allow to derive confidential keying material between the RADIUS/TLS client (i.e. the server which executes the discovery algorithm) and the RADIUS/TLS server which was discovered, TLS-PSK ciphersuites can not be used for the subsequent TLS handshake in the RADIUS/TLS conversation. Only TLS ciphersuites using X.509 certificates can be used with this algorithm.
</t>
<t>
There are numerous ways to define which certificates are acceptable for use in this context. This document defines one mandatory-to-implement mechanism which allows to verify whether the contacted host is authoritative for a NAI realm or not. It also gives one example of another mechanism which is currently in wide-spread deployment, and one possible approach based on DNSSEC which is yet unimplemented.
</t>
<section title="Mandatory-to-implement mechanism: Trust Roots + NAIRealm" anchor="mti"><!--DEFS-RR-NAPTR-HANDSHAKE-MTI-->
<t>
Verification of authority to provide AAA services over RADIUS/TLS is a two-step process.</t>
<t>Step 1 is the verification of certificate wellformedness and validity as per <xref target="RFC5280"/> and whether it was issued from a root certificate which is deemed trustworthy by the RADIUS/TLS client.</t>
<t>Step 2 is: compare the value of algorithm's variable "R" after the execution of step 3 of the discovery algorithm in <xref target="core-algo"/> below (i.e. after a consortium name mangling, but before conversion to a form usable by the name resolution library) to all values of the contacted RADIUS/TLS server's X.509 certificate property "subjectAlternativeName:otherName:NAIRealm" as defined in <xref target="certprop"/>.
The comparison is a byte-by-byte comparison, except for dot-separated parts of the value whose content is a single "*" character; such labels match all strings in the same part of the NAI realm. If at least one of the sAN:otherName:NAIRealm values matches the NAI realm, the server is considered authorized; if none matches, the server is considered unauthorized.
</t>
<t>Examples:
<figure anchor="nairealm-examples" title="Examples for NAI realm vs. certificate matching"><artwork>
<![CDATA[
+-----------------+-----------------------------------------------+
| NAI realm           | NAIRealm          | MATCH?                |
+-----------------+-----------------------------------------------+
| foo.example         | foo.example       | YES                   |
| foo.example         | *.example         | YES                   |
| bar.foo.example     | *.example         | NO                    |
| bar.foo.example     | bar.*.example     | NO (NAIRealm invalid) |
| bar.foo.example     | *.*.example       | NO (NAIRealm invalid) |
| sub.bar.foo.example | *.*.example       | NO (NAIRealm invalid) |
| sub.bar.foo.example | *.bar.foo.example | YES                   |
+-----------------+-----------------------------------------------+
]]></artwork></figure>
</t>
</section><!--DEFS-RR-NAPTR-HANDSHAKE-MTI-->
<section title="Other mechanism: Trust Roots + policyOID" anchor="eduroam-authz"><!--DEFS-RR-NAPTR-HANDSHAKE-EDUROAM-->
<t>Verification of authority to provide AAA services over RADIUS/TLS is a two-step process.</t>
<t>Step 1 is the verification of certificate wellformedness and validity as per <xref target="RFC5280"/> and whether it was issued from a root certificate which is deemed trustworthy by the RADIUS/TLS client.</t>
<t>Step 2 is: compare the values of the contacted RADIUS/TLS server's X.509 certificate's extensions of type "Policy OID" to a list of configured acceptable Policy OIDs for the roaming consortium. If one of the configured OIDs is found in the certificate's Policy OID extensions, then the server is considered authorized; if there is no match, the server is considered unauthorized.</t>
<t>This mechanism is inferior to the mandatory-to-implement mechanism in the previous section because all authorized servers are validated by the same OID value; the mechanism is not fine-grained enough to express authority for one specific realm inside the consortium. If the consortium contains members which are hostile against other members, this weakness can be exploited by one RADIUS/TLS server impersonating another if DNS responses can be spoofed by the hostile member.
</t>
<t>
It should be noted that these shortcomings can be mitigated by using the RADIUS infrastructure only with authentication payloads which provide mutual authentication; that way, the final EAP server that was reached can be validated by the EAP peer, and any improper redirections to a different server will be detected. 
</t>
</section><!--DEFS-RR-NAPTR-HANDSHAKE-EDUROAM-->
<section title="Other mechanism: DNSSEC / DANE" anchor="dane"><!--DEFS-RR-NAPTR-HANDSHAKE-DANE-->
<t>
Where DNSSEC is used, the results of the algorithm can be trusted; i.e. the entity which executes the algorithm can be certain that the realm that triggered the discovery is actually served by the server that was discovered via DNS. 
However, this does not guarantee that the server is also authorized (i.e. a recognised member of the roaming consortium). 
</t><t>
The authorization can be sketched using DNSSEC+DANE as follows: if DANE/TLSA records of all authorized servers are put into a DNSSEC zone with a common, consortium-specific branch of the DNS tree, then the entity executing the algorithm can retrieve TLSA RRs for the label "realm.commonroot" and verify that the presented server certificate during the RADIUS/TLS handshake matches the information in the TLSA record.
</t>
<t>Example:
<list style="none">
<t>Realm = "example.com"</t>
<t>Common Branch = "idp.roaming-consortium.example.</t>
<t>label for TLSA query = "example.com.idp.roaming-consortium.example.</t>
<t>result of discovery algorithm for realm "example.com" = 192.0.2.1:2083</t>
<t>( TLS certificate of 192.0.2.1:2083 matches TLSA RR ? "PASS" : "FAIL" )</t>
</list>
</t>
</section><!--DEFS-RR-NAPTR-HANDSHAKE-DANE-->
<section title="Remark" anchor="client-authz">
<t>Note that RADIUS/TLS connections always mutually authenticate the RADIUS server and the RADIUS client. This specification provides an algorithm for a RADIUS client to contact and verify authorization of a RADIUS server only. 
During connection setup, the RADIUS server also needs to verify whether it considers the connecting RADIUS client authorized; this is outside the scope of this specification.</t>
</section>
</section><!--DEFS-RR-NAPTR-HANDSHAKE-->
</section><!--DEFS-RR-NAPTR-->
<section title="SRV" anchor="SRV"><!--DEFS-RR-SRV-->
<t>This specification defines two SRV prefixes (i.e. two values for the "_service._proto" part of an SRV RR as per <xref target="RFC2782" />):
<figure anchor="srv-labels" title="List of SRV Labels"><artwork>
<![CDATA[
+-----------------+-----------------------------------------+
| SRV Label       | Use                                     |
+-----------------+-----------------------------------------+
| _radiustls._tcp | RADIUS transported over TLS as defined  |
|                 | in [RFC6614]                            |
| - - - - - - - - | - - - - - - - - - - - - - - - - - - - - |
| _radiustls._udp | RADIUS transported over DTLS as defined |
|                 | in [I-D.ietf-radext-dtls]               |
+-----------------+-----------------------------------------+
]]></artwork></figure></t>
<t>
Just like NAPTR records, the lookup and subsequent follow-up of SRV records may yield more than one server to contact in a prioritised list.
<xref target="RFC2782" /> does not specify rules regarding "Definition of Conditions for Retry/Failure", nor "Server Identification and Handshake".
This specification defines that the rules for these two topics as defined in <xref target="NAPTR-conditions"/> and <xref target="NAPTR-handshake"/> SHALL be used both for targets retrieved via an initial NAPTR RR as well as for targets retrieved via an initial SRV RR (i.e. in the absence of NAPTR RRs).
</t>
</section><!--DEFS-RR-SRV-->
<section title="Remarks" anchor="Remarks"><!--DEFS-RR-REMARKS-->
<t>It is expected that in most cases, the SRV and/or NAPTR label used for the records is the DNS A-label representation of the literal realm name for which the server is the authoritative RADIUS server (i.e. the realm name after conversion according to section 5 of [RFC5891]).</t>
            <t>
                    However, arbitrary other labels or service tags may be used if, for example,
a roaming consortium uses realm names which are not associated to DNS names or
special-purpose consortia where a globally valid discovery is not a use case.
Such other labels require a consortium-wide agreement about the transformation
from realm name to lookup label, and/or which service tag to use.
            </t>
            <t>Examples:
                    <list style="letters">
                            <t>A general-purpose RADIUS server for realm
example.com might have DNS entries as follows:
                            <list style="empty">
                                    <t>example.com. IN NAPTR 50 50 "s"
"aaa+auth:radius.tls" "" _radiustls._tcp.foobar.example.com.</t>
                                    <t>_radiustls._tcp.foobar.example.com. IN SRV 0 10
2083 radsec.example.com.</t>
                            </list>
                            </t>
                            <t>The consortium "foo" provides roaming services for
its members only. The realms used are of the form enterprise-name.example. The
consortium operates a special purpose DNS server for the (private) TLD
"example" which all RADIUS servers use to resolve realm names. "Bad, Inc." is
part of the consortium. On the consortium's DNS server, realm
bad.example might have the following DNS entries:
                                    <list style="empty">
                                            <t>bad.example IN NAPTR 50
50 "a" "aaa+auth:radius.dtls" "" very.bad.example</t>
                                    </list>
                            </t>
                            <t>The eduroam consortium uses realms based on DNS,
but provides its services to a closed community only. However, a AAA domain
participating in eduroam may also want to expose AAA services to other,
general-purpose, applications (on the same or other RADIUS servers). Due to that,
the eduroam consortium uses the service tag "x-eduroam" for authentication purposes and eduroam RADIUS
servers use this tag to look up other eduroam servers. An eduroam participant example.org which also
provides general-purpose AAA on a different server uses the general "aaa+auth" tag:
                                    <list style="empty">
                                            <t>example.org. IN NAPTR 50 50 "s" "x-eduroam:radius.tls" "" _radiustls._tcp.eduroam.example.org.</t>
                                            <t>example.org. IN NAPTR 50 50 "s" "aaa+auth:radius.tls" "" _radiustls._tcp.aaa.example.org</t>
                                            <t>_radiustls._tcp.eduroam.example.org. IN SRV 0 10 2083 aaa-eduroam.example.org.</t>
                                            <t>_radiustls._tcp.aaa.example.org. IN SRV 0 10 2083 aaa-default.example.org.</t>
                                    </list>
                            </t>
                    </list>
            </t>
</section><!--DEFS-RR-REMARKS-->
</section><!--DEFS-RR-->
<section title="Definition of the X.509 certificate property SubjectAltName:otherName:NAIRealm" anchor="certprop"><!--DEFS-CERT-->
<t>
This specification retrieves IP addresses and port numbers from the Domain Name System which are subsequently used to authenticate users via the RADIUS/TLS protocol. Since the Domain Name System is not necessarily trustworthy (e.g. if DNSSEC is not deployed for the queried domain name), it is important to verify that the server which was contacted is authorized to service requests for the user which triggered the discovery process.
</t>
<t>The input to the algorithm is a NAI realm as specified in <xref target="input"/>. As a consequence, the X.509 certificate of the server which is ultimately contacted for user authentication needs to be able to express that it is authorized to handle requests for that realm.
</t>
<t>
Current subjectAltName fields do not semantically allow to express an NAI realm; the field subjectAltName:dNSName is syntactically a good match but would inappropriately conflate DNS names and NAI realm names. Thus, this specification defines a new subjectAltName field to hold either a single NAI realm name or a wildcard name matching a set of NAI realms.
</t>
<t>
The subjectAltName:otherName:sRVName field certifies that a certificate holder is authorized to provide a service; this can be compared to the target of DNS label's SRV resource record. If the Domain Name System is insecure, it is required that the label of the SRV record itself is known-correct. In this specification, that label is not known-correct; it is potentially derived from a (potentially untrusted) NAPTR resource record of another label. If DNS is not secured with DNSSEC, the NAPTR resource record may have been altered by an attacker with access to the Domain Name System resolution, and thus the label to lookup the SRV record for may already be tainted. This makes subjectAltName:otherName:sRVName not a trusted comparison item.
</t>
<t>
Further to this, this specification's NAPTR entries may be of type "A" which do not involve resolution of any SRV records, which again makes subjectAltName:otherName:sRVName unsuited for this purpose.
</t>
<t>
This section defines the NAIRealm name as a form of otherName from the GeneralName structure in SubjectAltName defined in <xref target="RFC5280"/>.
<list style="none">
<t>id-on-nai OBJECT IDENTIFIER ::= { id-on XXX }</t>
<t>NAIRealm ::= UTF8String (SIZE (1..MAX))</t>
</list>
The NAIRealm, if present, MUST contain an NAI realm as defined in <xref target="I-D.ietf-radext-nai"/>. It MAY substitute labels on the leftmost dot-separated part of the NAI with the single character "*" to indicate a wildcard match for "all labels in this part". Further features of regular expressions, such as a number of characters followed by a * to indicate a common prefix inside the part, are not permitted.
</t>
<t>
This subjectAltName MAY occur more than once in a certificate.
</t>
<t>
<xref target="nai-asn1"/> contains the ASN.1 definition of the above objects.
</t>
</section><!--DEFS-CERT-->
</section><!--DEFS-->
<section title="DNS-based NAPTR/SRV Peer Discovery" anchor="dns"><!--ALGO-->
<section title="Applicability" anchor="applicability"><!--ALGO-APPL-->
    <t>
		    Dynamic server discovery as defined in this document is only
     applicable for AAA transactions where a RADIUS entity which acts
     as a forwarding server for one or more realms receives a request with a realm
     for which it is not authoritative, and which no explicit next hop is configured.
It is only applicable for 
<list style="letters">
<t>new user sessions,
i.e. for the initial Access-Request. Subsequent messages concerning this
session, for example Access-Challenges and Access-Accepts use the previously-established communication
channel between client and server.</t>
<t>RADIUS DynAuth server discovery</t>
</list>
	    </t>
	</section><!--ALGO-APPL-->
    <section title="Configuration Variables" anchor="variables">
<t>The algorithm contains various variables for timeouts. These variables are named here and reasonable default values are provided. Implementations wishing to deviate from these defaults should make they understand the implications of changes.
<list style="none">
<t>DNS_TIMEOUT: maximum amount of time to wait for the complete set of all DNS queries to complete: Default = 3 seconds</t>
<t>MIN_EFF_TTL: minimum DNS TTL of discovered targets: Default = 60 seconds</t>
<t>BACKOFF_TIME: if no conclusive DNS response was retrieved after DNS_TIMEOUT, do not attempt dynamic discovery before BACKOFF_TIME has elapsed. Default = 600 seconds</t>
</list>
</t>
</section>
        <section title="Terms" anchor="defs"><!--ALGO-THETHING-DEFS-->
	<t>Positive DNS response: a response which contains the RR that was queried for.</t>
	<t>Negative DNS response: a response which does not contain the RR that was queried for, but contains an SOA record along with a TTL indicating cache duration for this negative result.</t> 
        <t>DNS Error: Where the algorithm states "name resolution returns with an error", this shall mean that either the DNS request timed out, or a DNS response which is neither a positive nor a negative response (e.g. SERVFAIL).
        </t>
        <t>Effective TTL: The validity period for discovered RADIUS/TLS target hosts. Calculated as: Effective TTL (set of DNS TTL values) = max { MIN_EFF_TTL, min { DNS TTL values } }
        </t>
	<t>SRV lookup: for the purpose of this specification, SRV lookup procedures are defined as per <xref target="RFC2782" />, but excluding that RFCs "A" fallback as defined in its section "Usage Rules", final "else" clause.</t>
	<t>Greedy result evaluation: The NAPTR to SRV/A/AAAA resolution may lead to a tree of results, whose leafs are the IP addresses to contact. The branches of the tree are ordered according to their order/preference DNS properties. An implementation is executing greedy result evaluation if it uses a depth-first search in the tree along the highest order results, attempts to connect to the corresponding resulting IP addresses, and only backtracks to other branches if the higher ordered results did not end in successful connection attempts.</t>
        </section><!--ALGO-THETHING-DEFS-->

    <section title="Realm to RADIUS server resolution algorithm" anchor="algo"><!--ALGO-THETHING-->
	<section title="Input" anchor="input"><!--ALGO-THETHING-INPUT-->
	    <t>For RADIUS Authentication and RADIUS Accounting server discovery, input I to the algorithm is the RADIUS User-Name attribute with content of the form "user@realm"; the literal @ sign being the separator between a local user identifier within a realm and its realm. The use of multiple literal @ signs in a User-Name is strongly discouraged; but if present, the last @ sign is to be considered the separator. All previous instances of the @ sign are to be considered part of the local user identifier.</t>
<t>For RADIUS DynAuth Server discovery, input I to the algorithm is the domain name of the operator of a RADIUS realm as was communicated during user authentication using the Operator-Name attribute (<xref target="RFC5580"/>, section 4.1). Only Operator-Name values with the namespace "1" are supported by this algorithm - the input to the algorithm is the actual domain name, preceeded with an "@" (but without the "1" namespace identifier byte of that attribute).</t>
<t>
                    Note well: The attribute User-Name is defined to contain UTF-8 text. In practice, the content may or may not be UTF-8. Even if UTF-8, it may or may not map to a domain name in the realm part. Implementors MUST take possible conversion error paths into consideration when parsing incoming User-Name attributes.
This document describes server discovery only for well-formed realms mapping to DNS domain names in UTF-8
encoding. The result of all other possible contents of User-Name is unspecified;
this includes, but is not limited to:
                    <list>
                      <t>Usage of separators other than @</t>
                      <t>Encoding of User-Name in local encodings</t>
                      <t>UTF-8 realms which fail the conversion rules as per <xref target="RFC5891"/></t>
                      <t>UTF-8 realms which end with a . ("dot") character.</t>
                    </list>
For the last bullet point, "trailing dot", special precautions should be taken to avoid problems when resolving servers with the algorithm below: they may resolve to a RADIUS server even if the peer RADIUS server only is configured to handle the realm without the trailing dot. If that RADIUS server again uses NAI discovery to determine the authoritative server, the server will forward the request to localhost, resulting in a tight endless loop.
            </t>
	</section><!--ALGO-THETHING-INPUT-->
	<section title="Output" anchor="Output"><!--ALGO-THETHING-OUTPUT-->
<t>Output O of the algorithm is a two-tuple consisting of:  O-1) a set of tuples {hostname; port; order/preference; Effective TTL} - the set can be empty; and O-2) an integer: if the set in the first part of the tuple is empty, the integer contains the Effective TTL for backoff timeout, if the set is not empty, the integer is set to 0 (and not used).</t>
	</section><!--ALGO-THETHING-OUTPUT-->
	<section title="Algorithm" anchor="core-algo"><!--ALGO-THETHING-CORE-->
	    <t>The algorithm to determine the RADIUS server to contact is as follows:
		    <list style="numbers">
			    <t>Determine P = (position of last "@" character) in I.</t>
			    <t>generate R = (substring from P+1 to end of I)</t>
			    <t>modify R according to agreed consortium procedures if applicable</t>
			    <t>convert R to a representation usable by the name resolution library if needed</t>
			    <t>Initialize TIMER = 0; start TIMER. If TIMER reaches DNS_TIMEOUT, continue at step 20.</t>
			    <t>Using the host's name resolution library, perform a NAPTR query for R (see "Delay considerations" below). If the result is a negative DNS response, O-2 = Effective TTL ( TTL value of the SOA record ) and continue at step 13. If name resolution returns with error, O-1 = { empty set }, O-2 = BACKOFF_TIME and terminate.</t>
			    <t>Extract NAPTR records with service tag "aaa+auth", "aaa+acct", "aaa+dynauth" as appropriate. Keep note of the remaining TTL of each of the discovered NAPTR records.</t>
			    <t>If no records found, continue at step 13.</t>
			    <t>For the extracted NAPTRs, perform successive resolution as defined in <xref target="RFC3958"/>, section 2.2. An implementation MAY use greedy result evaluation according to the NAPTR order/preference fields (i.e. can execute the subsequent steps of this algorithm for the highest-order entry in the set of results, and only lookup the remainder of the set if necessary).</t>
			    <t>If the set of hostnames is empty, O-1 = { empty set }, O-2 = BACKOFF_TIME and terminate. </t>
			    <t>O' = (set of {hostname; port; order/preference; Effective TTL ( all DNS TTLs that led to this hostname ) } for all terminal lookup results).</t>
			    <t>Proceed with step 18.</t>
			    <t>Generate R' = (prefix R with "_radiustls._tcp." or "_radiustls._udp.")</t>
			    <t>Using the host's name resolution library, perform
SRV lookup with R' as label (see "Delay considerations" below).</t>
			    <t>If name resolution returns with error, O-1 = { empty set }, O-2 = BACKOFF_TIME and terminate.</t>
			    <t>If the result is a negative DNS response, O-1 = { empty set }, O-2 = min { O-2, Effective TTL ( TTL value of the SOA record ) } and terminate.</t>
<t>O' = (set of {hostname; port; order/preference; Effective TTL ( all DNS TTLs that led to this result ) } for all
hostnames).</t>
<t>Generate O-1 by resolving hostnames in O' into corresponding A and/or AAAA addresses: O-1 = (set of {IP address; port; order/preference; Effective TTL ( all DNS TTLs that led to this result ) } for all hostnames ), O-2 = 0.</t>
<t>For each element in O-1, test if the original request which triggered dynamic discovery was received on {IP address; port}. If yes, O-1 = { empty set }, O-2 = BACKOFF_TIME, log error, Terminate (see next section for a rationale). If no, O is the result of dynamic discovery. Terminate.</t>
<t>O-1 = { empty set }, O-2 = BACKOFF_TIME, log error, Terminate.</t>
		    </list>
	    </t>
	</section><!--ALGO-THETHING-CORE-->
<section title="Validity of results" anchor="validity"><!--ALGO-THETHING-VALIDITY-->
	<t>The dynamic discovery algorithm is used by servers which do not have sufficient configuration information to process an incoming request on their own. If the discovery algorithm result contains the server's own listening address (IP address and port), then this will either lead to a tight loop (if that DNS entry has topmost priority, the server would forward the request to itself, triggering dynamic discovery again in a perpetual loop), or lead to a potential loop with intermediate hops in between (the server could forward to another host with a higher priority, which might use DNS itself and forward the packet back to the first server). The underlying reason that enables these loops is that the server executing the discovery algorithm is seriously misconfigured in that it does not recognise the request as one that is to be processed by itself. RADIUS has no built-in loop detection, so any such loops would remain undetected. So, if step 18 of the algorithm discovers such a possible-loop situation, the algorithm should be aborted and an error logged. Note that this safeguard does not provide perfect protection against routing loops: other reasons include the possiblity that a subsequent hop has a statically configured next-hop which leads to an earlier host in the loop; or the algorithm execution was executed with greedy result evaluation, and the own address was in a lower-priority branch of the result set which was not retrieved from DNS at all.
	</t>
	<t>After executing the above algorithm, the RADIUS server establishes a connection to a home server from the result set. This connection can potentially remain open for an indefinite amount of time. This conflicts with the possibility of changing device and network configurations on the receiving end. Typically, TTL values for records in the name resolution system are used to indicate how long it is safe to rely on the results of the name resolution. If these TTLs are very low, thrashing of connections becomes possible; the Effective TTL mitigates that risk. When a connection is open and the smallest of the Effective TTL value which was learned during discovering the server has not expired, subsequent new user sessions for the realm which corresponds to that open connection SHOULD re-use the existing connection and SHOULD NOT re-execute the dynamic discovery algorithm nor open a new connection.  To allow for a change of configuration, a RADIUS server SHOULD re-execute the dynamic discovery algorithm after the Effective TTL that is associated with this connection has expired. The server MAY keep the session open during this re-assessment to avoid closure and immediate re-opening of the connection should the result not have changed.
</t>
<t>
Should the algorithm above terminate with O-1 = empty set, the RADIUS server SHOULD NOT attempt another execution of this algorithm for the same target realm before the timeout O-2 has passed.
</t>
</section><!--ALGO-THETHING-VALIDITY-->
<section title="Delay considerations" anchor="delay"><!--ALGO-THETHING-DELAY-->
<t>The host's name resolution library may need to contact outside entities to perform the name resolution (e.g. authoritative name servers for a domain), and since the NAI discovery algorithm is based on uncontrollable user input, the destination of the lookups is out of control of the server that performs NAI discovery. 
If such outside entities are misconfigured or unreachable, the algorithm above may need an unacceptably long time to terminate. 
Many RADIUS implementations time out after five seconds of delay between Request and Response. 
It is not useful to wait until the host name resolution library signals a time-out of its name resolution algorithms. The algorithm therefore control execution time with TIMER. 
Execution of the NAI discovery algorithm SHOULD be non-blocking (i.e. allow other requests to be processed in parallel to the execution of the algorithm).</t>
</section><!--ALGO-THETHING-DELAY-->
        <section title="Example" anchor="example"><!--ALGO-THETHING-EXAMPLE-->
            <t>
            Assume 
<list style="empty">
<t>a user from the Technical University of Munich,
Germany, has a RADIUS User-Name of "foobar@tu-m[U+00FC]nchen.example".</t>
<t>The name resolution library on the RADIUS forwarding server does not have the realm tu-m[U+00FC]nchen.example in its forwarding configuration, but uses DNS for name resolution and has configured the use of Dynamic Discovery to discover RADIUS servers.</t>
<t>It is IPv6-enabled and prefers AAAA records over A records.</t>
<t>It is listening for incoming RADIUS/TLS requests on 192.0.2.1, TCP/2083.</t>
</list>
May the configuration variables be
<list style="none">
<t>DNS_TIMEOUT = 3 seconds</t>
<t>MIN_EFF_TTL = 60 seconds</t>
<t>BACKOFF_TIME = 3600 seconds</t>
</list>

If DNS contains the following records:
            <list style="empty">
                    <t>xn--tu-mnchen-t9a.example. IN NAPTR 50 50 "s"
"aaa+auth:radius.tls" "" _myradius._tcp.xn--tu-mnchen-t9a.example.</t>
                    <t>xn--tu-mnchen-t9a.example. IN NAPTR 50 50 "s"
"fooservice:bar.dccp" "" _abc123._def.xn--tu-mnchen-t9a.example.</t>
                    <t>_myradius._tcp.xn--tu-mnchen-t9a.example. IN SRV 0 10 2083
radsecserver.xn--tu-mnchen-t9a.example.</t>
                    <t>_myradius._tcp.xn--tu-mnchen-t9a.example. IN SRV 0 20 2083
backupserver.xn--tu-mnchen-t9a.example.</t>
                    <t>radsecserver.xn--tu-mnchen-t9a.example. IN AAAA
2001:0DB8::202:44ff:fe0a:f704</t>
                    <t>radsecserver.xn--tu-mnchen-t9a.example. IN A    192.0.2.3</t>
                    <t>backupserver.xn--tu-mnchen-t9a.example. IN A    192.0.2.7</t>
            </list>
                    Then the algorithm executes as follows, with I =
"foobar@tu-m[U+00FC]nchen.example", and no consortium name mangling in use:
                    <list style="numbers">
                            <t>P = 7</t>
                            <t>R = "tu-m[U+00FC]nchen.example"</t>
                            <t>NOOP</t>
                            <t>name resolution library converts R to xn--tu-mnchen-t9a.example</t>
			    <t>TIMER starts.</t>
                            <t>Result: <list style="none"><t>(TTL = 47) 50 50 "s" "aaa+auth:radius.tls" "" _myradius._tcp.xn--tu-mnchen-t9a.example.</t><t>(TTL = 522) 50 50 "s" "fooservice:bar.dccp" "" _abc123._def.xn--tu-mnchen-t9a.example.</t></list></t>
                            <t>Result: <list style="none"><t>(TTL = 47) 50 50 "s" "aaa+auth:radius.tls" "" _myradius._tcp.xn--tu-mnchen-t9a.example.</t></list></t>
			    <t>NOOP</t>
                            <t>Successive resolution performs SRV query for label _myradius._tcp.xn--tu-mnchen-t9a.example, which results in<list style="none">
<t>(TTL 499) 0 10 2083 radsec.xn--tu-mnchen-t9a.example.</t><t>(TTL 2200) 0 20 2083 backup.xn--tu-mnchen-t9a.example.</t></list></t>
                            <t>NOOP</t>
			    <t>O' = { <list style="none"><t>(radsec.xn--tu-mnchen-t9a.example.; 2083; 10; 60),</t><t>(backup.xn--tu-mnchen-t9a.example.; 2083; 20; 60)</t></list> } // minimum TTL is 47, up'ed to MIN_EFF_TTL</t>
                            <t>Continuing at 18.</t>
                            <t>(not executed)</t>
                            <t>(not executed)</t>
                            <t>(not executed)</t>
                            <t>(not executed)</t>
			    <t>(not executed)</t>
			    <t>O-1 = {<list style="none"><t>(2001:0DB8::202:44ff:fe0a:f704; 2083; 10; 60),</t><t>(192.0.2.7; 2083; 20; 60)</t></list>}; O-2 = 0</t>
			    <t>No match with own listening address; terminate with tuple (O-1, O-2) from previous step.</t>
                    </list>

                    The implementation will then attempt to connect to two
servers, with preference to [2001:0DB8::202:44ff:fe0a:f704]:2083.
</t>
</section><!--ALGO-THETHING-EXAMPLE-->
    </section><!--ALGO-THETHING-->
</section><!--ALGO-->
    <section title="Security Considerations" anchor="sec">
<t>
	The results from the execution of this algorithm are only trustworthy if each of the
lookup steps by the name resolution library were cryptographically secured; i.e. if DNSSEC
validation was turned on during the resolution AND all of the records were in a DNSSEC signed
zone AND validation of all those records was successful.
</t>    
<t>
	    When using DNS without DNSSEC security extensions for at least one of the replies to NAPTR, SRV and
A/AAAA requests as described in section <xref target="dns" />, the result O can not be
trusted. Even if it can be trusted (i.e. DNSSEC is in use), actual authorization of the discovered server to provide service for the given realm needs to be verified.
A mechanism from section <xref target="NAPTR-handshake"/> or equivalent MUST be used to verify authorization. 
    </t>
<t>
	The algorithm has a configurable completion time-out DNS_TIMEOUT defaulting to three seconds for RADIUS' operational reasons.
The lookup of DNS resource records based on unverified user input is an attack vector for DoS attacks: an attacker might intentionally craft bogus DNS zones which take a very long time
to reply (e.g. due to a particularly byzantine tree structure, or artificial delays in responses).</t>
<t>
To mitigate this DoS vector, implementations SHOULD consider rate-limiting either their amount of new executions of the dynamic discovery algorithm as a whole,
or the amount of intermediate responses to track, or at least the number of pending DNS queries. Implementations MAY choose lower values than the default for DNS_TIMEOUT to limit the impact of DoS attacks via that vector. They MAY also continue their attempt to resolve DNS records even after DNS_TIMEOUT has passed; a subsequent request for the same realm might benefit from retrieving the results anyway. The amount of time to spent waiting for a result will influence the impact of a possible DoS attack; the waiting time value is implementation dependent and outside the scope of this specification.
</t>
<t>
With Dynamic Discovery being enabled for a RADIUS Server, and depending on the deployment scenario, the server may need to open up its target IP address and port for the entire internet, because arbitrary clients may discover it as a target for their authentication requests. If such clients are not part of the roaming consortium, the RADIUS/TLS connection setup phase will fail (which is intended) but the computational cost for the connection attempt is significant. With the port for a TLS-based service open, the RADIUS server shares all the typical attack vectors for services based on TLS (such as HTTPS, SMTPS, ...). Deployments of RADIUS/TLS with Dynamic Discovery should consider these attack vectors and take appropriate counter-measures (e.g. blacklisting known-bad IPs on a firewall, rate-limiting new connection attempts, etc.).
</t>
    </section>
<section title="Privacy Considerations" anchor="privacy">
<t>The classic RADIUS operational model (known, pre-configured peers, shared secret security, mostly plaintext communication) and this new RADIUS dynamic discovery model (peer discovery with DNS, PKI security and packet confidentiality) differ significantly in their impact on the privacy of end users trying to authenticate to a RADIUS server.</t>
<t>With classic RADIUS, traffic in large environments gets aggregated by statically configured clearinghouses. The packets sent to those clearinghouses and their responses are mostly unprotected. As a consequence,
<list style="symbols">
<t>All intermediate IP hops can inspect most of the packet payload in clear text, including the User-Name and Calling-Station-Id attributes, and can observe which client sent the packet to which clearinghouse. This allows the creation of mobility profiles for any passive observer on the IP path.</t>
<t>The existence of a central clearinghouse creates an opportunity for the clearinghouse to trivially create the same mobility profiles. The clearinghouse may or may not be trusted not to do this, e.g. by sufficiently threatening contractual obligations.</t>
<t>In addition to that, with the clearinghouse being a RADIUS intermediate in possession of a valid shared secret, the clearinghouse can observe and record even the security-critical RADIUS attributes such as User-Password. This risk may be mitigated by choosing authentication payloads which are cryptographically secured and do not use the attribute User-Password - such as certain EAP types.</t>
<t>There is no additional information disclosure to parties outside the IP path between the RADIUS client and server (in aprticular, no DNS servers learn about realms of current ongoing authentications).</t>
</list>
</t>
<t>With RADIUS and dynamic discovery,
<list style="symbols">
<t>Passive observers on the IP path cannot inspect any part of the RADIUS payload. They can observe source and destination of the traffic flow, but can not easily use this information to create mobility profiles because the user who tries to authenticate is not identifiable due to the encrypted payload.</t>
<t>Clearinghouses can be eliminated by RADIUS clients directly contacting the RADIUS home server, if this is desired. The possibility of aggregation of user information in the clearinghouse thus does not manifest. Note that despite the technical possibility of avoid clearinghouses, they may still remain in operation for other reasons.</t>
<t>RADIUS clients which make use of dynamic discovery will need to query the Domain Name System, and use a user's realm name as the query label. A passive observer on the IP path between the RADIUS client and the DNS server(s) being queried can learn that a user of that specific realm was trying to authenticate at that RADIUS client at a certain point in time. This may or may not be sufficient for the passive observer to create a mobility profile. During the recursive DNS resolution, a fair number of DNS servers and the IP hops in between those get to learn that information. Not every single authentication triggers DNS lookups, so there is no one-to-one relation of leaked realm information and the number of authentications for that realm.</t>
</list>
In summary, with classic RADIUS, few intermediate entities learn very detailed data about every ongoing authentications, while with dynamic discovery, many entities learn only very little about recently authenticated realms.
</t>
</section>
    <section title="IANA Considerations" anchor="iana">
	    <t>
		    This document requests IANA registration of the following entries in existing registries:
		    <list style="symbols">
		      <t>S-NAPTR Application Service Tags registry
			<list style="symbols">
			   <t>aaa+auth</t>
			   <t>aaa+acct</t>
			   <t>aaa+dynauth</t>
			</list>
		      </t>
		      <t>S-NAPTR Application Protocol Tags registry
			<list style="symbols">
			   <t>radius.tls</t>
			   <t>radius.dtls</t>
			</list>
		      </t>
		    </list>
	    </t>    
<t>This document reserves the use of the "_radiustls" and "_radiusdtls" Service labels.</t>
	    <t>
		This document requests the creation of a new IANA registry named "RADIUS/TLS SRV Protocol Registry" with the following initial entries:
		<list style="symbols">
                           <t>_tcp</t>
                           <t>_udp</t>
                        </list>
	</t>
	<t>
This specification allocates a X.509 certificate property "NAIRealm" as per section <xref target="certprop"/> above, see placeholders "XXX". There is currently no IANA registry for the subjectAltName:otherName namespace. The authority for this namespace appears to be the PKIX working group. Before issuing the RFC, IANA should liaise with PKIX to ensure that a value for NAIRealm is issued; IANA should subsequently, prior to issuing the RFC, update the placeholders in said section.
	</t>
    </section>
</middle>
<back>
	<references title="Normative References">
		&rfc2119;
		&rfc2782;
		&rfc2865;
		&rfc2866;
		&rfc3958;
<!--		&rfc4282; -->
		&rfc5176;
		&rfc5280;
		&rfc5580;
		&rfc5891; 
		&dtls;
		&rfc6614;
		&nai;
	</references>
<!--	<references title="Informative References">
	<reference anchor="radiator-manual"
target="http://www.open.com.au/radiator/ref.html">
		<front>
			<title>Radiator Radius Server - Installation and
Reference Manual</title>
			<author>
				<organization abbrev="OSC">Open System
Consultants</organization>
			</author>
			<date year="2006"/>
		</front>
		<format type="TXT"
target="http://www.open.com.au/radiator/ref.html"/>
	</reference>
</references> -->
<section title="Appendix A: ASN.1 Syntax of NAIRealm" anchor="nai-asn1">
<figure><artwork>
<![CDATA[

   PKIXServiceNameSAN93 {iso(1) identified-organization(3) dod(6)
       internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
       id-mod-dns-srv-name-93(40) }

   DEFINITIONS EXPLICIT TAGS ::=

   BEGIN

   -- EXPORTS ALL --

   IMPORTS

      id-pkix
            FROM PKIX1Explicit88 { iso(1) identified-organization(3)
            dod(6) internet(1) security(5) mechanisms(5) pkix(7)
            id-mod(0) id-pkix1-explicit(18) } ;
             -- from RFC 5280 


   -- In the GeneralName definition using the 1993 ASN.1 syntax
   -- includes:

   OTHER-NAME ::= TYPE-IDENTIFIER


   -- Service Name Object Identifier

   id-on   OBJECT IDENTIFIER ::= { id-pkix 8 }

   id-on-nai OBJECT IDENTIFIER ::= { id-on XXX }

   -- Service Name

   naiRealm OTHER-NAME ::= { NAIRealm IDENTIFIED BY { id-on-nai }}

   NAIRealm ::= UTF8String (SIZE (1..MAX))

   END

]]>
</artwork></figure>
</section>

</back>
</rfc>
