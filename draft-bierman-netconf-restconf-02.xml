<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>
<rfc ipr="trust200902"   category="std"
     docName="draft-bierman-netconf-restconf-02" >
    <front>
    <title abbrev="RESTCONF">RESTCONF Protocol</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' >
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>
    <author initials="K" surname="Watsen" fullname='Kent Watsen' >
      <organization>Juniper Networks</organization>
      <address>
        <email>kwatsen@juniper.net</email>
      </address>
    </author>
    <author initials="R" surname="Fernando" fullname='Rex Fernando' >
      <organization>Cisco</organization>
      <address>
        <email>rex@cisco.com</email>
      </address>
    </author>
	<date/>
    <abstract>
	<t>
This document describes a RESTful protocol that provides 
a programmatic interface over HTTP for accessing data
defined in YANG, using the datastores defined in NETCONF.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
There is a need for standard mechanisms to allow WEB applications
to access the configuration data, operational data, 
data-model specific protocol operations, and notification events
within a networking device, in a modular and extensible manner.
    </t>
    <t>
This document describes a RESTful protocol called RESTCONF,
running over HTTP <xref target="RFC2616"/>, for accessing data defined
in YANG <xref target="RFC6020"/>, using datastores defined in NETCONF <xref target="RFC6241"/>.
    </t>
    <t>
The NETCONF protocol defines configuration datastores and
a set of Create, Retrieve, Update, Delete (CRUD) operations 
that can be used to access these datastores.  The YANG language
defines the syntax and semantics of datastore content,
operational data, custom protocol operations, and
notification events. RESTful operations are used to
access the hierarchical data within a datastore.
    </t>
    <t>
A RESTful API can be created that provides CRUD operations on a
NETCONF datastore containing YANG-defined data.  This can be done in a
simplified manner, compatible with HTTP and RESTful design principles.
Since NETCONF protocol operations are not relevant, the user should
not need any prior knowledge of NETCONF in order to use the RESTful
API.
    </t>
    <t>
Configuration data and state data are exposed as resources that
can be retrieved with the GET method.  
Resources representing configuration data
can be modified with the DELETE, PATCH, POST, and PUT methods.
Data-model specific protocol operations defined with
the YANG &quot;rpc&quot; statement can be invoked with the POST method.
Data-model specific notification events defined with
the YANG &quot;notification&quot; statement can be accessed.
    </t>
<section title="Simple Subset of NETCONF Functionality">
    <t>
The framework and meta-model used for a RESTful API does not need to
mirror those used by the NETCONF protocol, but it needs to
be compatible with NETCONF.  A simplified framework and protocol
is needed that utilizes the three NETCONF datastores (candidate,
running, startup), but hides the complexity of multiple datastores
from the client.
    </t>
    <t>
A simplified transaction model is needed that allows basic
CRUD operations on a hierarchy of conceptual resources.
This represents a limited subset of the transaction capabilities
of the NETCONF protocol.
    </t>
    <t>
Applications that require more complex transaction capabilities
might consider NETCONF instead of RESTCONF.  The following
transaction features are not directly provided in RESTCONF:
    </t>
<t>
 <list style="symbols">
 <t>
datastore locking (full or partial)
 </t>
 <t>
candidate datastore
 </t>
 <t>
startup datastore
 </t>
 <t>
validate operation
 </t>
 <t>
confirmed-commit procedure
 </t>
 </list>
</t>
    <t>
The RESTful API is not intended to replace NETCONF, but rather provide
an additional simplified interface that follows RESTful principles and
is compatible with a resource-oriented device abstraction.  It is
expected that applications that need the full feature set of NETCONF
will continue to use NETCONF.
    </t>
    <t>
The following figure shows the system components:
    </t>
	<figure>
	    <artwork><![CDATA[
      +-----------+           +-----------------+
      |  WEB app  | <-------> |                 |
      +-----------+   HTTP    | network device  |
                              |                 |
      +-----------+           |   +-----------+ |
      |  NMS app  | <-------> |   | datastore | |
      +-----------+  NETCONF  |   +-----------+ |
                              +-----------------+
	    ]]></artwork>
	</figure>
</section>
<section title="Data Model Driven API">
    <t>
RESTCONF combines the simplicity of a RESTful API over HTTP
with the predictability and automation potential
of a schema-driven API.
    </t>
    <t>
A RESTful client using HATEOAS principles would not use
any data modeling language to define the application-specific content
of the API.  The client would discover each new child
resource as it traverses the URIs returned as Location IDs
to discover the server capabilities.
    </t>
    <t>
This approach has 3 significant weaknesses wrt/ control
of complex networking devices:
    </t>
<t>
 <list style="symbols">
 <t>
inefficient performance: configuration APIs will be quite
complex and may require thousands of protocol messages to
discover all the schema information.  Typically the
data type information has to be passed in the protocol messages,
which is also wasteful overhead.
 </t>
 <t>
no data model richness: without a data model, the schema-level
semantics and validation constraints are not available to the
application.
 </t>
 <t>
no tool automation: API automation tools need some sort of
content schema to function.  Such tools can automate
various programming and documentation tasks related
to specific data models.
 </t>
 </list>
</t>
    <t>
Data model modules such as YANG modules serve as an &quot;API contract&quot;
that will be honored by the server.  An application designer
can code to the data model, knowing in advance important details
about the exact protocol operations and datastore content
a conforming server implementation will support.
    </t>
    <t>
RESTCONF provides the YANG module capability information
supported by the server, in case the client wants to use it.
The URIs for custom protocol operations and datastore content
are predictable, based on the YANG module definitions.
    </t>
    <t>
Operational experience with CLI and SNMP indicates that
operators learn the &apos;location&apos; of specific service
or device related data and do not expect such information
to be arbitrary and discovered each time the
client opens a management session to a server.
    </t>
</section>
<section title="Terminology">
    <t>
The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <xref target="RFC2119"/>.
    </t>
<section title="NETCONF">
    <t>
The following terms are defined in <xref target="RFC6241"/>:
    </t>
<t>
 <list style="symbols">
 <t>
candidate configuration datastore
 </t>
 <t>
client
 </t>
 <t>
configuration data
 </t>
 <t>
datastore
 </t>
 <t>
configuration datastore
 </t>
 <t>
protocol operation
 </t>
 <t>
running configuration datastore
 </t>
 <t>
server
 </t>
 <t>
startup configuration datastore
 </t>
 <t>
state data
 </t>
 <t>
user
 </t>
 </list>
</t>
</section>
<section title="HTTP">
    <t>
The following terms are defined in <xref target="RFC2616"/>:
    </t>
<t>
 <list style="symbols">
 <t>
entity tag
 </t>
 <t>
fragment
 </t>
 <t>
header line
 </t>
 <t>
message body
 </t>
 <t>
method
 </t>
 <t>
path
 </t>
 <t>
query
 </t>
 <t>
request URI
 </t>
 <t>
response body
 </t>
 </list>
</t>
</section>
<section title="YANG">
    <t>
The following terms are defined in <xref target="RFC6020"/>:
    </t>
<t>
 <list style="symbols">
 <t>
container
 </t>
 <t>
data node
 </t>
 <t>
key leaf
 </t>
 <t>
leaf
 </t>
 <t>
leaf-list
 </t>
 <t>
list
 </t>
 <t>
presence container (or P-container)
 </t>
 <t>
RPC operation (now called protocol operation)
 </t>
 <t>
non-presence container (or NP-container)
 </t>
 <t>
ordered-by system
 </t>
 <t>
ordered-by user
 </t>
 </list>
</t>
</section>
<section title="Terms">
    <t>
The following terms are used within this document:
    </t>
<t>
 <list style="symbols">
 <t>
API resource: a resource with the media type 
&quot;application/yang.api+xml&quot; or &quot;application/yang.api+json&quot;.
API resources can only be edited by the server.
 </t>
 <t>
data resource: a resource with the media type 
&quot;application/yang.data+xml&quot; or &quot;application/yang.data+json&quot;.
Data resources can be edited by clients or the server.
Only YANG containers and lists can be data resources.
Top-level YANG terminals are treated as fields within
the datastore resource.
 </t>
 <t>
datastore resource: a resource with the media type 
&quot;application/yang.datastore+xml&quot; or 
&quot;application/yang.datastore+json&quot;.
Datastore resources can only be edited by the server.
 </t>
 <t>
edit operation: a RESTCONF operation on a data resource
using the POST, PUT, PATCH, or DELETE method.
 </t>
 <t>
event stream resource: a resource with the media type 
&quot;application/yang.stream+xml&quot; or 
&quot;application/yang.stream+json&quot;. This resource represents
an SSE event stream. The content consists of text
using the media type &quot;text/event&#8209;stream&quot;. Each event represents
one &lt;notification&gt; message generated by the server.
It contains a conceptual system or data-model specific event
that is delivered within a notification event stream.
 </t>
 <t>
field: a YANG terminal node within a resource.
 </t>
 <t>
operation: the conceptual RESTCONF operation for a message,
derived from the HTTP method, request URI, headers, and message body.
 </t>
 <t>
operation resource: a resource with the media type 
&quot;application/yang.operation+xml&quot; or
&quot;application/yang.operation+json&quot;.
 </t>
 <t>
patch: a generic PATCH operation on the target datastore.
The media type of the message body content will identify
the patch type in use.
 </t>
 <t>
plain patch: a PATCH operation where the media type
is &quot;application/yang.data+xml&quot; or &quot;application/yang.data+json&quot;.
 </t>
 <t>
query parameter: a parameter (and its value if any),
encoded within the query component of the request URI.
 </t>
 <t>
resource: a conceptual object representing a manageable 
component within a device. Refers to the resource itself of
the resource and all its fields.
 </t>
 <t>
retrieval request: an operation using the GET or HEAD methods.
 </t>
 <t>
target resource: the resource that is associated with
a particular message, identified by the &quot;path&quot; component
of the request URI.
 </t>
 <t>
unified datastore: A conceptual representation of the device
running configuration. The server will hide all NETCONF datastore
details for edit operations, such as the &quot;:candidate&quot; and &quot;:startup&quot;
capabilities.
 </t>
 <t>
YANG Patch: a PATCH operation where the media type
is &quot;application/yang.patch+xml&quot; or
&quot;application/yang.patch+json&quot;.
 </t>
 <t>
YANG Patch Status: the status data returned for a YANG Patch operation
identified by the media type &quot;application/yang.patch&#8209;status+xml&quot;
or &quot;application/yang.patch&#8209;status+json&quot;.
 </t>
 <t>
YANG terminal node: a YANG node representing a leaf,
leaf-list, or anyxml definition.
 </t>
 </list>
</t>
</section>
<section title="Tree Diagrams">
    <t>
A simplified graphical representation of the data model is used in
this document.  The meaning of the symbols in these
diagrams is as follows:
    </t>
<t>
 <list style="symbols">
 <t>
Brackets &quot;[&quot; and &quot;]&quot; enclose list keys.
 </t>
 <t>
Abbreviations before data node names: &quot;rw&quot; means configuration
(read-write) and &quot;ro&quot; state data (read-only).
 </t>
 <t>
Symbols after data node names: &quot;?&quot; means an optional node and &quot;*&quot;
denotes a &quot;list&quot; and &quot;leaf&#8209;list&quot;.
 </t>
 <t>
Parentheses enclose choice and case nodes, and case nodes are also
marked with a colon (&quot;:&quot;).
 </t>
 <t>
Ellipsis (&quot;...&quot;) stands for contents of subtrees that are not shown.
 </t>
 </list>
</t>
</section>
</section>
<section title="Overview">
    <t>
This document defines the RESTCONF protocol, a RESTful API for accessing
conceptual datastores containing data defined with the YANG language.
RESTCONF provides an application framework and meta-model,
using HTTP methods.
    </t>
    <t>
The RESTCONF resources are accessed via a set of
URIs defined in this document.
The set of YANG modules supported by the server
will determine the additional data model specific operations,
top-level data node resources, and notification event messages
supported by the server.
    </t>
<section title="Resource URI Map">
    <t>
The URI hierarchy for the RESTCONF resources
consists of an entry point container,
4 top-level resources, and 1 field.
Refer to <xref target="resources"/> for details on each URI.
    </t>
	<figure>
	    <artwork><![CDATA[
  /restconf
     /config
        /<top-level-data-nodes> (configuration data)
     /operational
        /<top-level-data-nodes> (operational data)
     /modules
        /module
           /name
           /revision
           /namespace
           /feature
           /deviation
     /operations
        /<custom protocol operations>
     /streams
        /stream
           /name
           /description
           /replay-support
           /replay-log-creation-time
           /events
     /version (field)
	    ]]></artwork>
	</figure>
</section>
<section title="RESTCONF Message Examples" anchor="main-examples">
    <t>
The examples within this document use the normative
YANG module defined in <xref target="module"/> and the non-normative
example YANG module defined in <xref target="example-module"/>.
    </t>
    <t>
This section shows some typical RESTCONF message exchanges.
    </t>
<section title="Retrieve the Top-level API Resource">
    <t>
The client may start by retrieving the top-level
API resource, using the entry point URI &quot;/restconf&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf?format=json HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Content-Type: application/yang.api+json

   {
     "ietf-restconf:restconf": {
       "config" : [ null ],
       "operational" : [ null ],
       "modules": {
         "module": [
           {
             "name" : "example-jukebox",
             "revision" : "2013-10-19",
             "namespace" : "http://example.com/ns/example-jukebox"
           }
         ]
       },
       "operations" : {
          "play" : [ null ]
       },
       "streams" : {
         "stream" : [
           {
             "name" : "NETCONF",
             "description" : "default NETCONF event stream",
             "replay-support" : true,
             "replay-log-creation-time:" : "2007-07-08T00:00:00Z",
             "events" : [ null ]
           }
         ]
       },
       "version": "1.0"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
To request that the response content to be encoded in XML,
the &quot;Accept&quot; header can be used, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf HTTP/1.1
   Host: example.com
   Accept: application/yang.api+xml
	    ]]></artwork>
	</figure>
    <t>
An alternate approach is provided using the &quot;format&quot; query
parameter, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf?format=xml HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server will return the same response either way,
which might be as follows :
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.api+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <restconf xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <config/>
     <operational/>
     <modules>
       <module>
         <name>example-jukebox</name>
         <revision>2013-10-19</revision>
         <namespace>
           http://example.com/ns/example-jukebox
         </namespace>
       </module>
     </modules>
     <operations>
       <play xmlns="http://example.com/ns/example-jukebox"/>
     </operations>
     <streams>
       <stream>
         <name>NETCONF</name>
         <description>default NETCONF event stream
         </description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-08T00:00:00Z
         </replay-log-creation-time>
         <events/>
       </stream>
     </streams>
     <version>1.0</version>
   </restconf>
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="get"/> for details on the GET method.
    </t>
</section>
<section title="Create New Data Resources">
    <t>
To create a new &quot;jukebox&quot; resource, the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/config HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   { "example-jukebox:jukebox" : [null] }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond as follows.
Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Location: http://example.com/restconf/config/
      example-jukebox:jukebox
   Last-Modified: Mon, 23 Apr 2012 17:01:00 GMT
   ETag: b3a3e673be2
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;artist&quot; resource within the &quot;library&quot;
resource, the client might send the following request.
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/config/example-jukebox:jukebox/library HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   { "example-jukebox:artist" : {
       "name" : "Foo Fighters"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond as follows.
Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Location: http://example.com/restconf/config/
        example-jukebox:jukebox/library/artist/Foo%20Fighters
   Last-Modified: Mon, 23 Apr 2012 17:02:00 GMT
   ETag: b3830f23a4c
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;album&quot; resource for this artist within the &quot;jukebox&quot;
resource, the client might send the following request.
Note that the request URI header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters  HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:alternative",
       "year" : 2012    # note this is the wrong date
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond
as follows.  Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
   Location: http://example.com/restconf/config/
     example-jukebox:jukebox/library/artist/Foo%20Fighters/
     album/Wasting%20Light
   Last-Modified: Mon, 23 Apr 2012 17:03:00 GMT
   ETag: b8389233a4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="post"/> for details on the POST method.
    </t>
</section>
<section title="Replace an Existing Data Resource">
    <t>
Note: replacing a resource is a fairly drastic operation.
The PATCH method is often more appropriate.
    </t>
    <t>
The album sub-resource is replaced here for example
purposes only.
To replace the &quot;album&quot; resource contents,
the client might send as follows.
Note that the request URI header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   PUT /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light   HTTP/1.1
   Host: example.com
   If-Match: b3830f23a4c
   Content-Type: application/yang.data+json

   {
     "example-jukebox:album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:alternative",
       "year" : 2011
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:04:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:04:00 GMT
   ETag: b27480aeda4c
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="put"/> for details on the PUT method.
    </t>
</section>
<section title="Patch an Existing Data Resource">
    <t>
To replace just the &quot;year&quot; field in the &quot;album&quot; resource
(instead of replacing the entire resource),
the client might send a plain patch as follows.
Note that the request URI header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light HTTP/1.1
   Host: example.com
   If-Match: b8389233a4c
   Content-Type: application/yang.data+json

   { "example-jukebox:year" : 2011 }
	    ]]></artwork>
	</figure>
    <t>
If the field is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:30 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:49:30 GMT
   ETag: b2788923da4c
	    ]]></artwork>
	</figure>
    <t>
The XML encoding for the same request might be:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light HTTP/1.1
   Host: example.com
   If-Match: b8389233a4c
   Content-Type: application/yang.data+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <year xmlns="http://example.com/ns/example-jukebox">2011</year>
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="patch"/> for details on the PATCH method.
    </t>
</section>
<section title="Delete an Existing Data Resource">
    <t>
To delete a resource such as the &quot;album&quot; resource,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   DELETE /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the resource is deleted, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:40 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="delete"/> for details on the DELETE method.
    </t>
</section>
<section title="Delete an Optional Field Within a Data Resource">
    <t>
The DELETE method cannot be used to delete an 
optional field within a resource. This can only be done
using the PATCH method with the YANG Patch media type.
    </t>
    <t>
Refer to <xref target="yang-patch"/> for details on the YANG Patch method.
    </t>
</section>
<section title="Invoke a Data Model Specific Operation">
    <t>
To invoke a data-model specific operation via an
operation resource, the POST method is used.
A client might send a &quot;backup&#8209;datastore&quot; request as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:backup-datastore   HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:50:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="protocol-ops"/> for details on using the POST method
with operation resources.
    </t>
</section>
</section>
</section>
</section>
<section title="Framework">
    <t>
The RESTCONF protocol defines a framework
that can be used to implement a common API for
configuration management.  This section describes
the components of the RESTCONF framework.
    </t>
<section title="Message Model">
    <t>
The RESTCONF protocol uses HTTP entities for messages.
A single HTTP message corresponds to a single protocol method.
Most messages can perform a single task on a single resource,
such as retrieving a resource or editing a resource.
The exception is the PATCH method, which allows multiple datastore
edits within a single message.
    </t>
</section>
<section title="Notification Model" anchor="notification-model">
    <t>
The RESTCONF protocol supports YANG-defined event notifications.
The solution preserves aspects of NETCONF Event Notifications <xref target="RFC5277"/>
while utilizing the Server-Sent Events <xref target="wd-eventsource"/> transport strategy.
    </t>
<section title="Server Support">
    <t>
A RESTCONF server is not required to support RESTCONF notifications.
Clients may determine if a server supports RESTCONF notifications by
using the HTTP operation OPTIONS, HEAD, or GET on the
&quot;/restconf/streams&quot; resource described below.
The server does not support RESTCONF notifications if an HTTP error 
code is returned (e.g. 404 Not Found).
    </t>
</section>
<section title="Event Stream Discovery">
    <t>
A RESTCONF client retrieves the list of supported event streams from
a RESTCONF server using the GET operation on the &quot;/restconf/streams&quot;
resource.
    </t>
    <t>
The &quot;/restconf/streams&quot; container definition in the &quot;ietf&#8209;restconf&quot; module
defined in <xref target="module"/> is used to specify the structure and syntax
of the conceptual fields and sub-resources within the &quot;streams&quot; resource.
    </t>
    <t>
For example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams HTTP/1.1
   Host: example.com
   Accept: application/yang.api+xml
	    ]]></artwork>
	</figure>
    <t>
Available event streams for the requesting session are returned
according 
the YANG container  <xref target="RFC5277"/>:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/yang.api+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <streams xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
      <stream>
         <name>NETCONF</name>
         <description>default NETCONF event stream
         </description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-08T00:00:00Z
         </replay-log-creation-time>
         <events/>
      </stream>
      <stream>
         <name>SNMP</name>
         <description>SNMP notifications</description>
         <replay-support>false</replay-support>
         <events/>
      </stream>
      <stream>
         <name>syslog-critical</name>
         <description>Critical and higher severity
         </description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-01T00:00:00Z
         </replay-log-creation-time>
         <events/>
      </stream>
   </streams>
	    ]]></artwork>
	</figure>
</section>
<section title="Subscribing to Receive Notifications" anchor="receive-notifs">
    <t>
RESTCONF clients can subscribe to receive notifications by sending an
HTTP GET to the &quot;/restconf/streams/stream/&lt;stream&#8209;name&gt;&quot; resource
with the &quot;Accept&quot; type &quot;text/event&#8209;stream&quot;, which signals the desire to use the
Server Sent Events <xref target="wd-eventsource"/> transport strategy.
    </t>
    <t>
For example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams/stream/NETCONF/events HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
	    ]]></artwork>
	</figure>
    <t>
A RESTCONF client MAY request the server compress the events using
the HTTP header field &quot;Accept&#8209;Encoding&quot;.  For instance:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams/stream/NETCONF/events HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
   Accept-Encoding: gzip, deflate
	    ]]></artwork>
	</figure>
<section title="Query Parameters">
    <t>
Consistent with <xref target="RFC5277"/>, RESTCONF notification subscriptions
may specify parameters indicating the events it wishes to receive.
These parameters are passed in RESTCONF using HTTP query parameters
as follows:
    </t>
<section title="start-time">
    <t>
An optional parameter used to trigger the replay feature
and indicate that the replay should start at the time
specified.  If the stream does not support replay, per the
&quot;replay&#8209;support&quot; attribute returned by the /restconf/streams
resource, then the server MUST return the HTTP error code
400 Bad Request.  If the &quot;start&#8209;time&quot; parameter is not present,
this is not a replay
subscription.  It is not valid to specify start times that are
later than the current time.  If the &quot;start&#8209;time&quot; specified is
earlier than the log can support, the replay will begin with
the earliest available notification. 
This parameter is of YANG type &quot;date&#8209;and&#8209;time&quot; from the
&quot;ietf&#8209;inet&#8209;types&quot; module in <xref target="RFC6991"/>.
    </t>
    <t>
Example: (line wrapped for display purposes only)
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams/stream/syslog-critical/events?
      start-time=2012-12-31T23:59:59Z
	    ]]></artwork>
	</figure>
</section>
<section title="stop-time">
    <t>
The optional &quot;stop&#8209;time&quot; parameter is used with the optional
replay feature to indicate the newest notifications of
interest.  This parameter MUST be used with and have a value later than 
the &quot;start&#8209;time&quot; parameter.  If the &quot;stop&#8209;time&quot; parameter is not present,
the notifications will continue until the subscription is terminated.
Values of &quot;stop&#8209;time&quot; in the future are valid.  This parameter is 
of YANG type &quot;date&#8209;and&#8209;time&quot; from the &quot;ietf&#8209;inet&#8209;types&quot; module
in <xref target="RFC6991"/>.
    </t>
    <t>
Example:    (&apos;\&apos; added for formatting only)
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/events?start-time=2013-12-31T23:59:00Z;\
   stop-time=2014-01-01T00:01:00Z
	    ]]></artwork>
	</figure>
</section>
<section title="filter">
    <t>
The optional &quot;filter&quot; parameter is used to indicate which subset of
all possible events are of interest.  If not present, all events not
precluded by other parameters will be sent.  The format of this
parameter is an XPath expression as defined in <xref target="XPATH"/>.  The XPath
filter expression is evaluated in the following context:
    </t>
<t>
 <list style="symbols">
 <t>
The set of namespace declarations is the set of prefix and namespace
pairs for all supported YANG modules, where the prefix is the YANG
module name, and the namespace is as defined by the &quot;namespace&quot;
statement in the YANG module.
 </t>
 <t>
The function library is the core function library defined in
<xref target="XPATH"/>.
 </t>
 <t>
The set of variable bindings is empty.
 </t>
 <t>
The context node is the root node
 </t>
 </list>
</t>
    <t>
The filter is used as defined in <xref target="RFC5277"/>, section 3.6.
If the boolean result of the expression is true when applied
to the conceptual &quot;notification&quot; document root, then the notification
event is delivered to the client.
    </t>
    <t>
Examples:  (lines wrapped for display purposes only)
    </t>
	<figure>
	    <artwork><![CDATA[
   // filter = /event/eventClass='fault'
   GET /restconf/streams/stream/NETCONF/events?
      filter=%2Fevent%2FeventClass%3D'fault'

   // filter = /event/severityCode<=4
   GET /restconf/streams/stream/NETCONF/events?
      filter=%2Fevent%2FseverityCode%3C%3D4

   // filter = /linkUp|/linkDown
   GET /restconf/streams/stream/SNMP/events?
      filter=%2FlinkUp%7C%2FlinkDown

   // filter = /*/reportingEntity/card!='Ethernet0'
   GET /restconf/streams/stream/NETCONF/events?
      filter=%2F*%2FreportingEntity%2Fcard%21%3D'Ethernet0'

   // filter = /*/email-addr[contains(.,'company.com')]
   GET /restconf/streams/stream/critical-syslog/events?
      filter=%2F*%2Femail-addr[contains(.%2C'company.com')]

   // Note: the module name is used as prefix.
   // filter = (/example-mod:event1/name='joe' and
   //           /example-mod:event1/status='online')
   GET /restconf/streams/stream/NETCONF/events?
     filter=(%2Fexample-mod%3Aevent1%2Fname%3D'joe'%20and
             %20%2Fexample-mod%3Aevent1%2Fstatus%3D'online')
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="Receiving Event Notifications">
    <t>
RESTCONF notifications are encoded per NETCONF Event Notifications
<xref target="RFC5277"/>, though they may be in either XML or JSON format,
depending on value of the &quot;format&quot; query parameter passed by the client.  
The structure of the event data MUST conform to the &quot;notification&quot;
element definition in section 4 of <xref target="RFC5277"/>.
    </t>
    <t>
An example SSE notification encoded using XML:
    </t>
	<figure>
	    <artwork><![CDATA[
   data: <notification
   data:    xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
   data:    <event-time>2013-09-30T00:01:00Z</event-time>
   data:    <event xmlns="http://example.com/event/1.0">
   data:       <eventClass>fault</eventClass>
   data:       <reportingEntity>
   data:           <card>Ethernet0</card>
   data:       </reportingEntity>
   data:       <severity>major</severity>
   data:     </event>
   data: </notification>
	    ]]></artwork>
	</figure>
    <t>
An example SSE notification encoded using JSON:
    </t>
	<figure>
	    <artwork><![CDATA[
   data: {
   data:   "ietf-restconf:notification": {
   data:     "eventTime": "2013-09-30T00:01:00Z",
   data:     "example-mod:event": {
   data:       "eventClass": "fault",
   data:       "reportingEntity": { "card": "Ethernet0" },
   data:       "severity": "major"
   data:     }
   data:   }
   data: }
	    ]]></artwork>
	</figure>
    <t>
Alternatively, since neither XML nor JSON are whitespace sensitive,
the above messages can be encoded onto a single line.  For example:
    </t>
    <t>
XML:    (&apos;\&apos; line wrapping added for formatting only)
    </t>
	<figure>
	    <artwork><![CDATA[
   data: <notification xmlns="urn:ietf:params:xml:ns:yang:ietf-rest\
   conf"><event-time>2013-09-30T00:01:00Z</event-time><event xmlns="\
   http://example.com/event/1.0"><eventClass>fault</eventClass><repo\
   rtingEntity><card>Ethernet0</card></reportingEntity><severity>maj\
   or</severity></event></notification>
	    ]]></artwork>
	</figure>
    <t>
JSON:  (&apos;\&apos; line wrapping added for formatting only)
    </t>
	<figure>
	    <artwork><![CDATA[
   data: { "ietf-restconf:notification": { "event-time": "2013-09-30\
   T00:01:00Z", "example-mod:event": { "eventClass": "fault", "repor\
   tingEntity": { "card": "Ethernet0" }, "severity": "major" } } }
	    ]]></artwork>
	</figure>
    <t>
The SSE specifications supports the following additional fields:
event, id and retry.  A RESTCONF server MAY send the &quot;retry&quot; field
and, if it does, RESTCONF clients SHOULD use it.
A RESTCONF server SHOULD NOT send the &quot;event&quot; or &quot;id&quot; fields,
as there are no meaningful values that could be used for them
that would not be redundant to the contents of the notification itself.
RESTCONF servers that do not send the &quot;id&quot; field also do not need
to support the HTTP header &quot;Last&#8209;Event&#8209;Id&quot;.  RESTCONF servers that
do send the &quot;id&quot; field MUST still support the &quot;startTime&quot; query
parameter as the preferred means for a client to specify where to
restart the event stream.
    </t>
</section>
</section>
<section title="Resource Model">
    <t>
The RESTCONF protocol operates on a hierarchy of resources,
starting with the top-level API resource itself. Each resource
represents a manageable component within the device.
    </t>
    <t>
A resource can be considered a collection of conceptual data 
and the set of allowed methods on that data.  It can contain
child nodes that are nested resources or fields.
The child resource types and methods allowed on them
are data-model specific.
    </t>
    <t>
A resource has its own media type identifier, represented
by the &quot;Content&#8209;Type&quot; header in the HTTP response message.
A resource can contain zero or more nested resources.
A resource can be created and deleted independently of its 
parent resource, as long as the parent resource exists.
    </t>
    <t>
All RESTCONF resources are defined in this document except
datastore contents, protocol operations, and notification events.
The syntax and semantics for these resource types are
defined in YANG modules.
    </t>
<section title="RESTCONF Resource Types">
    <t>
The RESTCONF protocol defines some application specific media types
to identify each of the available resource types.  The following
table summarizes the purpose of each resource.
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Media Types">
<ttcol align='left'> Resource</ttcol>
<ttcol align='left'>Media Type</ttcol>
<c>API</c>
<c>application/yang.api</c>
<c>Datastore</c>
<c>application/yang.datastore</c>
<c>Data</c>
<c>application/yang.data</c>
<c>Operation</c>
<c>application/yang.operation</c>
<c>Patch</c>
<c>application/yang.patch</c>
<c>Patch Status</c>
<c>application/yang.patch-status</c>
<c>Stream</c>
<c>application/yang.stream</c>
</texttable>
<?rfc compact="no"?>    <t>
These resources are described in <xref target="resources"/>.
    </t>
</section>
<section title="Resource Discovery" anchor="resource-discovery">
    <t>
A client SHOULD start by retrieving the top-level
API resource, using the entry point URI &quot;/restconf&quot;.
    </t>
    <t>
The RESTCONF protocol does not include a
resource discovery mechanism.  Instead, the definitions
within the YANG modules advertised by the server
are used to construct a predictable operation or data
resource identifier. 
    </t>
    <t>
The &quot;depth&quot; query parameter can be used to control how many 
descendant levels should be included when retrieving
sub-resources. This parameter can be used with the GET method
to discover sub-resources within a particular resource.
    </t>
    <t>
Refer to <xref target="depth-param"/> for more details on the &quot;depth&quot; parameter.
    </t>
</section>
</section>
<section title="Datastore Model">
    <t>
A conceptual &quot;unified datastore&quot; is used to simplify resource
management for the client. The RESTCONF unified datastore is a
combination of the running configuration and any
non-configuration data supported by the device.
By default only configuration data is returned
by a GET method on the datastore contents.
    </t>
    <t>
The underlying NETCONF datastores can be used
to implement the unified datastore, but the server design
is not limited to the exact datastore procedures defined
in NETCONF.
    </t>
    <t>
The &quot;candidate&quot; and &quot;startup&quot; datastores are not visible
in the RESTCONF protocol.  Transaction management and
configuration persistence are handled by the server
and not controlled by the client.
    </t>
<section title="Content Model">
    <t>
The RESTCONF protocol operates on a conceptual datastore defined with
the YANG data modeling language.  The server lists each YANG
module it supports under &quot;/restconf/modules&quot;
in the top-level API resource type, using a structure based on
the YANG module capability URI format defined in RFC 6020.
    </t>
    <t>
The conceptual datastore contents, data-model-specific
operations and notification events are identified by this set of
YANG module resources.  All RESTCONF content identified 
as either a data resource, operation resource, or event stream resource
is defined with the YANG language.
    </t>
    <t>
The classification of data as configuration or
non-configuration is derived from the YANG &quot;config&quot; statement.
Data retrieval with the GET method can be filtered
in several ways, including the &quot;config&quot; parameter
to retrieve configuration or non-configuration data.
    </t>
    <t>
Data ordering behavior is derived from the YANG &quot;ordered&#8209;by&quot;
statement.  The YANG Patch operation is provided to allow
list or leaf-list fields to be inserted or moved
in the same manner as NETCONF.
    </t>
</section>
<section title="Editing Model">
    <t>
The RESTCONF datastore editing model is simple and direct,
similar to the behavior of the &quot;:writable&#8209;running&quot;
capability in NETCONF.
    </t>
    <t>
Each RESTCONF edit of a datastore resource is
activated upon successful completion of the transaction.
    </t>
    <t>
Applications which need more control over the editing model
might consider using NETCONF instead of RESTCONF.
    </t>
<section title="Edit Operation Discovery">
    <t>
The OPTIONS method can be used to identify which
HTTP methods are supported by the server for a particular
resource.  For example, if the server will allow a data resource 
node to be created then the POST method will be
returned in the response.
    </t>
</section>
<section title="Edit Collision Detection" anchor="edit-collision">
    <t>
Two &quot;edit collision detection&quot; mechanisms are provided
in RESTCONF, for datastore and data resources.
    </t>
<t>
 <list style="symbols">
 <t>
timestamp: the last change time is maintained and
the &quot;Last&#8209;Modified&quot; and &quot;Date&quot; headers are returned in the
response for a retrieval request. 
The &quot;If&#8209;Unmodified&#8209;Since&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource has been modified
since the specified timestamp.
 </t>
 <t>
entity tag: a unique opaque string is maintained and
the &quot;ETag&quot; header is returned in the
response for a retrieval request. 
The &quot;If&#8209;Match&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource entity tag
does not match the specified value.
 </t>
 </list>
</t>
    <t>
The server MUST maintain these properties
for datastore resources, and MAY maintain them for individual data
resources.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the server just supports the
mandatory datastore last-changed timestamp.
The client has previously retrieved the &quot;Last&#8209;Modified&quot;
header and has some value cached to provide in
the following request to replace a list entry
with key value &quot;11&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /restconf/config/example-jukebox:jukebox/
     library/artist/Foo%20Fighters/album/Wasting%20Light/year
     HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
   If-Unmodified-Since: Mon, 23 Apr 2012 17:01:00 GMT
   Content-Type: application/yang.data+json   

   { "example-jukebox:year" : "2011" }
	    ]]></artwork>
	</figure>
    <t>
In this example the datastore resource has changed
since the time specified in the &quot;If&#8209;Unmodified&#8209;Since&quot;
header.  The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 412 Precondition Failed
   Date: Mon, 23 Apr 2012 19:01:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:45:00 GMT
   ETag: b34aed893a4c
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Locking Model">
    <t>
Datastore locking is not provided by RESTCONF.
An application that needs to make several changes
to the running configuration datastore
contents in sequence, without disturbance from other clients
might consider using the NETCONF protocol instead of RESTCONF.
    </t>
</section>
<section title="Persistence Model" anchor="persistence-model">
    <t>
Each RESTCONF edit of a datastore resource is
saved to non-volatile storage in an 
implementation-specific matter by the server.
There is no guarantee that configuration changes
are saved immediately, or that the saved configuration
is always a mirror of the running configuration.
    </t>
    <t>
Applications which need more control over the persistence model
might consider using NETCONF instead of RESTCONF.
    </t>
</section>
<section title="Defaults Model">
    <t>
NETCONF has a rather complex model for handling default values for
leafs.  RESTCONF attempts to avoid this complexity by
restricting the operations that can be applied to
a resource.
    </t>
    <t>
If the target of a GET method (plus &quot;select&quot; value) is a data node
that represents a leaf that has a default value,
and the leaf has not been given a value yet, the server MUST
return the default value that is in use by the server.
    </t>
    <t>
If the target of a GET method (plus &quot;select&quot; value) is a data node
that represents a container or list that has any fields 
with default values, for the fields that have not been given
value yet, the server MAY
return the default values that are in use by the server.
    </t>
    <t>
Applications which need more control over the defaults model
might consider using NETCONF instead of RESTCONF.
    </t>
</section>
</section>
<section title="Transaction Model" anchor="transaction-model">
    <t>
The RESTCONF protocol provides
a simplified transaction model that uses plain
REST operations to edit one resource (and sub-resources)
at a time.  It also provides YANG Patch, which is a standard
PATCH method using a new media type (application/yang.patch).
This allows a full set of
edit operations that can be applied to multiple resources
at once.
    </t>
    <t>
RESTCONF does not provide a more complex transaction
model that allows for multiple edits to be stored in
a temporary scratchpad and committed all at once,
after one or more edit operations have been done.
    </t>
    <t>
Applications which need more control over the transaction model
might consider using NETCONF instead of RESTCONF.
    </t>
</section>
<section title="Extensibility Model">
    <t>
The RESTCONF protocol is designed to be extensible for
datastore content and data-model specific protocol operations.
    </t>
    <t>
Separate namespaces for each YANG module are used.
Content encoded in XML will indicate the module
using the &quot;namespace&quot; URI value in the YANG module.
Content encoded in JSON will indicate the module
using the module name specified in the YANG module,
but this is not required unless multiple sibling nodes
have the same YANG identifier name.
JSON encoding rules for module names are specified 
in <xref target="I-D.lhotka-netmod-json"/>.
    </t>
</section>
<section title="Versioning Model">
    <t>
The version of a resource instance is identified with an entity tag,
as defined by HTTP.
The version identifiers in this section apply to the 
version of the schema definition of a resource.
There are two types of schema versioning information used
in the RESTCONF protocol:
    </t>
<t>
 <list style="symbols">
 <t>
the RESTCONF protocol version
 </t>
 <t>
data and operation resource definition versions
 </t>
 </list>
</t>
    <t>
The protocol version is identified by the string used for the 
well-known URI entry point &quot;/restconf&quot;.
This would be changed (e.g., &quot;/restconf2&quot;) 
if non-backward compatible changes are ever needed.  
Version changes that do not break
backward-compatibility will not cause the entry point to change.
    </t>
    <t>
The field &quot;/restconf/version&quot; in the API resource can be used by the client to
identify the exact version of the RESTCONF protocol implemented
by the server.
    </t>
    <t>
The resource definition version for a data or operation 
resource is a date string,
which is the revision date of the YANG module that defines the
resource.
The resource version for all other resource types is the numeric
string defined by the &quot;/restconf/version&quot; field.
    </t>
</section>
<section title="Retrieval Filtering Model">
    <t>
There are three types of filtering for retrieval of data resources
in the RESTCONF protocol.
    </t>
<t>
 <list style="symbols">
 <t>
conditional all-or-nothing: use some conditional test
mechanism in the request headers and retrieve either a
complete &quot;200 OK&quot; response if the condition is met,
or a &quot;304 Not Modified&quot; Status-Line if the condition is not met.
 </t>
 <t>
data classification: request configuration or non-configuration
data.
 </t>
 <t>
filter: request a subset of all possible descendant nodes
within the target resource.  The &quot;select&quot; query parameter can be used
for this purpose.
 </t>
 </list>
</t>
    <t>
Refer to <xref target="data-retrieval"/> for details on data retrieval filtering.
    </t>
</section>
<section title="Access Control Model">
    <t>
The RESTCONF protocol provides granular access control for operation
and data resources using the NETCONF Access Control Model (NACM)
<xref target="RFC6536"/>.  There is a specific mapping between RESTCONF operations
and NETCONF edit operations, defined in <xref target="table-crud-operations"/>.  The
resource path also needs to be converted internally by the server to
the corresponding YANG instance-identifier.  Using this information,
the server can apply the NACM access control rules to RESTCONF
messages.
    </t>
    <t>
The server MUST NOT allow any operation to any resources that
the client is not authorized to access.  
    </t>
</section>
</section>
<section title="Operations" anchor="operations">
    <t>
The RESTCONF protocol uses HTTP methods to identify
the CRUD operation requested for a particular resource.
The following table
shows how the RESTCONF operations relate to NETCONF 
protocol operations:
    </t>
<?rfc compact="yes"?><texttable anchor="table-crud-operations" title="CRUD Methods in RESTCONF">
<ttcol align='left'> RESTCONF</ttcol>
<ttcol align='left'>NETCONF</ttcol>
<c>OPTIONS</c>
<c>none</c>
<c>HEAD</c>
<c>none</c>
<c>GET</c>
<c>&lt;get-config&gt;, &lt;get&gt;</c>
<c>POST</c>
<c>&lt;edit-config&gt; (operation=&quot;create&quot;)</c>
<c>PUT</c>
<c>&lt;edit-config&gt; (operation=&quot;replace&quot;)</c>
<c>PATCH</c>
<c>&lt;edit-config&gt; (operation=&quot;merge&quot; or &lt;any&gt;)</c>
<c>DELETE</c>
<c>&lt;edit-config&gt; (operation=&quot;delete&quot;)</c>
</texttable>
<?rfc compact="no"?>    <t>
The NETCONF &quot;remove&quot; operation attribute is not supported
by the HTTP DELETE method. The resource must exist or
the DELETE method will fail. The PATCH method is equivalent to
a &quot;merge&quot; operation for a plain PATCH method (using the media
type &quot;application/yang.data&quot;). Any operation
is possible within a YANG Patch (using the media type
&quot;application/yang.patch&quot;).
    </t>
    <t>
This section defines the RESTCONF protocol usage for
each HTTP method.
    </t>
<section title="OPTIONS" anchor="options">
    <t>
The OPTIONS method is sent by the client to
discover which methods are supported by the server
for a specific resource.
It is supported for all media types.
Note that implementation
of this method is part of HTTP, and this section does
not introduce any additional requirements.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The server will return a &quot;Status&#8209;Line&quot; header containing
&quot;204 No Content&quot;.
and include the &quot;Allow&quot; header in the response.
This header will be filled in based on the target resource
media type.
Other headers MAY also be included in the response.
    </t>
    <t>
Example 1:
    </t>
    <t>
A client might request the methods supported for a data
resource called &quot;library&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /restconf/config/example-jukebox:jukebox/
      library/artist   HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond (for a config=true list):
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Allow: OPTIONS,HEAD,GET,POST,PUT,PATCH,DELETE
	    ]]></artwork>
	</figure>
    <t>
Example 2:
    </t>
    <t>
A client might request the methods supported for a 
non-configuration &quot;counters&quot; resource within a &quot;system&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /restconf/operational/example-system:system/
      counters HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Allow: OPTIONS,HEAD,GET
	    ]]></artwork>
	</figure>
    <t>
Example 3:
    </t>
    <t>
A client might request the methods supported for an
operation resource called &quot;play&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
   OPTIONS /restconf/operations/example-jukebox:play HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Allow: POST
	    ]]></artwork>
	</figure>
</section>
<section title="HEAD" anchor="head">
    <t>
The HEAD method is sent by the client to
retrieve just the headers that would be returned
for the comparable GET method, without the response body.
It is supported for all resource types, except operation resources.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The same query parameters supported by the GET method
are supported by the HEAD method.  For example,
the &quot;select&quot; query parameter can be used to
specify a nested resource within the target resource.
    </t>
    <t>
The access control behavior is enforced
as if the method was GET instead of HEAD.
The server MUST respond the same as if the method
was GET instead of HEAD, except that no
response body is included.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for
JSON representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   HEAD /restconf/config/example-jukebox:jukebox/library HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT
	    ]]></artwork>
	</figure>
</section>
<section title="GET" anchor="get">
    <t>
The GET method is sent by the client to
retrieve data and meta-data for a resource.
It is supported for all resource types, except operation resources.
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The following query parameters are supported
by the GET method:
    </t>
<?rfc compact="yes"?><texttable title="GET Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>depth</c>
<c><xref format="counter" target="depth-param"/></c>
<c>Control the depth of a retrieval request</c>
<c>format</c>
<c><xref format="counter" target="format-param"/></c>
<c>Request either JSON or XML content in the response</c>
<c>select</c>
<c><xref format="counter" target="select-param"/></c>
<c>Specify a nested resource within the target resource</c>
</texttable>
<?rfc compact="no"?>    <t>
The server MUST NOT return any data resources for which the user
does not have read privileges. 
    </t>
    <t>
If the user is not authorized to read any portion of
the target resource, an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  
    </t>
    <t>
If the user is authorized to read some but not all of
the target resource, the unauthorized content is omitted
from the response message body, and the authorized content
is returned to the client.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for a
JSON representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/config/example-jukebox:jukebox/
     library/artist/Foo%20Fighters/album?format=json HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT

   {
     "album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:alternative",
       "year" : 2011
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="POST" anchor="post">
    <t>
The POST method is sent by the client for various
reasons.  The server uses the target resource media type
to determine how to process the request.
    </t>
    <t>
The request MUST contain a request URI
that contains a target resource which
identifies one of the following resource types:
    </t>
<?rfc compact="yes"?><texttable title="Resource Types that Support POST">
<ttcol align='left'> Type</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Datastore</c>
<c>Create a top-level configuration data resource</c>
<c>Data</c>
<c>Create a configuration data sub-resource</c>
<c>Operation</c>
<c>Invoke protocol operation</c>
</texttable>
<?rfc compact="no"?><section title="Create Resource Mode">
    <t>
If the target resource type is a Datastore or Data resource,
then the POST is treated as a request to create a resource or
sub-resource.
    </t>
    <t>
The following query parameters are supported
by the POST method for Datastore and Data resource types.
They can only be used for YANG list data nodes
which are ordered by the user.
    </t>
<?rfc compact="yes"?><texttable title="POST Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Section</ttcol>
<ttcol align='left'>Description</ttcol>
<c>insert</c>
<c><xref format="counter" target="insert-param"/></c>
<c>Specify where to insert a resource</c>
<c>point</c>
<c><xref format="counter" target="point-param"/></c>
<c>Specify the insert point for a resource</c>
</texttable>
<?rfc compact="no"?>    <t>
If the POST method succeeds,
a &quot;204 No Content&quot; Status-Line is returned and there is
no response message body.
    </t>
    <t>
If the user is not authorized to create the target resource,
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="Invoke Operation Mode">
    <t>
If the target resource type is an Operation resource,
then the POST method is treated as a request to invoke that operation.
The message body (if any) is processed as the operation input
parameters.  Refer to <xref target="operation-resource"/> for details
on operation resources.
    </t>
    <t>
If the POST method succeeds, a &quot;200 OK&quot; Status-Line
is returned if there is a response message body, and
a &quot;204 No Content&quot; Status-Line is returned if there is
no response message body.
    </t>
    <t>
If the user is not authorized to invoke the target operation,
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
</section>
<section title="PUT" anchor="put">
    <t>
The PUT method is sent by the client to replace
the target resource.
    </t>
    <t>
The request MUST contain a request URI
that contains a target resource that
identifies the data resource to replace.
If the resource instance does not exist, the server MAY
create it.
    </t>
    <t>
If the PUT method succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to replace the target resource
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="PATCH" anchor="patch">
    <t>
The PATCH method uses the HTTP PATCH method defined
in <xref target="RFC5789"/> to provide an extensible framework for
resource patching mechanisms.  Each patch type needs a unique
media type.  Any number of patch types can be supported
by the server.  There are two mandatory patch types that
MUST be implemented by the server:
    </t>
<t>
 <list style="symbols">
 <t>
plain patch type: If the specified media type
is &quot;application/yang.data&quot;, then the PATCH method is a simple
merge operation on the target resource.  The message body contains
the XML or JSON encoded resource content that will be merged
with the target resource.
 </t>
 <t>
YANG Patch type: If the specified media type
is &quot;application/yang.patch&quot;, then the PATCH method is a
YANG Patch formatted list of edits (see <xref target="yang-patch"/>).
The message body
contains the XML or JSON encoded instance of the &apos;patch&apos; container
specified in the &apos;ietf&#8209;restconf&apos; YANG module (see <xref target="module"/>).
 </t>
 </list>
</t>
    <t>
The PATCH method MUST be used to create or delete an optional
field within an existing resource or sub-resource.
If the resource instance does not exist, the server MUST
NOT create it. 
    </t>
    <t>
If the PATCH method succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to alter the target resource
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="DELETE" anchor="delete">
    <t>
The DELETE method is used to delete the target resource.
    </t>
    <t>
If the DELETE method succeeds, a &quot;200 OK&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to delete the target resource then
an error response containing
a &quot;403 Forbidden&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
</section>
<section title="Query Parameters" anchor="query-parameters">
    <t>
Each RESTCONF operation allows zero or more query
parameters to be present in the request URI.
Refer to <xref target="operations"/>
for details on the query parameters used
in the definition of each operation.
    </t>
    <t>
Query parameters can be given in any order.
Each parameter can appear zero or one time.
A default value may apply if the parameter is missing.
    </t>
    <t>
This section defines all the RESTCONF query parameters.
    </t>
<section title="&quot;depth&quot; Parameter" anchor="depth-param">
    <t>
The &quot;depth&quot; parameter is used to specify the number
of nest levels returned in a response for a GET method.
A nest-level consists of the target resource and any
child nodes which are contained within the target resource node.
    </t>
    <t>
The start level is determined by the target resource
for the operation.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: depth=<range: 1..max> | unbounded
     default: unbounded
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
This example operation would retrieve 2 levels of configuration
data nodes that exist within the top-level &quot;jukebox&quot; resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/config/example-jukebox:jukebox
      ?depth=2 HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-jukebox:jukebox" : {
       "library" : {
         "artist" : {
           "name" : "Foo Fighters"
         }
       },
       "player" : {
         "gap" : 0.5
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
By default, the server will include all sub-resources within
a retrieved resource, which have the same resource type as the
requested resource.
Only only level of sub-resources with a different
media type than the target resource will be returned.
    </t>
    <t>
For example, if the client retrieves the &quot;application/yang.api&quot;
resource type,
then the node for the datastore resource is returned
as an empty node, because all its child nodes are data resources.
The entire contents of the datastore are not returned in this case.
The operation resources are also returned as empty nodes
(e.g. &quot;play&quot; operation).
    </t>
    <t>
Request URL:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf HTTP/1.1
	    ]]></artwork>
	</figure>
    <t>
Response:
    </t>
	<figure>
	    <artwork><![CDATA[
   {
     "ietf-restconf:restconf": {
       "config" : [ null ],
       "operational" : [ null ],
       "modules": {
         "module": [
           {
             "name" : "example-jukebox",
             "revision" : "2013-10-19",
             "namespace" : "http://example.com/ns/example-jukebox"
           }
         ]
       },
       "operations" : {
          "play" : [ null ]
       },
       "version": "1.0"
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;format&quot; Parameter" anchor="format-param">
    <t>
The &quot;format&quot; parameter is used to specify the format
of any content returned in the response.  Note that
this parameter MAY be used instead of the &quot;Accept&quot; header
to identify the format desired in the response.
    </t>
    <t>
The &quot;format&quot; parameter is only supported for the GET and 
HEAD methods. It is supported for all RESTCONF media types.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: format= xml | json
     default: Accept header, then xml
	    ]]></artwork>
	</figure>
    <t>
If the &quot;format&quot; parameter is present, then it overrides
the Accept header, if present. If neither the Accept
header or the &quot;format&quot; parameter are present, then the
default is XML.
    </t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/config/example-routing:routing  HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
This example request would retrieve only the configuration data nodes
that exist within the top-level &quot;routing&quot; resource, and retrieve
them in JSON encoding.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/config/example-routing:routing?
       format=json HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
This example request would retrieve only the configuration data nodes
that exist within the top-level &quot;routing&quot; resource, and retrieve
them in JSON encoding.
    </t>
</section>
<section title="&quot;insert&quot; Parameter" anchor="insert-param">
    <t>
The &quot;insert&quot; parameter is used to specify how a
resource should be inserted within a user-ordered list.
    </t>
    <t>
This parameter is only supported for the POST method.
It is also only supported if the target resource is
a data resource, and that data represents
a YANG list that is ordered by the user, not the system.
    </t>
    <t>
If the values &quot;before&quot; or &quot;after&quot; are used, then a &quot;point&quot;
parameter for the insertion parameter MUST also be present.
    </t>
	<figure>
	    <artwork><![CDATA[
     syntax: insert= first | last | before | after
     default: last
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   POST /restconf/config/example-jukebox:jukebox/
     playlist/Foo-One?insert=first HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:song" : {
        "index" : 1,
        "id" : "/example-jukebox:jukebox/library/artist/
            Foo%20Fighters/album/Wasting%20Light/song/Rope"
      }
   }

 Response from server:

   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   Location: http://example.com/restconf/config/
      example-jukebox:jukebox/playlist/Foo-One/song/1
   ETag: eeeada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;point&quot; Parameter" anchor="point-param">
    <t>
The &quot;point&quot; parameter is used to specify the insertion point
for a data resource that is being created or moved within
a user ordered list.  It is ignored unless the &quot;insert&quot;
query parameter is also present, and has the value &quot;before&quot; or &quot;after&quot;.
    </t>
    <t>
This parameter contains the instance identifier of the
resource to be used as the
insertion point for a POST method.  It is
encoded according to the rules defined in <xref target="uri-encoding"/>.
There is no default for this parameter.
    </t>
    <t>
Note that the first path component encoded for an instance
identifier is the top-level YANG data node.
The &quot;/restconf/config&quot; entry point is not included
in an instance-identifier.
    </t>
	<figure>
	    <artwork><![CDATA[
   syntax: point= <instance-identifier of insertion point node>
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
In this example, the client is inserting a new &quot;song&quot; resource
within an &quot;album&quot; resource after another song.
The request URI is split for display purposes only.
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   POST /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light?
      insert=after&point=%2Fexample-jukebox%3Ajukebox%2F
      library%2Fartist%2FFoo%20Fighters%2Falbum%2F
      Wasting%20Light%2Fsong%2FBridge%20Burning   HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:song" : {
        "name" : "Rope",
        "location" : "/media/rope.mp3",
        "format" : "MP3",
        "length" : 259
     }
   }

 Response from server:

   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   ETag: abcada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;select&quot; Parameter" anchor="select-param">
    <t>
The &quot;select&quot; query parameter is used to specify an
expression which can represent a subset of all data nodes
within the target resource. It contains a relative
path expression, using the target resource as the context node.
    </t>
    <t>
It is supported for all resource types except operation resources.
The contents are encoded according to the &quot;api&#8209;select&quot;
rule defined in <xref target="uri-encoding"/>.  This parameter is only allowed
for GET and HEAD methods.
    </t>
    <t>
[FIXME: the syntax of the select string is still TBD;
XPath, schema-identifier, regular expressions, something else;
Perhaps add parameter &quot;xselect&quot; for XPath and this param
is limited to a path-expr.]
    </t>
    <t>
In this example the client is retrieving the API version
field from the server in JSON format:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf?select=version&format=json HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
   Content-Type: application/yang.api+json

   { "ietf-restconf:version": "1.0" }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Protocol Operations" anchor="protocol-ops">
    <t>
The RESTCONF protocol allows data-model specific protocol operations
to be invoked using the POST method.  The media type 
&quot;application/yang.operation+xml&quot; or &quot;application/yang.operation+json&quot;
MUST be used in the &quot;Content&#8209;Type&quot; line in the message header.
    </t>
    <t>
Data model specific operations are supported.
The syntax and semantics of these operations
exactly correspond to the YANG &quot;rpc&quot; statement definition
for the operation.
    </t>
    <t>
Refer to <xref target="operation-resource"/> for details on operation resources.
    </t>
</section>
</section>
<section title="Messages" anchor="messages">
    <t>
This section describes the messages that are used in the RESTCONF
protocol.
    </t>
<section title="Request URI Structure">
    <t>
Resources are represented with URIs following the structure
for generic URIs in <xref target="RFC3986"/>.
    </t>
    <t>
A RESTCONF operation is derived from the HTTP method
and the request URI, using the following conceptual fields:
    </t>
	<figure>
	    <artwork><![CDATA[
     <OP> /restconf/<path>?<query>#<fragment>
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
      ^       ^        ^       ^         ^   
      |       |        |       |         |   
    method  entry  resource  query    fragment

      M       M        O        O         I

    M=mandatory, O=optional, I=ignored
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
    <text> replaced by client with real values
	    ]]></artwork>
	</figure>
<t>
 <list style="symbols">
 <t>
method: the HTTP method identifying the RESTCONF operation
requested by the client, to act upon the target resource
specified in the request URI.  RESTCONF operation details are
described in <xref target="operations"/>.
 </t>
 <t>
entry: the well-known RESTCONF entry point (&quot;/restconf&quot;).
 </t>
 <t>
resource: the path expression identifying the resource
that is being accessed by the operation.
If this field is not present, then the target resource
is the API itself, represented by the media type &quot;application/yang.api&quot;.
 </t>
 <t>
query: the set of parameters associated with the RESTCONF
message. These have the familiar form of &quot;name=value&quot; pairs.
There is a specific set of parameters defined,
although the server MAY choose to support additional
parameters not defined in this document.
The contents of the any query parameter value MUST be encoded
according to <xref target="RFC2396"/>, section 3.4. Any reserved characters
MUST be encoded with escape sequences, according to <xref target="RFC2396"/>,
section 2.4.
 </t>
 <t>
fragment: This field is not used by the RESTCONF protocol.
 </t>
 </list>
</t>
    <t>
When new resources are created by the client, a &quot;Location&quot; header
is returned, which identifies the path of the newly created resource.
The client MUST use this exact path identifier to access
the resource once it has been created.
    </t>
    <t>
The &quot;target&quot; of an operation is a resource.
The &quot;path&quot; field in the request URI represents
the target resource for the operation.  
    </t>
</section>
<section title="Message Headers">
    <t>
There are several HTTP header lines utilized in RESTCONF messages.
Messages are not limited to the HTTP headers listed in this section.
    </t>
    <t>
HTTP defines which header lines are required for particular
circumstances. Refer to each operation definition section
in <xref target="operations"/> for examples on how particular headers are used.
    </t>
    <t>
There are some request headers that are used within RESTCONF,
usually applied to data resources.
The following tables summarize the headers most relevant
in RESTCONF message requests:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Request Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Accept</c>
<c>Response Content-Types that are acceptable</c>
<c>Content-Type</c>
<c>The media type of the request body</c>
<c>Host</c>
<c>The host address of the server</c>
<c>If-Match</c>
<c>Only perform the action if the entity matches ETag</c>
<c>If-Modified-Since</c>
<c>Only perform the action if modified since time</c>
<c>If-Unmodified-Since</c>
<c>Only perform the action if un-modified since time</c>
</texttable>
<?rfc compact="no"?>    <t>
The following tables summarize the headers most relevant
in RESTCONF message responses:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Response Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Allow</c>
<c>Valid actions when 405 error returned</c>
<c>Cache-Control</c>
<c>The cache control parameters for the response</c>
<c>Content-Type</c>
<c>The media type of the response body</c>
<c>Date</c>
<c>The date and time the message was sent</c>
<c>ETag</c>
<c>An identifier for a specific version of a resource</c>
<c>Last-Modified</c>
<c>The last modified date and time of a resource</c>
<c>Location</c>
<c>The resource identifier for a newly created resource</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Message Encoding">
    <t>
RESTCONF messages are encoded in HTTP according to RFC 2616.
The &quot;utf&#8209;8&quot; character set is used for all messages.
RESTCONF message content is sent in the HTTP message body.
    </t>
    <t>
Content is encoded in either JSON or XML format.
    </t>
    <t>
XML encoding rules for data nodes are defined in <xref target="RFC6020"/>.
The same encoding rules are used for all XML content.
    </t>
    <t>
JSON encoding rules are defined in <xref target="I-D.lhotka-netmod-json"/>.
Plain JSON cannot be used because special encoding rules
are needed to handle multiple
module namespaces and provide consistent data type processing.
    </t>
    <t>
Request input content encoding format is identified with the Content-Type
header.  This field MUST be present if a message body is sent
by the client.
    </t>
    <t>
Response output content encoding format is identified with the Accept
header, the &quot;format&quot; query parameter, or if
neither is specified, the request input encoding format is used.
If there was no request input, then the default output encoding is XML.
File extensions encoded in the request are not used to identify
format encoding.
    </t>
</section>
<section title="RESTCONF Meta-Data">
    <t>
The RESTCONF protocol needs to retrieve the same meta-data that is
used in the NETCONF protocol.  Information about default leafs,
last-modified timestamps, etc. are commonly used to annotate
representations of the datastore contents.  This meta-data
is not defined in the YANG schema because it applies to the
datastore, and is common across all data nodes.
    </t>
    <t>
This information is encoded as attributes in XML, but JSON 
does not have a standard way of attaching non-schema defined
meta-data to a resource or field.
    </t>
<section title="JSON Encoding of RESTCONF Meta-Data">
    <t>
The YANG to JSON mapping <xref target="I-D.lhotka-netmod-json"/> does not support
attributes because YANG does not support meta-data in data node
definitions. This section specifies how RESTCONF meta-data is
encoded in JSON.
    </t>
    <t>
Only simple meta-data is supported:
    </t>
<t>
 <list style="symbols">
 <t>
A meta-data instance can appear 0 or 1 times for a particular
data node
 </t>
 <t>
A meta-data instance associated with a resource is 
encoded as if it were a YANG leaf of type &quot;string&quot;,
according to the encoding rules in <xref target="I-D.lhotka-netmod-json"/>,
except the identifier is prepended with a &quot;@&quot; (%40) character.
 </t>
 <t>
A meta-data instance associated with a field within a resource is 
encoded as if it were a container for the meta-data values
and the field value in its native encoding. It is encoded
according to the rules in <xref target="I-D.lhotka-netmod-json"/>,
except the meta-data identifiers are prepended with a &quot;@&quot; (%40) character.
The field name/value pair is repeated inside this container,
which contains the actual value of the field.
 </t>
 </list>
</t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
   Meta-data:  

     enabled=<boolean>
     owner=<owner-name>

   YANG module: example
   YANG example:

     container top {
       leaf A {
         type int32;
       }
       leaf B {
         type boolean;
       }
     }
	    ]]></artwork>
	</figure>
    <t>
The client is retrieving the &quot;top&quot; data resource, and the server
is including datastore meta-data. Note that a query parameter to request
or suppress specific meta-data is not provided in RESTCONF.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/config/example:top HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Content-Type: application/yang.data+json

   {
     "example:top": {
       "@enabled" : "true",
       "@owner" : "fred",
       "A" : {
         "@enabled" : "true",
         "A" : 42
       },
       "B" : {
         "@enabled" : "false",
         "B" : true
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Return Status">
    <t>
Each message represents some sort of resource access.
An HTTP &quot;Status&#8209;Line&quot; header line is returned for each request.
If a 4xx or 5xx range status code is returned in the Status-Line,
then the error information will be returned in the response,
according to the format defined in <xref target="errors"/>.
    </t>
</section>
<section title="Message Caching">
    <t>
Since the datastore contents change at unpredictable times,
responses from a RESTCONF server generally SHOULD NOT be cached.
    </t>
    <t>
The server SHOULD include a &quot;Cache&#8209;Control&quot; header in every response
that specifies whether the response should be cached.  A &quot;Pragma&quot;
header specifying &quot;no&#8209;cache&quot; MAY also be sent in case the
&quot;Cache&#8209;Control&quot; header is not supported.
    </t>
    <t>
Instead of using HTTP caching, the client SHOULD track the &quot;ETag&quot;
and/or &quot;Last&#8209;Modified&quot; headers returned by the server for the
datastore resource (or data resource if the server supports it).
A retrieval request for a resource can include
the &quot;If&#8209;None&#8209;Match&quot; and/or &quot;If&#8209;Modified&#8209;Since&quot; headers, which
will cause the server to return a &quot;304 Not Modified&quot; Status-Line
if the resource has not changed.
The client MAY use the HEAD method to retrieve just
the message headers, which SHOULD include the &quot;ETag&quot; 
and &quot;Last&#8209;Modified&quot; headers, if this meta-data is maintained
for the target resource.
    </t>
</section>
</section>
<section title="Resources" anchor="resources">
    <t>
The resources used in the RESTCONF protocol are identified
by the &quot;path&quot; component in the request URI.  Each operation
is performed on a target resource.
    </t>
<section title="API Resource (/restconf) ">
    <t>
The API resource contains the state and access points for
the RESTCONF features.
It is the top-level resource and has the media type 
&quot;application/yang.api+xml&quot; or &quot;application/yang.api+json&quot;.
It is accessible through the well-known relative
URI &quot;/restconf&quot;.
    </t>
    <t>
YANG Tree Diagram for &quot;application/yang.api&quot; Resource Type:
    </t>
	<figure>
	    <artwork><![CDATA[
   +--rw restconf
   |  +--rw config
   |  +--rw operational
   |  +--rw modules
   |  |  +--rw module [name revision]
   |  |     +--rw name         yang:yang-identifier
   |  |     +--rw revision     union
   |  |     +--rw namespace    inet:uri
   |  |     +--rw feature*     yang:yang-identifier
   |  |     +--rw deviation*   yang:yang-identifier
   |  +--rw operations
   |  +--rw streams
   |  |  +--rw stream [name]
   |  |     +--rw name                        string
   |  |     +--rw description?                string
   |  |     +--rw replay-support?             boolean
   |  |     +--rw replay-log-creation-time?   yang:date-and-time
   |  |     +--rw events?                     empty
   |  +--ro version?      enumeration
   +--rw notification
      +--rw event-time    yang:date-and-time
	    ]]></artwork>
	</figure>
    <t>
The &quot;restconf&quot; container definition in the &quot;ietf&#8209;restconf&quot; module
defined in <xref target="module"/> is used to specify the structure and syntax
of the conceptual fields and sub-resources within the API resource.
    </t>
    <t>
The &quot;restconf&quot; entry point container, and all fields and
sub-resources with the same resource type, are defined
in the namespace of the &quot;ietf&#8209;restconf&quot; module.
    </t>
    <t>
There is one mandatory field &quot;version&quot; that
identifies the specific version of the RESTCONF protocol
implemented by the server:
    </t>
<t>
 <list style="symbols">
 <t>
The same server-wide response MUST be returned
each time this field is retrieved.
 </t>
 <t>
It is assigned by the server when the server is started.
 </t>
 <t>
The server MUST return the value &quot;1.0&quot; for this
version of the RESTCONF protocol.
 </t>
 <t>
This field is encoded with the rules for an &quot;enumeration&quot; data type,
using the &quot;version&quot; leaf definition in <xref target="module"/>.
 </t>
 </list>
</t>
    <t>
This resource has the following child resources:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Resources">
<ttcol align='left'> Child Resource</ttcol>
<ttcol align='left'>Description</ttcol>
<c>datastore</c>
<c>Link to &quot;datastore&quot; resource</c>
<c>modules</c>
<c>YANG module capability URIs</c>
<c>operations</c>
<c>Data-model specific operations</c>
<c>streams</c>
<c>Notification event streams</c>
</texttable>
<?rfc compact="no"?><section title="/restconf/config">
    <t>
This mandatory resource represents the running configuration
datastore.
It contains configuration data resources that may
be retrieved and edited by a client.
It cannot be created or deleted by a client.
This resource type is defined in <xref target="datastore-resource"/>.
    </t>
</section>
<section title="/restconf/operational">
    <t>
This mandatory resource represents the operational
datastore.
It contains operational data and statistics data resources that may
be retrieved by a client.
It cannot be created or deleted by the client.
This resource type is defined in <xref target="datastore-resource"/>.
    </t>
    <t>
Example:
    </t>
    <t>
This example request by the client
would retrieve only the non-configuration data nodes
that exist within the &quot;library&quot; resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/operational/example-jukebox:jukebox/library
      HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-jukebox:library" : {
        "artist-count" : 42,
        "album-count" : 59,
        "song-count" : 374
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="/restconf/modules">
    <t>
This mandatory resource contains the identifiers 
for the YANG data model modules supported by the server.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this 
resource, and return the &quot;Last&#8209;Modified&quot; header when this 
resource is retrieved with the GET or HEAD methods.
    </t>
    <t>
The server SHOULD maintain an entity-tag for this 
resource, and return the &quot;ETag&quot; header when this 
resource is retrieved with the GET or HEAD methods.
    </t>
<section title="/restconf/modules/module">
    <t>
This mandatory resource contains one list entry
for each YANG data model module supported by the server.
There MUST be an instance of this resource for every
YANG module that is accessible via an operation resource
or a data resource.
    </t>
    <t>
The contents of the &quot;module&quot; resource are defined in
the &quot;module&quot; YANG list statement in <xref target="module"/>.
    </t>
    <t>
The server MAY maintain a last-modified timestamp for 
each instance of this resource, and return the 
&quot;Last&#8209;Modified&quot; header when this resource is retrieved 
with the GET or HEAD methods.  If not supported
then the timestamp for the parent &quot;modules&quot; resource
MAY be used instead.
    </t>
    <t>
The server MAY maintain an entity-tag for each instance
of this resource, and return the &quot;ETag&quot; header when this 
resource is retrieved with the GET or HEAD methods.
If not supported then the timestamp for the
parent &quot;modules&quot; resource MAY be used instead.
    </t>
</section>
<section title="Retrieval Example">
    <t>
In this example the client is retrieving the modules
resource from the server in JSON format:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/modules&format=json HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
   Content-Type: application/yang.api+json

   {
     "ietf-restconf:modules": {
       "module": [
         {
           "name" : "foo",
           "revision" : "2012-01-02",
           "namespace" : "http://example.com/ns/foo",
           "feature" : [ "feature1", "feature2" ]
         },
         {
           "name" : "foo-types",
           "revision" : "2012-01-05",
           "namespace" : "http://example.com/ns/foo-types"
         },
         {
           "name" : "bar",
           "revision" : "2012-11-05",
           "namespace" : "http://example.com/ns/bar",
           "feature" : [ "bar-ext" ]
         }
       ]
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="/restconf/operations ">
    <t>
This optional resource is a container that provides access to the 
data-model specific protocol operations supported by the server.
The server MAY omit this resource if no data-model specific
operations are advertised.
    </t>
    <t>
Any data-model specific operations defined in the YANG
modules advertised by the server MAY be available
as child nodes of this resource.
    </t>
    <t>
Refer to <xref target="operation-resource"/> for details
on operation resources.
    </t>
</section>
<section title="/restconf/streams">
    <t>
This optional resource is a container that provides access to the 
notification event streams supported by the server.
The server MAY omit this resource if no 
notification event streams are supported.
The media type for this resource is &quot;application/yang.api&quot;.
    </t>
    <t>
The server will populate this container with a stream list entry for
each stream type it supports.  Each stream contains a leaf
called &quot;events&quot; which represents an event stream resource.
The media type for this resource is &quot;application/yang.stream&quot;.
Refer to <xref target="notification-model"/> for details on notifications.
    </t>
</section>
</section>
<section title="Datastore Resource" anchor="datastore-resource">
    <t>
A datastore resource represents the conceptual root
of a tree of data resources.
The media type for this resource is &quot;application/yang.datastore&quot;.
A datastore resource can be retrieved with the GET method.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this 
resource, and return the &quot;Last&#8209;Modified&quot; header when this 
resource is retrieved with the GET or HEAD methods.
Only changes to configuration data resources within
the datastore affect this timestamp.
    </t>
    <t>
The server MUST maintain a resource entity tag for this
resource, and return the &quot;ETag&quot; header when this
resource is retrieved with the GET or HEAD methods.
The resource entity tag MUST be changed to a new
previously unused value if changes to any configuration
data resources within the datastore are made.
    </t>
    <t>
The depth of the subtrees returned in retrieval operations
can be controlled with the &quot;depth&quot; query parameter.
The number of nest levels, starting at the target resource,
can be specified, or an unlimited number can be returned.
Refer to <xref target="depth-param"/> for more details.
    </t>
    <t>
A datastore resource can only be written directly with
the PATCH method. Only the configuration data resources
within the datastore resource can be edited directly with
all methods.]
    </t>
</section>
<section title="Data Resource" anchor="data-resource">
    <t>
A data resource represents a YANG data node that is a descendant
node of a datastore resource. Only YANG container and list data node
types are considered to represent data resources.  Other YANG data nodes
are considered to be fields within their parent resource.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a last-modified timestamp for the
resource, and return the &quot;Last&#8209;Modified&quot; header when it
is retrieved with the GET or HEAD methods.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a resource entity tag for the
resource, and return the &quot;ETag&quot; header when it
is retrieved as the target resource with the GET or HEAD methods.
If maintained, the resource entity tag MUST be changed to a new
previously unused value if changes to the resource
or any configuration resource within the resource is altered.
    </t>
    <t>
A data resource can be retrieved with the GET method.
Configuration data resources
can be accessed via the &quot;/restconf/config&quot; entry point.
Operational data resources can be accessed via the
&quot;/restconf/operational&quot; entry point.
    </t>
    <t>
The depth of the subtrees returned in retrieval operations
can be controlled with the &quot;depth&quot; query parameter.
The number of nest levels, starting at the target resource,
can be specified, or an unlimited number can be returned.
Refer to <xref target="depth-param"/> for more details.
    </t>
    <t>
A configuration data resource can be altered by the client
with some of all of the edit operations, depending on the
target resource and the specific operation. Refer to <xref target="operations"/>
for more details on edit operations.
    </t>
<section title="Encoding YANG Instance Identifiers in the Request URI" anchor="uri-encoding">
    <t>
In YANG, data nodes are named with an absolute
XPath expression, from the document root to the target resource.
In RESTCONF, URL friendly path expressions are used instead.
    </t>
    <t>
The YANG &quot;instance&#8209;identifier&quot; (i-i) data type is represented
in RESTCONF with the path expression format defined
in this section. 
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF instance-identifier Type Conversion">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Comments</ttcol>
<c>point</c>
<c>Insertion point is always a full i-i</c>
<c>path</c>
<c>Request URI path is a full or partial i-i</c>
</texttable>
<?rfc compact="no"?>    <t>
The &quot;path&quot; component of the request URI contains the
absolute path expression that identifies the
target resource.  The &quot;select&quot; query parameter is
used to optionally identify the requested data nodes
within the target resource to be retrieved in a GET method.
    </t>
    <t>
A predictable location for a data resource
is important, since applications will code to the YANG
data model module, which uses static naming and defines an
absolute path location for all data nodes.
    </t>
    <t>
A RESTCONF data resource identifier is not an XPath expression.
It is encoded from left to right, starting with the top-level
data node, according to the &quot;api&#8209;path&quot; rule in <xref target="path-abnf"/>.
The node name of each ancestor of the target resource node
is encoded in order, ending with the node name for the
target resource.
    </t>
    <t>
If the &quot;select&quot; is present, it is encoded,
starting with a child node of the target resource,
according to the &quot;api&#8209;select&quot; rule defined in <xref target="path-abnf"/>.
    </t>
    <t>
If a data node in the path expression is a YANG list node,
then the key values for the list (if any) are encoded
according to the &quot;key&#8209;value&quot; rule.  If the list node
is the target resource, then the key values MAY be omitted,
according to the operation.  For example, the POST
method to create a new data resource for a list node
does not allow the key values to be present in the request URI.
    </t>
    <t>
The key leaf values for a data resource representing a YANG list
MUST be encoded as follows:
    </t>
<t>
 <list style="symbols">
 <t>
The value of each leaf identified in the &quot;key&quot; statement
is encoded in order.
 </t>
 <t>
All the components in the &quot;key&quot; statement MUST be encoded.
Partial instance identifiers are not supported.
 </t>
 <t>
Each value is encoded using the &quot;key&#8209;value&quot; rule in <xref target="path-abnf"/>,
according to the encoding rules for the data type of the key leaf.
 </t>
 <t>
An empty string can be a valid key value
(e.g., &quot;/top/list/key1//key3&quot;).
 </t>
 <t>
The &quot;/&quot; character MUST be URL-encoded (i.e., &quot;%2F&quot;).
 </t>
 <t>
All whitespace MUST be URL-encoded.
 </t>
 <t>
A &quot;null&quot; value is not allowed since the &quot;empty&quot; data type is
not allowed for key leafs.
 </t>
 <t>
The XML encoding is defined in <xref target="RFC6020"/>.
 </t>
 <t>
The JSON encoding is defined in <xref target="I-D.lhotka-netmod-json"/>.
 </t>
 <t>
The entire &quot;key&#8209;value&quot; MUST be properly URL-encoded,
according to the rules defined in <xref target="RFC3986"/>.
 </t>
 <t>
resource URI values returned in Location headers
for data resources MUST identify the module name, even
if there are no conflicting local names when the resource
is created. This ensures the correct resource will be identified
even if the server loads a new module that the old client
does not know about.
 </t>
 </list>
</t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
  [ lines wrapped for display purposes only ]

  /restconf/config/example-jukebox:jukebox/library/
     artist/Beatles&select=album

  /restconf/config/example-list:newlist/17&
     select=nextlist%2Ffoo%2Fbar%2Facme-list-ext%3Aext-leaf

  /restconf/config/example-list:somelist/the%20key

  /restconf/config/example-list:somelist/the%20key/address
	    ]]></artwork>
	</figure>
<section title="ABNF For Data Resource Identifiers" anchor="path-abnf">
    <t>
The following ABNF syntax is used to construct RESTCONF
path identifiers:
    </t>
	<figure>
	    <artwork><![CDATA[
    api-path = "/"  |
               ("/" api-identifier
                 0*("/" (api-identifier | key-value )))

    [FIXME: the syntax for the select string is still TBD]
    api-select = api-identifier
                    0*("/" (api-identifier | key-value ))

    api-identifier = [module-name ":"] identifier

    module-name = identifier

    key-value = string 

    ;; An identifier MUST NOT start with 
    ;; (('X'|'x') ('M'|'m') ('L'|'l'))
    identifier  = (ALPHA / "_")
                  *(ALPHA / DIGIT / "_" / "-" / ".")

    string = <an unquoted string>
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Data Resource Retrieval" anchor="data-retrieval">
    <t>
There are three types of filtering for retrieval of data resources.
This section defines each mode.
    </t>
<section title="Conditional Retrieval">
    <t>
The HTTP headers (such as &quot;If&#8209;Modified&#8209;Since&quot; and &quot;If&#8209;Match&quot;)
can by used in for a request message for a GET method
to check a condition within the server state, such as the
last time the datastore resource was modified, or the resource
entity tag of the target resource.  
    </t>
    <t>
If the condition is met according to the header
definition, a &quot;200 OK&quot; Status-Line and the data requested is 
returned in the response message.
If the condition is not met, a &quot;304 Not Modified&quot;
Status-Line is returned in response message instead.
    </t>
</section>
<section title="Data Classification Retrieval">
    <t>
The &quot;/restconf/config&quot; datastore resource is used to
access child configuration data resources.
The &quot;/restconf/operational&quot; datastore resource is used
to access child operational data resources.
    </t>
</section>
<section title="Filtered Retrieval">
    <t>
The &quot;select&quot; query parameter is used to specify a filter
that should be applied to the target resource to
request a subset of all possible descendant nodes
within the target resource.
    </t>
    <t>
The format of the &quot;select&quot; parameter string is defined
in <xref target="select-param"/>.  The set of nodes selected by the
filter expression is applied to each context node
identified by the target resource.
    </t>
</section>
</section>
</section>
<section title="Operation Resource" anchor="operation-resource">
    <t>
An operation resource represents an protocol operation
defined with the YANG &quot;rpc&quot; statement.
    </t>
    <t>
All operation resources share the same module namespace
as any top-level data resources, so the name of an operation
resource cannot conflict with the name of a top-level
data resource defined within the same module.
    </t>
    <t>
If 2 different YANG modules define the same &quot;rpc&quot; identifier,
then the module name MUST be used in the request URI.
For example, if &quot;module&#8209;A&quot; and &quot;module&#8209;B&quot; both defined
a &quot;reset&quot; operation, then invoking the operation from &quot;module&#8209;A&quot;
would be requested as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/module-A:reset HTTP/1.1
   Server example.com
	    ]]></artwork>
	</figure>
    <t>
Any usage of an operation resource from the same module,
with the same name, refers to the same &quot;rpc&quot; statement
definition.  This behavior can be used to design protocol operations
that perform the same general function on different
resource types.
    </t>
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then a message body
MAY be sent by the client in the request, otherwise the request
message MUST NOT include a message body.
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then a message body
MAY be sent by the server in the response. Otherwise the 
server MUST NOT include a message body in the response message,
and MUST send a &quot;204 No Content&quot; Status-Line instead.
    </t>
<section title="Encoding Operation Input Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then
the &quot;input&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;input&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc reboot {
      input {
        leaf delay {
          units seconds;
          type uint32;
          default 0;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:reboot HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-ops:input" : {
       "delay" : 600,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 11:01:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="Encoding Operation Output Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then
the &quot;output&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;output&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc get-reboot-info {
      output {
        leaf reboot-time {
          units seconds;
          type uint32;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:get-reboot-info HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 25 Apr 2012 11:10:30 GMT
   Server: example-server

   {
     "example-ops:output" : {
       "reboot-time" : 30,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Stream Resource" anchor="stream-resource">
    <t>
A stream resource represents a source for system generated
event notifications.  Each stream is created and modified
by the server only.  A client can retrieve a stream resource
or initiate a long-poll server sent event stream,
using the procedure specified in <xref target="receive-notifs"/>.
    </t>
    <t>
A notification stream functions according to the NETCONF
Notifications specification <xref target="RFC5277"/>.  The &quot;ietf&#8209;restconf&quot;
YANG module contains the &quot;stream&quot; list (/restconf/streams/stream)
which specifies the syntax and semantics of a stream resource.
    </t>
</section>
</section>
<section title="Error Reporting" anchor="error-reporting">
    <t>
HTTP Status-Lines are used to report success or failure
for RESTCONF operations.
The &lt;rpc&#8209;error&gt; element returned in NETCONF error responses
contains some useful information.  This error information
is adapted for use in RESTCONF, and error information
is returned for &quot;4xx&quot; class of status codes.
    </t>
    <t>
The following table summarizes the return status codes
used specifically by RESTCONF operations:
    </t>
<?rfc compact="yes"?><texttable title="HTTP Status Codes used in RESTCONF">
<ttcol align='left'> Status-Line</ttcol>
<ttcol align='left'>Description</ttcol>
<c>100 Continue</c>
<c>POST accepted, 201 should follow</c>
<c>200 OK</c>
<c>Success with response body</c>
<c>201 Created</c>
<c>POST to create a resource success</c>
<c>202 Accepted</c>
<c>POST to create a resource accepted</c>
<c>204 No Content</c>
<c>Success without response body</c>
<c>304 Not Modified</c>
<c>Conditional operation not done</c>
<c>400 Bad Request</c>
<c>Invalid request message</c>
<c>403 Forbidden</c>
<c>Access to resource denied</c>
<c>404 Not Found</c>
<c>Resource target or resource node not found</c>
<c>405 Method Not Allowed</c>
<c>Method not allowed for target resource</c>
<c>409 Conflict</c>
<c>Resource or lock in use</c>
<c>412 Precondition Failed</c>
<c>Conditional method is false</c>
<c>413 Request Entity Too Large</c>
<c>too-big error</c>
<c>414 Request-URI Too Large</c>
<c>too-big error</c>
<c>415 Unsupported Media Type</c>
<c>non RESTCONF media type</c>
<c>500 Internal Server Error</c>
<c>operation-failed</c>
<c>501 Not Implemented</c>
<c>unknown-operation</c>
<c>503 Service Unavailable</c>
<c>Recoverable server error</c>
</texttable>
<?rfc compact="no"?>    <t>
Since an operation resource is defined with a YANG &quot;rpc&quot;
statement, a mapping between the NETCONF &lt;error&#8209;tag&gt; value
and the HTTP status code is needed.   The specific error
condition and response code to use are data-model specific
and might be contained in the YANG &quot;description&quot; statement
for the &quot;rpc&quot; statement.
    </t>
<?rfc compact="yes"?><texttable title="Mapping from error-tag to status code">
<ttcol align='left'> &lt;error&#8209;tag&gt;</ttcol>
<ttcol align='left'>status code</ttcol>
<c>in-use</c>
<c>409</c>
<c>invalid-value</c>
<c>400</c>
<c>too-big</c>
<c>413</c>
<c>missing-attribute</c>
<c>400</c>
<c>bad-attribute</c>
<c>400</c>
<c>unknown-attribute</c>
<c>400</c>
<c>bad-element</c>
<c>400</c>
<c>unknown-element</c>
<c>400</c>
<c>unknown-namespace</c>
<c>400</c>
<c>access-denied</c>
<c>403</c>
<c>lock-denied</c>
<c>409</c>
<c>resource-denied</c>
<c>409</c>
<c>rollback-failed</c>
<c>500</c>
<c>data-exists</c>
<c>409</c>
<c>data-missing</c>
<c>409</c>
<c>operation-not-supported</c>
<c>501</c>
<c>operation-failed</c>
<c>500</c>
<c>partial-operation</c>
<c>500</c>
<c>malformed-message</c>
<c>400</c>
</texttable>
<?rfc compact="no"?><section title="Error Response Message" anchor="errors">
    <t>
When an error occurs for a request message on a data resource
or an operation resource, and a &quot;4xx&quot; class of status codes
(except for status code &quot;403&quot;),
then the server SHOULD send a response body containing
the information described by the &quot;errors&quot; container definition
within the YANG module <xref target="module"/>.
    </t>
    <t>
YANG Tree Diagram for &lt;errors&gt; Data:
    </t>
	<figure>
	    <artwork><![CDATA[
   +--ro errors
      +--ro error
         +--ro error-type       enumeration
         +--ro error-tag        string
         +--ro error-app-tag?   string
         +--ro error-path?      data-resource-identifier
         +--ro error-message?   string
         +--ro error-info
	    ]]></artwork>
	</figure>
    <t>
Example:
    </t>
    <t>
The following example shows an error returned for
an &quot;lock&#8209;denied&quot; error on a datastore resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:lock-datastore HTTP/1.1   
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 17:11:00 GMT
   Server: example-server
   Content-Type: application/yang.api+json

   {
     "ietf-restconf:errors": {
       "error": {
         "error-type": "protocol",
         "error-tag": "lock-denied",
         "error-message": "Lock failed, lock already held"
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="YANG Patch" anchor="yang-patch">
    <t>
The YANG Patch operation is provided so complex
editing operations can be performed within RESTCONF.
The &quot;plain patch&quot; operation only provides a simple merge
edit operation on the target datastore.
    </t>
    <t>
A &quot;YANG Patch&quot; is an ordered list of edits that are applied
to the target datastore by the server. The specific fields
are defined with the &apos;yang&#8209;patch&apos; container definition in
the YANG module <xref target="module"/>.
    </t>
    <t>
The YANG Patch operation is selected by the client by
invoking a PATCH method with the YANG Patch media type.
A message body representing the YANG Patch input parameters
MUST be provided.
    </t>
    <t>
Each patch is identified by a client provided string,
called the &quot;patch&#8209;id&quot;.
    </t>
    <t>
YANG Tree Diagram For &quot;application/yang.patch&quot; Media Type
    </t>
	<figure>
	    <artwork><![CDATA[
   +--rw yang-patch
   |  +--rw patch-id?   string
   |  +--rw comment?    string
   |  +--rw edit [edit-id]
   |     +--rw edit-id      string
   |     +--rw operation    enumeration
   |     +--rw target       data-resource-identifier
   |     +--rw point?       data-resource-identifier
   |     +--rw where?       enumeration
   |     +--rw value
	    ]]></artwork>
	</figure>
    <t>
A data element representing the YANG Patch Status is returned
to the client to report the detailed status of the edit operation.
This data is identified by the YANG Patch Status media type.
    </t>
    <t>
YANG Tree Diagram For &quot;application/yang.patch&#8209;status&quot; Media Type:
    </t>
	<figure>
	    <artwork><![CDATA[
   +--rw yang-patch-status
      +--rw patch-id?        string
      +--rw (global-status)?
      |  +--:(global-errors)
      |  |  +--ro errors
      |  |
      |  +--:(ok)
      |     +--rw ok?              empty
      +--rw edit-status
         +--rw edit [edit-id]
            +--rw edit-id     string
            +--rw (edit-status-choice)?
               +--:(ok)
               |  +--rw ok?         empty
               +--:(location)
               |  +--rw location?   inet:uri
               +--:(errors)
                  +--ro errors
	    ]]></artwork>
	</figure>
<section title="Why not use JSON Patch?">
    <t>
The HTTP PATCH method requires that the media type
of the patch content be specified, so it should be possible
to use any patch mechanism, including JSON Patch <xref target="RFC6902"/>.
    </t>
    <t>
The RESTCONF protocol is designed to utilize the YANG
data modeling language to specify content schemas.
The JSON Patch mechanism is incompatible with RESTCONF
for the following reasons:
    </t>
<t>
 <list style="symbols">
 <t>
A patch mechanism that works with either XML or JSON encoding
is needed.
 </t>
 <t>
YANG configuration nodes can be named with complex keys,
using one or more key leafs. JSON arrays are packed and
all the YANG keys would be collapsed down to a single integer
index.
 </t>
 <t>
YANG configuration nodes are named with stable, persistent
identifiers, using key leafs. JSON arrays are packed,
and if entry I is added or deleted, then all entries I+1 .. Imax
are renumbered.
 </t>
 <t>
The edit operation set needs to align with the NETCONF protocol,
and JSON Patch does not provide an aligned set of edit operations.
 </t>
 <t>
The datastore validation procedures need to be specific and aligned
with YANG validation procedures.
 </t>
 <t>
The error reporting needs to align with the NETCONF protocol,
and JSON Patch does not provide an aligned error reporting mechanism.
 </t>
 </list>
</t>
</section>
<section title="YANG Patch Target Data Node">
    <t>
The target data node for each edit operation is determined
by the value of the target resource in the request and the
&quot;target&quot; leaf within each &quot;edit&quot; entry.
    </t>
    <t>
If the target resource specified in the request URI identifies
a datastore resource, then the path string in the &quot;target&quot; leaf
is an absolute path expression. The first node specified
in the &quot;target&quot; leaf is a top-level data node defined within
a YANG module.
    </t>
    <t>
If the target resource specified in the request URI identifies
a data resource, then the path string in the &quot;target&quot; leaf
is a relative path expression. The first node specified
in the &quot;target&quot; leaf is a child node of the data node associated
with the target resource.
    </t>
</section>
<section title="YANG Patch Edit Operations">
    <t>
Each YANG patch edit specifies one edit operation on
the target data node. The set of operations is aligned
with the NETCONF edit operations, but also includes
some new operations.
    </t>
<?rfc compact="yes"?><texttable title="YANG Patch Edit Operations">
<ttcol align='left'> Operation</ttcol>
<ttcol align='left'>Description</ttcol>
<c>create</c>
<c>create a new data resource if it does not already exist or error</c>
<c>delete</c>
<c>delete a data resource if it already exists or error</c>
<c>insert</c>
<c>insert a new user-ordered data resource</c>
<c>merge</c>
<c>merge the edit value with the target data resource; create if it does not already exist</c>
<c>move</c>
<c>re-order the target data resource</c>
<c>replace</c>
<c>replace the target data resource with the edit value</c>
<c>remove</c>
<c>remove a data resource if it already exists or no error</c>
</texttable>
<?rfc compact="no"?></section>
<section title="YANG Patch Error Handling">
    <t>
If a well-formed, schema-valid YANG Patch message is received, then
then the server will process the supplied edits in ascending order.
The following error modes apply to the processing of this edit list:
    </t>
    <t>
All the specified edits MUST be applied or the
target datastore contents SHOULD be returned to its original state
before the PATCH method started.  The server MAY fail to restore
the contents of the target datastore completely and with certainty.
It is possible for a rollback to fail or an &quot;undo&quot; operation
to fail.
    </t>
    <t>
The server will save the running datastore to non-volatile storage
if it has changed, after the edits have been attempted.
    </t>
</section>
<section title="YANG Patch Response">
    <t>
A special response is returned for YANG Patch operations,
in order to report status information for each individual edit.
It is possible to report general errors as well.
The YANG conceptual container definition &quot;yang&#8209;patch&#8209;status&quot;
defined in <xref target="module"/> defines the syntax.
    </t>
</section>
<section title="YANG Patch Examples">
<section title="Add Resources: Error">
    <t>
The following example shows several songs being added to
an existing album. Each edit contains one song.
The first song already exists, so an error will be
reported for that edit. The rest of the edits were not attempted,
since the first edit failed.
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   PATCH /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light HTTP/1.1
   Host: example.com
   Accept: application/yang.patch-status+json
   Content-Type: application/yang.patch+json

   {
     "ietf-restconf:yang-patch" : {
       "patch-id" : "add-songs-patch",
       "edit" : [
         {
           "edit-id" : 1,
           "operation" : "create",
           "target" : "/song",
           "value" : {
             "song" : {
               "name" : "Bridge Burning",
               "location" : "/media/bridge_burning.mp3",
               "format" : "MP3",
               "length" : 288
             }
           }
         },
         {
           "edit-id" : 2,
           "operation" : "create",
           "target" : "/song",
           "value" : {
             "song" : {
               "name" : "Rope",
               "location" : "/media/rope.mp3",
               "format" : "MP3",
               "length" : 259
             }
           }
         },
         {
           "edit-id" : 3,
           "operation" : "create",
           "target" : "/song",
           "value" : {
             "song" : {
               "name" : "Dear Rosemary",
               "location" : "/media/dear_rosemary.mp3",
               "format" : "MP3",
               "length" : 269
             }
           }
         }
       ]
     }
   }

 Response from server:

   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   Content-Type: application/yang.patch-status+json

   {
     "ietf-restconf:yang-patch-status" : {
       "patch-id" : "add-songs-patch",
       "edit-status" : {
         "edit" : [
           {
             "edit-id" : 1,
             "errors" : {
               "error" : [
                 {
                   "error-type": "application",
                   "error-tag": "data-exists",
                   "error-path": "/example-jukebox:jukebox/library
                      /artist/Foo%20Fighters/album/Wasting%20Light
                      /song/Burning%20Light",
                   "error-message": 
                     "Data already exists, cannot be created"
                 }
               ]
             }
           }
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Add Resources: Success">
    <t>
The following example shows several songs being added to
an existing album.
    </t>
<t>
 <list style="symbols">
 <t>
Each of 2 edits contains one song.
 </t>
 <t>
Both edits succeed and new sub-resources are created
 </t>
 </list>
</t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   PATCH /restconf/config/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light
      HTTP/1.1
   Host: example.com
   Accept: application/yang.patch-status+json
   Content-Type: application/yang.patch+json

   {
     "ietf-restconf:yang-patch" : {
       "patch-id" : "add-songs-patch-2",
       "edit" : [
         {
           "edit-id" : 1,
           "operation" : "create",
           "target" : "/song",
           "value" : {
             "song" : {
               "name" : "Rope",
               "location" : "/media/rope.mp3",
               "format" : "MP3",
               "length" : 259
             }
           }
         },
         {
           "edit-id" : 2,
           "operation" : "create",
           "target" : "/song",
           "value" : {
             "song" : {
               "name" : "Dear Rosemary",
               "location" : "/media/dear_rosemary.mp3",
               "format" : "MP3",
               "length" : 269
             }
           }
         }
       ]
     }
   }

 Response from server:

   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   Content-Type: application/yang.patch-status+json

   {
     "ietf-restconf:yang-patch-status" : {
       "patch-id" : "add-songs-patch-2",
       "ok" : [null],
       "edit-status" : {
         "edit" : [
           {
             "edit-id" : 1,
             "location" : "http://example.com/restconf/
                config/example-jukebox:jukebox/library/artist/
                Foo%20Fighters/album/Wasting%20Light/song/Rope"
           },
           {
             "edit-id" : 2,
             "location" : "http://example.com/restconf/
                config/example-jukebox:jukebox/library/artist/
                Foo%20Fighters/album/Wasting%20Light/song/
                Dear%20Rosemary"
           }
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Move list entry example">
    <t>
The following example shows a song being moved within
an existing playlist. Song &quot;1&quot; in playlist &quot;Foo&#8209;One&quot; is
being moved after song &quot;3&quot; in the playlist.
The operation succeeds, so a non-error reply example can be shown.
    </t>
	<figure>
	    <artwork><![CDATA[
 Request from client:

   PATCH /restconf/config/example-jukebox:jukebox/
     playlist/Foo-One   HTTP/1.1
   Host: example.com
   Accept: application/yang.patch-status+json
   Content-Type: application/yang.patch+json

   {
     "ietf-restconf:yang-patch" : {
       "patch-id" : "move-song-patch",
       "comment" : "Move song 1 after song 3",
       "edit" : [
         {
           "edit-id" : 1,
           "operation" : "move",
           "target" : "/song/1",
           "point" : "/song3",
           "where" : "after"
         }
       ]
     }
   }

 Response from server:

   HTTP/1.1 400 OK
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   Content-Type: application/yang.patch-status+json

   {
     "ietf-restconf:yang-patch-status" : {
       "patch-id" : "move-song-patch",
       "ok" : [null],
       "edit-status" : {
         "edit" : [
           {
             "edit-id" : 1,
             "ok" : [ null ]
           }
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
</section>
<section title="RESTCONF module" anchor="module">
    <t>
The &quot;ietf&#8209;restconf&quot; module defines conceptual definitions
within groupings, which are not meant to be implemented
as datastore contents by a server.
    </t>
    <t>
The &quot;ietf&#8209;yang&#8209;types&quot; and &quot;ietf&#8209;inet_types&quot; modules from <xref target="RFC6991"/>
are used by this module for some type definitions.
    </t>
    <t>
RFC Ed.: update the date below with the date of RFC publication and
remove this note.
    </t>
<t>&lt;CODE BEGINS> file "ietf-restconf@2013-10-19.yang"</t>
	<figure>
	    <artwork><![CDATA[
module ietf-restconf {
  namespace "urn:ietf:params:xml:ns:yang:ietf-restconf";
  prefix "restconf";

  import ietf-yang-types { prefix yang; }
  import ietf-inet-types { prefix inet; }

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "Editor:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Editor:   Kent Watsen
               <mailto:kwatsen@juniper.net>

     Editor:   Rex Fernando
               <mailto:rex@cisco.com>";

  description
    "This module contains conceptual YANG specifications
     for the YANG Patch and error content that is used in
     RESTCONF protocol messages. A conceptual container
     representing the RESTCONF API nodes (media type 
     application/yang.api).

     Note that the YANG definitions within this module do not
     represent configuration data of any kind.
     The YANG grouping statements provide a normative syntax
     for XML and JSON message encoding purposes.

     Copyright (c) 2013 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  // RFC Ed.: replace XXXX with actual RFC number and remove this
  // note.

  // RFC Ed.: remove this note
  // Note: extracted from draft-bierman-netconf-restconf-02.txt

  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  revision 2013-10-19 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: RESTCONF Protocol.";
  }

  typedef data-resource-identifier {
    type string {
      length "1 .. max";
    }
    description
      "Contains a Data Resource Identifier formatted string
       to identify a specific data node. The data node that
       uses this data type SHOULD define the document root
       for data resource identifiers.  The default document
       root is the target datastore conceptual root node.
       Data resource identifiers are defined relative to
       this document root.";
    reference
      "RFC XXXX: [sec. 5.3.1.1 ABNF For Data Resource Identifiers]";
  }

  // this typedef is TBD; not currently used
  typedef datastore-identifier {
    type union {
      type enumeration {
        enum candidate {
          description
            "Identifies the NETCONF shared candidate datastore.";
          reference
            "RFC 6241, section 8.3";
        }
        enum running {
          description
            "Identifies the NETCONF running datastore.";
          reference
            "RFC 6241, section 5.1";
        }
        enum startup {
          description
            "Identifies the NETCONF startup datastore.";
          reference
            "RFC 6241, section 8.7";
        }
      }
      type string;
    }
    description
      "Contains a string to identify a specific datastore.
       The enumerated datastore identifier values are
       reserved for standard datastore names.";
  }

  typedef revision-identifier {
    type string {
      pattern '\d{4}-\d{2}-\d{2}';
    }
    description
      "Represents a specific date in YYYY-MM-DD format.
       TBD: make pattern more precise to exclude leading zeros.";
  }

  grouping yang-patch {

    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of a
       YANG Patch edit request message.";

    container yang-patch {
      description
        "Represents a conceptual sequence of datastore edits,
         called a patch. Each patch is given a client-assigned
         patch identifier. Each edit MUST be applied
         in ascending order, and all edits MUST be applied.
         If any errors occur, then the target datastore MUST NOT
         be changed by the patch operation.
  
         A patch MUST be validated by the server to be a 
         well-formed message before any of the patch edits
         are validated or attempted.
  
         YANG datastore validation (defined in RFC 6020, section
         8.3.3) is performed after all edits have been
         individually validated.
  
         It is possible for a datastore constraint violation to occur
         due to any node in the datastore, including nodes not
         included in the edit list. Any validation errors MUST
         be reported in the reply message.";
  
      reference
        "RFC 6020, section 8.3.";
  
      leaf patch-id {
        type string;
        description
          "An arbitrary string provided by the client to identify
           the entire patch.  This value SHOULD be present in any
           audit logging records generated by the server for the
           patch. Error messages returned by the server pertaining
           to this patch will be identified by this patch-id value.";
      }

      leaf comment {
        type string {
          length "0 .. 1024";
        }
        description
          "An arbitrary string provided by the client to describe
           the entire patch.  This value SHOULD be present in any
           audit logging records generated by the server for the
           patch.";
      }
  
      list edit {
        key edit-id;
        ordered-by user;

        description
          "Represents one edit within the YANG Patch
           request message.";

        leaf edit-id {
          type string;
          description
            "Arbitrary string index for the edit.
             Error messages returned by the server pertaining
             to a specific edit will be identified by this
             value.";
        }
  
        leaf operation {
          type enumeration {
            enum create {
              description
                "The target data node is created using the
                 supplied value, only if it does not already
                 exist.";
            }
            enum delete {
              description
                "Delete the target node, only if the data resource
                 currently exists, otherwise return an error.";
            }
            enum insert {
              description
                "Insert the supplied value into a user-ordered
                 list or leaf-list entry. The target node must
                 represent a new data resource.";
            }
            enum merge {
              description
                "The supplied value is merged with the target data
                 node.";
            }
            enum move {
              description
                "Move the target node. Reorder a user-ordered
                 list or leaf-list. The target node must represent
                 an existing data resource.";
            }
            enum replace {
              description
                "The supplied value is used to replace the target
                 data node.";
            }
            enum remove {
              description
                "Delete the target node if it currently exists.";
            }
          }
          mandatory true;
          description
            "The datastore operation requested for the associated
             edit entry";
        }
  
        leaf target {
          type data-resource-identifier;
          mandatory true;
          description
            "Identifies the target data resource for the edit
             operation.";
        }
  
        leaf point {
          when "(../operation = 'insert' or " +
            "../operation = 'move') and " +
            "(../where = 'before' or ../where = 'after')" {
            description
              "Point leaf only applies for insert or move
               operations, before or after an existing entry.";
          }
          type data-resource-identifier;
          description
            "The absolute URL path for the data node that is being
             used as the insertion point or move point for the
             target of this edit entry.";
        }
  
        leaf where {
          when "../operation = 'insert' or ../operation = 'move'" {
            description
              "Where leaf only applies for insert or move
               operations.";
          }
          type enumeration {
            enum before {
              description
                "Insert or move a data node before the data resource
                 identified by the 'point' parameter.";
            }
            enum after {
              description
                "Insert or move a data node after the data resource
                 identified by the 'point' parameter.";
            }
            enum first {
              description
                "Insert or move a data node so it becomes ordered
                 as the first entry.";
            }
            enum last {
              description
                "Insert or move a data node so it becomes ordered
                 as the last entry.";
            }
  
          }
          default last;
          description
            "Identifies where a data resource will be inserted or
             moved. YANG only allows these operations for
             list and leaf-list data nodes that are ordered-by
             user.";
        }
  
        anyxml value {
          when "(../operation = 'create' or " +
            "../operation = 'merge' " +
            "or ../operation = 'replace' or " +
            "../operation = 'insert')" {
            description
              "Value node only used for create, merge,
               replace, and insert operations";
          }
          description
            "Value used for this edit operation.";
        }
      }
    }

  } // grouping yang-patch


  grouping yang-patch-status {

    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of
       YANG Patch status response message.";
    
    container yang-patch-status {
      description
        "A container representing the response message
         sent by the server after a YANG Patch edit
         request message has been processed.";

      leaf patch-id {
        type string;
        description
          "The patch-id value used in the request";
      }

      choice global-status {
        description
          "Report global errors or complete success.
           If there is no case selected then errors
           are reported in the edit-status container.";

        case global-errors {
          uses errors;
          description
            "This container will be present if global
             errors unrelated to a specific edit occurred.";
        }
        leaf ok {
          type empty;
          description
            "This leaf will be present if the request succeeded
             and there are no errors reported in the edit-status
             container.";
        }
      }

      container edit-status {
        description
          "This container will be present if there are
           edit-specific status responses to report.";
      
        list edit {
          key edit-id;

          description
            "Represents a list of status responses,
             corresponding to edits in the YANG Patch
             request message.  If an edit entry was
             skipped or not reached by the server,
             then this list will not contain a corresponding
             entry for that edit.";

          leaf edit-id {
            type string;
             description
               "Response status is for the edit list entry
                with this edit-id value.";
          }
          choice edit-status-choice {
            description
              "A choice between different types of status
               responses for each edit entry.";
            leaf ok {
              type empty;
              description
                "This edit entry was invoked without any
                 errors detected by the server associated
                 with this edit.";
            }
            leaf location {
              type inet:uri;
              description
                "Contains the Location header value that would be
                 returned if this edit causes a new resource to be
                 created. If the edit identified by the same edit-id
                 value was successfully invoked and a new resource
                 was created, then this field will be returned
                 instead of 'ok'.";
            }
            case errors {
              uses errors;
              description
                "The server detected errors associated with the
                  edit identified by the same edit-id value.";
            }
          }
        }
      }
    }
  }  // grouping yang-patch-status


  grouping errors {

    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of a
       YANG Patch errors report within a response message.";

    container errors {
      config false;  // needed so list error does not need a key
      description
        "Represents an error report returned by the server if
         a request results in an error.";
  
      list error {
        description
          "An entry containing information about one
           specific error that occurred while processing
           a RESTCONF request.";
        reference "RFC 6241, Section 4.3";
  
        leaf error-type { 
          type enumeration {
            enum transport {
              description "The transport layer";
            }
            enum rpc {
              description "The rpc or notification layer";
            }
            enum protocol {
              description "The protocol operation layer";
            }
            enum application {
              description "The server application layer";
            }
          }
          mandatory true;
          description
            "The protocol layer where the error occurred.";
        }
  
        leaf error-tag {
          type string;
          mandatory true;
          description
            "The enumerated error tag.";
        }
  
        leaf error-app-tag { 
          type string;
          description
            "The application-specific error tag.";
        }
  
        leaf error-path { 
          type data-resource-identifier;
          description
            "The target data resource identifier associated
             with the error, if any.";
        }
  
        leaf error-message { 
          type string;
          description
            "A message describing the error.";
        }
  
        container error-info { 
           description
             "A container allowing additional information
              to be included in the error report.";
           // arbitrary anyxml content here
        }
      }
    }
  } // grouping errors


  grouping restconf {

    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of
       the RESTCONF API resource.";

    container restconf {
      description
        "Conceptual container representing the
         application/yang.api resource type.";
  
      container config {
        description
          "Container representing the application/yang.datastore
           resource type. Represents the conceptual root of the
           unified configuration datastore containing YANG data
           nodes. The child nodes of this container are
           configuration data resources (application/yang.data)
           defined as top-level YANG data nodes from the modules
           advertised by the server in /restconf/modules.";
      }

      container operational {
        description
          "Container representing the application/yang.datastore
           resource type. Represents the conceptual root of the
           operational data supported by the server.  The child
           nodes of this container are operational data resources 
           (application/yang.data) defined as top-level
           YANG data nodes from the modules advertised by
           the server in /restconf/modules.";
      }

      container modules {
        description
          "Contains a list of module description entries.
           These modules are currently loaded into the server.";
  
        list module {
          key "name revision";
          description
            "Each entry represents one module currently
             supported by the server.";

          leaf name {
            type yang:yang-identifier;
            description "The YANG module name.";
          }
          leaf revision {
            type union {
              type revision-identifier;
              type string { length 0; }
            }
            description
              "The YANG module revision date. An empty string is
               used if no revision statement is present in the
               YANG module.";
          }
          leaf namespace {
            type inet:uri;
            mandatory true;
            description
              "The XML namespace identifier for this module.";
          }
          leaf-list feature {
            type yang:yang-identifier;
            description
              "List of YANG feature names from this module that are
               supported by the server.";
          }
          leaf-list deviation {
            type yang:yang-identifier;
            description
              "List of YANG deviation module names used by this
               server to modify the conformance of the module
               associated with this entry.";
          }
        }
      }

      container operations {
        description
          "Container for all operation resources
           (application/yang.operation),

           Each resource is represented as an empty leaf with the
           name of the RPC operation from the YANG rpc statement.
  
           E.g.;
  
              POST /restconf/operations/show-log-errors
  
              leaf show-log-errors {
                type empty;
              }
          ";
      }

      container streams {
        description
          "Container representing the notification event streams
           supported by the server.";
         reference
           "RFC 5277, Section 3.4, <streams> element.";

        list stream {
          key name;
          description
            "Each entry describes an event stream supported by
             the server.";

          leaf name {
            type string;
            description "The stream name";
            reference "RFC 5277, Section 3.4, <name> element.";
          }

          leaf description {
            type string;
            description "Description of stream content";
            reference
              "RFC 5277, Section 3.4, <description> element.";
          }

          leaf replay-support {
            type boolean;
            description
              "Indicates if replay buffer supported for this stream";
            reference
              "RFC 5277, Section 3.4, <replaySupport> element.";
          }

          leaf replay-log-creation-time {
            type yang:date-and-time;
            description
              "Indicates the time the replay log for this stream
               was created.";
            reference
              "RFC 5277, Section 3.4, <replayLogCreationTime>
               element.";
          }

          leaf events {
            type empty;
            description
              "Represents the entry point for establishing
               notification delivery via server sent events.";
          }
        }
      }

      leaf version {
        type enumeration {
          enum "1.0" {
            description 
              "Version 1.0 of the RESTCONF protocol.";
          }
        }
        config false;
        description
          "Contains the RESTCONF protocol version.";
      }
    }
  }  // grouping restconf


  grouping notification {
    description
      "Contains the notification message wrapper definition.";

    container notification {
      description
        "RESTCONF notification message wrapper.";

      leaf event-time {
        type yang:date-and-time;
        mandatory true;
        description
          "The time the event was generated by the
           event source.";
        reference
          "RFC 5277, section 4, <eventTime> element.";
      }

      /* The YANG-specific notification container is encoded
       * after the 'event-time' element.  The format
       * corresponds to the notificationContent element
       * in RFC 5277, section 4. For example:
       *
       *  module example-one {
       *     ...
       *     notification event1 { ... }
       *
       *  }
       *
       *  Encoded as element 'event1' in the namespace
       *  for module 'example-one'.
       */
    }
  }  // grouping notification

}
	    ]]></artwork>
	</figure>
<t>&lt;CODE ENDS></t>
</section>
<section title="IANA Considerations" anchor="iana">
<section title="YANG Module Registry">
    <t>
This document registers one URI in the IETF XML registry
<xref target="RFC3688"/>. Following the format in RFC 3688, the following
registration is requested to be made.
    </t>
	<figure>
	    <artwork><![CDATA[
     URI: urn:ietf:params:xml:ns:yang:ietf-restconf
     Registrant Contact: The NETMOD WG of the IETF.
     XML: N/A, the requested URI is an XML namespace.
	    ]]></artwork>
	</figure>
    <t>
This document registers one YANG module in the YANG Module Names
registry <xref target="RFC6020"/>.
    </t>
	<figure>
	    <artwork><![CDATA[
  name:         ietf-restconf
  namespace:    urn:ietf:params:xml:ns:yang:ietf-restconf
  prefix:       restconf
  // RFC Ed.: replace XXXX with RFC number and remove this note
  reference:    RFC XXXX
	    ]]></artwork>
	</figure>
</section>
<section title="application/yang Media Type">
    <t>
The MIME media type for RESTCONF resources is application/yang.
    </t>
	<figure>
	    <artwork><![CDATA[
   Type name: application

   Subtype name: yang

   Required parameters: TBD

   Optional parameters: TBD

   Encoding considerations: TBD

   Security considerations: TBD

   Interoperability considerations: TBD

   // RFC Ed.: replace XXXX with RFC number and remove this note
   Published specification: RFC XXXX
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Security Considerations">
    <t>
TBD
    </t>
</section>
</middle>
<back>
<references title="Normative References">

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author initials="S." surname="Bradner" fullname="S.  Bradner">
        <organization>Harvard University</organization>
      </author>
      <date month="March" year="1997"/>
      <abstract>
        <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.</t>
      </abstract>
    </front>
    <seriesInfo name="BCP" value="14"/>
    <seriesInfo name="RFC" value="2119"/>
    <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
  </reference>


<reference anchor='RFC2396'>

<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifiers (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<author initials='R.T.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='U.C. Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox Corporation'>Xerox PARC</organization>
<address>
<postal>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<facsimile>+1(415)812-4333</facsimile>
<email>masinter@parc.xerox.com</email></address></author>
<date year='1998' month='August' />
<area>Applications</area>
<keyword>uniform resource</keyword>
<keyword>URI</keyword>
<abstract>
<t>
   A Uniform Resource Identifier (URI) is a compact string of characters
   for identifying an abstract or physical resource.  This document
   defines the generic syntax of URI, including both absolute and
   relative forms, and guidelines for their use; it revises and replaces
   the generic definitions in RFC 1738 and RFC 1808.
</t>
<t>
   This document defines a grammar that is a superset of all valid URI,
   such that an implementation can parse the common components of a URI
   reference without knowing the scheme-specific requirements of every
   possible identifier type.  This document does not define a generative
   grammar for URI; that task will be performed by the individual
   specifications of each URI scheme.
</t></abstract>
<note title='IESG Note'>
<t>
   This paper describes a "superset" of operations that can be applied
   to URI.  It consists of both a grammar and a description of basic
   functionality for URI.  To understand what is a valid URI, both the
   grammar and the associated description have to be studied.  Some of
   the functionality described is not applicable to all URI schemes, and
   some operations are only possible when certain media types are
   retrieved using the URI, regardless of the scheme used.
</t></note></front>

<seriesInfo name='RFC' value='2396' />
<format type='TXT' octets='83639' target='http://www.rfc-editor.org/rfc/rfc2396.txt' />
<format type='HTML' octets='130638' target='http://xml.resource.org/public/rfc/html/rfc2396.html' />
<format type='XML' octets='104983' target='http://xml.resource.org/public/rfc/xml/rfc2396.xml' />
</reference>
<!-- end RFC 2396 -->


<reference anchor="RFC2616">

<front>
<title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="UC Irvine">Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="J." surname="Gettys" fullname="James Gettys">
<organization abbrev="Compaq/W3C">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
<organization abbrev="Compaq">Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Xerox">Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials="P." surname="Leach" fullname="Paul J. Leach">
<organization abbrev="Microsoft">Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year="1999" month="June"/>
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name="RFC" value="2616"/>
<format type="TXT" octets="422317" target="http://www.rfc-editor.org/rfc/rfc2616.txt"/>
<format type="PS" octets="5529857" target="http://www.rfc-editor.org/rfc/rfc2616.ps"/>
<format type="PDF" octets="550558" target="http://www.rfc-editor.org/rfc/rfc2616.pdf"/>
<format type="HTML" octets="636125" target="http://xml.resource.org/public/rfc/html/rfc2616.html"/>
<format type="XML" octets="493420" target="http://xml.resource.org/public/rfc/xml/rfc2616.xml"/>
</reference>  


  <reference anchor='RFC3688'>
    <front>
      <title>The IETF XML Registry</title>
      <author initials='M.' surname='Mealling' fullname='M. Mealling'>
        <organization /></author>
      <date year='2004' month='January' />
      <abstract>
        <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front>
    
    <seriesInfo name='BCP' value='81' />
    <seriesInfo name='RFC' value='3688' />
    <format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />
  </reference>
  
<reference anchor="RFC3986">

<front>
<title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="Day Software">Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year="2005" month="January"/>
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name="STD" value="66"/>
<seriesInfo name="RFC" value="3986"/>
<format type="TXT" octets="141811" target="http://www.rfc-editor.org/rfc/rfc3986.txt"/>
<format type="HTML" octets="213584" target="http://xml.resource.org/public/rfc/html/rfc3986.html"/>
<format type="XML" octets="163534" target="http://xml.resource.org/public/rfc/xml/rfc3986.xml"/>
</reference>

  <reference anchor='RFC5277'>
      <front>
        <title>NETCONF Event Notifications</title>
        <author initials='S.C.' surname='Chisholm' fullname='S. Chisholm'>
          <organization>Nortel</organization>
        </author>
        <author initials='H.T.' surname='Trevino' fullname='H. Trevino'>
          <organization>Cisco</organization>
        </author>
        <date year='2008' month='July'/>
        <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
      </front>
      <seriesInfo name='RFC' value='5277'/>
    <format type="HTML" octets="96192" target="http://tools.ietf.org/html/rfc5277.html"/>
  </reference>




<reference anchor="RFC5789">

<front>
<title>PATCH Method for HTTP</title>
<author initials="L." surname="Dusseault" fullname="L. Dusseault">
<organization/></author>
<author initials="J." surname="Snell" fullname="J. Snell">
<organization/></author>
<date year="2010" month="March"/>
<abstract>
<t>Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing HTTP PUT method only allows a complete replacement of a document.  This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="5789"/>
<format type="TXT" octets="21706" target="http://www.rfc-editor.org/rfc/rfc5789.txt"/>
</reference>

<!--
<reference anchor='RFC5785'>
<front>
<title>Defining Well-Known Uniform Resource Identifiers (URIs)</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
<organization /></author>
<author initials='E.' surname='Hammer-Lahav' fullname='E. Hammer-Lahav'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>This memo defines a path prefix for "well-known locations", "/.well-known/", in selected Uniform Resource Identifier (URI) schemes. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5785' />
<format type='TXT' octets='13779' target='http://www.rfc-editor.org/rfc/rfc5785.txt' />
</reference>
-->

  <reference anchor='RFC6241'>
      <front>
        <title>Network Configuration Protocol (NETCONF)</title>
        <author initials='R.' surname='Enns' fullname='R. Enns' role="editor">
          <organization/>
        </author>
        <author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role="editor">
          <organization/>
        </author>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder' role="editor">
          <organization/>
        </author>
        <author initials='A.' surname='Bierman' fullname='A. Bierman' role="editor">
          <organization/>
        </author>
        <date year='2011' month='June'/>
      </front>
      <seriesInfo name='RFC' value='6241'/>
  </reference>


  <reference anchor="RFC6020">
    <front>
      <title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
      <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
        <organization/>
      </author>
      <date year="2010" month="October"/>
      <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
    </front>
    <seriesInfo name="RFC" value="6020"/>
    <format type="TXT" octets="324178" target="http://www.rfc-editor.org/rfc/rfc6020.txt"/>
  </reference>



<reference anchor="RFC6536">

<front>
<title>Network Configuration Protocol (NETCONF) Access Control Model</title>
<author initials="A." surname="Bierman" fullname="A. Bierman">
<organization/></author>
<author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
<organization/></author>
<date year="2012" month="March"/>
<abstract>
<t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF protocol access for particular users to a pre-configured subset of all available NETCONF protocol operations and content.  This document defines such an access control model. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="6536"/>
<format type="TXT" octets="90803" target="http://www.rfc-editor.org/rfc/rfc6536.txt"/>
</reference>

  <reference anchor="I-D.lhotka-netmod-json">
    <front>
      <title>Modeling JSON Text with YANG</title>
      <author initials="L." surname="Lhotka" fullname="L. Lhotka">
        <organization>CZ.NIC</organization>
      </author>
      <date year="2013" month="September"/>
    </front>
    <seriesInfo name="Internet-Draft"
                value="draft-lhotka-netmod-yang-json-02"/>
    <format type='TXT'
    target='http://www.ietf.org/id/draft-lhotka-netmod-yang-json-02.txt'/>
  </reference>


<reference anchor='RFC6991'>

<front>
<title>Common YANG Data Types</title>
<author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
<organization /></author>
<date year='2013' month='July' />
<abstract>
<t>This document introduces a collection of common data types to be used with the YANG data modeling language.  This document obsoletes RFC 6021.</t></abstract></front>

<seriesInfo name='RFC' value='6991' />
<format type='TXT' octets='60242' target='http://www.rfc-editor.org/rfc/rfc6991.txt' />
</reference>

<reference anchor='wd-eventsource'>

<front>
<title>Server-Sent Events</title>
<author initials='I.H.' surname='Hickson' fullname='Ian Hickson'>
<organization>Google Inc.</organization></author>
<date year='2012' month='December' />
<abstract>
<t>This specification defines an API for opening an HTTP connection for receiving push notifications from a server in the form of DOM events. The API is designed such that it can be extended to work with other push notification schemes such as Push SMS.</t></abstract></front>

<format type='HTML' octets='73384' target='http://www.w3.org/TR/eventsource/' />
</reference>


</references>
<references title="Informative References">


<reference anchor='RFC6902'>

<front>
<title>JavaScript Object Notation (JSON) Patch</title>
<author initials='P.' surname='Bryan' fullname='P. Bryan'>
<organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
<organization /></author>
<date year='2013' month='April' />
<abstract>
<t>JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document; it is suitable for use with the HTTP PATCH method.  The "application/json-patch+json" media type is used to identify such patch documents.</t></abstract></front>

<seriesInfo name='RFC' value='6902' />
<format type='TXT' octets='26405' target='http://www.rfc-editor.org/rfc/rfc6902.txt' />
</reference>

<reference anchor="XPATH" target="http://www.w3.org/TR/1999/REC-xpath-19991116">
      <front>
        <title>XML Path Language (XPath) Version 1.0</title>
        <author initials="J." surname="Clark" fullname="James Clark">
          <organization/>
        </author>
        <author initials="S." surname="DeRose" fullname="Steven DeRose">
          <organization/>
        </author>
        <date month="November" day="16" year="1999"/>
      </front>
      <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xpath-19991116"/>
      <format type="HTML" target="http://www.w3.org/TR/1999/REC-xpath-19991116"/>
</reference>

</references>
<section title="Change Log">
	<figure>
	    <artwork><![CDATA[
    -- RFC Ed.: remove this section before publication.  
	    ]]></artwork>
	</figure>
<section title="01 to 02">
<t>
 <list style="symbols">
 <t>
Added Notification Model (section 2.2)
 </t>
 <t>
Remove error-action from YANG Patch
 </t>
 <t>
Add &quot;comment&quot; and &quot;ok&quot; leafs to yang-patch-status container
 </t>
 <t>
Fixed YANG Patch JSON example syntax
 </t>
 <t>
Added stream resource type and streams container
to /restconf container
 </t>
 <t>
Removed &quot;vnd&quot; from media type definitions
 </t>
 <t>
Changed yang-patch edit list from ascending uint32 key to
an arbitrary string key and an ordered-by user list.
 </t>
 <t>
Several clarifications and corrections
 </t>
 <t>
Add YANG tree diagrams
 </t>
 <t>
Add application/yang.patch-status media type
 </t>
 <t>
Remove redundant &quot;global&#8209;errors&quot; container from
&quot;yang&#8209;patch&#8209;status&quot; container
 </t>
 <t>
Split the /restconf/datastore entry point into 2 entry
points (config and operational)
 </t>
 <t>
Remove the &quot;config&quot; parameter since it is no longer needed
after datastore is split
 </t>
 </list>
</t>
</section>
<section title="00 to 01">
<t>
 <list style="symbols">
 <t>
Removed incorrect /.well-known URI prefix.
 </t>
 <t>
Remove incorrect IANA request for well-known URI.
 </t>
 <t>
Clarified that API resource type nodes are defined in
the ietf-restconf namespace.
 </t>
 <t>
Changed CamelCase names in example-jukebox.yang to lowercase,
and updated examples.
 </t>
 <t>
Updated and corrected YANG types in ietf-restconf module.
 </t>
 </list>
</t>
</section>
<section title="YANG-API-01 to RESTCONF-00">
<t>
 <list style="symbols">
 <t>
Protocol renamed from YANG-API to RESTCONF
 </t>
 <t>
Fields are clarified.  Containers and lists are
sub-resources. All other YANG data node types are fields
within a parent resource.
 </t>
 <t>
The &apos;optional&#8209;key&apos; YANG extension has been removed.
 </t>
 <t>
The default value is returned by the server if the target resource
represents a missing data node but the server is using a default value
for the leaf.
 </t>
 <t>
The default for the &apos;depth&apos; parameter has been changed from &apos;1&apos;
to &apos;unbounded&apos;.  The depth is only limited if an integer value
for this parameter is specified by the client.
 </t>
 <t>
The default for the &apos;format&apos; parameter has been changed from
&apos;json&apos; to &apos;xml&apos;.
 </t>
 <t>
expanded introduction
 </t>
 <t>
removed transactions
 </t>
 <t>
removed capabilities
 </t>
 <t>
removed usage of Range and IfRange headers
 </t>
 <t>
simplified editing model
 </t>
 <t>
removed global protocol operations from ietf-restconf.yang
 </t>
 <t>
changed RPC operation terminology to protocol operation
 </t>
 <t>
updated JSON draft reference
 </t>
 <t>
updated IANA section
 </t>
 <t>
added YANG Patch
 </t>
 <t>
added YANG definitions to ietf-restconf.yang
 </t>
 <t>
added Kent Watsen and Rex Fernando as co-authors
 </t>
 <t>
updated YANG modules so they pass pyang --ietf checking
 </t>
 <t>
changed examples so resource URIs use the module name variant
to identify data resources
 </t>
 <t>
changed depth behavior so the entire server contents are not
returned for &quot;GET /restconf&quot;; Server will stop at new
resource type; e.g. yang.api --&gt; yang.datastore returns
the datastore as an empty node;
yang.api --&gt; yang.operation returns
the operation name as an empty node;
 </t>
 </list>
</t>
</section>
</section>
<section title="Closed Issues">
<t>
 <list style="symbols">
 <t>
Which WG should do this work? NETCONF? NETMOD?
It is not clear since RESTCONF builds on concepts and
standards from documents owned by both working groups.
 </t>
 </list>
</t>
    <t>
A: The NETCONF WG would do this work.
    </t>
<t>
 <list style="symbols">
 <t>
Should sessions be used or not?
Should &quot;reusable sessions&quot; be used? Better for auditing?
How does locking of the /restconf/config resource
work for multiple edits if a session is 1 operation?
When does the server release the lock and decide it has
been abandoned or client was disconnected?
 </t>
 </list>
</t>
    <t>
A: RESTCONF is a session-less protocol.  It could be implemented
to utilize persistent HTTP connections, but this is not required
or designed into the protocol.
    </t>
<t>
 <list style="symbols">
 <t>
Should the &quot;/restconf/modules&quot; resource within the API resource
be a separate resource, with its own timestamp?  Currently the
API timestamp is coupled to any changes to the list of loaded
modules.  Should the API resource be static and cacheable?
 </t>
 </list>
</t>
    <t>
A: all child containers are considered sub-resources.  The server
MAY support timestamps and entity IDs for data nodes.
    </t>
<t>
 <list style="symbols">
 <t>
What to do about no REMOVE operation, just DELETE?
The effect is local to the request; in a NETCONF
edit-config it is worse, since the netconf request might
create/delete/modify many nodes
 </t>
 </list>
</t>
    <t>
A: The YANG Patch operation allows remove or delete semantics.
    </t>
<t>
 <list style="symbols">
 <t>
Should every YANG data node be a data resource and every YANG RPC 
statement an operation resource? Is a YANG extension needed to
allow data modeler control of resource boundaries?
 </t>
 </list>
</t>
    <t>
A: Nested containers and lists are considered sub-resources.
Terminal nodes (leaf, leaf-list, anyxml) are considered properties
of the parent resource.
    </t>
<t>
 <list style="symbols">
 <t>
Resource creation order and other dependencies between resources
are not well identified in YANG.
YANG has leafrefs and instance-identifiers, which can be used 
to identify some order dependencies.
Are any new mechanisms needed in RESTCONF needed to identify
resource creation order and other dependency requirements?
 </t>
 </list>
</t>
    <t>
A: YANG Patch allows the client to control creation
order when multiple resources need to be edited at once.
The edit operations allow the server to order
all the descendant resources provided by the client,
for a single datastore edit target node.
    </t>
<t>
 <list style="symbols">
 <t>
Encoding of leafrefs?  Is there some additional meta-data needed?
Do leafref nodes need to be identified in responses (RFC 5988) or
is the YANG module definition sufficient to provide this meta-data?
 </t>
 </list>
</t>
    <t>
A: no special message encoding of leaf-refs is needed.
The server must understand the YANG schema no matter what
protocol or encoding is used.
    </t>
<t>
 <list style="symbols">
 <t>
What should the default algorithm be for defining data resources?
Should the default for an augment from another namespace be to
start a new resource? Top-level data node defaults as a resource OK?
 </t>
 </list>
</t>
    <t>
A: Augmented nodes do not follow different rules than other nested
YANG structures. Containers and lists start new sub-resources.
    </t>
</section>
<section title="Open Issues">
<section title="message-id">
<t>
 <list style="symbols">
 <t>
There is no &quot;message&#8209;id&quot; field in a RESTCONF message.
Is a message identifier needed?  If so, should either the &quot;Message&#8209;ID&quot;
or &quot;Content&#8209;ID&quot; header from RFC 2392 be used for this purpose?
 </t>
 </list>
</t>
</section>
<section title="select parameter">
<t>
 <list style="symbols">
 <t>
What syntax should be used for the &quot;select&quot; query parameter?
The current choices are &quot;xpath&quot; and &quot;path&#8209;expr&quot;.  Perhaps an additional
parameter to identify the select string format is needed
to allow extensibility?
 </t>
 </list>
</t>
</section>
<section title="server support verification">
<t>
 <list style="symbols">
 <t>
Are all header lines used by RESTCONF supported by common application
frameworks, such as FastCGI and WSGI?  If not, then should
query parameters be used instead, since the QUERY_STRING is
widely available to WEB applications?
 </t>
 </list>
</t>
</section>
<section title="error media type">
<t>
 <list style="symbols">
 <t>
Should the &lt;errors&gt; element returned in error responses
be a separate media type?
 </t>
 </list>
</t>
</section>
<section title="additional datastores">
<t>
 <list style="symbols">
 <t>
How should additional datastores be supported, which may be added to the
NETCONF/NETMOD framework in the future?
 </t>
 </list>
</t>
</section>
<section title="PATCH media type discovery">
<t>
 <list style="symbols">
 <t>
How does a client know which PATCH media types are supported
by the server in addition to application/yang.data and
application/yang.patch?
 </t>
 </list>
</t>
</section>
<section title="RESTCONF version">
<t>
 <list style="symbols">
 <t>
Is the /restconf/version field considered meta-data?
Should it be returned as XRD (Extensible Resource Descriptor)?
In addition or instead of the version field? Should this be
the ietf-restconf YANG module revision date, instead of the string 1.0?
 </t>
 </list>
</t>
</section>
<section title="YANG to resource mapping">
<t>
 <list style="symbols">
 <t>
Since data resources can only be YANG containers or lists,
what should be done about top-level YANG data nodes that are
not containers or lists? Are they allowed in RESTCONF?
 </t>
 <t>
Can a choice be a resource?  YANG choices are invisible
to RESTCONF at this time.
 </t>
 </list>
</t>
</section>
<section title=".well-known usage">
<t>
 <list style="symbols">
 <t>
Does RESTCONF need to Use a .well-known link relation to
to re-map API entry point?
 </t>
 </list>
</t>
    <t>
The client first discovers the server&apos;s root for the RESTCONF API.
In this example, it is &quot;/api/restconf&quot;:
    </t>
	<figure>
	    <artwork><![CDATA[
    Request
    -------
    GET /.well-known/host-meta users HTTP/1.1
    Host: example.com
    Accept: application/xrd+xml

    Response
    --------
    HTTP/1.1 200 OK
    Content-Type: application/xrd+xml
    Content-Length: nnn
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
    <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
        <Link rel='restconf' href='/api/restconf'/>
    </XRD>
	    ]]></artwork>
	</figure>
    <t>
Once discovering the RESTCONF API root, the client MUST 
prepend it to any access to a RESTCONF resource:
    </t>
	<figure>
	    <artwork><![CDATA[
    Request
    -------
    GET /api/restconf?select=version&format=json HTTP/1.1
    Host: example.com
    Accept: application/yang.api+json

    Response
    --------
    HTTP/1.1 200 OK
    Date: Mon, 23 Apr 2012 17:01:00 GMT
    Server: example-server
    Cache-Control: no-cache
    Pragma: no-cache
    Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
    Content-Type: application/yang.api+json

    { "version": "1.0" }
	    ]]></artwork>
	</figure>
</section>
<section title="_self links for HATEOAS support">
<t>
 <list style="symbols">
 <t>
Should there be a mode where the client can request that
the resource identifier is returned in a GET request?
 </t>
 </list>
</t>
</section>
<section title="netconf-state monitoring support">
<t>
 <list style="symbols">
 <t>
Should long-term RESTCONF operations (i.e. SSE long-poll)
be considered sessions wrt/ NETCONF monitoring &quot;session&quot; list?
If so, what text is needed in RESTCONF draft to standardize
the RESTCONF session entries?
 </t>
 </list>
</t>
</section>
<section title="secure transport">
<t>
 <list style="symbols">
 <t>
Details to support secure operation over TLS are needed
 </t>
 <t>
Security considerations need to be written
 </t>
 </list>
</t>
</section>
</section>
<section title="Example YANG Module">
    <t>
The example YANG module used in this document represents
a simple media jukebox interface.
    </t>
    <t>
YANG Tree Diagram for &quot;example&#8209;jukebox&quot; Module
    </t>
	<figure>
	    <artwork><![CDATA[
   +--rw jukebox?
      +--rw library
      |  +--rw artist [name]
      |  |  +--rw name     string
      |  |  +--rw album [name]
      |  |     +--rw name     string
      |  |     +--rw genre?   identityref
      |  |     +--rw year?    uint16
      |  |     +--rw song [name]
      |  |        +--rw name        string
      |  |        +--rw location    string
      |  |        +--rw format?     string
      |  |        +--rw length?     uint32
      |  +--ro artist-count?   uint32
      |  +--ro album-count?    uint32
      |  +--rw song-count?     uint32
      +--rw playlist [name]
      |  +--rw name           string
      |  +--rw description?   string
      |  +--rw song [index]
      |     +--rw index    uint32
      |     +--rw id       instance-identifier
      +--rw player
         +--rw gap?   decimal64
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
  rpcs:
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   +---x play    
      +--ro input     
         +--ro playlist       string
         +--ro song-number    uint32
	    ]]></artwork>
	</figure>
<section title="example-jukebox YANG Module" anchor="example-module">
	<figure>
	    <artwork><![CDATA[
module example-jukebox {

   namespace "http://example.com/ns/example-jukebox";
   prefix "jbox";

   organization "Example, Inc.";
   contact "support at example.com";
   description "Example Jukebox Data Model Module";
   revision "2013-10-19" {
     description "Initial version.";
     reference "example.com document 1-4673";
   }

   identity genre {
     description "Base for all genre types";
   }

   // abbreviated list of genre classifications
   identity alternative {
     base genre;
     description "Alternative music";
   }
   identity blues {
     base genre;
     description "Blues music";
   }
   identity country {
     base genre;
     description "Country music";
   }
   identity jazz {
     base genre;
     description "Jazz music";
   }
   identity pop {
     base genre;
     description "Pop music";
   }
   identity rock {
     base genre;
     description "Rock music";
   }

   container jukebox {
     presence 
       "An empty container indicates that the jukebox
        service is available";

     description
       "Represents a jukebox resource, with a library, playlists,
        and a play operation.";

     container library {

       description "Represents the jukebox library resource.";

       list artist {
         key name;

         description
           "Represents one artist resource within the 
            jukebox library resource.";

         leaf name {
           type string {
             length "1 .. max";
           }
           description "The name of the artist.";
         }

         list album {
           key name;

           description
             "Represents one album resource within one
              artist resource, within the jukebox library.";

           leaf name {
             type string {
               length "1 .. max";
             }
             description "The name of the album.";
           }

           leaf genre {
             type identityref { base genre; }
             description
               "The genre identifying the type of music on
                the album.";
           }

           leaf year {
             type uint16 {
               range "1900 .. max";
             }
             description "The year the album was released";
           }

           list song {
             key name;

             description
               "Represents one song resource within one
                album resource, within the jukebox library.";

             leaf name {
               type string {
                  length "1 .. max";
               }
               description "The name of the song";
             }
             leaf location {
               type string;
               mandatory true;
               description 
                "The file location string of the
                 media file for the song";
             }
             leaf format {
               type string;
               description
                 "An identifier string for the media type
                  for the file associated with the
                  'location' leaf for this entry.";
             }
             leaf length {
               type uint32;
               units "seconds";
               description
                 "The duration of this song in seconds.";
             }
           }   // end list 'song'
         }   // end list 'album'
       }  // end list 'artist'

       leaf artist-count {
          type uint32;
          units "songs";
          config false;
          description "Number of artists in the library";
       }
       leaf album-count {
          type uint32;
          units "albums";
          config false;
          description "Number of albums in the library";
       }
       leaf song-count {
          type uint32;
          units "songs";
          description "Number of songs in the library";
       }
     }  // end library
  
     list playlist {
       key name;

       description 
         "Example configuration data resource";

       leaf name {
         type string;
         description
           "The name of the playlist.";
       }
       leaf description {
         type string;
         description
           "A comment describing the playlist.";
       }
       list song {
         key index;
         ordered-by user;

         description 
           "Example nested configuration data resource";

         leaf index {    // not really needed
           type uint32;
           description
             "An arbitrary integer index for this
              playlist song.";
         }
         leaf id {
           type instance-identifier;
           mandatory true;
           description 
             "Song identifier. Must identify an instance of
              /jukebox/library/artist/album/song/name.";
         }
       }
     }
  
     container player {
       description
         "Represents the jukebox player resource.";

       leaf gap {
         type decimal64 {
           fraction-digits 1;
           range "0.0 .. 2.0";
         }
         units "tenths of seconds";
         description "Time gap between each song";
       }
     }
   }

   rpc play {
     description "Control function for the jukebox player";
     input {
       leaf playlist {           
         type string;
         mandatory true;
         description "playlist name";
       }
       leaf song-number {
         type uint32;
         mandatory true;
         description "Song number in playlist to play";
       }
     }
   }         
}

	    ]]></artwork>
	</figure>
</section>
</section>
</back></rfc>
