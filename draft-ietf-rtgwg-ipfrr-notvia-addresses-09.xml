<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the -->
<!-- references. -->
<!ENTITY RFC5880 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5880.xml">
<!ENTITY GRE SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1701.xml">
<!ENTITY RFC5714 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5714.xml">
<!ENTITY IPIP SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2003.xml">
<!ENTITY L2TPv3 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3931.xml">
<!ENTITY LDP SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5036.xml">
<!ENTITY BASE SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5286.xml">
<!ENTITY NNHL SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.shen-mpls-ldp-nnhop-label.xml">
<!ENTITY AAH SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-rtgwg-ordered-fib.xml">
<!ENTITY QS SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.shand-remote-lfa.xml">
<!ENTITY RFC5101 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5101.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?Xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-ietf-rtgwg-ipfrr-notvia-addresses-09"
     ipr="trust200902" updates="">
  <front>
    <title>IP Fast Reroute Using Not-via Addresses</title>

    <!-- -->

    <!-- -->

    <author fullname="Stewart Bryant" initials="S." surname="Bryant">
      <organization>Cisco Systems</organization>

      <address>
        <postal>
          <street>250, Longwater Avenue.</street>

          <city>Reading</city>

          <region>Berks</region>

          <code>RG2 6GB</code>

          <country>UK</country>
        </postal>

        <email>stbryant@cisco.com</email>
      </address>
    </author>

    <author fullname="Stefano Previdi" initials="S." surname="Previdi">
      <organization>Cisco Systems</organization>

      <address>
        <postal>
          <street>Via Del Serafico, 200</street>

          <city>00142 Rome</city>

          <region></region>

          <code></code>

          <country>Italy</country>
        </postal>

        <email>sprevidi@cisco.com</email>
      </address>
    </author>

    <author fullname="Mike Shand" initials="M." surname="Shand">
      <organization>Individual Contributor</organization>

      <address>
        <postal>
          <street></street>
        </postal>

        <email>imc.shand@googlemail.com</email>
      </address>
    </author>

    <date year="2012" />

    <!-- -->

    <abstract>
      <t>This draft describes a mechanism that provides fast reroute in an IP
      network through encapsulation to "not-via" addresses. A single level of
      encapsulation is used. The mechanism protects unicast, multicast and LDP
      traffic against link, router and shared risk group failure, regardless
      of network topology and metrics.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC2119</xref>.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>When a link or a router fails, only the neighbors of the failure are
      initially aware that the failure has occurred. In a network operating IP
      fast reroute <xref target="RFC5714"></xref>, the routers that are the
      neighbors of the failure repair the failure. These repairing routers
      have to steer packets to their destinations despite the fact that most
      other routers in the network are unaware of the nature and location of
      the failure.</t>

      <t>A common limitation in most IPFRR mechanisms is an inability to
      indicate the identity of the failure and to explicitly steer the
      repaired packet round the failure. The extent to which this limitation
      affects the repair coverage is topology dependent. The mechanism
      proposed here is to encapsulate the packet to an address that explicitly
      identifies the network component that the repair must avoid. This
      produces a repair mechanism, which, provided the network is not
      partitioned by the failure, will always achieve a repair.</t>
    </section>

    <section title="Overview of Not-via Repairs">
      <t>This section provides a brief overview of the not-via method of
      IPFRR. Consider the network fragment shown in <xref
      target="fig-repair"></xref> below, in which S has a packet for some
      destination D that it would normally send via P and B, and that S
      suspects that P has failed.</t>

      <figure anchor="fig-repair" title="Not-via repair of router failure">
        <preamble></preamble>

        <artwork><![CDATA[              A  
              |                Bp is the address to use to get  
              |                  a packet to B not-via P 
              | 
   S----------P----------B. . . . . . . . . .D 
    \         |        Bp^    
     \        |          |  
      \       |          | 
       \      C          | 
        \                | 
         X-------Y-------Z 
           Repair to Bp  
]]></artwork>

        <postamble></postamble>
      </figure>

      <t></t>

      <t></t>

      <t>In the not-via IPFRR method, S encapsulates the packet to Bp, where
      Bp is an address on node B that has the property that it is not
      reachable from node P, i.e. the notation Bp means "an address of node B
      that is only reachable not via node P. We later show how to install the
      path from S to Bp such that it is the shortest path from S to B not
      going via P. If the network contains a path from S to B that does not
      transit router P, i.e. the network is not partitioned by the failure of
      P and the path from S to Bp has been installed, then the packet will be
      successfully delivered to B. In the example we are considering this is
      the path S-X-Y-Z-B. When the packet addressed to Bp arrives at B, B
      removes the encapsulation and forwards the repaired packet towards its
      final destination.</t>

      <t>Note that if the path from B to the final destination includes one or
      more nodes that are included in the repair path, a packet MAY back track
      after the encapsulation is removed. However, because the decapsulating
      router is always closer to the packet destination than the encapsulating
      router, the packet will not loop.</t>

      <t>For complete protection, all of P's neighbors will require a not-via
      address that allows traffic to be directed to them without traversing P.
      This is shown in <xref target="fig-notvia-P"></xref>. Similarly, P will
      require a set of not-via address (one for each neighbor) allowing
      traffic to be directed to P without traversing each of those
      neighbors.</t>

      <t>The not-via addresses are advertised in the routing protocol in a way
      that clearly identifies them as not-via addresses and not 'ordinary'
      addresses.</t>

      <figure anchor="fig-notvia-P" title="The set of Not-via P Addresses  ">
        <preamble></preamble>

        <artwork><![CDATA[              A  
              |Ap  
              | 
    Sp      Pa|Pb 
   S----------P----------B 
            Ps|Pc      Bp    
              | 
            Cp| 
              C 
]]></artwork>

        <postamble></postamble>
      </figure>

      <t></t>

      <section title="Use of Equal Cost Multi-Path">
        <t></t>

        <t>A router can use an equal cost multi-path (ECMP) repair in place of
        a not-via repair.</t>

        <t>A router computing a not-via repair path MAY subject the repair to
        ECMP.</t>
      </section>

      <section title="Use of LFA repairs">
        <t></t>

        <t>The not-via approach provides complete repair coverage and
        therefore MAY be used as the sole repair mechanism. There are,
        however, advantages in using not-via in combination with loop free
        alternates (LFA) and or downstream paths as documented in <xref
        target="RFC5286"></xref>. In particular LFAs do not require the
        assignment and management of additional IP addresses to nodes, they do
        not require nodes in the network to be upgraded in order to calculate
        not-via repair paths, and they do not require the use of
        encapsulation.</t>

        <t>LFAs are computed on a per destination basis and in general, only a
        subset of the destinations requiring repair will have a suitable LFA
        repair. In this case, those destinations which are repairable by LFAs
        are so repaired and the remainder of the destinations are repaired
        using the not-via encapsulation. On the other hand, the path taken by
        an LFA repair may be less optimal than that of the equivalent not-via
        repair for traffic destined to nodes close to the far end of the
        failure, but may be more optimal for some other traffic. The
        description in this document assumes that LFAs will be used where
        available, but the distribution of repairs between the two mechanisms
        is a local implementation choice.</t>
      </section>
    </section>

    <section title="Not-via Repair Path Computation ">
      <t></t>

      <t>The not-via repair mechanism requires that all routers on the path
      from S to B (<xref target="fig-repair"></xref>) have a route to Bp. They
      can calculate this by failing node P, running a Shortest Path First
      Algorithm (SPF), and finding the shortest route to B.</t>

      <t>A router has no simple way of knowing whether it is on the shortest
      path for any particular repair. It is therefore necessary for every
      router to calculate the path it would use in the event of any possible
      router failure. Each router therefore "fails" every router in the
      network, one at a time, and calculates its own best route to each of the
      neighbors of that router. In other words, with reference to <xref
      target="fig-repair"></xref>, routers A, B, C, X, Y, Z and P will
      consider each router in turn, assume that router has failed, and then
      calculate its own route to each of the not-via addresses advertised by
      the neighbors of that router. In other words in the case of a presumed
      failure of P, ALL routers (in this case S, A, B, C, X, Y and Z)
      calculate their routes to Sp, Ap, Bp, and Cp, in each case, not via
      P.</t>

      <t>To calculate the repair paths a router has to calculate n-1 SPFs
      where n is the number of routers in the network. This is expensive to
      compute. However, the problem is amenable to a solution in which each
      router (X) proceeds as follows. X first calculates the base topology
      with all routers functional and determines its normal path to all
      not-via addresses. This can be performed as part of the normal SPF
      computation. For each router P in the topology, X then performs the
      following actions:-</t>

      <t><list style="numbers">
          <t>Removes router P from the topology.</t>

          <t>Performs an incremental SPF (iSPF) <xref target="ISPF"></xref> on
          the modified topology. The iSPF process involves detaching the
          sub-tree affected by the removal of router P, and then re-attaching
          the detached nodes. However, it is not necessary to run the iSPF to
          completion. It is sufficient to run the iSPF up to the point where
          all of the nodes advertising not-via P addresses have been
          re-attached to the SPT, and then terminate it.</t>

          <t>Reverts to the base topology.</t>
        </list>This algorithm is significantly less expensive than a set of
      full SPFs. Thus, although a router has to calculate the repair paths for
      n-1 failures, the computational effort is much less than n-1 SPFs.</t>

      <t>Experiments on a selection of real world network topologies with
      between 40 and 400 nodes suggest that the worst-case computational
      complexity using the above optimizations is equivalent to performing
      between 5 and 13 full SPFs. Further optimizations are described in
      section 6.</t>

      <section title="Computing not-via repairs in distance and path vector routing protocols">
        <t>While this document focuses on link state routing protocols, it is
        equally possible to compute not-via repairs in distance vector (e.g.
        RIP) or path vector (e.g. BGP) routing protocols. This can be achieved
        with very little protocol modification by advertising the not-via
        address in the normal way, but ensuring that the information about a
        not-via address Ps is not propagated through the node S. In the case
        of link protection this simply means that the advertisement from P to
        S is suppressed, with the result that S and all other nodes compute a
        route to Ps which doesn't traverse S, as required.</t>

        <t>In the case of node protection, where P is the protected node, and
        N is some neighbor, the advertisement of Np MUST be suppressed not
        only across the link N-&gt;P, but also across any link to P. The
        simplest way of achieving this is for P itself to perform the
        suppression of any address of the form Xp.</t>
      </section>
    </section>

    <section title="Operation of Repairs">
      <t>This section explains the basic operation of the not-via repair of
      node and link failure.</t>

      <section title="Node Failure">
        <t></t>

        <t>When router P fails (<xref target="fig-notvia-P"></xref>) S
        encapsulates any packet that it would send to B via P to Bp, and then
        sends the encapsulated packet on the shortest path to Bp. S follows
        the same procedure for routers A and C in <xref
        target="fig-notvia-P"></xref>. The packet is decapsulated at the
        repair target (A, B or C) and then forwarded normally to its
        destination. The repair target can be determined as part of the normal
        SPF by recording the "next-next-hop" for each destination in addition
        to the normal next-hop. The next-next hop is the router that the next
        hop router regards as its own next hop to the destination. In <xref
        target="fig-repair"></xref>, B is S's next next hop to D.</t>

        <t>Notice that with this technique only one level of encapsulation is
        needed, and that it is possible to repair ANY failure regardless of
        link metrics and any asymmetry that may be present in the network. The
        only exception to this is where the failure was a single point of
        failure that partitioned the network, in which case ANY repair is
        clearly impossible.</t>
      </section>

      <section title="Link Failure">
        <t>The normal mode of operation of the network would be to assume
        router failure. However, where some destinations are only reachable
        through the failed router, it is desirable that an attempt be made to
        repair to those destinations by assuming that only a link failure has
        occurred.</t>

        <t>To perform a link repair, S encapsulates to Ps (i.e. it instructs
        the network to deliver the packet to P not-via S). All of the
        neighbors of S will have calculated a path to Ps in case S itself had
        failed. S could therefore give the packet to any of its neighbors
        (except, of course, P). However, S SHOULD send the encapsulated packet
        on the shortest available path to P. This path is calculated by
        running an SPF with the link SP failed. Note that this may again be an
        incremental calculation, which can terminate when address Ps has been
        reattached.</t>

        <section anchor="LPUNFsec" title="Loop Prevention Under Node Failure">
          <t>It is necessary to consider the behavior of IPFRR solutions when
          a link repair is attempted in the presence of node failure. In its
          simplest form, the not-via IPFRR solution prevents the formation of
          loops as a result of mutual repair, by never providing a repair path
          for a not-via address. The repair of packets with not-via addresses
          is considered in more detail in <xref target="MIFsec"></xref>.
          Referring to <xref target="fig-notvia-P"></xref>, if A was the
          neighbor of P that was on the link repair path from S to P, and P
          itself had failed, the repaired packet from S would arrive at A
          encapsulated to Ps. A would have detected that the AP link had
          failed and would normally attempt to repair the packet. However, no
          repair path is provided for any not-via address, and so A would be
          forced to drop the packet, thus preventing the formation of a
          loop.</t>
        </section>
      </section>

      <section title="Multi-homed Prefixes">
        <t></t>

        <t>A multi-homed Prefix (MHP) is a prefix that is reachable via more
        than one router in the network. Some of these may be repairable using
        LFAs as described in <xref target="RFC5286"></xref>. Only those
        without such a repair need be considered here.</t>

        <t>When IPFRR router S (<xref target="fig-MHP"></xref>) discovers that
        P has failed, it needs to send packets addressed to the MHP X, which
        is normally reachable through P, to an alternate router, which is
        still able to reach X.</t>

        <figure anchor="fig-MHP" title="Multi-homed Prefixes">
          <preamble></preamble>

          <artwork><![CDATA[   X                          X                          X 
   |                          |                          | 
   |                          |                          | 
   |                Sp        |Pb                        | 
   Z...............S----------P----------B...............Y 
                            Ps|Pc      Bp    
                              | 
                            Cp| 
                              C ]]></artwork>

          <postamble></postamble>
        </figure>

        <t></t>

        <t>S SHOULD choose the closest router that can reach X during the
        failure as the alternate router. S determines which router to use as
        the alternate while running the SPF with P failed. This is
        accomplished by the normal process of re-attaching a leaf node to the
        core topology (this is sometimes known as a "partial SPF").</t>

        <t>First, consider the case where the shortest alternate path to X is
        via Z. S can reach Z without using the failed router P. However, S
        cannot just send the packet towards Z, because the other routers in
        the network will not be aware of the failure of P, and may loop the
        packet back to S. S therefore encapsulates the packet to Z (using a
        normal address for Z). When Z receives the encapsulated packet it
        removes the encapsulation and forwards the packet to X.</t>

        <t>Now consider the case where the shortest alternate path to X is via
        Y, which S reaches via P and B. To reach Y, S must first repair the
        packet to B using the normal not-via repair mechanism. To do this S
        encapsulates the packet for X to Bp. When B receives the packet it
        removes the encapsulation and discovers that the packet is intended
        for MHP X. The situation now reverts to the previous case, in which
        the shortest alternate path does not require traversal of the failure.
        B therefore follows the algorithm above and encapsulates the packet to
        Y (using a normal address for Y). Y removes the encapsulation and
        forwards the packet to X.</t>

        <t>It may be that the cost of reaching X using local delivery from the
        alternate router (i.e. Z or Y) is greater than the cost of reaching X
        via P. Under those circumstances, the alternate router would normally
        forward to X via P, which would cause the IPFRR repair to loop. To
        prevent the repair from looping the alternate router MUST locally
        deliver a packet received via a repair encapsulation. This may be
        specified by using a special address with the above semantics. Note
        that only one such address is required per node. Notice that using the
        not-via approach, only one level of encapsulation was needed to repair
        MHPs to the alternate router.</t>
      </section>

      <section title="Installation of Repair Paths ">
        <t></t>

        <t>The following algorithm is used by node S (<xref
        target="fig-MHP"></xref>) to pre- calculate and install repair paths
        in the FIB, ready for immediate use in the event of a failure. It is
        assumed that the not-via repair paths have already been calculated as
        described above.</t>

        <t>For each neighbor P, consider all destinations which are reachable
        via P in the current topology:-</t>

        <t><list style="numbers">
            <t>For all destinations with an ECMP or LFA repair (as described
            in <xref target="RFC5286"></xref>) install that repair.</t>

            <t>For each destination (DR) that remains, identify in the current
            topology the next-next-hop (H) (i.e. the neighbor of P that P will
            use to send the packet to DR). This can be determined during the
            normal SPF run by recording the additional information. If S has a
            path to the not-via address Hp (H not via P), install a not-via
            repair to Hp for the destination DR.</t>

            <t>Identify all remaining destinations (M) which can still be
            reached when node P fails. These will be multi-homed prefixes that
            are not repairable by LFA, for which the normal attachment node is
            P, or a router for which P is a single point of failure, and have
            an alternative attachment point that is reachable after P has
            failed. One way of determining these destinations would be to run
            an SPF rooted at S with node P removed, but an implementation may
            record alternative attachment points during the normal SPF run. In
            either case, the next best point of attachment can also be
            determined for use in step (4) below.</t>

            <t>For each multi-homed prefix (M) identified in step (3):-<list
                style="letters">
                <t>Identify the new attachment node (as shown in <xref
                target="fig-MHP"></xref>). This may be:-<list style="letters">
                    <t>Y, where the next hop towards Y is P, or</t>

                    <t>Z, where the next hop towards Z is not P.</t>
                  </list>If the attachment node is Z, install the repair for M
                as a tunnel to Z' (where Z' is the address of Z that is used
                to force local forwarding).</t>

                <t>For the subset of prefixes (M) that remain (having
                attachment point Y), install the repair path previously
                installed for destination Y.</t>
              </list>For each destination (DS) that remains, install a not-via
            repair to Ps (P not via S). Note, these are destinations for which
            node P is a single point of failure, and can only be repaired by
            assuming that the apparent failure of node P was simply a failure
            of the S-P link. Note that, if available, a downstream path to P
            MAY be used for such a repair. This cannot generate a persistent
            loop in the event of the failure of node P, but if one neighbor of
            P uses a not-via repair and another uses a downstream path, it is
            possible for a packet sent on the downstream path to be returned
            to the sending node inside a not-via encapsulation. Since packets
            destined to not-via addresses are not repaired, the packet will be
            dropped after executing a single turn loop.</t>
          </list></t>
      </section>
    </section>

    <section title="Compound Failures">
      <t>The following types of failures involve more than one component:</t>

      <t><list style="numbers">
          <t>Shared Risk Link Groups</t>

          <t>Local Area Networks</t>

          <t>Multiple Independent Failures</t>
        </list>The considerations that apply in each of the above situations
      are described in the following sections.</t>

      <section title="Shared Risk Link Groups">
        <t>A Shared Risk Link Group (SRLG) is a set of links whose failure can
        be caused by a single action such as a conduit cut or line card
        failure. When repairing the failure of a link that is a member of an
        SRLG, it MUST be assumed that all the other links that are also
        members of the SRLG have also failed. Consequently, any repair path
        MUST be computed to avoid not just the adjacent link, but also all the
        links which are members of the same SRLG.</t>

        <t>In <xref target="fig-SRLG1"></xref> below, the links S-P and A-B
        are both members of SRLG "a". The semantics of the not-via address Ps
        changes from simply "P not-via the link S-P" to be "P not-via the link
        S-P or any other link with which S-P shares an SRLG" In <xref
        target="fig-SRLG1"></xref> this is the links that are members of SRLG
        "a". I.e. links S-P and A-B. Since the information about SRLG
        membership of all links is available in the Link State Database, all
        nodes computing routes to the not-via address Ps can infer these
        semantics, and perform the computation by failing all the links in the
        SRLG when running the iSPF.</t>

        <t>Note that it is not necessary for S to consider repairs to any
        other nodes attached to members of the SRLG (such as B). It is
        sufficient for S to repair to the other end of the adjacent link (P in
        this case).</t>

        <figure anchor="fig-SRLG1" title="Shared Risk Link Group  ">
          <preamble></preamble>

          <artwork><![CDATA[                a   Ps  
           S----------P---------D 
           |          | 
           |    a     | 
           A----------B 
           |          | 
           |          | 
           C----------E ]]></artwork>

          <postamble></postamble>
        </figure>

        <t>In some cases, it may be that the links comprising the SRLG occur
        in series on the path from S to the destination D, as shown in <xref
        target="fig-SRLG2"></xref>. In this case, multiple consecutive repairs
        may be necessary. S will first repair to Ps, then P will repair to Dp.
        In both cases, because the links concerned are members of SRLG "a" the
        paths are computed to avoid all members of SRLG "a".</t>

        <figure anchor="fig-SRLG2"
                title="Shared Risk Link Group members in series">
          <preamble></preamble>

          <artwork><![CDATA[                a   Ps    a   Dp  
           S----------P---------D 
           |          |         | 
           |    a     |         | 
           A----------B         | 
           |          |         | 
           |          |         | 
           C----------E---------F ]]></artwork>

          <postamble></postamble>
        </figure>

        <t></t>

        <t>While the use of multiple repairs in series introduces some
        additional overhead, these semantics avoid the potential combinatorial
        explosion of not-via addresses that could otherwise occur.</t>

        <t>Note that although multiple repairs are used, only a single level
        of encapsulation is required. This is because the first repair packet
        is decapsulated before the packet is re-encapsulated using the not-
        via address corresponding to the far side of the next link which is a
        member of the same SRLG. In some cases the decapsulation and re-
        encapsulation takes place (at least notionally) at a single node,
        while in other cases, these functions may be performed by different
        nodes. This scenario is illustrated in <xref
        target="fig-SRLG3"></xref> below.</t>

        <figure anchor="fig-SRLG3"
                title="Shared Risk Link Group members in series ">
          <preamble></preamble>

          <artwork><![CDATA[                a   Ps              a  Dg  
           S----------P---------G--------D 
           |          |         |        | 
           |    a     |         |        | 
           A----------B         |        | 
           |          |         |        | 
           |          |         |        | 
           C----------E---------F--------H 
]]></artwork>

          <postamble></postamble>
        </figure>

        <t></t>

        <t>In this case, S first encapsulates to Ps, and node P decapsulates
        the packet and forwards it "native" to G using its normal FIB entry
        for destination D. G then repairs the packet to Dg.</t>

        <t>It can be shown that such multiple repairs can never form a loop
        because each repair causes the packet to move closer to its
        destination.</t>

        <t>It is often the case that a single link may be a member of multiple
        SRLGs, and those SRLGs may not be isomorphic. This is illustrated in
        <xref target="fig-SRLG4"></xref> below.</t>

        <figure anchor="fig-SRLG4" title="Multiple Shared Risk Link Groups ">
          <preamble></preamble>

          <artwork><![CDATA[                ab  Ps              a  Dg  
           S----------P---------G--------D 
           |          |         |        | 
           |    a     |         |        | 
           A----------B         |        | 
           |          |         |        | 
           |    b     |         |   b    | 
           C----------E---------F--------H 
           |          | 
           |          | 
           J----------K ]]></artwork>

          <postamble></postamble>
        </figure>

        <t>The link SP is a member of SRLGs "a" and "b". When a failure of the
        link SP is detected, it MUST be assumed that BOTH SRLGs have failed.
        Therefore the not-via path to Ps must be computed by failing all links
        which are members of SRLG "a" or SRLG "b". I.e. the semantics of Ps is
        now "P not-via any links which are members of any of the SRLGs of
        which link SP is a member". This is illustrated in <xref
        target="fig-SRLG5"></xref> below.</t>

        <figure anchor="fig-SRLG5"
                title="Topology used for repair computation for link S-P">
          <preamble></preamble>

          <artwork><![CDATA[                ab  Ps              a  Dg  
           S----/-----P---------G---/----D 
           |          |         |        | 
           |    a     |         |        | 
           A----/-----B         |        | 
           |          |         |        | 
           |    b     |         |   b    | 
           C----/-----E---------F---/----H 
           |          | 
           |          | 
           J----------K ]]></artwork>

          <postamble></postamble>
        </figure>

        <t>In this case, the repair path to Ps will be S-A-C-J-K-E-B-P. It may
        appear that there is no path to D because GD is a member of SRLG "a"
        and FH is a member of SRLG "b". This is true if BOTH SRLGs "a" and "b"
        have in fact failed, which would be an instance of multiple
        independent failures. In practice, it is likely that there is only a
        single failure, i.e. either SRLG "a" or SRLG "b" has failed, but not
        both. These two possibilities are indistinguishable from the point of
        view of the repairing router S and so it MUST repair on the assumption
        that both are unavailable. However, each link repair is considered
        independently. The repair to Ps delivers the packet to P which then
        forwards the packet to G. When the packet arrives at G, if SRLG "a"
        has failed it will be repaired around the path G-F-H-D. This is
        illustrated in <xref target="fig-SRLG6"></xref> below. If, on the
        other hand, SRLG "b" has failed, link GD will still be available. In
        this case the packet will be delivered as normal across the link
        GD.</t>

        <figure anchor="fig-SRLG6"
                title="Topology used for repair computation for link G-D  ">
          <preamble></preamble>

          <artwork><![CDATA[                ab  Ps              a  Dg  
           S----/-----P---------G---/----D 
           |          |         |        | 
           |    a     |         |        | 
           A----/-----B         |        | 
           |          |         |        | 
           |    b     |         |   b    | 
           C----------E---------F--------H 
           |          | 
           |          | 
           J----------K ]]></artwork>

          <postamble></postamble>
        </figure>

        <t></t>

        <t>If both SRLG a and SRLG b had failed, the packet would be repaired
        as far as P by S, and would be forwarded by P to G. G would
        encapsulate the packet to D using the not-via address Dg and forward
        it to F. F would recognise that the its next hop to Dg (H) was
        unreachable due to the failure of link FH (part of SRLG b) and would
        drop the packet, because packets addressed to a not-via address are
        not repaired in basic not-via IPFRR.</t>

        <t>The repair of multiple independent failures is not provided by the
        basic not-via IPFRR method described so far in this memo.</t>

        <t>A repair strategy that assumes the worst-case failure for each link
        can often result in longer repair paths than necessary. In cases where
        only a single link fails, rather than the full SRLG, this strategy may
        occasionally fail to identify a repair even though a viable repair
        path exists in the network. The use of sub-optimal repair paths is an
        inevitable consequence of this compromise approach. The failure to
        identify any repair is a serious deficiency, but is a rare occurrence
        in a robustly designed network. This problem can be addressed
        by:-<list style="numbers">
            <t>Reporting that the link in question is irreparable, so that the
            network designer can take appropriate action.</t>

            <t>Modifying the design of the network to avoid this
            possibility.</t>

            <t>Using some form of SRLG diagnostic (for example, by running BFD
            over alternate repair paths) to determine which SRLG member(s) has
            actually failed and using this information to select an
            appropriate pre-computed repair path. However, aside from the
            complexity of performing the diagnostics, this requires multiple
            not-via addresses per interface, which has poor scaling
            properties.</t>

            <t>Using the mechanism described in <xref
            target="MIFsec"></xref></t>
          </list></t>
      </section>

      <section title="Local Area Networks">
        <t>LANs are a special type of SRLG and are solved using the SRLG
        mechanisms outlined above. With all SRLGs there is a trade-off between
        the sophistication of the fault detection and the size of the SRLG.
        Protecting against link failure of the LAN link(s) is relatively
        straightforward, but as with all fast reroute mechanisms, the problem
        becomes more complex when it is desired to protect against the
        possibility of failure of the nodes attached to the LAN as well as the
        LAN itself.</t>

        <figure anchor="fig-LAN1" title="Local Area Networks ">
          <preamble></preamble>

          <artwork><![CDATA[                        +--------------Q------C 
                        |                          
                        | 
                        | 
      A--------S-------(N)-------------P------B 
                        |                            
                        |       
                        |                             
                        +--------------R------D ]]></artwork>

          <postamble></postamble>
        </figure>

        <t></t>

        <t>Consider the LAN shown in <xref target="fig-LAN1"></xref>. For
        connectivity purposes, we consider that the LAN is represented by the
        pseudonode (N). To provide IPFRR protection, S MUST run a connectivity
        check to each of its protected LAN adjacencies P, Q, and R, using, for
        example BFD <xref target="RFC5880"></xref>.</t>

        <t>When S discovers that it has lost connectivity to P, it is unsure
        whether the failure is:</t>

        <t><list style="symbols">
            <t>its own interface to the LAN,</t>

            <t>the LAN itself,</t>

            <t>the LAN interface of P,</t>

            <t>the node P.</t>
          </list></t>

        <section title="Simple LAN Repair">
          <t>A simple approach to LAN repair is to consider the LAN and all of
          its connected routers as a single SRLG. Thus, the address P not via
          the LAN (Pl) would require P to be reached not-via any router
          connected to the LAN. This is shown in <xref
          target="fig-LAN2"></xref>.</t>

          <figure anchor="fig-LAN2" title="Local Area Networks - LAN SRLG">
            <preamble></preamble>

            <artwork><![CDATA[                                    Ql       Cl 
                        +-------------Q--------C 
                        |              Qc 
                        | 
       As       Sl      |           Pl       Bl 
      A--------S-------(N)------------P--------B 
             Sa         |              Pb      
                        |       
                        |           Rl       Dl  
                        +-------------R--------D 
                                       Rd   
  ]]></artwork>

            <postamble></postamble>
          </figure>

          <t></t>

          <t>In this case, when S detected that P had failed it would send
          traffic reached via P and B to B not-via the LAN or any router
          attached to the LAN (i.e. to Bl). Any destination only reachable
          through P would be addressed to P not-via the LAN or any router
          attached to the LAN (except of course P).</t>

          <t>Whilst this approach is simple, it assumes that a large portion
          of the network adjacent to the failure has also failed. This will
          result in the use of sub-optimal repair paths and in some cases the
          inability to identify a viable repair.</t>

          <t></t>
        </section>

        <section title="LAN Component Repair">
          <t></t>

          <t>In this approach, possible failures are considered at a finer
          granularity, but without the use of diagnostics to identify the
          specific component that has failed. Because S is unable to diagnose
          the failure it MUST repair traffic sent through P and B, to B not-
          via P,N (i.e. not via P and not via N), on the conservative
          assumption that both the entire LAN and P have failed. Destinations
          for which P is a single point of failure MUST as usual be sent to P
          using an address that avoids the interface by which P is reached
          from S, i.e. to P not-via N. Similarly for routers Q and R.</t>

          <t>Notice that each router that is connected to a LAN MUST, as
          usual, advertise one not-via address for each neighbor. In addition,
          each router on the LAN MUST advertise an extra address not via the
          pseudonode (N).</t>

          <t>Notice also that each neighbor of a router connected to a LAN
          MUST advertise two not-via addresses, the usual one not via the
          neighbor and an additional one, not via either the neighbor or the
          pseudonode. The required set of LAN address assignments is shown in
          <xref target="fig-LAN3"></xref> below. Each router on the LAN, and
          each of its neighbors, is advertising exactly one address more than
          it would otherwise have advertised if this degree of connectivity
          had been achieved using point-to-point links.</t>

          <figure anchor="fig-LAN3" title="Local Area Networks">
            <preamble></preamble>

            <artwork><![CDATA[                                  Qs Qp Qc    Cqn 
                        +--------------Q---------C 
                        |         Qr Qn        Cq  
                        | 
       Asn   Sa Sp Sq   |         Ps Pq Pb    Bpn 
      A--------S-------(N)-------------P---------B        
       As       Sr Sn   |         Pr Pn        Bp 
                        |       
                        |         Rs Rp Pd    Drn   
                        +--------------R---------D 
                                  Rq Rn        Dr ]]></artwork>

            <postamble></postamble>
          </figure>
        </section>

        <section title="LAN Repair Using Diagnostics ">
          <t>A more specific LAN repair can be undertaken by using
          diagnostics. In order to explicitly diagnose the failed network
          component, S correlates the connectivity reports from P and one or
          more of the other routers on the LAN, in this case, Q and R. If it
          lost connectivity to P alone, it could deduce that the LAN was still
          functioning and that the fault lay with either P, or the interface
          connecting P to the LAN. It would then repair to B not via P (and P
          not-via N for destinations for which P is a single point of failure)
          in the usual way. If S lost connectivity to more than one router on
          the LAN, it could conclude that the fault lay only with the LAN, and
          could repair to P, Q and R not-via N, again in the usual way.</t>
        </section>
      </section>

      <section anchor="MIFsec" title="Multiple Independent Failures ">
        <t anchor="MIF">IPFRR repair of multiple simultaneous failures which
        are not members of a known SRLG is complicated by the problem that the
        use of multiple concurrent repairs may result in looping repair paths.
        As described in <xref target="LPUNFsec"> </xref>, the simplest method
        of preventing such loops, is to ensure that packets addressed to a
        not-via address are not repaired but instead are dropped. It is
        possible that a network may experience multiple simultaneous failures.
        This may be due to simple statistical effects, but the more likely
        cause is unanticipated SRLGs. When multiple failures which are not
        part of an anticipated group are detected, repairs are abandoned and
        the network reverts to normal convergence. Although safe, this
        approach is somewhat draconian, since there are many circumstances
        were multiple repairs do not induce loops.</t>

        <t>This section describes the properties of multiple unrelated
        failures and proposes some methods that may be used to address this
        problem.</t>

        <section title="Looping Repairs">
          <t>Let us assume that the repair mechanism is based on solely on
          not-via repairs. LFA or downstream routes MAY be incorporated, and
          will be dealt with later.</t>

          <figure anchor="GenMF" title="The General Case of Multiple Failures">
            <preamble></preamble>

            <artwork><![CDATA[           A------//------B------------D
          /                \
         /                  \
        F                    G
         \                  /                 
          \                /
           X------//------Y



]]></artwork>
          </figure>

          <t></t>

          <t>The essential case is as illustrated in <xref
          target="GenMF"></xref>. Note that depending on the repair case under
          consideration, there may be paths present in <xref
          target="GenMF"></xref>, that are in addition to those shown in the
          figure. For example there may be paths between A and B, and/or
          between X and Y. These paths are omitted for graphical clarity.</t>

          <t>There are three cases to consider:</t>

          <t><list counter="">
              <t>1) Consider the general case of a pair of protected links A-B
              and X-Y as shown in the network fragment shown <xref
              target="GenMF"></xref>. If the repair path for A-B does not
              traverse X-Y and the repair path for X-Y does not traverse A-B,
              this case is completely safe and will not cause looping or
              packet loss.</t>

              <t>A more common variation of this case is shown in <xref
              target="ConCatMF"></xref>, which shows two failures in different
              parts of the network in which a packet from A to D traverses two
              concatenated repairs.</t>

              <t></t>

              <t><figure anchor="ConCatMF" title="Concatenated Repairs">
                  <preamble></preamble>

                  <artwork><![CDATA[    A------//------B------------X------//------Y------D
    |              |            |              |
    |              |            |              |
    M--------------+            N--------------+

]]></artwork>
                </figure></t>

              <t></t>

              <t>2) In <xref target="GenMF"></xref>, the repair for A-B
              traverses X-Y, but the repair for X-Y does not traverse A-B.
              This case occurs when the not-via path from A to B traverses
              link X-Y, but the not-via path from X to Y traverses some path
              not shown in <xref target="GenMF"></xref>. Without the
              multi-failure mechanism described in this section the repaired
              packet for A-B would be dropped when it reached X-Y, since the
              repair of repaired packets would be forbidden. However, if this
              packet were allowed to be repaired, the path to D would be
              complete and no harm would be done, although two levels of
              encapsulation would be required.</t>

              <t>3) The repair for A-B traverses X-Y AND the repair for X-Y
              traverses A-B. In this case unrestricted repair would result in
              looping packets and increasing levels of encapsulation.</t>
            </list> The challenge in applying IPFRR to a network that is
          undergoing multiple failures is, therefore, to identify which of
          these cases exist in the network and react accordingly.</t>
        </section>

        <section title="Outline Solution">
          <t>When A is computing the not-via repair path for A-B (i.e. the
          path for packets addressed to Ba, read as "B not-via A") it is aware
          of the list of nodes which this path traverses. This can be recorded
          by a simple addition to the SPF process, and the not-via addresses
          associated with each forward link can be determined. If the path
          were A, F, X, Y, G, B, (<xref target="GenMF"></xref>) the list of
          not-via addresses would be: Fa, Xf, Yx, Gy, Bg. Under standard
          not-via operation, A would populate its FIB such that all normal
          addresses normally reachable via A-B would be encapsulated to Ba
          when A-B fails, but traffic addressed to any not-via address
          arriving at A would be dropped. The new procedure modifies this such
          that any traffic for a not-via address normally reachable over A-B
          is also encapsulated to Ba unless the not-via address is one of
          those previously identified as being on the path to Ba, for example
          Yx, in which case the packet is dropped.</t>

          <t>The above procedure allows cases 1 and 2 above to be repaired,
          while preventing the loop which would result from case 3.</t>

          <t>Note that this is accomplished by pre-computing the required FIB
          entries, and does not require any detailed packet inspection. The
          same result could be achieved by checking for multiple levels of
          encapsulation and dropping any attempt to triple encapsulate.
          However, this would require more detailed inspection of the packet,
          and causes difficulties when more than 2 &ldquo;simultaneous&rdquo;
          failures are contemplated.</t>

          <t>So far we have permitted benign repairs to coexist, albeit
          sometimes requiring multiple encapsulation. Note that in many cases
          there will be no performance impact since unless both failures are
          on the same node, the two encapsulations or two decapsulations will
          be performed at different nodes. There is however the issue of the
          MTU impact of multiple encapsulations.</t>

          <t>In the following sub-section we consider the various strategies
          that may be applied to case 3 - mutual repairs that would loop.</t>
        </section>

        <section title="Looping Repairs">
          <t>In case 3, the simplest approach is to simply not install repairs
          for repair paths that might loop. In this case, although the
          potentially looping traffic is dropped, the traffic is not repaired.
          If we assume that a hold-down is applied before reconvergence in
          case the link failure was just a short glitch, and if a loop free
          convergence mechanism further delays convergence, then the traffic
          will be dropped for an extended period. In these circumstances it
          would be better to &ldquo;abandon all hope&rdquo; (AAH) <xref
          target="I-D.ietf-rtgwg-ordered-fib"></xref> (Appendix A) and
          immediately invoke normal re-convergence.</t>

          <t>Note that it is not sufficient to expedite the issuance of an LSP
          reporting the failure, since this may be treated as a permitted
          simultaneous failure by the ordered FIB (oFIB) algorithm <xref
          target="I-D.ietf-rtgwg-ordered-fib"></xref>. It is therefore
          necessary to explicitly trigger an oFIB AAH.</t>

          <section title="Dropping Looping Packets">
            <t>One approach to case 3 is to allow the repair, and to
            experimentally discover the incompatibility of the repairs if and
            when they occur. With this method we permit the repair in case 3
            and trigger AAH when a packet drop count on the not-via address
            has been incremented. Alternatively, it is possible to wait until
            the LSP describing the change is issued normally (i.e. when X
            announces the failure of X-Y). When the repairing node A, which
            has precomputed that X-Y failures are mutually incompatible with
            its own repairs receives this LSP it can then issue the AAH. This
            has the disadvantage that it does not overcome the hold-down
            delay, but it requires no &ldquo;data-driven&rdquo; operation, and
            it still has the required effect of abandoning the oFIB which is
            probably the longer of the delays (although with signalled oFIB
            this should be sub-second).</t>

            <t>Whilst both of the experimental approaches described above are
            feasible, they tend to induce AAH in the presence of otherwise
            feasible repairs, and they are contrary to the philosophy of
            repair pre-determination that has been applied to existing IPFRR
            solutions.</t>
          </section>

          <section title="Computing non-looping Repairs of Repairs">
            <t>An alternative approach to simply dropping the looping packets,
            or to detecting the loop after it has occurred, is to use
            secondary SRLGs. With a link state routing protocol it is possible
            to precompute the incompatibility of the repairs in advance and to
            compute an alternative SRLG repair path. Although this does
            considerably increase the computational complexity it may be
            possible to compute repair paths that avoid the need to simply
            drop the offending packets.</t>

            <t>This approach requires us to identify the mutually incompatible
            failures, and advertise them as &ldquo;secondary SRLGs&rdquo;.
            When computing the repair paths for the affected not-via addresses
            these links are simultaneously failed. Note that the assumed
            simultaneous failure and resulting repair path only applies to the
            repair path computed for the conflicting not-via addresses, and is
            not used for normal addresses. This implies that although there
            will be a longer repair path when there is more than one failure,
            if there is a single failure the repair path length will be
            "normal".</t>

            <t>Ideally we would wish to only invoke secondary SRLG computation
            when we are sure that the repair paths are mutually incompatible.
            Consider the case of node A in <xref target="GenMF"></xref>. A
            first identifies that the repair path for A-B is via F-X-Y-G-B. It
            then explores this path determining the repair path for each link
            in the path. Thus, for example, it performs a check at X by
            running an SPF rooted at X with the X-Y link removed to determine
            whether A-B is indeed on X's repair path for packets addressed to
            Yx.</t>

            <t>Some optimizations are possible in this calculation, which
            appears at first sight to be order hk (where h is the average hop
            length of repair paths and k is the average number of neighbours
            of a router). When A is computing its set of repair paths, it does
            so for all its k neighbours. In each case it identifies a list of
            node pairs traversed by each repair. These lists may often have
            one or more node pairs in common, so the actual number of link
            failures which require investigation is the union of these sets.
            It is then necessary to run an SPF rooted at the first node of
            each pair (the first node because the pairings are ordered
            representing the direction of the path), with the link to the
            second node removed. This SPF, while not an incremental, can be
            terminated as soon as the not-via address is reached. For example,
            when running the SPF rooted at X, with the link X-Y removed, the
            SPF can be terminated when Yx is reached. Once the path has been
            found, the path is checked to determine if it traverses any of
            A&rsquo;s links in the direction away from A. Note that, because
            the node pair XY may exist in the list for more than one of
            A&rsquo;s links (i.e. it lies on more than one repair path), it is
            necessary to identify the correct list, and hence link which has a
            mutually looping repair path. That link of A is then advertised by
            A as a secondary SRLG paired with the link X-Y. Also note that X
            will be running this algorithm as well, and will identify that XY
            is paired with A-B and so advertise it. This could perhaps be used
            as a further check.</t>

            <t>The ordering of the pairs in the lists is important. i.e. X-Y
            and Y-X are dealt with separately. If and only if the repairs are
            mutually incompatible, we need to advertise the pair of links as a
            secondary SRLG, and then ALL nodes compute repair paths around
            both failures using an additional not-via address with the
            semantics not-via A-B AND not-via X-Y.</t>

            <t>A further possibility is that because we are going to the
            trouble of advertising these SRLG sets, we could also advertise
            the new repair path and only get the nodes on that path to perform
            the necessary computation. Note also that once we have reached
            Q-space <xref target="AppA"></xref> with respect to the two
            failures we need no longer continue the computation, so we only
            need to notify the nodes on the path that are not in Q-space.</t>

            <t>One cause of mutually looping repair paths is the existence of
            nodes with only two links, or sections of the network which are
            only bi-connected. In these cases, repair is clearly impossible
            &ndash; the failure of both links partitions the network. It would
            be advantageous to be able to identify these cases, and inhibit
            the fruitless advertisement of the secondary SRLG information.
            This could be achieved by the node detecting the requirement for a
            secondary SRLG, first running the not-via computation with both
            links removed. If this does not result in a path, it is clear that
            the network would be partitioned by such a failure, and so no
            advertisement is required.</t>
          </section>
        </section>

        <section title="Mixing LFAs and Not-via">
          <t>So far in this section we have assumed that all repairs use
          not-via tunnels. However, in practise we may wish to use LFAs or
          downstream routes where available. This complicates the issue,
          because their use results in packets which are being repaired, but
          NOT addressed to not-via addresses. If BOTH links are using
          downstream routes there is no possibility of looping, since it is
          impossible to have a pair of nodes which are both downstream of each
          other <xref target="RFC5286"></xref>.</t>

          <t>Loops can however occur when LFAs are used. An obvious example is
          the well known node repair problem with LFAs <xref
          target="RFC5286"></xref>. If one link is using a downstream route,
          while the other is using a not-via tunnel, the potential mechanism
          described above would work provided it were possible to determine
          the nodes on the path of the downstream route. Some methods of
          computing downstream routes do not provide this path information. If
          the path information is however available, the link using a
          downstream route will have a discard FIB entry for the not-via
          address of the other link. The consequence is that potentially
          looping packets will be discarded when they attempt to cross this
          link.</t>

          <t>In the case where the mutual repairs are both using not-via
          repairs, the loop will be broken when the packet arrives at the
          second failure. However packets are unconditionally repaired by
          means of a downstream routes, and thus when the mutual pair consists
          of a downstream route and a not-via repair, the looping packet will
          only be dropped when it gets back to the first failure. i.e. it will
          execute a single turn of the loop before being dropped.</t>

          <t>There is a further complication with downstream routes, since
          although the path may be computed to the far side of the failure,
          the packet may &ldquo;peel off&rdquo; to its destination before
          reaching the far side of the failure. In this case it may traverse
          some other link which has failed and was not accounted for on the
          computed path. If the A-B repair (<xref target="GenMF"></xref>) is a
          downstream route and the X-Y repair is a not-via repair, we can have
          the situation where the X-Y repair packets encapsulated to Yx follow
          a path which attempts to traverse A-B. If the A-B repair path for
          &ldquo;normal&rdquo; addresses is a downstream route, it cannot be
          assumed that the repair path for packets addressed to Yx can be sent
          to the same neighbour. This is because the validity of a downstream
          route MUST be ascertained in the topology represented by Yx, i.e.
          that with the link X-Y failed. This is not the same topology that
          was used for the normal downstream calculation, and use of the
          normal downstream route for the encapsulated packets may result in
          an undetected loop. If it is computationally feasible to check the
          downstream route in this topology (i.e. for any not-via address Qp
          which traverses A-B we MUST perform the downstream calculation for
          that not-via address in the topology with link Q-P failed.), then
          the downstream repair for Yx can safely be used. These packets
          cannot re-visit X-Y, since by definition they will avoid that link.
          Alternatively, the packet could be always repaired in a not-via
          tunnel. i.e. even though the normal repair for traffic traversing
          A-B would be to use a downstream route, we could insist that such
          traffic addressed to a not-via address MUST use a tunnel to Ba. Such
          a tunnel would only be installed for an address Qp if it were
          established that it did not traverse Q-P (using the rules described
          above).</t>
        </section>
      </section>
    </section>

    <section anchor="Sec6" title="Optimizing not-via computations using LFAs">
      <t>If repairing node S has an LFA to the repair endpoint it is not
      necessary for any router to perform the incremental SPF with the link SP
      removed in order to compute the route to the not-via address Ps. This is
      because the correct routes will already have been computed as a result
      of the SPF on the base topology. Node S can signal this condition to all
      other routers by including a bit in its LSP or LSA associated with each
      LFA protected link. Routers computing not-via routes can then omit the
      running of the iSPF for links with this bit set.</t>

      <t>When running the iSPF for a particular link AB, the calculating
      router first checks whether the link AB is present in the existing SPT.
      If the link is not present in the SPT, no further work is required. This
      check is a normal part of the iSPF computation.</t>

      <t>If the link is present in the SPT, this optimization introduces a
      further check to determine whether the link is marked as protected by an
      LFA in the direction in which the link appears in the SPT. If so the
      iSPF need not be performed. For example, if the link appears in the SPT
      in the direction A-&gt;B and A has indicated that the link AB is
      protected by an LFA no further action is required for this link.</t>

      <t>If the receipt of this information is delayed, the correct operation
      of the protocol is not compromised provided that the necessity to
      perform a not-via computation is re-evaluated whenever new information
      arrives.</t>

      <t>This optimization is not particularly beneficial to nodes close to
      the repair since, as has been observed above, the computation for nodes
      on the LFA path is trivial. However, for nodes upstream of the link SP
      for which S-P is in the path to P, there is a significant reduction in
      the computation required.</t>
    </section>

    <section title="Multicast">
      <t>Multicast traffic can be repaired in a similar way to unicast. The
      multicast forwarder is able to use the not-via address to which the
      multicast packet was addressed as an indication of the expected receive
      interface and hence to correctly run the required RPF check.</t>

      <t>In some cases, all the destinations, including the repair endpoint,
      are repairable by an LFA. In this case, all unicast traffic may be
      repaired without encapsulation. Multicast traffic still requires
      encapsulation, but for the nodes on the LFA repair path the computation
      of the not-via forwarding entry is unnecessary since, by definition,
      their normal path to the repair endpoint is not via the failure.</t>

      <t>A more complete description of multicast operation is for further
      study.</t>
    </section>

    <section title="Fast Reroute in an MPLS LDP Network.  ">
      <t>Not-via addresses are IP addresses and LDP <xref
      target="RFC5036"></xref> will distribute labels for them in the usual
      way. The not-via repair mechanism may therefore be used to provide fast
      re-route in an MPLS network by first pushing the label which the repair
      endpoint uses to forward the packet, and then pushing the label
      corresponding to the not-via address needed to effect the repair.
      Referring once again to <xref target="fig-repair"></xref>, if S has a
      packet destined for D that it must reach via P and B, S first pushes B's
      label for D. S then pushes the label that its next hop to Bp needs to
      reach Bp.</t>

      <t>Note that in an MPLS LDP network it is necessary for S to have the
      repair endpoint's label for the destination. When S is effecting a link
      repair it already has this. In the case of a node repair, S either needs
      to set up a directed LDP session with each of its neighbor's neighbors,
      or it needs to use a method similar to the next-next hop label
      distribution mechanism proposed in <xref
      target="I-D.shen-mpls-ldp-nnhop-label"></xref>.</t>
    </section>

    <section title="Encapsulation">
      <t>Any IETF specified IP in IP encapsulation may be used to carry a
      not-via repair. IP in IP <xref target="RFC2003"></xref>, GRE <xref
      target="RFC1701"></xref> and L2TPv3 <xref target="RFC3931"></xref>, all
      have the necessary and sufficient properties. The requirement is that
      both the encapsulating router and the router to which the encapsulated
      packet is addressed have a common ability to process the chosen
      encapsulation type. When an MPLS LDP network is being protected, the
      encapsulation would normally be an additional MPLS label. In an MPLS
      enabled IP network an MPLS label may be used in place of an IP in IP
      encapsulation in the case above.</t>
    </section>

    <section title="Routing Extensions">
      <t>IPFRR requires routing protocol extensions. Each IPFRR router that is
      directly connected to a protected network component MUST advertise a
      not-via address for that component. This MUST be advertised in such a
      way that the association between the protected component (link, router
      or SRLG) and the not-via address can be determined by the other routers
      in the network.</t>

      <t>It is necessary that not-via capable routers advertise in the IGP
      that they will calculate not-via routes.</t>

      <t>It is necessary for routers to advertise the type of encapsulation
      that they support (MPLS, GRE, L2TPv3 etc). However, the deployment of
      mixed IP encapsulation types within a network is discouraged.</t>

      <t>If the optimization proposed in <xref target="Sec6"></xref> is to be
      used the use of the LFA in place of the not-via repair MUST also be
      signalled in the routing protocol.</t>
    </section>

    <section title="Incremental Deployment">
      <t>Incremental deployment is supported by excluding routers that are not
      calculating not-via routes (as indicated by their capability information
      flooded with their link state information) from the base topology used
      for the computation of repair paths. In that way repairs may be steered
      around islands of routers that are not IPFRR capable. Routers that are
      protecting a network component need to have the capability to
      encapsulate and decapsulate packets. However, routers that are on the
      repair path only need to be capable of calculating not-via paths and
      including the not-via addresses in their FIB i.e. these routers do not
      need any changes to their forwarding mechanism.</t>

      <t></t>
    </section>

    <section title="Manageability Considerations">
      <t><xref target="RFC5714"></xref> outlines the general set of
      manageability consideration that apply to the general case of IPFRR. We
      slightly expand this and add details that are not-via specific. There
      are three classes manageability consideration:</t>

      <t><list style="numbers">
          <t>Pre-failure configuration</t>

          <t>Pre-failure Monitoring and operational support</t>

          <t>Failure action verification</t>
        </list></t>

      <section title="Pre-failure configuration">
        <t>Pre-failure configuration for not-via includes:</t>

        <t><list style="symbols">
            <t>Enabling/disabling not-via IPFRR support.</t>

            <t>Enabling/disabling protection on a per-link or per-node
            basis.</t>

            <t>Expressing preferences regarding the links/nodes used for
            repair paths.</t>

            <t>Configuration of failure detection mechanisms.</t>

            <t>Setting a preference concerning the use of LFA.</t>

            <t>Configuring not-via address (per interface), or not-via address
            set (per node).</t>

            <t>Configuring any SRLG rules or preferences.</t>
          </list>Any standard configuration method may be used and the
        selection of the method to be used is outside the scope of this
        document.</t>
      </section>

      <section title="Pre-failure Monitoring and operational support">
        <t>Pre-failure Monitoring and operational support for not-via
        includes:</t>

        <t><list style="symbols">
            <t>Notification of links/nodes/destinations that cannot be
            protected.</t>

            <t>Notification of pre-computed repair paths.</t>

            <t>Notification of repair type to be used (LFA or not-via).</t>

            <t>Notification of not-via address assignment.</t>

            <t>Notification of path or address optimizations used.</t>

            <t>Testing repair paths. Note that not-via addresses look
            identical to "ordinary" addresses as far as tools such as trace
            route and ping are concerned and thus it is anticipated that these
            will be used to verify the established repair path.</t>
          </list></t>

        <t>Any standard IETF method may be used for the above and the
        selection of the method to be used is outside the scope of this
        document.</t>
      </section>

      <section title="Failure action monitoring ">
        <t>Failure action monitoring for not-via includes:</t>

        <t><list style="symbols">
            <t>Counts of failure detections, protection invocations, and
            packets forwarded over repair paths.</t>

            <t>Logging of the events using a sufficiently accurate and precise
            timestamp.</t>

            <t>Validation that the packet loss was within specification using
            a suitable loss verification tool.</t>

            <t>Capture of the in-flight repair packet flows using a tool such
            as IPFIX<xref target="RFC5101"></xref>.</t>
          </list>Note that monitoring the repair in action requires the
        capture of the signatures of a short, possibly sub-second network
        transient which is not a well developed IETF technology.</t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>There are no IANA considerations that arise from this draft.</t>
    </section>

    <section title="Security Considerations">
      <t>The repair endpoints present vulnerability in that they might be used
      as a method of disguising the delivery of a packet to a point in the
      network. The primary method of protection SHOULD be through the use of a
      private address space for the not-via addresses. These addresses MUST
      NOT be advertised outside the area, and SHOULD be filtered at the
      network entry points. In addition, a mechanism might be developed that
      allowed the use of the mild security available through the use of a key
      <xref target="RFC1701"></xref> <xref target="RFC3931"></xref>. With the
      deployment of such mechanisms, the repair endpoints would not increase
      the security risk beyond that of existing IP tunnel mechanisms. An
      attacker may attempt to overload a router by addressing an excessive
      traffic load to the de-capsulation endpoint. Typically, routers take a
      50% performance penalty in decapsulating a packet. The attacker could
      not be certain that the router would be impacted, and the extremely high
      volume of traffic needed, would easily be detected as an anomaly. If an
      attacker were able to influence the availability of a link, they could
      cause the network to invoke the not-via repair mechanism. A network
      protected by not-via IPFRR is less vulnerable to such an attack than a
      network that undertook a full convergence in response to a link up/down
      event.</t>

      <t></t>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to acknowledge contributions made by Alia
      Atlas and John Harper.</t>
    </section>

    <!-- -->
  </middle>

  <back>
    <!-- -->

    <references title="Normative References">
      &RFC2119;
    </references>

    <references title="Informative References">
      &RFC5880;

      &RFC5101;

      &GRE;

      &RFC5714;

      &IPIP;

      &L2TPv3;

      &LDP;

      &BASE;

      &NNHL;

      &AAH;

      &QS;

      <reference anchor="ISPF">
        <front>
          <title>ARPANET Routing Algorithm Improvements"</title>

          <author initials="J." surname="McQuillan">
            <organization abbrev="BBN">BBN</organization>
          </author>

          <author initials="I." surname="Richer">
            <organization abbrev="BBN">BBN</organization>
          </author>

          <author initials="E." surname="Rosen">
            <organization abbrev="BBN">BBN</organization>
          </author>

          <date year="1978" />
        </front>

        <seriesInfo name="BBN Technical Report" value="3803" />
      </reference>
    </references>

    <section anchor="AppA" title="Q-Space">
      <t>Q-space is the set of routers from which a specific router can be
      reached without any path (including equal cost path splits) transiting
      the protected link (or node). It is fully described in <xref
      target="I-D.shand-remote-lfa"></xref>.</t>

      <figure anchor="QspaceFig">
        <preamble></preamble>

        <artwork><![CDATA[
             S---E
            /     \
           A       D
            \     /
             B---C
]]></artwork>

        <postamble></postamble>
      </figure>

      <t></t>

      <t>Consider a repair of link S-E (<xref target="QspaceFig"></xref>). The
      set of routers from which the node E can be reached, by normal
      forwarding, without traversing the link S-E is termed the Q-space of E
      with respect to the link S-E. The Q-space can be obtained by computing a
      reverse shortest path tree (rSPT) rooted at E, with the sub-tree which
      traverses the failed link excised (including those which are members of
      an ECMP). The rSPT uses the cost towards the root rather than from it
      and yields the best paths towards the root from other nodes in the
      network. In the case of <xref target="QspaceFig"></xref> the Q-space
      comprises nodes C and D only.</t>

      <t></t>
    </section>
  </back>
</rfc>
