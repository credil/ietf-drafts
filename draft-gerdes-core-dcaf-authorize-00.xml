<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY SELF "[RFC-XXXX]">
]>

<rfc ipr="trust200902" docName="draft-gerdes-core-dcaf-authorize-00" category="std">

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

  <front>
    <title abbrev="DCAF">Delegated CoAP Authorization Function (DCAF)</title>

    <author initials="S." surname="Gerdes" fullname="Stefanie Gerdes">
      <organization>Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63906</phone>
        
        <email>gerdes@tzi.org</email>
        
      </address>
    </author>
    <author initials="O." surname="Bergmann" fullname="Olaf Bergmann">
      <organization>Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63904</phone>
        
        <email>bergmann@tzi.org</email>
        
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        
        <email>cabo@tzi.org</email>
        
      </address>
    </author>

    <date year="2013" month="July" day="15"/>

    <area>Applications</area>
    <workgroup>CoRE Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a protocol for delegating client
authentication and authorization in a constrained environment for
establishing a Datagram Transport Layer Security (DTLS) channel between resource-constrained nodes.
The protocol relies on DTLS to
transfer authorization information and shared secrets for symmetric
cryptography between entities in a constrained network. A
resource-constrained node can use this protocol to delegate
authentication of communication peers and management of authorization
information to a trusted host with less limitations regarding
processing power and memory.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The Constrained Application Protocol (CoAP) <xref target="I-D.ietf-core-coap"/> is
a transfer protocol similar to HTTP which is designed for the special
requirements of constrained environments. A serious problem with
constrained devices is the realization of secure communication. The
devices only have limited resources such as memory, disk space and
transmission capacity and often lack input/output devices such as
keyboards or displays. Therefore, they are not readily capable of
using common protocols. Especially authentication mechanisms are
difficult to realize, because the lack of disk space severely limits
the number of keys the system can store. Moverover, although CoAP
provides for a simple authorization mechanism, it has no means to
distinguish access rights for different clients.</t>

<t>The DCAF architecture is designed to relieve the constrained nodes
from managing keys for numerous devices by introducing authorization
servers which conduct the authentication and authorization for their
nodes. To achieve this, authorization tickets are used. A device which
wants to access a constrained node’s resource first has to gain
permission in the form of a ticket from the node’s authorization
server. </t>

<t>The main goals of DCAF are the setup of a Datagram Transport Layer
Security (DTLS) <xref target="RFC6347"/> channel with symmetric pre-shared keys (PSK)
<xref target="RFC4279"/> and
to securely transmit authorization tickets.</t>

<section anchor="features" title="Features">

<t><list style='symbols'>
  <t>Providing means for DTLS communication with pre-shared keys.</t>
  <t>Authenticated exchange of authorization information.</t>
  <t>Using only symmetric encryption on constrained nodes.</t>
</list></t>

<!-- Kerberos: RFC4120: -->

</section>
<section anchor="terminology" title="Terminology">

<!-- In this document, the key words "MUST", "MUST NOT", "REQUIRED", -->
<!-- "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", -->
<!-- and "OPTIONAL" are to be interpreted as described in BCP 14, RFC 2119 -->
<!-- {{RFC2119}}. -->

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<section anchor="roles" title="Roles">

<t>Authorization Server (AS): The device which conducts authentication and authorization for a constrained device. An Authorization Server can be responsible for a single or multiple devices or even for a whole network. A constrained device can have multiple Authorization Servers.</t>

<t>Resource Server (RS): The constrained device which hosts resources the Client wants to access.</t>

<t>Client (C): A device which wants to access a resource on the Resource Server.</t>

<t>Resource Owner: The subject who owns the resource and controls its access permissions.</t>

</section>
</section>
</section>
<section anchor="system-overview" title="System Overview">
<t>Within the DCAF Architecture each constrained device has one or more Authorization servers (AS) which conduct the authentication and authorization for the device. The constrained device and the AS share a symmetric key which has to be exchanged initially to provide for a secure channel. The mechanism used for this is not in the scope of this document.</t>

<t>To gain access to a specific resource on a Resource Server (RS), a client (C) has to request an authorization ticket from RS’ Authorization Server (AS(RS)) either directly or, if it is a constrained device using its own Authorization Server (AS(C)).</t>

<t>If AS(RS) decides that C is allowed to access the resource, it generates a DTLS pre-shared key (PSK) for the communication between C and RS and wraps it together with the access permissions into an authorization ticket. After presenting the ticket to the RS, C and RS can communicate securely.</t>

<t>To be able to provide for the authentication and authorization
services, the Authorization Servers have to fulfill several
requirements. They MUST have enough disk space to store a sufficient
number of credentials (matching the number of clients and Resource
Servers) and MUST possess means for user interaction, for example
input/output devices like keyboard and display to allow for
configuration of authorization information by the Resource
Owner. Additionally they MUST have enough processing power to handle
the authorization requests for all devices they are responsible for.</t>

<!-- *TODO: Requirements from {{selander-core-access-control}}* -->
<!-- *TODO: Scalability* -->
<!-- *TODO: Does this architecture generate more traffic than direct authentication with the client?* -->

</section>
<section anchor="protocol" title="Protocol">

<t>The DCAF protocol comprises three parts:</t>

<t><list style='numbers'>
  <t>Transmission of authorization information between C and RS,</t>
  <t>transmission of authorization requests and access grants
between C and AS(C), and</t>
  <t>transmission of authorization requests and access grants
between AS(C) and AS(RS).</t>
</list></t>

<!-- In most network topologies, at least two of the three sub-protocols -->
<!-- will be present, depending on the actual roles that each device -->
<!-- impersonates. In simple scenarios, AS(C) and AS(RS) might be -->
<!-- identical, i.e. C and RS use the same authorization server. In this -->
<!-- case, no AS-to-AS communication is required. Moreover, if C is capable -->
<!-- of mutual authentication with AS(RS), it could act as AS(C). -->

<section anchor="overview" title="Overview">

<t>In <xref target="protocol-overview"/>, a protocol flow with an Authentication Server for RS is depicted (messages in square brackets are optional):</t>

<figure title="Protocol Overview" anchor="protocol-overview"><artwork><![CDATA[
AS(C)                  C                    RS                 AS(RS)
  | <== DTLS chan. ==> |                    | <== DTLS chan. ==> |
  |                    | [Resource Req.-->] |                    |
  |                    |                    |                    |
  |                    | [<-- AS(RS) Info.] |                    |
  |                    |                    |                    |
  | <-- Author. Req.   |                    |                    |
  |                    |                    |                    |
  | <====== TLS/DTLS channel (AS Mutual Authentication) =======> |
  |                    |                    |                    |
  | Ticket Request   ------------------------------------------> |
  |                    |                    |                    |
  | <------------------------------------------    Ticket Grant  |
  |                    |                    |                    |
  | Ticket Transm. --> |                    |                    |
  |                    |                    |                    |
  |                    | <== DTLS chan. ==> |                    |
  |                    | Auth. Res. Req. -> |                    |

]]></artwork></figure>

<t>To determine the Authorization Server that is in charge of a resource
hosted at the Resource Server (RS), the client (C) MAY send an initial
Unauthorized Resource Request message to RS.
RS then rejects the request and sends the address of its authorization server (AS(RS)) back to the client.</t>

<t>Instead of the initial Unauthorized Resource Request message, C MAY
lookup the desired resource in a
resource directory (cf. <xref target="I-D.ietf-core-resource-directory"/>) that
lists RS’s resources as discussed in <xref target="rd"/>.</t>

<t>Once C knows AS(RS)’s address, it can
send a request for authorization to AS(RS) using its own Authorization
Server (AS(C)). After authenticating AS(C), AS(RS) decides if C
is allowed to access the requested resource and in this case
generates an access ticket for C. The ticket contains a
representation of the permissions C has for the resource as
well as keying material for the establishment of a secure channel. 
C keeps one part of the access ticket and presents the other part
to RS to prove its right to access the resource. With their respective
parts of the ticket, C and RS are able to establish
a secure channel.</t>

<t>The following sections specify how CoAP is used to interchange
authorization-related data between RS and AS(RS) so that AS(RS) can
provide C and RS with sufficient information to establish a secure
channel using symmetric cryptography, and simultaneously convey
authorization information specific for this communication relationship
to RS.</t>

<t>This document uses JavaScript Object Notation (JSON, <xref target="RFC4627"/>) to
express authorization information as set of attributes passed in CoAP
payloads. Notation and encoding options are discussed in
<xref target="payload-format"/>.</t>

</section>
<section anchor="rreq" title="Unauthorized Resource Request Message">

<t>The optional Unauthorized Resource Request message is a request for a resource
hosted by RS for which no proper authorization is granted. RS MUST
treat any CoAP request as Unauthorized Resource Request message when any of the
following holds:</t>

<t><list style='symbols'>
  <t>The request has been received on an insecure channel.</t>
  <t>RS has no valid authorization information for the sender of the
request regarding the requested action on that resource.</t>
  <t>RS has valid authorization information for the sender of the
request that does not allow the requested action on the requested
resource.</t>
</list></t>

<t>Note: These conditions ensure that RS can handle requests autonomously
once access was granted and a secure channel has been established
between C and RS.</t>

<t>Unauthorized Resource Request messages MUST be rejected with a 4.01
(Unauthorized)
response. In this response, the Resource Server MUST provide
proper AS(RS) Information to enable the Client to request an
access ticket from RS’s Authorization Server as described in
<xref target="as-info"/>.</t>

</section>
<section anchor="as-info" title="AS(RS) Information Message">

<t>The AS(RS) Information Message is sent by RS as a response to an
Unauthorized Resource Request message (see <xref target="rreq"/>) to point the sender of the
Unauthorized Resource Request message to RS’s Authorization Server. The AS(RS)
Information is a set of attributes containing an absolute URI (see Section 4.3 of <xref target="RFC3986"/>) that specifies the
   Authorization Server in charge of RS.</t>

<t>The message MAY also contain a timestamp generated by RS. <!-- (RS wants either his own timestamp or a timestamp generated by AS(RS) back in the end to make sure the information it gets is fresh)--></t>

<t><xref target="as-info-payload"/> shows an example for an AS(RS) Information message
payload using JSON. (Refer to <xref target="payload-format"/> for a detailed
description of the available attributes and their semantics.)</t>

<figure title="AS(RS) Information Payload Example" anchor="as-info-payload"><artwork><![CDATA[
    4.01 Unauthorized
    Content-Format: application/dcaf+json
    {
      "AS": "coaps://as-rs.example.com/authorize",
      "TS": 168537
    }
]]></artwork></figure>

<t>In this example, the attribute AS points the receiver of this message
to the URI “coaps://as-rs.example.com/authorize” to request access
permissions. The originator of the AS(RS) Information payload
(i.e. RS) uses a local clock that is loosely synchronized with wall
clock time. Therefore, it has included a time stamp on its own time
scale that is used as a nonce for replay attack prevention. Refer
to <xref target="face"/> for more details concerning the usage of time stamps to 
ensure freshness of authorization tickets.</t>

</section>
<section anchor="authorization-request" title="Authorization Request">

<t>To retrieve an authorization ticket for the resource that C wants to
access, C sends an Authorization Request to its authorization server
AS(C). The Authorization Request is constructed as follows:</t>

<t><list style='numbers'>
  <t>The request method is POST.</t>
  <t>The request URI is set as described below.</t>
  <t>The message payload contains a data structure that describes the
action and resource for which C requests an authorization ticket.</t>
</list></t>

<t>The request URI identifies a resource at AS(C) for handling
authorization requests from C. The URI SHOULD be announced by AS(C) in
its resource directory as described in <xref target="rd"/>.</t>

<t><list style='hanging'>
  <t hangText='Note:'>
  Where capacity limitations of C do not allow for resource directory
lookups, the request URI in authorization requests could be
hard-coded during provisioning or set in a specific device
configuration profile.</t>
</list></t>

<t>The message payload is constructed from the authorization information
that RS has returned in its AS(RS) Information message (see
<xref target="as-info"/>) and information that C provides to describe its intended
request(s). The
Authorization Request MUST contain the following attributes:</t>

<t><list style='numbers'>
  <t>Contact information for the AS(RS) to use.</t>
  <t>An identifier of C that is recognized by AS(RS).</t>
  <t>An absolute URI of the resource that C wants to access.</t>
  <t>The actions that C wants to perform on the resource.</t>
  <t>Any time stamp generated by RS.</t>
</list></t>

<t>An example Authorization Request from C to AS(C) is depicted in
<xref target="authorization-message-example"/>. (Refer to <xref target="payload-format"/> for a detailed
description of the available attributes and their semantics.)</t>

<figure title="Authorization Message Example" anchor="authorization-message-example"><artwork><![CDATA[
   POST client-authorize
   Content-Format: application/dcaf+json
   {
      "AS": coaps://as-rs.example.com/authorize",
      "CI": "node-588",
      "M": [ "GET", "PUT" ],
      "R": "coaps://temp451.example.com/s/tempC",
      "TS": 168537
    }
]]></artwork></figure>

<t>The example shows an Authorization Request message payload for the resource
“/s/tempC” on the Resource Server “temp451.example.com”. Requested operations in
attribute M are GET and PUT. The requesting client is identified as
“node-588”.</t>

<t>The attributes AS (that denotes the Authorization Server to use) and
TS (a nonce generated by RS) are taken from the AS(RS) Information
message from RS.</t>

<t>The response to an Authorization Request is delivered by AS(C) back to
C in a Ticket Transmission message.</t>

</section>
<section anchor="ticket-request-message" title="Ticket Request Message">

<t>When AS(C) receives an Authorization Request message from C it MAY
return a cached response if it is known to be fresh. Otherwise, it
checks whether the request payload is of type “application/dcaf+json”
and contains at least the fields AS, CI, M, and R. AS(C) MUST respond
with 4.00 (Bad Request) if the type is “application/dcaf+json” and any
of these fields is missing or does not conform to the format described
in <xref target="payload-format"/>. Content formats other than
application/dcaf+json are out of scope of this specification.</t>

<t>When the payload is correct AS(C) MUST create a Ticket Request message
from the Authorization Request received from C as follows:</t>

<t><list style='numbers'>
  <t>The destination of the Ticket Request message is derived from the
authority information in the URI contained in field “AS” of the
Authorization Request message payload.</t>
  <t>The request method is POST.</t>
  <t>The request URI is constructed from the AS field received in the
Authorization Request message payload.</t>
  <t>The payload is copied from the Authorization Request sent by C.</t>
</list></t>

<t>To sent the Ticket Request message to AS(RS)
a secure channel between AS(C)
and AS(RS) MUST be used. Depending on the URI scheme used in the
AS field of the Authorization Request message payload, this could be,
e.g., a DTLS channel (for “coaps”) or a TLS connection (for
“https”). AS(C) and AS(RS) MUST be able to mutually authenticate each other,
e.g. based on a public key infrastructure. (Refer to <xref target="trust"/> for a detailed
discussion of the trust relationship between authorization servers.)</t>

</section>
<section anchor="ticket-grant-message" title="Ticket Grant Message">

<t>When AS(RS) has received a Ticket Request message it has to evaluate
the authorization request information contained therein. First, it
checks whether the request payload is of type “application/dcaf+json”
and contains at least the fields AS, CI, M, and R. AS(RS) MUST respond
with 4.00 (Bad Request) for CoAP (or 400 for HTTP) if the type is “application/dcaf+json” and any
of these fields is missing or does not conform to the format described
in <xref target="payload-format"/>.</t>

<t>AS(RS) decides whether or not access is granted to the requested
resource and then creates a Ticket Grant message that reflects the
result. 
If AS(RS) grants access to the requested resource it has to create an
access ticket comprised of a Face and a Verifier as described in
<xref target="face"/>.</t>

<t>The Ticket Grant message then is constructed as a success response
indicating attached content, i.e. 2.05 for CoAP, or 200 for HTTP,
respectively. The payload of the Ticket Grant message is a data
structure that contains the result of the access request. When 
access is granted the data structure MUST contain the 
ticket’s Face, the Verifier and the Session Key Generation Method.</t>

<t>The Ticket Grant message MAY provide cache-control options to enable
intermediaries to cache the response. The message MAY be cached
according to the rules defined in <xref target="I-D.ietf-core-coap"/> to facilitate
ticket retrieval when C has crashed and wants to recover the DTLS
session with RS.</t>

<t>AS(RS) sets Max-Age according to the ticket lifetime in its response
(Ticket Grant Message).</t>

<t><xref target="ticket-grant"/> shows an example Ticket Grant message using CoAP. The
Face/Verifier information is transferred as JSON data structure as
specified in <xref target="payload-format"/>. The Max-Age option tells the
receiving AS(C) how long this ticket will be valid.</t>

<figure title="Example Ticket Grant Message" anchor="ticket-grant"><artwork><![CDATA[
   2.05 Content
   Content-Format: application/dcaf+json
   Max-Age: 86400
   { "F": {
            "AI": { "Role" : 3 },
            "CI": "2001:db8:ab9:1234:7920:3133:ae5f:87",
            "TS": "2013-07-10T10:04:12.391",
            "L":  86400,
            "G": "hmac_sha256"
     },
     "V": "w+ZeJx5MxIEkt7yBMWjX6ztSYcIBTz+sv4z98m+PUEY="
   }  
]]></artwork></figure>

<t>A Ticket Grant message that declines any operation on the requested
resource is illustrated in <xref target="ticket-reject"/>. As no ticket needs
to be issued, an empty payload is included with the response.</t>

<figure title="Example Ticket Grant Message With Reject" anchor="ticket-reject"><artwork><![CDATA[
    2.05 Content
    Content-Format: application/dcaf+json
]]></artwork></figure>

</section>
<section anchor="ticket-transmission" title="Ticket Transmission Message">

<t>A Ticket Transmission message delivers the authorization information
sent by AS(RS) in a Ticket Grant message to the requesting client C.
The Ticket Transmission message MUST be the first and only response to
the corresponding Authorization Request message sent from C to AS(C)
and include any authorization information from AS(RS) contained in the
Ticket Grant message.</t>

</section>
<section anchor="dtls-channel" title="DTLS Channel Setup Between C and RS">

<t>Using the information contained in a positive response to its
Authorization Request (i.e. a Ticket Transmission message that contains 
a Face and a Verifier), C can initiate establishment of a new DTLS
channel with RS. To use DTLS with pre-shared keys, C follows the PSK
key exchange algorithm specified in Section 2 of <xref target="RFC4279"/>, with the
following additional requirements:</t>

<t><list style='numbers'>
  <t>C MUST set the psk_identity field of the ClientKeyExchange message
to the ticket Face received in the Ticket Transmission message.</t>
  <t>C MUST use the ticket Verifier as PSK when constructing the premaster 
secret.</t>
</list></t>

<t>Note1: As RS cannot provide C with a meaningful PSK identity hint in
response to C’s ClientHello message, RS SHOULD NOT send a
ServerKeyExchange message.</t>

<t>Note2: According to <xref target="I-D.ietf-core-coap"/>, CoAP implementations MUST
support the ciphersuite TLS_PSK_WITH_AES_128_CCM_8
<xref target="RFC6655"/>. C is therefore expected to offer at least this
ciphersuite to RS.</t>

<t>Note3: The ticket is constructed by AS(RS) such that RS can derive the
authorization information as well as the PSK (refer to
<xref target="key-generation"/> for details).</t>

</section>
<section anchor="authorized-rreq" title="Authorized Resource Request Message">

<t>Successful establishment of the DTLS channel between C and RS ties the
authorization information contained in the psk_identity field to this
channel. Any request that RS receives on this channel is checked
against these authorization rules. Incoming CoAP requests that are not
Authorized Resource Requests MUST be rejected by RS with 4.01
response as described in <xref target="rreq"/>.</t>

<t>RS SHOULD treat an incoming CoAP request as Authorized Resource
Request if the following holds:</t>

<t><list style='numbers'>
  <t>The message was received on a secure channel that has been
established using the procedure defined in <xref target="dtls-channel"/>.   </t>
  <t>The authorization information tied to the secure channel is valid.</t>
  <t>The request is destined for RS.</t>
  <t>The resource URI specified in the request is covered by the 
authorization information.</t>
  <t>The request method is an authorized action on the resource with
respect to the authorization information.</t>
</list></t>

<t>Note that the authorization information is not restricted to a single
resource URI. For example, role-based authorization can be used to
authorize a collection of semantically connected resources
simultaneously. As a result, C can use the same DTLS channel not only
for subsequent requests for the same resource (e.g. for block-wise
transfer as defined in <xref target="I-D.ietf-core-block"/> or refreshing
observe-relationships <xref target="I-D.ietf-core-observe"/>) but also for requests
to distinct resources.</t>

</section>
</section>
<section anchor="ticket" title="Ticket">

<t>A DCAF ticket consists of two parts, the Face and the Verifier.</t>

<section anchor="face" title="Face">

<t>Face is the part of the ticket generated for RS. Face MUST contain all
information needed for authorized access to a resource:</t>

<t><list style='symbols'>
  <t>Authorization Information</t>
  <t>Client Identifier</t>
  <t>A timestamp generated by AS(RS)</t>
</list></t>

<t>Optionally, Face MAY also contain:</t>

<t><list style='symbols'>
  <t>A lifetime (optional)</t>
  <t>A DTLS pre-shared key (optional)
<!-- end of list --></t>
</list></t>

<t>RS MUST verify the integrity of Face, i.e. the information contained
in Face stems from AS(RS) and was not manipulated by anyone else.</t>

<t>Face MUST contain a timestamp to verify that the contained information
is fresh. As constrained devices may not have a clock, timestamps MAY
be generated using the clock ticks since the last reboot. To
circumvent synchronization problems the timestamp MAY be generated by
RS and included in the first AS(RS) Information
message. Alternatively, AS(RS) MAY generate the timestamp. In this
case, AS(RS) and RS MUST use a time synchronisation mechanism to make
sure that RS interprets the timestamp correctly.</t>

<t>Face MAY be encrypted. If Face contains a DTLS PSK, the
whole content of Face MUST be encrypted.</t>

<t>Note: The integrity of Face can be ensured by various means. Face may be
encrypted by AS(RS) with a key it shares with RS. Alternatively, RS
can use a mechanism to generate the DTLS PSK which includes Face
and is only able to calculate the correct key with the correct Face
(refer to <xref target="key-generation"/> for details).</t>

</section>
<section anchor="verifier" title="Verifier">

<t>The Verifier part of the ticket is generated for C. It contains the
DTLS PSK for C. The Verifier MUST NOT be transmitted over
insecure channels.</t>

</section>
<section anchor="revocation" title="Revocation">

<section anchor="time" title="Lifetime">

<t>Tickets MAY have a lifetime. AS(RS) is responsible for defining the
ticket lifetime. If AS(RS) sets a lifetime for a ticket, AS(RS) and RS
MUST use a time synchronisation method to ensure that RS is able to
interpret the lifetime correctly. RS SHOULD end the DTLS connection to
C if the lifetime of a ticket has run out and it MUST NOT accept new
requests. RS MUST NOT accept tickets with an invalid lifetime.</t>

<t>Note: Defining reasonable ticket lifetimes is difficult to
accomplish. How long a client needs to access a resource depends
heavily on the application scenario and may be difficult to decide for
AS(RS).</t>

</section>
<section anchor="revocation-messages" title="Revocation Messages">

<t>AS(RS) MAY revoke tickets by sending a ticket revocation message to
RS. If RS receives a ticket revocation message, it MUST end the DTLS
connection to C and MUST NOT accept any further requests from C.</t>

<t>If ticket revocation messages are used, RS MUST check regularly if
AS(RS) is still available. If RS cannot contact AS(RS), it MUST end
all DTLS connections and reject any further requests from C.</t>

<t>Note: The loss of the connection between RS and AS(RS) prevents all
access to RS. This might especially be a severe problem if AS(RS) is
responsible for several Resource Servers or even a whole network.</t>

</section>
</section>
</section>
<section anchor="payload-format" title="Payload Format and Encoding (application/dcaf+json)">

<t>Various messages types of the DCAF protocol carry payloads to express
authorization information and parameters for generating the DTLS PSK
to be used by C and RS. In this section, a representation in
JavaScript Object Notation (JSON, <xref target="RFC4627"/>) is defined.</t>

<t>The following attributes are defined:</t>

<t><list style='hanging'>
  <t hangText='AS:'>
  Authentication Server. This attribute denotes the authorization
server that is in charge of the resource specified in attribute
R. The attribute’s value is a string that contains an absolute URI
according to Section 4.3 of <xref target="RFC3986"/>.</t>
  <t hangText='AI:'>
  Authorization Information. A data structure used to convey
authorization information from AS(RS) to RS (see below).</t>
  <t hangText='CI:'>
  Client Identity. A string that identifies the initiator of the
authorization request. This label MAY be a fully qualified domain
name, an IP address, or any other character literal that is used by
the Authorization Server to decide whether or not access is granted
to the requesting entity.</t>
  <t hangText='E:'>
  Encrypted Ticket Face. A string containing an encrypted ticket Face
encoded as base64 according to Section 4 of <xref target="RFC4648"/>.</t>
  <t hangText='K:'>
  Key. A string that identifies the shared key between RS and AS(RS)
that can be used to decrypt the contents of E. If the attribute E
is present and no attribute K has been specified, the default is
to use the current session key for the secured channel between RS
and AS(RS).</t>
  <t hangText='M:'>
  Methods. The list of actions to be performed on the resource R,
encoded as an array of strings. In
an authorization request, this list contains the actions that the
initiator of the request wants to perform. In an authorization
ticket, this attribute denotes the actions that are permitted.</t>
  <t hangText='R:'>
  Resource. A string that denotes the absolute URI of the resource to
be accessed. As the access ticket is requested in order to establish
a DTLS connection with the server that hosts this resource, the URI
scheme typically is “coaps”.</t>
  <t hangText='TS:'>
  Time Stamp. An optional time stamp that indicates the instant when
the access ticket request was formed. This attribute can be used by
the resource server in an AS(RS) Information message to convey a
time stamp in its local time scale (e.g. when it does not have a
real time clock with synchronized global time). When the attribute’s
value is encoded as a string, it MUST contain a valid UTC timestamp
without time zone information. When encoded as integer, TS contains
a system timestamp relative to the local time scale of its
generator, usually RS.</t>
  <t hangText='L:'>
  Lifetime. A lifetime of the ticket. When encoded as a string, L MUST
denote the ticket’s expiry time as a valid UTC timestamp without
time zone information. When encoded as an integer, L MUST denote the
ticket’s validity period in seconds relative to TS.</t>
  <t hangText='G:'>
  DTLS PSK Generation Method. A string that identifies the method 
that RS MUST use to derive the DTLS PSK from the ticket Face. This 
attribute MUST NOT be used when attribute V is present within the
contents of F.</t>
  <t hangText='F:'>
  Ticket Face. An object containing the fields AI, CI, TS, and optionally
 G, L and V.</t>
  <t hangText='V:'>
  Ticket Verifier. A string containing the shared secret between C and
RS, encoded as base64 according to Section 4 of <xref target="RFC4648"/>.</t>
</list></t>

<t>The exact specification of AI is out of scope for this document. AI
may, e.g., contain a single role identifier known by RS, or an array
of pairs (M, R) with M and R defined as above.</t>

<t>As AI is used to authorize resource access as defined in
<xref target="authorized-rreq"/>, RS MUST be able to interpret the contained
information.</t>

<section anchor="examples" title="Examples">

<t>The following example specifies an Authorization Server that will be
accessed using HTTP over TLS. The request URI is set to
“/a?ep=%5B2001:DB8::dcaf:1234%5D” (hence denoting the endpoint address
to authorize). TS denotes a local timestamp in UTC.</t>

<figure><artwork><![CDATA[
POST /a?ep=%5B2001:DB8::dcaf:1234%5D HTTP/1.1
Host: as-rs.example.com
Content-Type: application/dcaf+json

{
  "AS": "https://as-rs.example.com/a?ep=%5B2001:DB8::dcaf:1234%5D",
  "CI": "2001:DB8::dcaf:1234",
  "M":  [ "GET" ],
  "R": "coaps://temp451.example.com/s/tempC",
  "TS": "2013-07-14T11:58:22.923"
}
]]></artwork></figure>

<t>The following example shows a ticket for the distributed key
generation method (cf. <xref target="key-derivation"/>), comprised of a Face (F)
and a Verifier (V). The Face data structure contains authorization
information AI with an application-specific role identifier, a client
identifier, a timestamp using the local time scale of RS, and a
lifetime relative to RS’s time scale.</t>

<t>The DTLS PSK Generation Method is set to “hmac_sha256” denoting
that the distributed key derivation is used as defined in
<xref target="key-derivation"/> with SHA-256 as HMAC function.</t>

<t>The Verifier V contains a shared secret to be used as DTLS PSK
between C and RS.</t>

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/dcaf+json

{ 
  "F": { 
         "AI": { "Role" : 3 },
         "CI": "2001:db8:ab9:1234:7920:3133:ae5f:87",
         "TS": 2938749,
         "L":  3600,
         "G": "hmac_sha256"
       },
  "V": "zrPOuc6xzr/Pjc+Bz4TOuSDOvM61IM68zq3Ou865Cg=="
}
]]></artwork></figure>

<t>The Face may be encrypted as illustrated in the following example.
Here, the field E carries an encrypted and base64-encoded Face data structure that
contains the same information as the previous example, and an
additional Verifier. Encryption was done with a secret shared by
AS(RS) and RS. (This example uses AES128_CCM with the secret { 0x00,
0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
0x0c, 0x0d, 0x0e, 0x0f } and RS’s timestamp { 0x00, 0x2C, 0xD7, 0x7D
} as nonce.) Line breaks have been inserted to improve readability.</t>

<t>The attribute K describes the identity of the key to be used by RS to
decrypt the contents of attribute E. Here, The value “key0” in this
example is used to indicate that the shared session key between RS and
AS(RS) was used for encrypting E.</t>

<figure><artwork><![CDATA[
{
  "E": "rjtolfjyX9q7Emxgsnz+nf0xTQhe1MjzZBRoIEW4vmSVlyJdW4KDgVtW
        LyBnQSVX0lmVpxUYbdNuk/5PkCOJBeex0obiEBC1UmKoJfJfjy7bLQhq
        k9HuJD7cvjHNOVZtNZf5qrxt7xJSoZFe6j/SJuxGNH/72SPDrdMQeXJI
        pX6vCJB698FcRDOXh/ipi9KT8YWeo/ljUMgJc+LI",
  "K": "key0",
  "V": "zrPOuc6xzr/Pjc+Bz4TOuSDOvM61IM68zq3Ou865Cg=="
}
]]></artwork></figure>

<t>The decrypted contents of E are depicted below (whitespace has been
added to improve readability). The presence of the attribute V
indicates that the DTLS PSK Transfer is used to convey the session key
(cf. <xref target="key-transfer"/>).</t>

<figure><artwork><![CDATA[
"F":{"AI":{"Role":3},
"CI":"2001:db8:ab9:1234:7920:3133:ae5f:87",
"TS":2938749,
"L":3600,
"V":"zrPOuc6xzr/Pjc+Bz4TOuSDOvM61IM68zq3Ou865Cg=="}
]]></artwork></figure>

</section>
</section>
<section anchor="key-generation" title="DTLS PSK Generation Methods">

<t>One goal of the DCAF protocol is to provide for a DTLS PSK shared between C and RS. AS(RS) and RS MUST negotiate the method for the DTLS PSK generation.</t>

<section anchor="key-transfer" title="DTLS PSK Transfer">

<t>The DTLS PSK is generated by AS(RS) and transmitted to C and RS using a secure channel.</t>

<t>The DTLS PSK transfer method is defined as follows: </t>

<t><list style='symbols'>
  <t>AS(RS) generates the DTLS PSK using an algorithm of its choice</t>
  <t>AS(RS) MUST include a representation of the DTLS PSK in Face and
encrypt it together with all other information in Face with a key
K(AS(RS),RS) it shares with RS. How AS(RS) and RS exchange
K(AS(RS),RS) is not in the scope of this document. AS(RS) and RS
MAY use their preshared key as K(AS(RS),RS).</t>
  <t>AS(RS) MUST include a representation of the DTLS PSK in the Verifier.</t>
  <t>As AS(RS) and C do not have a shared secret, the Verifier MUST
be transmitted to C using encrypted channels.</t>
  <t>RS MUST decrypt Face using K(AS(RS),RS)</t>
</list></t>

</section>
<section anchor="key-derivation" title="Distributed Key Derivation">

<t>AS(RS) generates a DTLS PSK for C which is transmitted using a secure channel. RS generates its own version of the DTLS PSK using the information contained in Face (see also <xref target="face"/>).</t>

<t>The distributed key derivation method is defined as follows:</t>

<t><list style='symbols'>
  <t>AS(RS) and RS both generate the DTLS PSK using the information.
included in Face. They use an HMAC algorithm on Face with a shared
key. The result serves as the DTLS PSK. How AS(RS) and RS
negotiate the used HMAC algorithm is not in the scope of this
document. They MAY however use the HMAC algorithm they use for their
DTLS connection.</t>
  <t>AS(RS) MUST include a representation of the DTLS PSK in the Verifier.</t>
  <t>As AS(RS) and C do not have a shared secret, the Verifier MUST
be transmitted to C using encrypted channels.</t>
  <t>AS(RS) MUST NOT include a representation of the DTLS PSK in Face.</t>
  <t>AS(RS) MUST NOT encrypt Face.</t>
</list></t>

</section>
</section>
<section anchor="authorization-configuration" title="Authorization Configuration">

<t>For the protocol defined in this document, proper configuration of
AS(RS) is crucial. The principal who owns the resources hosted by RS
(i.e. the Resource Owner) needs to define permissions for the
resources. The data representation of these permissions are not in the
scope of this document.</t>

</section>
<section anchor="trust" title="Trust Relationships">

<t>C and RS trust their respective Authorization Servers and vice versa. How this trust is established, is not in the scope of this document. It may be achieved by using a bootstrapping mechanism similar to <xref target="bergmann12"/>.</t>

<t>Additionally, AS(RS) and AS(C) already have a trust relationship. Its establishment is also not in the scope of this document. It fulfills the following conditions:</t>

<t><list style='numbers'>
  <t>AS(RS) has means to identify AS(C) (e.g. it has a certificate of AS(C) or a PKI in which AS(C) is included) and vice versa</t>
  <t>AS(RS) knows that AS(C) is responsible for C</t>
  <t>AS(RS) can be sure that AS(C) does not transmit tickets that have
 been generated for C to another client</t>
</list></t>

<!-- end of list -->

<t>AS(RS) trusts C implicitly because it trusts AS(C). The DCAF Protocol does not provide any means for AS(RS) to validate that a resource requests stems from C.</t>

<t>C trusts AS(RS) because AS(C) trusts AS(RS).</t>

<t>AS(C) trusts RS implicitely because it trusts AS(RS)</t>

<t>C implicitely trusts RS because it trusts AS(C) and because RS can proof that
it shares a key with AS(RS).</t>

<figure><artwork><![CDATA[
  AS(C) <----------------> AS(RS)

   /|\                      /|\
    |                        |
   \|/                      \|/

    C .....................  RS

]]></artwork></figure>

</section>
<section anchor="rd" title="Listing Authorization Server Information in a Resource Directory">

<t>CoAP utilizes the Web Linking format <xref target="RFC5988"/> to facilitate
discovery of services in an M2M environment.<xref target="RFC6690"/> defines
specific link parameters that can be used to describe resources to be
listed in a resource directory <xref target="I-D.ietf-core-resource-directory"/>.</t>

<t>This section defines a resource type “auth-request” that can be used
by clients to retrieve the request URI for a server’s authorization
service. When used with the parameter rt in a web link, “auth-request”
indicates that the corresponding target URI can be used in a POST
message to request authorization for the resource and action that are
described in the request payload.</t>

<t>The Content-Format “application/dcaf+json” with numeric identifier
TBD1 defined in this specification MAY be used to express
authorization requests and their responses.</t>

<t>The following example shows the web link used by AS(C) in this
document to relay incoming Authorization Request messages to AS(RS).
(Whitespace is included only for readability.)</t>

<figure><artwork><![CDATA[
<client-authorize>;rt="auth-request";ct=TBD1
                  ;title="Contact Remote Authorization Server"
]]></artwork></figure>

<t>The resource directory that hosts the resource descriptions of RS
could list the following description. In this example, the URI
“ep/node138/a/switch2941” is relative to the resource context
“coaps://as-rs.example.com/”, i.e. the authorization server AS(RS).</t>

<figure><artwork><![CDATA[
<ep/node138/a/switch2941>;rt="auth-request";ct=TBD1;ep="node138"
                         ;title="Request Client Authorization"
                         ;anchor="coaps://as-rs.example.com/"
]]></artwork></figure>

</section>
<section anchor="examples-1" title="Examples">

<t>This section gives a number of short examples with message flows for
the initial Unauthorized Resource Request and the subsequent retrieval
of a ticket
from AS(RS). The notation here follows the role conventions defined in
<xref target="roles"/>. The payload format is encoded as proposed in
<xref target="payload-format"/>. The IP address of AS(RS) is 2001:DB8::1, the IP address
of RS is 2001:DB8::dcaf:1234, and C’s IP address is 2001:DB8::c.</t>

<section anchor="access-granted" title="Access Granted">

<t>This example shows an Unauthorized PUT request from C to RS that is
answered with an AS(RS) Information message. C then sends a POST
request to AS(C) with a description of its intended request. AS(C)
forwards this request to AS(RS) using CoAP over a DTLS-secured
channel. The response from AS(RS) contains an access ticket that is
relayed back to AS(C).</t>

<figure><artwork><![CDATA[
C --> RS
PUT a/switch2941 [Mid=1234]
Content-Format: application/senml+json
{e: [{"bv": "1"}]}

C <-- RS
4.01 Unauthorized  [Mid=1234]
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941"}

C --> AS(C)
POST client-authorize [Mid=1235,Token="tok"]
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941",
 "CI": "2001:DB8::c",
 "M": [ "PUT" ],
 "R": "coaps://[2001:DB8::dcaf:1234]/a/switch2941"
}

AS(C) --> AS(RS) [Mid=23146]
POST ep/node138/a/switch2941
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941",
 "CI": "2001:DB8::c",
 "M": [ "PUT" ],
 "R": "coaps://[2001:DB8::dcaf:1234]/a/switch2941"
}

AS(C) <-- AS(RS)
2.05 Content  [Mid=23146]
Content-Format: application/dcaf+json
{ "F": { "AI": { "R" : "a/switch2941", "M" : [ "GET", "PUT" ] },
         "CI": "2001:DB8::c",
         "TS": "2013-07-04T20:17:38.002,
         "G": "hmac_sha256"
       },
  "V": "yYVLYZZ5Nssbn0by3fqel9WK6jHdoYyNej2d/kSuBLw="
}

C <-- AS(C) 
2.05 Content  [Mid=1235,Token="tok"]
Content-Format: application/dcaf+json
{ "F": { "AI": { "R" : "a/switch2941", "M" : [ "GET", "PUT" ] },
         "CI": "2001:DB8::c",
         "TS": "2013-07-04T20:17:38.002",
         "G": "hmac_sha256"
       },
  "V": "MR5TMrNngbSEAkFl0akmsdbmzF0gqxGI/d3KjwT8GxI="
}

C --> RS
ClientHello (TLS_PSK_WITH_AES_128_CCM_8)

C <-- RS
ServerHello (TLS_PSK_WITH_AES_128_CCM_8)
ServerHelloDone

C --> RS
ClientKeyExchange 
  psk_identity='"F":{"AI":{"R":"a/switch2941","M":["GET","PUT"]},
                     "CI": "2001:DB8::c",
                     "TS": "2013-07-04T20:17:38.002",
                     "G": "hmac_sha256"')

(C decodes the contents of V and uses the result as PSK)
ChangeCipherSpec
Finished

(RS calculates PSK from AI, CI, TS and its session key
 HMAC_sha256("{\"R\":\"a/switch2941\",\"M\":[\"GET\",\"PUT\"]}"+
             "2001:DB8::c"+"2013-07-04T20:17:38.002",
             "secret")
= 311e5332b36781b484024165d1a926b1d6e6cc5d20ab1188fdddca8f04fc1b12
)

C <-- RS
ChangeCipherSpec
Finished

]]></artwork></figure>

<!-- openssl dgst -sha256 -hmac $(cat secret) -binary <msg >hmac1.txt -->

</section>
<section anchor="access-denied" title="Access Denied">

<t>This example shows a denied Authorization request for the DELETE
operation.</t>

<figure><artwork><![CDATA[
C --> RS
DELETE a/switch2941

C <-- RS
4.01 Unauthorized
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941"}

C --> AS(C)
POST client-authorize
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941",
 "CI": "2001:DB8::c",
 "M": [ "DELETE" ],
 "R": "coaps://[2001:DB8::dcaf:1234]/a/switch2941"
}

AS(C) --> AS(RS)
POST ep/node138/a/switch2941
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941",
 "CI": "2001:DB8::c",
 "M": [ "DELETE" ],
 "R": "coaps://[2001:DB8::dcaf:1234]/a/switch2941"
}

AS(C) <-- AS(RS)
2.05 Content
Content-Format: application/dcaf+json

C <-- AS(C)
2.05 Content
Content-Format: application/dcaf+json
]]></artwork></figure>

</section>
<section anchor="access-restricted" title="Access Restricted">

<t>This example shows a denied Authorization request for the operations
GET, PUT, and DELETE. AS(RS) grants access for PUT only.</t>

<figure><artwork><![CDATA[
AS(C) --> AS(RS)
POST ep/node138/a/switch2941
Content-Format: application/dcaf+json
{"AS": "coaps://[2001:DB8::1]/ep/node138/a/switch2941",
 "CI": "2001:DB8::c",
 "M": [ "GET", "PUT", "DELETE" ],
 "R": "coaps://[2001:DB8::dcaf:1234]/a/switch2941"
}

AS(C) <-- AS(RS)
2.05 Content
Content-Format: application/dcaf+json
{ "F": { "AI": { "R" : "a/switch2941", "M" : [ "GET", "PUT" ] },
         "CI": "2001:DB8::c",
         "TS": "2013-07-04T21:33:11.930",
         "G": "hmac_sha256"
       },
  "V": "NZ8Q3o8P4eHOzkoscaUpoRvrn5d74Cscw/aXAiNmC/k="
}
]]></artwork></figure>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As this protocol builds on transitive trust between authorization
servers as mentioned in <xref target="trust"/>, AS(RS) has no means to validate<vspace />
that a resource request originates from C. It has to trust AS(C) that it is responsible for C and that it does not give authorization tickets meant for C to another client nor disclose the contained session key. </t>

<t>The Authentication Server also constitutes a single point of failure.
If the Authentication Server fails, the resources on all Resource
Servers it is responsible for cannot be accessed any more. Thus, 
it is crucial for large networks to use Authorization Servers in a failsafe setup.</t>

<!-- As already mentioned in {{trust}}, AS(RS) has no means to validate that a resource request really stems from C. It has to trust AS(C) that it really is responsible for C and that it does not give authorization tickets meant for C to another client.  -->

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>The following registrations are done following the procedure specified
in <xref target="RFC6838"/>.</t>

<t>Note to RFC Editor: Please replace all occurrences of “&SELF;” with
the RFC number of this specification.</t>

<section anchor="mt" title="dcaf+json Media Type Registration">

<t>Type name:  application</t>

<t>Subtype name:  dcaf+json</t>

<t>Required parameters:  none</t>

<t>Optional parameters:  none</t>

<t>Encoding considerations: Must be encoded as using a subset of the
encoding allowed in <xref target="RFC4627"/>.  Specifically, only the primitive data
types String and Number are allowed. The type Number is restricted to
int (i.e., no negative numbers, fractions or exponents are allowed).
Encoding MUST be UTF-8. These restrictions simplify implementations on
devices that have very limited memory capacity.</t>

<t>Security considerations:  TBD</t>

<t>Interoperability considerations: TBD</t>

<t>Published specification:  &SELF;</t>

<t>Applications that use this media type:  TBD</t>

<t>Additional information:</t>

<t>Magic number(s):  none</t>

<t>File extension(s):  dcaf</t>

<t>Macintosh file type code(s):  none</t>

<t>Person &amp; email address to contact for further information:  TBD</t>

<t>Intended usage:  COMMON</t>

<t>Restrictions on usage:  None</t>

<t>Author:  TBD</t>

<t>Change controller:  IESG</t>

</section>
<section anchor="coap-content-format-registration" title="CoAP Content Format Registration">

<t>This document specifies a new media type application/dcaf+json
(cf. <xref target="mt"/>). For use with CoAP, a numeric Content-Format identifier
is to be registered in the “CoAP Content-Formats” sub-registry within
the “CoRE Parameters” registry. </t>

<t>Note to RFC Editor: Please replace all occurrences of “RFC-XXXX” with
the RFC number of this specification.</t>

<texttable>
      <ttcol align='right'>Media type</ttcol>
      <ttcol align='left'>Encoding</ttcol>
      <ttcol align='left'>Id.</ttcol>
      <ttcol align='left'>Reference</ttcol>
      <c>application/dcaf+json</c>
      <c>utf-8</c>
      <c>TBD1</c>
      <c>&SELF;</c>
</texttable>

<!-- Local Variables: -->
<!-- coding: utf-8 -->
<!-- End: -->

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC3986'>

<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='Day Software'>Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Adobe Systems'>Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year='2005' month='January' />
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name='STD' value='66' />
<seriesInfo name='RFC' value='3986' />
<format type='TXT' octets='141811' target='http://www.rfc-editor.org/rfc/rfc3986.txt' />
<format type='HTML' octets='214067' target='http://xml.resource.org/public/rfc/html/rfc3986.html' />
<format type='XML' octets='163534' target='http://xml.resource.org/public/rfc/xml/rfc3986.xml' />
</reference>



<reference anchor='RFC4279'>

<front>
<title>Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</title>
<author initials='P.' surname='Eronen' fullname='P. Eronen'>
<organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'>
<organization /></author>
<date year='2005' month='December' />
<abstract>
<t>This document specifies three sets of new ciphersuites for the Transport Layer Security (TLS) protocol to support authentication based on pre-shared keys (PSKs).  These pre-shared keys are symmetric keys, shared in advance among the communicating parties.  The first set of ciphersuites uses only symmetric key operations for authentication.  The second set uses a Diffie-Hellman exchange authenticated with a pre-shared key, and the third set combines public key authentication of the server with pre-shared key authentication of the client. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4279' />
<format type='TXT' octets='32160' target='http://www.rfc-editor.org/rfc/rfc4279.txt' />
</reference>



<reference anchor='RFC6838'>

<front>
<title>Media Type Specifications and Registration Procedures</title>
<author initials='N.' surname='Freed' fullname='N. Freed'>
<organization /></author>
<author initials='J.' surname='Klensin' fullname='J. Klensin'>
<organization /></author>
<author initials='T.' surname='Hansen' fullname='T. Hansen'>
<organization /></author>
<date year='2013' month='January' />
<abstract>
<t>This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice.</t></abstract></front>

<seriesInfo name='BCP' value='13' />
<seriesInfo name='RFC' value='6838' />
<format type='TXT' octets='72942' target='http://www.rfc-editor.org/rfc/rfc6838.txt' />
</reference>



<reference anchor='RFC4648'>

<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
<organization /></author>
<date year='2006' month='October' />
<abstract>
<t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4648' />
<format type='TXT' octets='35491' target='http://www.rfc-editor.org/rfc/rfc4648.txt' />
</reference>



<reference anchor='RFC6347'>

<front>
<title>Datagram Transport Layer Security Version 1.2</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'>
<organization /></author>
<date year='2012' month='January' />
<abstract>
<t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6347' />
<format type='TXT' octets='73546' target='http://www.rfc-editor.org/rfc/rfc6347.txt' />
</reference>



<reference anchor='I-D.ietf-core-coap'>
<front>
<title>Constrained Application Protocol (CoAP)</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='June' day='28' year='2013' />

<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as 6LoWPAN often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine-to-machine (M2M) applications such as smart energy and building automation.  CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead and simplicity for constrained environments.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-coap-18' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-coap-18.txt' />
</reference>




    </references>

    <references title='Informative References'>





<reference anchor='RFC4627'>

<front>
<title>The application/json Media Type for JavaScript Object Notation (JSON)</title>
<author initials='D.' surname='Crockford' fullname='D. Crockford'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4627' />
<format type='TXT' octets='16319' target='http://www.rfc-editor.org/rfc/rfc4627.txt' />
</reference>



<reference anchor='RFC5988'>

<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
<organization /></author>
<date year='2010' month='October' />
<abstract>
<t>This document specifies relation types for Web links, and defines a registry for them.  It also defines the use of such links in HTTP headers with the Link header field. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5988' />
<format type='TXT' octets='46834' target='http://www.rfc-editor.org/rfc/rfc5988.txt' />
</reference>



<reference anchor='RFC6655'>

<front>
<title>AES-CCM Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'>
<organization /></author>
<author initials='D.' surname='Bailey' fullname='D. Bailey'>
<organization /></author>
<date year='2012' month='July' />
<abstract>
<t>This memo describes the use of the Advanced Encryption Standard (AES) in the Counter with Cipher Block Chaining - Message Authentication Code (CBC-MAC) Mode (CCM) of operation within Transport Layer Security (TLS) and Datagram TLS (DTLS) to provide confidentiality and data origin authentication.  The AES-CCM algorithm is amenable to compact implementations, making it suitable for constrained environments. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6655' />
<format type='TXT' octets='17052' target='http://www.rfc-editor.org/rfc/rfc6655.txt' />
</reference>



<reference anchor='RFC6690'>

<front>
<title>Constrained RESTful Environments (CoRE) Link Format</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'>
<organization /></author>
<date year='2012' month='August' />
<abstract>
<t>This specification defines Web Linking using a link format for use by constrained web servers to describe hosted resources, their attributes, and other relationships between links.  Based on the HTTP Link Header field defined in RFC 5988, the Constrained RESTful Environments (CoRE) Link Format is carried as a payload and is assigned an Internet media type. "RESTful" refers to the Representational State Transfer (REST) architecture.  A well-known URI is defined as a default entry point for requesting the links hosted by a server. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6690' />
<format type='TXT' octets='47720' target='http://www.rfc-editor.org/rfc/rfc6690.txt' />
</reference>


<reference anchor="bergmann12" >
  <front>
    <title>Secure Bootstrapping of Nodes in a CoAP Network</title>
    <author initials="O." surname="Bergmann" fullname="Olaf Bergmann">
      <organization></organization>
    </author>
    <author initials="S." surname="Gerdes" fullname="Stefanie Gerdes">
      <organization></organization>
    </author>
    <author initials="S." surname="Schaefer" fullname="Silke Schaefer">
      <organization></organization>
    </author>
    <author initials="F." surname="Junge" fullname="Florian Junge">
      <organization></organization>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization></organization>
    </author>
    <date year="2012" month="April"/>
  </front>
  <seriesInfo name="IEEE" value="Wireless Communications and Networking Conference Workshops (WCNCW)"/>
</reference>




<reference anchor='I-D.ietf-core-block'>
<front>
<title>Blockwise transfers in CoAP</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<date month='June' day='27' year='2013' />

<abstract><t>CoAP is a RESTful transfer protocol for constrained nodes and networks.  Basic CoAP messages work well for the small payloads we expect from temperature sensors, light switches, and similar building-automation devices.  Occasionally, however, applications will need to transfer larger payloads -- for instance, for firmware updates.  With HTTP, TCP does the grunt work of slicing large payloads up into multiple packets and ensuring that they all arrive and are handled in the right order.  CoAP is based on datagram transports such as UDP or DTLS, which limits the maximum size of resource representations that can be transferred without too much fragmentation.  Although UDP supports larger payloads through IP fragmentation, it is limited to 64 KiB and, more importantly, doesn't really work well for constrained applications and networks.  Instead of relying on IP fragmentation, this specification extends basic CoAP with a pair of "Block" options, for transferring multiple blocks of information from a resource representation in multiple request-response pairs.  In many important cases, the Block options enable a server to be truly stateless: the server can handle each block transfer separately, with no need for a connection setup or other server-side memory of previous block transfers.  In summary, the Block options provide a minimal way to transfer larger representations in a block-wise fashion.  The present revision -11 fixes one example and adds the text and examples about the Block/Observe interaction, taken from -observe. It also adds a couple of formatting bugs from the new xml2rfc.  The "grand rewrite" is next.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-block-12' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-block-12.txt' />
</reference>



<reference anchor='I-D.ietf-core-observe'>
<front>
<title>Observing Resources in CoAP</title>

<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>

<date month='July' day='15' year='2013' />

<abstract><t>CoAP is a RESTful application protocol for constrained nodes and networks.  The state of a resource on a CoAP server can change over time.  This document specifies a simple protocol extension for CoAP that enables CoAP clients to "observe" resources, i.e., to retrieve a representation of a resource and keep this representation updated by the server over a period of time.  The protocol follows a best- effort approach for sending new representations to clients, and provides eventual consistency between the state observed by each client and the actual resource state at the server.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-observe-09' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-observe-09.txt' />
</reference>



<reference anchor='I-D.ietf-core-resource-directory'>
<front>
<title>CoRE Resource Directory</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='S' surname='Krco' fullname='Srdjan Krco'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='June' day='3' year='2013' />

<abstract><t>In many M2M applications, direct discovery of resources is not practical due to sleeping nodes, disperse networks, or networks where multicast traffic is inefficient.  These problems can be solved by employing an entity called a Resource Directory (RD), which hosts descriptions of resources held on other servers, allowing lookups to be performed for those resources.  This document specifies the web interfaces that a Resource Directory supports in order for web servers to discover the RD and to register, maintain, lookup and remove resources descriptions.  Furthermore, new link attributes useful in conjunction with an RD are defined.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-resource-directory-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-resource-directory-00.txt' />
</reference>




    </references>



  </back>
</rfc>

