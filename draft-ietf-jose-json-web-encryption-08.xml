<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-jose-json-web-encryption-08">

  <front>
    <title abbrev="JWE">JSON Web Encryption (JWE)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization abbrev="RTFM">RTFM, Inc.</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>
      <address>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>

    <date day="27" month="December" year="2012" />

    <area>Security</area>
    <workgroup>JOSE Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>
    <keyword>JSON Web Algorithms</keyword>
    <keyword>JWA</keyword>

    <abstract>
      <t>
	JSON Web Encryption (JWE) is a means of representing encrypted
	content using JavaScript Object Notation (JSON) data structures.
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) specification.
	Related digital signature and MAC capabilities are described
	in the separate JSON Web Signature (JWS) specification.
      </t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction">
      <t>
	JSON Web Encryption (JWE) is a compact encryption format
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.
	It represents this content using JavaScript Object Notation (JSON)
	<xref target="RFC4627"/> based data structures.
	The JWE cryptographic mechanisms encrypt and provide integrity protection for
	arbitrary sequences of bytes.
      </t>
      <t>
	Cryptographic algorithms and identifiers for use with this
	specification are described in the separate
	JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	Related digital signature and MAC capabilities are described
	in the separate JSON Web Signature (JWS) <xref target="JWS" />
	specification.
      </t>

      <section title='Notational Conventions'>
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in
	  Key words for use in RFCs to Indicate Requirement Levels <xref target='RFC2119' />.
        </t>
      </section>

    </section>

    <section title="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Encryption (JWE)">
	    A data structure representing an encrypted message.
	    The structure consists of five parts:
	    the JWE Header, the JWE Encrypted Key,
	    the JWE Initialization Vector, the JWE Ciphertext, and
	    the JWE Integrity Value.
	  </t>

	  <t hangText="Plaintext">
	    The bytes to be encrypted -- a.k.a., the message.
	    The plaintext can contain an arbitrary sequence of bytes.
	  </t>

	  <t hangText="Ciphertext">
	    An encrypted representation of the Plaintext.
	  </t>

	  <t hangText="Content Encryption Key (CEK)">
	    A symmetric key used to encrypt the Plaintext for the
	    recipient to produce the Ciphertext.
	  </t>

	  <t hangText="Content Integrity Key (CIK)">
	    A key used with a MAC function to ensure the integrity
	    of the Ciphertext and the parameters used to create it.
	  </t>

	  <t hangText="Content Master Key (CMK)">
	    A key from which the CEK and CIK are derived.
	    When key wrapping or key encryption are employed, the CMK
	    is randomly generated and encrypted to the recipient as
	    the JWE Encrypted Key.
	    When direct encryption with a shared symmetric key is employed,
	    the CMK is the shared key.
	    When key agreement without key wrapping is employed,
	    the CMK is the result of the key agreement algorithm.
	  </t>

 	  <t hangText="JSON Text Object">
	    A UTF-8 encoded text string representing a JSON object;
	    the syntax of JSON objects is defined in
	    Section 2.2 of <xref target="RFC4627"/>.
	  </t>

          <t hangText="JWE Header">
	    A JSON Text Object that describes the
	    encryption operations applied to create the JWE Encrypted
	    Key, the JWE Ciphertext, and the JWE Integrity Value.
	  </t>
          <t hangText="JWE Encrypted Key">
	    When key wrapping or key encryption are employed,
	    the Content Master Key (CMK) is encrypted with the
	    intended recipient's key and the resulting encrypted
	    content is recorded as a byte array, which is referred to
	    as the JWE Encrypted Key.
	    Otherwise, when direct encryption with a shared or
	    agreed upon symmetric key is employed,
	    the JWE Encrypted Key is the empty byte array.
	  </t>
          <t hangText="JWE Initialization Vector">
	    A byte array containing the Initialization Vector used
	    when encrypting the Plaintext.
	  </t>
          <t hangText="JWE Ciphertext">
	    A byte array containing the Ciphertext.
	  </t>
	  <t hangText="JWE Integrity Value">
	    A byte array containing a MAC value that ensures the
	    integrity of the Ciphertext and the parameters used to
	    create it.
	  </t>

          <t hangText="Base64url Encoding">
	    The URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the (non URL-safe) '=' padding characters
	    omitted, as permitted by Section 3.2.  (See Appendix C of
	    <xref target="JWS" /> for notes on implementing base64url
	    encoding without padding.)
	  </t>

          <t hangText="Encoded JWE Header">
	    Base64url encoding of the JWE Header.
	  </t>
          <t hangText="Encoded JWE Encrypted Key">
	    Base64url encoding of the JWE Encrypted Key.
	  </t>
          <t hangText="Encoded JWE Initialization Vector">
	    Base64url encoding of the JWE Initialization Vector.
	  </t>
          <t hangText="Encoded JWE Ciphertext">
	    Base64url encoding of the JWE Ciphertext.
	  </t>
	  <t hangText="Encoded JWE Integrity Value">
	    Base64url encoding of the JWE Integrity Value.
	  </t>

	  <t hangText="Header Parameter Name">
	    The name of a member of the JWE Header.
	  </t>
	  <t hangText="Header Parameter Value">
	    The value of a member of the JWE Header.
	  </t>

	  <t hangText="JWE Compact Serialization">
	    A representation of the JWE as the concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Integrity Value
	    in that order, with the five strings being separated
	    by four period ('.') characters.
	  </t>

	  <t hangText="Authenticated Encryption">
	    An Authenticated Encryption algorithm is one that
	    provides an integrated content integrity check.
	    Authenticated Encryption algorithms accept two inputs, the plaintext and the
	    "additional authenticated data" value, and produce two outputs,
	    the ciphertext and the "authentication tag" value.
	    AES Galois/Counter Mode (GCM) is one such algorithm.
	  </t>

	  <t hangText="Collision Resistant Namespace">
	    A namespace that allows names to be allocated in a manner
	    such that they are highly unlikely to collide with other names.
	    For instance, collision resistance can be achieved through
	    administrative delegation of portions of the namespace or
	    through use of collision-resistant name allocation functions.
	    Examples of Collision Resistant Namespaces include:
	    Domain Names,
	    Object Identifiers (OIDs) as defined in the ITU-T X.660
	    and X.670 Recommendation series, and
	    Universally Unique IDentifiers (UUIDs)
	    <xref target="RFC4122"/>.
	    When using an administratively delegated namespace,
	    the definer of a name needs to take
	    reasonable precautions to ensure they are in control of
	    the portion of the namespace they use to define the name.
	  </t>

	  <t hangText="StringOrURI">
	    A JSON string value, with the additional requirement that
	    while arbitrary string values MAY be used, any value
	    containing a ":" character MUST be a URI
	    <xref target="RFC3986"/>.
	    StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied.
	  </t>

        </list>
      </t>
    </section>

    <section title="JSON Web Encryption (JWE) Overview">

      <t>
	JWE represents encrypted content using JSON data
	structures and base64url encoding.  The representation
	consists of five parts:
	the JWE Header,
	the JWE Encrypted Key,
	the JWE Initialization Vector,
	the JWE Ciphertext, and
	the JWE Integrity Value.
	In the Compact Serialization, the five parts are
	base64url-encoded for transmission, and represented
	as the concatenation of the encoded strings in that order,
	with the five strings being separated by four period ('.') characters.
	(A JSON Serialization for this information is defined in the separate
	JSON Web Encryption JSON Serialization (JWE-JS) <xref target="JWE-JS" />
	specification.)
      </t>
      <t>
	JWE utilizes encryption to ensure the confidentiality
	of the Plaintext.  JWE adds a content
	integrity check if not provided by the underlying encryption
	algorithm.
      </t>

      <section title="Example JWE using RSAES OAEP and AES GCM">
	<t>
	  This example encrypts the plaintext
	  "Live long and prosper."
	  to the recipient using RSAES OAEP and AES GCM.
	  The AES GCM algorithm has an integrated integrity check.
	</t>
	<t>
	  The following example JWE Header declares that:
	  <list style="symbols">
	    <t>
	      the Content Master Key is encrypted to the recipient
	      using the RSAES OAEP algorithm to produce the JWE
	      Encrypted Key and
	    </t>
	    <t>
	      the Plaintext is encrypted using the AES GCM
	      algorithm with a 256 bit key to produce the Ciphertext.
	    </t>
	  </list>
	</t>

	<figure><artwork><![CDATA[
  {"alg":"RSA-OAEP","enc":"A256GCM"}
]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWE Header yields this Encoded JWE Header value:
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
]]></artwork></figure>
	
	<t>
	  The remaining steps to finish creating this JWE are:
	  <list style="symbols">
	    <t>
	      Generate a random Content Master Key (CMK)
	    </t>
	    <t>
	      Encrypt the CMK with the recipient's public key using the RSAES OAEP
	      algorithm to produce the JWE Encrypted Key
	    </t>
	    <t>
	      Base64url encode the JWE Encrypted Key to produce the Encoded JWE Encrypted Key
	    </t>
	    <t>
	      Generate a random JWE Initialization Vector
	    </t>
	    <t>
	      Base64url encode the JWE Initialization Vector to produce the Encoded JWE Initialization Vector
	    </t>
	    <t>
	      Concatenate
	      the Encoded JWE Header value, a period character ('.'),
	      the Encoded JWE Encrypted Key, a second period character ('.'), and
	      the Encoded JWE Initialization Vector
	      to create the "additional authenticated data"
	      parameter for the AES GCM algorithm
	    </t>
	    <t>
	      Encrypt the Plaintext with AES GCM, using the CMK as the encryption key,
	      the JWE Initialization Vector,
	      and the "additional authenticated data" value above,
	      requesting a 128 bit "authentication tag" output
	    </t>
	    <t>
	      Base64url encode the resulting Ciphertext to create the Encoded JWE Ciphertext
	    </t>
	    <t>
	      Base64url encode the resulting "authentication tag" to create the Encoded JWE Integrity Value
	    </t>
	    <t>
	      Assemble the final representation:
	      The Compact Serialization of this result is the
	      concatenation of
	      the Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Integrity Value
	      in that order, with the five strings
	      being separated by four period ('.') characters.
	    </t>
	  </list>

	  The final result in this example
	  (with line breaks for display purposes only) is:
	</t>
	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  M2XxpbORKezKSzzQL_95-GjiudRBTqn_omS8z9xgoRb7L0Jw5UsEbxmtyHn2T71m
  rZLkjg4Mp8gbhYoltPkEOHvAopz25-vZ8C2e1cOaAo5WPcbSIuFcB4DjBOM3t0UA
  O6JHkWLuAEYoe58lcxIQneyKdaYSLbV9cKqoUoFQpvKWYRHZbfszIyfsa18rmgTj
  zrtLDTPnc09DSJE24aQ8w3i8RXEDthW9T1J6LsTH_vwHdwUgkI-tC2PNeGrnM-dN
  SfzF3Y7-lwcGy0FsdXkPXytvDV7y4pZeeUiQ-0VdibIN2AjjfW60nfrPuOjepMFG
  6BBBbR37pHcyzext9epOAQ.
  48V1_ALb6US04U3b.
  _e21tGGhac_peEFkLXr2dMPUZiUkrw.
  7V5ZDko0v_mf2PAc4JMiUg
]]></artwork></figure>

	<t>
	  See <xref target="OAEPGCMExample"/> for the complete details of computing this JWE.
	</t>
      </section>


      <section title="Example JWE using RSAES-PKCS1-V1_5 and AES CBC">
	<t>
	  This example encrypts the plaintext
	  "No matter where you go, there you are."
	  to the recipient using RSAES-PKCS1-V1_5 and AES CBC.
	  AES CBC does not have an integrated integrity check,
	  so a separate integrity check calculation is performed using HMAC SHA-256,
	  with separate encryption and integrity keys being derived from a master key
	  using the Concat KDF with the SHA-256 digest function.
	</t>
	<t>
	  The following example JWE Header (with line breaks for display purposes only) declares that:
	  <list style="symbols">
	    <t>
	      the Content Master Key is encrypted to the recipient
	      using the RSAES-PKCS1-V1_5 algorithm to produce the JWE
	      Encrypted Key and
	    </t>
	    <t>
	      the Plaintext is encrypted using the AES CBC
	      algorithm with a 128 bit key to produce the Ciphertext,
	      with the integrity of the
	      Ciphertext and the parameters used to create it being
	      secured using the HMAC SHA-256 algorithm.
	    </t>
	  </list>
	</t>

	<figure><artwork><![CDATA[
  {"alg":"RSA1_5","enc":"A128CBC+HS256"}
]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWE Header yields this Encoded JWE Header value:
	</t>

	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDK0hTMjU2In0
]]></artwork></figure>
	
	<t>
	  The remaining steps to finish creating this JWE are like the previous example,
	  but with an additional step to compute the separate integrity value:
	  <list style="symbols">
	    <t>
	      Generate a random Content Master Key (CMK)
	    </t>
	    <t>
	      Encrypt the CMK with the recipient's public key using the RSAES-PKCS1-V1_5
	      algorithm to produce the JWE Encrypted Key
	    </t>
	    <t>
	      Base64url encode the JWE Encrypted Key to produce the Encoded JWE Encrypted Key
	    </t>
	    <t>
	      Generate a random JWE Initialization Vector
	    </t>
	    <t>
	      Base64url encode the JWE Initialization Vector to produce the Encoded JWE Initialization Vector
	    </t>
	    <t>
	      Use the Concat key derivation function
	      to derive Content Encryption Key (CEK)
	      and Content Integrity Key (CIK) values from the CMK
	    </t>
	    <t>
	      Encrypt the Plaintext with AES CBC using
	      the CEK and JWE Initialization Vector to produce the Ciphertext
	    </t>
	    <t>
	      Base64url encode the resulting Ciphertext to create the Encoded JWE Ciphertext
	    </t>
	    <t>
	      Concatenate
	      the Encoded JWE Header value, a period character ('.'),
	      the Encoded JWE Encrypted Key, a second period character ('.'),
	      the Encoded JWE Initialization Vector, a third period ('.') character, and
	      the Encoded JWE Ciphertext
	      to create the value to integrity protect
	    </t>
	    <t>
	      Compute the HMAC SHA-256 of this value using the CIK to create the JWE Integrity Value
	    </t>
	    <t>
	      Base64url encode the resulting JWE Integrity Value to create the Encoded JWE Integrity Value
	    </t>
	    <t>
	      Assemble the final representation:
	      The Compact Serialization of this result is the
	      concatenation of
	      the Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Integrity Value
	      in that order, with the five strings
	      being separated by four period ('.') characters.
	    </t>
	  </list>

	  The final result in this example
	  (with line breaks for display purposes only) is:
	</t>
	<figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDK0hTMjU2In0.
  O6AqXqgVlJJ4c4lp5sXZd7bpGHAw6ARkHUeXQxD1cAW4-X1x0qtj_AN0mukqEOl4
  Y6UOwJXIJY9-G1ELK-RQWrKH_StR-AM9H7GpKmSEji8QYOcMOjr-u9H1Lt_pBEie
  G802SxWz0rbFTXRcj4BWLxcpCtjUZ31AP-sc-L_eCZ5UNl0aSRNqFskuPkzRsFZR
  DJqSSJeVOyJ7pZCQ83fli19Vgi_3R7XMUqluQuuc7ZHOWixi47jXlBTlWRZ5iFxa
  S8G6J8wUrd4BKggAw3qX5XoIfXQVlQZE0Vmkq_zQSIo5LnFKyowooRcdsEuNh9B9
  Mkyt0ZQElG-jGdtHWjZSOA.
  AxY8DCtDaGlsbGljb3RoZQ.
  1eBWFgcrz40wC88cgv8rPgu3EfmC1p4zT0kIxxfSF2zDJcQ-iEHk1jQM95xAdr5Z.
  RBGhYzE8_cZLHjJqqHuLhzbgWgL_wV3LDSUrcbkOiIA
]]></artwork></figure>

	<t>
	  See <xref target="RSACBCExample"/> for the complete details of computing this JWE.
	</t>
      </section>
    </section>

    <section title="JWE Header">

      <t>
	The members of the JSON object represented by the JWE Header
	describe the encryption applied to the Plaintext and optionally
	additional properties of the JWE.
	The Header Parameter Names within this object MUST be unique;
	JWEs with duplicate Header Parameter Names MUST be rejected.
	Implementations MUST understand the entire contents of the
	header; otherwise, the JWE MUST be rejected.
      </t>
      <t>
	There are two ways of distinguishing whether a header is a
	JWS Header or a JWE Header.
	The first is by examining the <spanx style="verb">alg</spanx>
	(algorithm) header value.
	If the value represents a digital signature or MAC algorithm,
	or is the value <spanx style="verb">none</spanx>, it is for a JWS;
	if it represents an encryption or key agreement algorithm, it is for a JWE.
	A second method is determining whether an
	<spanx style="verb">enc</spanx> (encryption method) member exists.
	If the <spanx style="verb">enc</spanx> member exists, it is a JWE;
	otherwise, it is a JWS.
	Both methods will yield the same result for all legal input values.
      </t>
      <t>
        There are three classes of Header Parameter Names:
	Reserved Header Parameter Names, Public Header Parameter Names,
	and Private Header Parameter Names.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following Header Parameter Names are reserved
	  with meanings as defined below.  All the
	  names are short because a core goal of JWE is for the
	  representations to be compact.
	</t>
	<t>
	  Additional reserved Header Parameter Names MAY be defined
	  via the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="JWS" />.
	  As indicated by the common registry, JWSs and JWEs share a
	  common header parameter space; when a parameter is used by
	  both specifications, its usage must be compatible
	  between the specifications.
	</t>

	<section title='"alg" (Algorithm) Header Parameter' anchor="algDef">
	  <t>
	    The <spanx style="verb">alg</spanx> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    encrypt or determine the value of the Content Master Key (CMK).
	    The algorithm specified by the <spanx style="verb">alg</spanx> value
	    MUST be supported by the implementation
	    and there MUST be a key for use with that algorithm associated with the
	    intended recipient
	    or the JWE MUST be rejected.
	    <spanx style="verb">alg</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" /> or be
	    a value that contains a Collision Resistant Namespace.
	    The <spanx style="verb">alg</spanx> value is a case sensitive string
	    containing a StringOrURI value.
	    Use of this header parameter is REQUIRED.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">alg</spanx> values can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 4.1 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"enc" (Encryption Method) Header Parameter' anchor="encDef">
	  <t>
	    The <spanx style="verb">enc</spanx> (encryption method)
	    header parameter identifies the block
	    encryption algorithm used to encrypt the Plaintext to produce the Ciphertext.
	    This algorithm MUST be an Authenticated Encryption algorithm with a specified key length.
	    The algorithm specified by the <spanx style="verb">enc</spanx> value
	    MUST be supported by the implementation
	    or the JWE MUST be rejected.
	    <spanx style="verb">enc</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" /> or be
	    a value that contains a Collision Resistant Namespace.
	    The <spanx style="verb">enc</spanx> value is a case sensitive string
	    containing a StringOrURI value.
	    Use of this header parameter is REQUIRED.
	  </t>
	  <t>
	    A list of defined <spanx style="verb">enc</spanx> values can be found
	    in the IANA JSON Web Signature and Encryption Algorithms registry
	    <xref target="JWA" />;
	    the initial contents of this registry are the values defined in
	    Section 4.2 of the
	    JSON Web Algorithms (JWA) <xref target="JWA" /> specification.
	  </t>
	</section>

	<section title='"epk" (Ephemeral Public Key) Header Parameter' anchor="epkDef">
	  <t>
	    The <spanx style="verb">epk</spanx> (ephemeral public key)
	    value created by the originator for the use in key agreement algorithms.
	    This key is represented as a JSON Web Key <xref target="JWK" /> value.
	    Use of this header parameter is OPTIONAL, although its use is
	    REQUIRED with some <spanx style="verb">alg</spanx> algorithms.
	  </t>
	</section>

	<section title='"zip" (Compression Algorithm) Header Parameter' anchor="zipDef">
	  <t>
	    The <spanx style="verb">zip</spanx> (compression algorithm)
	    applied to the Plaintext before encryption, if any.
	    If present, the value of the <spanx style="verb">zip</spanx>
	    header parameter MUST be the case sensitive string "DEF".
	    Compression is performed with the
	    DEFLATE <xref target="RFC1951" /> algorithm.
	    If no <spanx style="verb">zip</spanx> parameter is present,
	    no compression is applied to the Plaintext before encryption.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"jku" (JWK Set URL) Header Parameter' anchor="jkuDef">
	  <t>
	    The <spanx style="verb">jku</spanx> (JWK Set URL)
	    header parameter is a URI <xref target="RFC3986"/> that refers to a
	    resource for a set of JSON-encoded public keys, one of
	    which corresponds to the key used to
	    encrypt the JWE; this can be used to determine the private key needed to decrypt the JWE.
	    The keys MUST be encoded as a JSON Web Key Set (JWK Set) <xref target="JWK" />.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"jwk" (JSON Web Key) Header Parameter' anchor="jwkDef">
	  <t>
	    The <spanx style="verb">jwk</spanx> (JSON Web Key)
	    header parameter is a public key that corresponds to the key used to
	    encrypt the JWE; this can be used to determine the private key needed to decrypt the JWE.
	    This key is represented as a JSON Web Key <xref target="JWK" />.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5u" (X.509 URL) Header Parameter' anchor="x5uDef">
	  <t>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) header
	    parameter is a URI <xref target="RFC3986"/> that refers to a resource for
	    the X.509 public key certificate or certificate chain <xref target="RFC5280"/>
	    corresponding to the key used to
	    encrypt the JWE; this can be used to determine the private key needed to decrypt the JWE.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <xref target="RFC5280">RFC 5280</xref> in PEM encoded form
	    <xref target="RFC1421"/>.
	    The certificate containing the public key of the entity
	    that encrypted the JWE MUST be the first certificate.  This
	    MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The protocol used to acquire the resource MUST provide
	    integrity protection; an HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818"/> <xref target="RFC5246"/>;
	    the identity of the server MUST be validated, as per
	    Section 3.1 of HTTP Over TLS <xref target='RFC2818'/>.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"x5t" (X.509 Certificate Thumbprint) Header Parameter' anchor="x5tDef">
	  <t>
	    The <spanx style="verb">x5t</spanx> (X.509 Certificate Thumbprint)
	    header parameter provides a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of
	    the X.509 certificate <xref target="RFC5280"/> corresponding to the key used to
	    encrypt the JWE; this can be used to determine the private key needed to decrypt the JWE.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    If, in the future, certificate thumbprints need to be
	    computed using hash functions other than SHA-1, it is
	    suggested that additional related header parameters be
	    defined for that purpose.  For example, it is suggested
	    that a new <spanx style="verb">x5t#S256</spanx> (X.509
	    Certificate Thumbprint using SHA-256) header parameter
	    could be defined by registering it in the IANA
	    JSON Web Signature and Encryption Header Parameters
	    registry <xref target="JWS" />.
	  </t>
	</section>

	<section title='"x5c" (X.509 Certificate Chain) Header Parameter' anchor="x5cDef">
	  <t>
	    The <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    header parameter contains the X.509 public key
	    certificate or certificate chain <xref target="RFC5280"/>
	    corresponding to the key used to
	    encrypt the JWE; this can be used to determine the private key needed to decrypt the JWE.
	    The certificate or certificate chain is represented as an
	    array of certificate value strings.  Each string is a
	    base64 encoded (<xref target="RFC4648"/> Section 4 -- not base64url encoded)
	    DER <xref target="ITU.X690.1994"/> PKIX certificate value.
	    The certificate containing the public key of the entity
	    that encrypted the JWE MUST be the first certificate.  This
	    MAY be followed by additional certificates, with each
	    subsequent certificate being the one used to certify the
	    previous one.
	    The recipient MUST verify the certificate chain according
	    to <xref target="RFC5280"/> and reject the JWE if any
	    validation failure occurs.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    See Appendix B of <xref target="JWS"/> for an example
	    <spanx style="verb">x5c</spanx> value.
	  </t>
	</section>

	<section title='"kid" (Key ID) Header Parameter' anchor="kidDef">
	  <t>
	    The <spanx style="verb">kid</spanx> (key ID) header
	    parameter is a hint indicating which key was used to
	    encrypt the JWE; this can be used to determine the private key needed to decrypt the JWE.
	    This parameter allows originators to explicitly signal a change of
	    key to recipients.
	    Should the recipient be unable to locate a key
	    corresponding to the <spanx style="verb">kid</spanx>
	    value, they SHOULD treat that condition as an error.
	    The interpretation of the
	    <spanx style="verb">kid</spanx> value is unspecified.
	    Its value MUST be a string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    When used with a JWK, the <spanx style="verb">kid</spanx>
	    value MAY be used to match a JWK <spanx style="verb">kid</spanx>
	    parameter value.
	  </t>
	</section>

	<section title='"typ" (Type) Header Parameter' anchor="typDef">
	  <t>
	    The <spanx style="verb">typ</spanx> (type) header
	    parameter is used to declare the type of this object.
	    The type value <spanx style="verb">JWE</spanx> MAY be used
	    to indicate that this object is a JWE.
	    The <spanx style="verb">typ</spanx> value is a case sensitive string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    MIME Media Type <xref target="RFC2046"/>
	    values MAY be used as <spanx style="verb">typ</spanx> values.
	  </t>
	  <t>
	    <spanx style="verb">typ</spanx> values SHOULD either be
	    registered in the IANA
	    JSON Web Signature and Encryption Type Values registry
	    <xref target="JWS" /> or be
	    a value that contains a Collision Resistant Namespace.
	  </t>
	</section>

	<section title='"cty" (Content Type) Header Parameter' anchor="ctyDef">
	  <t>
	    The <spanx style="verb">cty</spanx> (content type) header
	    parameter is used to declare the type of the encrypted
	    content (the Plaintext).
	    The <spanx style="verb">cty</spanx> value is a case sensitive string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	  <t>
	    The values used for the <spanx style="verb">cty</spanx>
	    header parameter come from the same value space as the
	    <spanx style="verb">typ</spanx> header parameter,
	    with the same rules applying.
	  </t>
	</section>

	<section title='"apu" (Agreement PartyUInfo) Header Parameter' anchor="apuDef">
	  <t>
	    The <spanx style="verb">apu</spanx> (agreement PartyUInfo)
	    value for key agreement algorithms using it
	    (such as <spanx style="verb">ECDH-ES</spanx>),
	    represented as a base64url encoded string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"apv" (Agreement PartyVInfo) Header Parameter' anchor="apvDef">
	  <t>
	    The <spanx style="verb">apv</spanx> (agreement PartyVInfo)
	    value for key agreement algorithms using it
	    (such as <spanx style="verb">ECDH-ES</spanx>),
	    represented as a base64url encoded string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"epu" (Encryption PartyUInfo) Header Parameter' anchor="epuDef">
	  <t>
	    The <spanx style="verb">epu</spanx> (encryption PartyUInfo)
	    value for plaintext encryption algorithms using it
	    (such as <spanx style="verb">A128CBC+HS256</spanx>),
	    represented as a base64url encoded string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

	<section title='"epv" (Encryption PartyVInfo) Header Parameter' anchor="epvDef">
	  <t>
	    The <spanx style="verb">epv</spanx> (encryption PartyVInfo)
	    value for plaintext encryption algorithms using it
	    (such as <spanx style="verb">A128CBC+HS256</spanx>),
	    represented as a base64url encoded string.
	    Use of this header parameter is OPTIONAL.
	  </t>
	</section>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional Header Parameter Names can be defined by those
	  using JWEs. However, in order to prevent collisions, any new
	  Header Parameter Name SHOULD either be registered in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="JWS" /> or be a Public Name:
	  a value that contains a Collision Resistant Namespace.
	  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the Header Parameter Name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWEs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWE may agree to use Header Parameter Names
	  that are Private Names:  names that are
	  not Reserved Names <xref target="ReservedHeaderParameterName"></xref>
	  or Public Names <xref target="PublicHeaderParameterName"></xref>.
	  Unlike Public Names, Private Names are subject to collision and
	  should be used with caution.
	</t>

      </section>
    </section>

    <section title="Producing and Consuming JWEs" anchor="JWERules">

      <section anchor="sec.encryption" title="Message Encryption">
	<t>
	  The message encryption process is as follows.  The order of
	  the steps is not significant in cases where there are no
	  dependencies between the inputs and outputs of the steps.
	</t>

	<t><list style="numbers">
	  <t>
	    When key wrapping, key encryption,
	    or key agreement with key wrapping are employed,
	    generate a random Content Master Key (CMK).
	    See <xref target="RFC4086">RFC 4086</xref> for
	    considerations on generating random values.
	    The CMK MUST have a length equal to that
	    required for the block encryption algorithm.
	  </t>
	  <t>
	    When key agreement is employed, use the key agreement algorithm
	    to compute the value of the agreed upon key.
	    When key agreement without key wrapping is employed,
	    let the Content Master Key (CMK) be the agreed upon key.
	    When key agreement with key wrapping is employed,
	    the agreed upon key will be used to wrap the CMK.
	  </t>
	  <t>
	    When key wrapping, key encryption,
	    or key agreement with key wrapping are employed,
	    encrypt the CMK for the recipient (see <xref
	    target="sec.encrypt_cmk"/>) and let the result be the
	    JWE Encrypted Key.
	    Otherwise, when direct encryption with a shared or
	    agreed upon symmetric key is employed,
	    let the JWE Encrypted Key be the empty byte array.
	  </t>
	  <t>
	    When direct encryption with a shared symmetric key is employed,
	    let the Content Master Key (CMK) be the shared key.
	  </t>
	  <t>
	    Base64url encode the JWE Encrypted Key to create the
	    Encoded JWE Encrypted Key.
	  </t>
	  <t>
	    Generate a random JWE Initialization Vector of the correct size
	    for the block encryption algorithm (if required for the algorithm);
	    otherwise, let the JWE Initialization Vector be the empty byte string.
	  </t>
	  <t>
	    Base64url encode the JWE Initialization Vector to create the
	    Encoded JWE Initialization Vector.
	  </t>
	  <t>
	    Compress the Plaintext if a <spanx
	    style="verb">zip</spanx> parameter was included.
	  </t>
	  <t>
	    Serialize the (compressed) Plaintext into a byte sequence M.
	  </t>
	  <t>
	    Create a JWE Header containing the encryption
	    parameters used.
	    Note that white space is explicitly allowed
	    in the representation and no canonicalization need be performed
	    before encoding.
	  </t>
	  <t>
	    Base64url encode the bytes of the UTF-8 representation of
	    the JWE Header to create the Encoded JWE Header.
	  </t>
	  <t>
	    Let the "additional authenticated data" value be the bytes of the ASCII
	    representation of the concatenation of
	    the Encoded JWE Header, a period ('.') character,
	    the Encoded JWE Encrypted Key, a second period character ('.'), and
	    the Encoded JWE Initialization Vector.
	  </t>
	  <t>
	    Encrypt M using the CMK, the JWE Initialization Vector, and
	    the "additional authenticated data" value
	    using the specified block encryption algorithm
	    to create the JWE Ciphertext value and the JWE Integrity Value
	    (which is the "authentication tag" output from the calculation).
	  </t>
	  <t>
	    Base64url encode the JWE Ciphertext to create the Encoded JWE Ciphertext.
	  </t>
	  <t>
	    Base64url encode the JWE Integrity Value to create the
	    Encoded JWE Integrity Value.
	  </t>
	  <t>
	    The five encoded parts, taken together, are the result.
	  </t>
	  <t>
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Integrity Value
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	</list></t>
      </section>

      <section anchor="sec.decryption" title="Message Decryption">
	<t>
	  The message decryption process is the reverse of the
	  encryption process.  The order of the steps is not significant
	  in cases where there are no dependencies between the inputs
	  and outputs of the steps.  If any of these steps fails, the
	  JWE MUST be rejected.
	</t>

	<t>
	  <list style="numbers">
	    <t>
	      Determine
	      the Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Integrity Value
	      values contained in the JWE.
	      When using the Compact Serialization, these five values are
	      represented in that order, separated by four period ('.') characters.
	    </t>
	    <t>
	      The Encoded JWE Header,
	      the Encoded JWE Encrypted Key,
	      the Encoded JWE Initialization Vector,
	      the Encoded JWE Ciphertext, and
	      the Encoded JWE Integrity Value
	      MUST be successfully base64url decoded following the
	      restriction that no padding characters have been used.
	    </t>
	    <t>
	      The resulting JWE Header MUST be completely valid
	      JSON syntax conforming to <xref target="RFC4627">RFC 4627</xref>.
	    </t>
	    <t>
	      The resulting JWE Header MUST be validated to only include
	      parameters and values whose syntax and semantics are both
	      understood and supported.
	    </t>
	    <t>
	      Verify that the JWE uses a key known to the recipient.
	    </t>
	    <t>
	      When key agreement is employed, use the key agreement algorithm
	      to compute the value of the agreed upon key.
	      When key agreement without key wrapping is employed,
	      let the Content Master Key (CMK) be the agreed upon key.
	      When key agreement with key wrapping is employed,
	      the agreed upon key will be used to decrypt the JWE Encrypted Key.
	    </t>
	    <t>
	      When key wrapping, key encryption,
	      or key agreement with key wrapping are employed,
	      decrypt the JWE Encrypted Key to produce the Content
	      Master Key (CMK).
	      The CMK MUST have a length equal to that
	      required for the block encryption algorithm.
	    </t>
	    <t>
	      When direct encryption with a shared symmetric key is employed,
	      let the Content Master Key (CMK) be the shared key.
	    </t>
	    <t>
	      Let the "additional authenticated data" value be the bytes of the ASCII
	      representation of the concatenation of
	      the Encoded JWE Header, a period ('.') character,
	      the Encoded JWE Encrypted Key, a second period character ('.'), and
	      the Encoded JWE Initialization Vector.
	    </t>
	    <t>
	      Decrypt the JWE Ciphertext using the CMK, the JWE Initialization Vector,
	      the "additional authenticated data" value,
	      and the JWE Integrity Value
	      (which is the "authentication tag" input to the calculation)
	      using the specified block encryption algorithm,
	      returning the decrypted plaintext and verifying the JWE Integrity Value
	      in the manner specified for the algorithm,
	      rejecting the input without emitting any decrypted output
	      if the JWE Integrity Value is incorrect.
	    </t>
	    <t>
	      Uncompress the decrypted plaintext
	      if a <spanx style="verb">zip</spanx> parameter was included.
	    </t>
	    <t>
	      Output the resulting Plaintext.
	    </t>
	  </list>
	</t>
      </section>

      <section title="String Comparison Rules" anchor="StringComparison">

	<t>
	  Processing a JWE inevitably requires comparing known strings
	  to values in JSON objects. For example, in checking what the
	  encryption method is, the Unicode string encoding
	  <spanx style="verb">enc</spanx> will be
	  checked against the member names in the JWE Header
	  to see if there is a matching Header Parameter Name.
	</t>
	<t>
	  Comparisons between JSON strings and other Unicode strings
	  MUST be performed by comparing Unicode code points without normalization
	  as specified in the String Comparison Rules in Section 5.3 of <xref target="JWS" />.
	</t>
      </section>

    </section>

    <section title="Encrypting JWEs with Cryptographic Algorithms" anchor="Encrypting">

      <t>
	JWE uses cryptographic algorithms to encrypt the Plaintext
	and the Content Encryption Key (CMK) and to provide integrity
	protection for the JWE Header, JWE Encrypted Key, and JWE Ciphertext.
	The JSON Web Algorithms (JWA) <xref target="JWA" />
	specification specifies a set of cryptographic algorithms and
	identifiers to be used with this specification
	and defines registries for additional such algorithms.
	Specifically, Section 4.1 specifies a set of
	<spanx style="verb">alg</spanx> (algorithm) header parameter values and
	Section 4.2 specifies a set of
	<spanx style="verb">enc</spanx> (encryption method) header parameter values
	intended for use this specification.
	It also describes the semantics and operations that are
	specific to these algorithms.
      </t>
      <t>
	Public keys employed for encryption can be identified using the
	Header Parameter methods described in <xref
	target="ReservedHeaderParameterName" /> or can be distributed
	using methods that are outside the scope of this
	specification.
      </t>

      <section anchor="sec.encrypt_cmk" title="CMK Encryption">
	<t>
	  JWE supports three forms of Content Master Key (CMK) encryption:

	  <list style="symbols">
	    <t>
	      Asymmetric encryption under the recipient's public key.
	    </t>
	    <t>
	      Symmetric encryption under a key shared between the sender and receiver.
	    </t>
	    <t>
	      Symmetric encryption under a key agreed upon between the sender and receiver.
	    </t>
	  </list>

	  See the algorithms registered for <spanx style="verb">enc</spanx> usage in the IANA
	  JSON Web Signature and Encryption Algorithms registry <xref target="JWA" />
	  and Section 4.1 of the
	  JSON Web Algorithms (JWA) <xref target="JWA" /> specification
	  for lists of encryption algorithms that can be used for CMK encryption.
	</t>
      </section>

    </section>

    <section title="IANA Considerations" anchor="IANA">

      <section title="Registration of JWE Header Parameter Names" anchor="HeaderParamReg">
	<t>
	  This specification registers the Header Parameter Names defined in
	  <xref target="ReservedHeaderParameterName"/> in the IANA
	  JSON Web Signature and Encryption Header Parameters registry
	  <xref target="JWS" />.
	</t>

        <section title='Registry Contents'>
          <t> <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">alg</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="algDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">enc</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="encDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">epk</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="epkDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
            <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">zip</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="zipDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jku</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="jkuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">jwk</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification document(s): <xref target="jwkDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5u</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5uDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5t</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5tDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">x5c</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="x5cDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">kid</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="kidDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">typ</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="typDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">cty</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="ctyDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
 	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">apu</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="apuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
 	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">apv</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="apvDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
 	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">epu</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="epuDef"/> of [[ this document ]]
              </t>
            </list>
	  </t>
	  <t>
 	    <list style='symbols'>
              <t>
                Header Parameter Name: <spanx style="verb">epv</spanx>
              </t>
	      <t>
		Header Parameter Usage Location(s): JWE
	      </t>
              <t>
                Change Controller: IETF
              </t>
              <t>
                Specification Document(s): <xref target="epvDef"/> of [[ this document ]]
              </t>
            </list>
          </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section title='JSON Web Signature and Encryption Type Values Registration'>
	<section title='Registry Contents'>
	<t>
	  This specification registers the <spanx style='verb'>JWE</spanx>
	  type value in the
	  IANA JSON Web Signature and Encryption Type Values registry <xref target="JWS"/>:
	</t>
	<t> <?rfc subcompact="yes"?>
	  <list style='symbols'>
	    <t>
	      "typ" Header Parameter Value: <spanx style='verb'>JWE</spanx>
	    </t>
	    <t>
	      Abbreviation for MIME Type: application/jwe
	    </t>
	    <t>
	      Change Controller: IETF
	    </t>
	    <t>
	      Specification Document(s): <xref target="typDef"/> of [[ this document ]]
	    </t>
	  </list>
	</t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section title="Media Type Registration">
	<section title='Registry Contents'>
	  <t>
	    This specification registers the <spanx
	    style="verb">application/jwe</spanx> Media Type <xref target="RFC2046"/>
	    in the MIME Media Type registry <xref target="RFC4288"/>
	    to indicate that the content is a JWE using the Compact Serialization.
	  </t>
	  <t> <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Type Name: application
	      </t>
	      <t>
		Subtype Name: jwe
	      </t>
	      <t>
		Required Parameters: n/a
	      </t>
	      <t>
		Optional Parameters: n/a
	      </t>
	      <t>
		Encoding considerations: JWE values are encoded as a
		series of base64url encoded values (some of which may be the
		empty string) separated by period ('.') characters
	      </t>
	      <t>
		Security Considerations: See the Security Considerations section of this document
	      </t>
	      <t>
		Interoperability Considerations: n/a
	      </t>
	      <t>
		Published Specification: [[ this document ]]
	      </t>
	      <t>
		Applications that use this media type:
		OpenID Connect and other applications using encrypted JWTs
	      </t>
	      <t>
		Additional Information: Magic number(s): n/a,
		File extension(s): n/a,
		Macintosh file type code(s): n/a
	      </t>
	      <t>
		Person &amp; email address to contact for further information: Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Intended Usage: COMMON
	      </t>
	      <t>
		Restrictions on Usage: none
	      </t>
	      <t>
		Author: Michael B. Jones, mbj@microsoft.com
	      </t>
	      <t>
		Change Controller: IETF
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	All of the security issues faced by any cryptographic application
	must be faced by a JWS/JWE/JWK agent.  Among these issues are protecting
	the user's private and symmetric keys, preventing various attacks, and helping the
	user avoid mistakes such as inadvertently encrypting a message for
	the wrong recipient.  The entire list of security considerations is
	beyond the scope of this document.
      </t>
      <t>
	All the security considerations in the JWS specification
	also apply to this specification.
	Likewise, all the security considerations in
	<xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	also apply to JWE, other than those that are XML specific.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.1951.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4288.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml' ?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml2/_reference.ITU.X690.1994.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-xmlenc-core1-20120313.xml" ?>

      <reference anchor="JWS">
        <front>
          <title>JSON Web Signature (JWS)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <date day="27" month="December" year="2012" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-signature" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature" type="HTML" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="27" month="December" year="2012" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-key" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key" type="HTML" />
      </reference>

      <reference anchor="JWA">
        <front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="27" month="December" year="2012" />
        </front>
        <seriesInfo value="draft-ietf-jose-json-web-algorithms" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms" type="HTML" />
      </reference>

    </references>

    <references title="Informative References">
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4122.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml' ?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-rescorla-jsms-00.xml" ?>

      <reference anchor="JWE-JS">
        <front>
          <title abbrev="JWE JSON Serialization (JWE-JS)">JSON Web Encryption JSON Serialization (JWE-JS)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="27" month="December" year="2012" />
        </front>
        <seriesInfo value="draft-jones-jose-jwe-json-serialization" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-jones-jose-jwe-json-serialization" type="HTML" />
      </reference>

      <reference anchor="JSE">
        <front>
          <title>JSON Simple Encryption</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization abbrev="NRI">Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/enc/1.0/" type="HTML" />
      </reference>

    </references>


    <section title="JWE Examples" anchor="JWEExamples">

      <t>
	This section provides examples of JWE computations.
      </t>


      <section title="Example JWE using RSAES OAEP and AES GCM" anchor="OAEPGCMExample">
	<t>
	  This example encrypts the plaintext
	  "Live long and prosper."
	  to the recipient using RSAES OAEP and AES GCM.
	  The AES GCM algorithm has an integrated integrity check.
	  The representation of this plaintext is:
	</t>
	<t>
[76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32, 112, 114,
 111, 115, 112, 101, 114, 46]
	</t>

	<section title="JWE Header">
	  <t>
	    The following example JWE Header declares that:
	    <list style="symbols">
	      <t>
		the Content Master Key is encrypted to the recipient
		using the RSAES OAEP algorithm to produce the JWE
		Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES GCM
		algorithm with a 256 bit key to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA-OAEP","enc":"A256GCM"}
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Header">
	  <t>
	    Base64url encoding the bytes of the UTF-8 representation of
	    the JWE Header yields this Encoded JWE Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ
]]></artwork></figure>
	</section>

	<section title="Content Master Key (CMK)">
	  <t>
	    Generate a 256 bit random Content Master Key (CMK).
	    In this example, the value is:
	  </t>
	  <t>
[177, 161, 244, 128, 84, 143, 225, 115, 63, 180, 3, 255, 107, 154, 212, 246,
 138, 7, 110, 91, 112, 46, 34, 105, 47, 130, 203, 46, 122, 234, 64, 252]
	  </t>
	</section>

	<section title="Key Encryption">
	  <t>
	    Encrypt the CMK with the recipient's public key using the RSAES OAEP
	    algorithm to produce the JWE Encrypted Key.
	    In this example, the RSA key parameters are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>Modulus</c>
	    <c>
[161, 168, 84, 34, 133, 176, 208, 173, 46, 176, 163, 110, 57, 30, 135, 227,
 9, 31, 226, 128, 84, 92, 116, 241, 70, 248, 27, 227, 193, 62, 5, 91,
 241, 145, 224, 205, 141, 176, 184, 133, 239, 43, 81, 103, 9, 161, 153, 157,
 179, 104, 123, 51, 189, 34, 152, 69, 97, 69, 78, 93, 140, 131, 87, 182,
 169, 101, 92, 142, 3, 22, 167, 8, 212, 56, 35, 79, 210, 222, 192, 208,
 252, 49, 109, 138, 173, 253, 210, 166, 201, 63, 102, 74, 5, 158, 41, 90,
 144, 108, 160, 79, 10, 89, 222, 231, 172, 31, 227, 197, 0, 19, 72, 81,
 138, 78, 136, 221, 121, 118, 196, 17, 146, 10, 244, 188, 72, 113, 55, 221,
 162, 217, 171, 27, 57, 233, 210, 101, 236, 154, 199, 56, 138, 239, 101, 48,
 198, 186, 202, 160, 76, 111, 234, 71, 57, 183, 5, 211, 171, 136, 126, 64,
 40, 75, 58, 89, 244, 254, 107, 84, 103, 7, 236, 69, 163, 18, 180, 251,
 58, 153, 46, 151, 174, 12, 103, 197, 181, 161, 162, 55, 250, 235, 123, 110,
 17, 11, 158, 24, 47, 133, 8, 199, 235, 107, 126, 130, 246, 73, 195, 20,
 108, 202, 176, 214, 187, 45, 146, 182, 118, 54, 32, 200, 61, 201, 71, 243,
 1, 255, 131, 84, 37, 111, 211, 168, 228, 45, 192, 118, 27, 197, 235, 232,
 36, 10, 230, 248, 190, 82, 182, 140, 35, 204, 108, 190, 253, 186, 186, 27]
	    </c>

	    <c>Exponent</c>
	    <c>
[1, 0, 1]
	    </c>

	    <c>Private Exponent</c>
	    <c>
[144, 183, 109, 34, 62, 134, 108, 57, 44, 252, 10, 66, 73, 54, 16, 181,
 233, 92, 54, 219, 101, 42, 35, 178, 63, 51, 43, 92, 119, 136, 251, 41,
 53, 23, 191, 164, 164, 60, 88, 227, 229, 152, 228, 213, 149, 228, 169, 237,
 104, 71, 151, 75, 88, 252, 216, 77, 251, 231, 28, 97, 88, 193, 215, 202,
 248, 216, 121, 195, 211, 245, 250, 112, 71, 243, 61, 129, 95, 39, 244, 122,
 225, 217, 169, 211, 165, 48, 253, 220, 59, 122, 219, 42, 86, 223, 32, 236,
 39, 48, 103, 78, 122, 216, 187, 88, 176, 89, 24, 1, 42, 177, 24, 99,
 142, 170, 1, 146, 43, 3, 108, 64, 194, 121, 182, 95, 187, 134, 71, 88,
 96, 134, 74, 131, 167, 69, 106, 143, 121, 27, 72, 44, 245, 95, 39, 194,
 179, 175, 203, 122, 16, 112, 183, 17, 200, 202, 31, 17, 138, 156, 184, 210,
 157, 184, 154, 131, 128, 110, 12, 85, 195, 122, 241, 79, 251, 229, 183, 117,
 21, 123, 133, 142, 220, 153, 9, 59, 57, 105, 81, 255, 138, 77, 82, 54,
 62, 216, 38, 249, 208, 17, 197, 49, 45, 19, 232, 157, 251, 131, 137, 175,
 72, 126, 43, 229, 69, 179, 117, 82, 157, 213, 83, 35, 57, 210, 197, 252,
 171, 143, 194, 11, 47, 163, 6, 253, 75, 252, 96, 11, 187, 84, 130, 210,
 7, 121, 78, 91, 79, 57, 251, 138, 132, 220, 60, 224, 173, 56, 224, 201]
	    </c>
	  </texttable>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[51, 101, 241, 165, 179, 145, 41, 236, 202, 75, 60, 208, 47, 255, 121, 248,
 104, 226, 185, 212, 65, 78, 169, 255, 162, 100, 188, 207, 220, 96, 161, 22,
 251, 47, 66, 112, 229, 75, 4, 111, 25, 173, 200, 121, 246, 79, 189, 102,
 173, 146, 228, 142, 14, 12, 167, 200, 27, 133, 138, 37, 180, 249, 4, 56,
 123, 192, 162, 156, 246, 231, 235, 217, 240, 45, 158, 213, 195, 154, 2, 142,
 86, 61, 198, 210, 34, 225, 92, 7, 128, 227, 4, 227, 55, 183, 69, 0,
 59, 162, 71, 145, 98, 238, 0, 70, 40, 123, 159, 37, 115, 18, 16, 157,
 236, 138, 117, 166, 18, 45, 181, 125, 112, 170, 168, 82, 129, 80, 166, 242,
 150, 97, 17, 217, 109, 251, 51, 35, 39, 236, 107, 95, 43, 154, 4, 227,
 206, 187, 75, 13, 51, 231, 115, 79, 67, 72, 145, 54, 225, 164, 60, 195,
 120, 188, 69, 113, 3, 182, 21, 189, 79, 82, 122, 46, 196, 199, 254, 252,
 7, 119, 5, 32, 144, 143, 173, 11, 99, 205, 120, 106, 231, 51, 231, 77,
 73, 252, 197, 221, 142, 254, 151, 7, 6, 203, 65, 108, 117, 121, 15, 95,
 43, 111, 13, 94, 242, 226, 150, 94, 121, 72, 144, 251, 69, 93, 137, 178,
 13, 216, 8, 227, 125, 110, 180, 157, 250, 207, 184, 232, 222, 164, 193, 70,
 232, 16, 65, 109, 29, 251, 164, 119, 50, 205, 236, 109, 245, 234, 78, 1]
	  </t>
	</section>

	<section title="Encoded JWE Encrypted Key">
	  <t>
	    Base64url encode the JWE Encrypted Key to produce the Encoded JWE Encrypted Key.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  M2XxpbORKezKSzzQL_95-GjiudRBTqn_omS8z9xgoRb7L0Jw5UsEbxmtyHn2T71m
  rZLkjg4Mp8gbhYoltPkEOHvAopz25-vZ8C2e1cOaAo5WPcbSIuFcB4DjBOM3t0UA
  O6JHkWLuAEYoe58lcxIQneyKdaYSLbV9cKqoUoFQpvKWYRHZbfszIyfsa18rmgTj
  zrtLDTPnc09DSJE24aQ8w3i8RXEDthW9T1J6LsTH_vwHdwUgkI-tC2PNeGrnM-dN
  SfzF3Y7-lwcGy0FsdXkPXytvDV7y4pZeeUiQ-0VdibIN2AjjfW60nfrPuOjepMFG
  6BBBbR37pHcyzext9epOAQ
]]></artwork></figure>
	</section>

	<section title="Initialization Vector">
	  <t>
	    Generate a random 96 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [227, 197, 117, 252, 2, 219, 233, 68, 180, 225, 77, 219]
	  </t>
	  <t>
	    Base64url encoding this value yields the Encoded JWE Initialization Vector value:
	  </t>
<figure><artwork><![CDATA[
  48V1_ALb6US04U3b
]]></artwork></figure>
	</section>

	<section title='"Additional Authenticated Data" Parameter'>
	  <t>
	    Concatenate
	    the Encoded JWE Header value, a period character ('.'),
	    the Encoded JWE Encrypted Key, a second period character ('.'), and
	    the Encoded JWE Initialization Vector
	    to create the "additional authenticated data"
	    parameter for the AES GCM algorithm.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  M2XxpbORKezKSzzQL_95-GjiudRBTqn_omS8z9xgoRb7L0Jw5UsEbxmtyHn2T71m
  rZLkjg4Mp8gbhYoltPkEOHvAopz25-vZ8C2e1cOaAo5WPcbSIuFcB4DjBOM3t0UA
  O6JHkWLuAEYoe58lcxIQneyKdaYSLbV9cKqoUoFQpvKWYRHZbfszIyfsa18rmgTj
  zrtLDTPnc09DSJE24aQ8w3i8RXEDthW9T1J6LsTH_vwHdwUgkI-tC2PNeGrnM-dN
  SfzF3Y7-lwcGy0FsdXkPXytvDV7y4pZeeUiQ-0VdibIN2AjjfW60nfrPuOjepMFG
  6BBBbR37pHcyzext9epOAQ.
  48V1_ALb6US04U3b
]]></artwork></figure>
	  <t>
	    The representation of this value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69, 116,
 84, 48, 70, 70, 85, 67, 73, 115, 73, 109, 86, 117, 89, 121, 73, 54,
 73, 107, 69, 121, 78, 84, 90, 72, 81, 48, 48, 105, 102, 81, 46, 77,
 50, 88, 120, 112, 98, 79, 82, 75, 101, 122, 75, 83, 122, 122, 81, 76,
 95, 57, 53, 45, 71, 106, 105, 117, 100, 82, 66, 84, 113, 110, 95, 111,
 109, 83, 56, 122, 57, 120, 103, 111, 82, 98, 55, 76, 48, 74, 119, 53,
 85, 115, 69, 98, 120, 109, 116, 121, 72, 110, 50, 84, 55, 49, 109, 114,
 90, 76, 107, 106, 103, 52, 77, 112, 56, 103, 98, 104, 89, 111, 108, 116,
 80, 107, 69, 79, 72, 118, 65, 111, 112, 122, 50, 53, 45, 118, 90, 56,
 67, 50, 101, 49, 99, 79, 97, 65, 111, 53, 87, 80, 99, 98, 83, 73,
 117, 70, 99, 66, 52, 68, 106, 66, 79, 77, 51, 116, 48, 85, 65, 79,
 54, 74, 72, 107, 87, 76, 117, 65, 69, 89, 111, 101, 53, 56, 108, 99,
 120, 73, 81, 110, 101, 121, 75, 100, 97, 89, 83, 76, 98, 86, 57, 99,
 75, 113, 111, 85, 111, 70, 81, 112, 118, 75, 87, 89, 82, 72, 90, 98,
 102, 115, 122, 73, 121, 102, 115, 97, 49, 56, 114, 109, 103, 84, 106, 122,
 114, 116, 76, 68, 84, 80, 110, 99, 48, 57, 68, 83, 74, 69, 50, 52,
 97, 81, 56, 119, 51, 105, 56, 82, 88, 69, 68, 116, 104, 87, 57, 84,
 49, 74, 54, 76, 115, 84, 72, 95, 118, 119, 72, 100, 119, 85, 103, 107,
 73, 45, 116, 67, 50, 80, 78, 101, 71, 114, 110, 77, 45, 100, 78, 83,
 102, 122, 70, 51, 89, 55, 45, 108, 119, 99, 71, 121, 48, 70, 115, 100,
 88, 107, 80, 88, 121, 116, 118, 68, 86, 55, 121, 52, 112, 90, 101, 101,
 85, 105, 81, 45, 48, 86, 100, 105, 98, 73, 78, 50, 65, 106, 106, 102,
 87, 54, 48, 110, 102, 114, 80, 117, 79, 106, 101, 112, 77, 70, 71, 54,
 66, 66, 66, 98, 82, 51, 55, 112, 72, 99, 121, 122, 101, 120, 116, 57,
 101, 112, 79, 65, 81, 46, 52, 56, 86, 49, 95, 65, 76, 98, 54, 85,
 83, 48, 52, 85, 51, 98]
	  </t>
	</section>

	<section title="Plaintext Encryption">
	  <t>
	    Encrypt the Plaintext with AES GCM using the CMK as the encryption key,
	    the JWE Initialization Vector,
	    and the "additional authenticated data" value above,
	    requesting a 128 bit "authentication tag" output.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[253, 237, 181, 180, 97, 161, 105, 207, 233, 120, 65, 100, 45, 122, 246, 116,
 195, 212, 102, 37, 36, 175]
	  </t>
	  <t>
	    The resulting "authentication tag" value is:
	  </t>
	  <t>
[237, 94, 89, 14, 74, 52, 191, 249, 159, 216, 240, 28, 224, 147, 34, 82]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext">
	  <t>
	    Base64url encode the resulting Ciphertext to create the Encoded JWE Ciphertext.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  _e21tGGhac_peEFkLXr2dMPUZiUkrw
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Integrity Value">
	  <t>
	    Base64url encode the resulting "authentication tag" to create the Encoded JWE Integrity Value.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  7V5ZDko0v_mf2PAc4JMiUg
]]></artwork></figure>
	</section>

	<section title="Complete Representation">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Integrity Value
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.
  M2XxpbORKezKSzzQL_95-GjiudRBTqn_omS8z9xgoRb7L0Jw5UsEbxmtyHn2T71m
  rZLkjg4Mp8gbhYoltPkEOHvAopz25-vZ8C2e1cOaAo5WPcbSIuFcB4DjBOM3t0UA
  O6JHkWLuAEYoe58lcxIQneyKdaYSLbV9cKqoUoFQpvKWYRHZbfszIyfsa18rmgTj
  zrtLDTPnc09DSJE24aQ8w3i8RXEDthW9T1J6LsTH_vwHdwUgkI-tC2PNeGrnM-dN
  SfzF3Y7-lwcGy0FsdXkPXytvDV7y4pZeeUiQ-0VdibIN2AjjfW60nfrPuOjepMFG
  6BBBbR37pHcyzext9epOAQ.
  48V1_ALb6US04U3b.
  _e21tGGhac_peEFkLXr2dMPUZiUkrw.
  7V5ZDko0v_mf2PAc4JMiUg
]]></artwork></figure>
	</section>

	<section title="Validation">
	  <t>
	    This example illustrates the process of creating a JWE with an Authenticated Encryption algorithm.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Note that since the RSAES OAEP computation includes random values,
	    the encryption results above will not be completely reproducible.
	    However, since the AES GCM computation is deterministic, the JWE Encrypted Ciphertext
	    values will be the same for all encryptions performed using these inputs.
	  </t>
	</section>
      </section>


      <section title="Example JWE using RSAES-PKCS1-V1_5 and AES CBC" anchor="RSACBCExample">
	<t>
	  This example encrypts the plaintext
	  "No matter where you go, there you are."
	  to the recipient using RSAES-PKCS1-V1_5 and AES CBC.
	  AES CBC does not have an integrated integrity check,
	  so a separate integrity check calculation is performed using HMAC SHA-256,
	  with separate encryption and integrity keys being derived from a master key
	  using the Concat KDF with the SHA-256 digest function.
	  The representation of this plaintext is:
	</t>
	<t>
[78, 111, 32, 109, 97, 116, 116, 101, 114, 32, 119, 104, 101, 114, 101, 32,
 121, 111, 117, 32, 103, 111, 44, 32, 116, 104, 101, 114, 101, 32, 121, 111,
 117, 32, 97, 114, 101, 46]
	</t>

	<section title="JWE Header">
	  <t>
	    The following example JWE Header (with line breaks for display purposes only) declares that:
	    <list style="symbols">
	      <t>
		the Content Master Key is encrypted to the recipient
		using the RSAES-PKCS1-V1_5 algorithm to produce the JWE
		Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES CBC
		algorithm with a 128 bit key to produce the Ciphertext,
		with the integrity of the
		Ciphertext and the parameters used to create it being
		secured with the HMAC SHA-256 algorithm.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"RSA1_5","enc":"A128CBC+HS256"}
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Header">
	  <t>
	    Base64url encoding the bytes of the UTF-8 representation of
	    the JWE Header yields this Encoded JWE Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDK0hTMjU2In0
]]></artwork></figure>
	</section>

	<section title="Content Master Key (CMK)">
	  <t>
	    Generate a 256 bit random Content Master Key (CMK).
	    In this example, the key value is:
	  </t>
	  <t>
[4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	  </t>
	</section>

	<section title="Key Encryption">
	  <t>
	    Encrypt the CMK with the recipient's public key using the RSAES-PKCS1-V1_5
	    algorithm to produce the JWE Encrypted Key.
	    In this example, the RSA key parameters are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>Modulus</c>
	    <c>
[177, 119, 33, 13, 164, 30, 108, 121, 207, 136, 107, 242, 12, 224, 19, 226,
 198, 134, 17, 71, 173, 75, 42, 61, 48, 162, 206, 161, 97, 108, 185, 234,
 226, 219, 118, 206, 118, 5, 169, 224, 60, 181, 90, 85, 51, 123, 6, 224,
 4, 122, 29, 230, 151, 12, 244, 127, 121, 25, 4, 85, 220, 144, 215, 110,
 130, 17, 68, 228, 129, 138, 7, 130, 231, 40, 212, 214, 17, 179, 28, 124,
 151, 178, 207, 20, 14, 154, 222, 113, 176, 24, 198, 73, 211, 113, 9, 33,
 178, 80, 13, 25, 21, 25, 153, 212, 206, 67, 154, 147, 70, 194, 192, 183,
 160, 83, 98, 236, 175, 85, 23, 97, 75, 199, 177, 73, 145, 50, 253, 206,
 32, 179, 254, 236, 190, 82, 73, 67, 129, 253, 252, 220, 108, 136, 138, 11,
 192, 1, 36, 239, 228, 55, 81, 113, 17, 25, 140, 63, 239, 146, 3, 172,
 96, 60, 227, 233, 64, 255, 224, 173, 225, 228, 229, 92, 112, 72, 99, 97,
 26, 87, 187, 123, 46, 50, 90, 202, 117, 73, 10, 153, 47, 224, 178, 163,
 77, 48, 46, 154, 33, 148, 34, 228, 33, 172, 216, 89, 46, 225, 127, 68,
 146, 234, 30, 147, 54, 146, 5, 133, 45, 78, 254, 85, 55, 75, 213, 86,
 194, 218, 215, 163, 189, 194, 54, 6, 83, 36, 18, 153, 53, 7, 48, 89,
 35, 66, 144, 7, 65, 154, 13, 97, 75, 55, 230, 132, 3, 13, 239, 71]
	    </c>

	    <c>Exponent</c>
	    <c>
[1, 0, 1]
	    </c>

	    <c>Private Exponent</c>
	    <c>
[84, 80, 150, 58, 165, 235, 242, 123, 217, 55, 38, 154, 36, 181, 221, 156,
 211, 215, 100, 164, 90, 88, 40, 228, 83, 148, 54, 122, 4, 16, 165, 48,
 76, 194, 26, 107, 51, 53, 179, 165, 31, 18, 198, 173, 78, 61, 56, 97,
 252, 158, 140, 80, 63, 25, 223, 156, 36, 203, 214, 252, 120, 67, 180, 167,
 3, 82, 243, 25, 97, 214, 83, 133, 69, 16, 104, 54, 160, 200, 41, 83,
 164, 187, 70, 153, 111, 234, 242, 158, 175, 28, 198, 48, 211, 45, 148, 58,
 23, 62, 227, 74, 52, 117, 42, 90, 41, 249, 130, 154, 80, 119, 61, 26,
 193, 40, 125, 10, 152, 174, 227, 225, 205, 32, 62, 66, 6, 163, 100, 99,
 219, 19, 253, 25, 105, 80, 201, 29, 252, 157, 237, 69, 1, 80, 171, 167,
 20, 196, 156, 109, 249, 88, 0, 3, 152, 38, 165, 72, 87, 6, 152, 71,
 156, 214, 16, 71, 30, 82, 51, 103, 76, 218, 63, 9, 84, 163, 249, 91,
 215, 44, 238, 85, 101, 240, 148, 1, 82, 224, 91, 135, 105, 127, 84, 171,
 181, 152, 210, 183, 126, 24, 46, 196, 90, 173, 38, 245, 219, 186, 222, 27,
 240, 212, 194, 15, 66, 135, 226, 178, 190, 52, 245, 74, 65, 224, 81, 100,
 85, 25, 204, 165, 203, 187, 175, 84, 100, 82, 15, 11, 23, 202, 151, 107,
 54, 41, 207, 3, 136, 229, 134, 131, 93, 139, 50, 182, 204, 93, 130, 89]
	    </c>
	  </texttable>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[102, 105, 229, 169, 104, 35, 95, 42, 176, 142, 190, 220, 92, 124, 172, 240,
 94, 253, 106, 114, 20, 35, 162, 118, 81, 103, 64, 201, 20, 4, 112, 96,
 84, 248, 163, 199, 177, 227, 204, 247, 93, 63, 70, 132, 195, 26, 237, 72,
 91, 141, 3, 159, 71, 111, 113, 213, 68, 142, 146, 92, 60, 243, 72, 111,
 53, 156, 51, 16, 226, 215, 125, 68, 141, 232, 62, 111, 197, 98, 91, 150,
 23, 230, 132, 93, 97, 216, 145, 226, 3, 18, 12, 48, 119, 153, 185, 8,
 156, 195, 84, 21, 63, 143, 43, 144, 174, 101, 25, 199, 7, 106, 212, 43,
 151, 225, 62, 225, 122, 92, 90, 139, 45, 144, 134, 229, 15, 235, 38, 110,
 132, 189, 236, 126, 92, 183, 13, 64, 2, 77, 107, 95, 186, 8, 133, 53,
 217, 104, 247, 152, 241, 49, 199, 15, 111, 110, 123, 16, 13, 78, 193, 224,
 23, 230, 133, 220, 162, 126, 82, 192, 236, 7, 185, 100, 106, 21, 70, 93,
 192, 255, 252, 139, 61, 124, 81, 140, 113, 97, 164, 231, 131, 167, 246, 157,
 199, 195, 114, 122, 49, 121, 115, 63, 114, 12, 165, 11, 186, 3, 108, 12,
 199, 101, 29, 226, 80, 56, 193, 149, 45, 134, 146, 102, 221, 202, 63, 166,
 150, 53, 42, 133, 3, 83, 199, 14, 15, 181, 209, 199, 174, 76, 75, 106,
 254, 243, 196, 227, 225, 173, 122, 254, 13, 224, 174, 4, 185, 217, 99, 225]

	  </t>
	</section>

	<section title="Encoded JWE Encrypted Key">
	  <t>
	    Base64url encode the JWE Encrypted Key to produce the Encoded JWE Encrypted Key.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  ZmnlqWgjXyqwjr7cXHys8F79anIUI6J2UWdAyRQEcGBU-KPHsePM910_RoTDGu1I
  W40Dn0dvcdVEjpJcPPNIbzWcMxDi131Ejeg-b8ViW5YX5oRdYdiR4gMSDDB3mbkI
  nMNUFT-PK5CuZRnHB2rUK5fhPuF6XFqLLZCG5Q_rJm6Evex-XLcNQAJNa1-6CIU1
  2Wj3mPExxw9vbnsQDU7B4BfmhdyiflLA7Ae5ZGoVRl3A__yLPXxRjHFhpOeDp_ad
  x8NyejF5cz9yDKULugNsDMdlHeJQOMGVLYaSZt3KP6aWNSqFA1PHDg-10ceuTEtq
  _vPE4-Gtev4N4K4Eudlj4Q
]]></artwork></figure>
	</section>

	<section title="Key Derivation">
	  <t>
	    Use the Concat key derivation function
	    to derive Content Encryption Key (CEK)
	    and Content Integrity Key (CIK) values from the CMK.
	    The details of this derivation are shown in <xref target="KeyDeriv1"/>.
	    The resulting CEK value is:
	  </t>
	  <t>
[203, 165, 180, 113, 62, 195, 22, 98, 91, 153, 210, 38, 112, 35, 230, 236]
	  </t>
	  <t>
	    The resulting CIK value is:
	  </t>
	  <t>
[218, 24, 160, 17, 160, 50, 235, 35, 216, 209, 100, 174, 155, 163, 10, 117,
 180, 111, 172, 200, 127, 201, 206, 173, 40, 45, 58, 170, 35, 93, 9, 60]
	  </t>
	</section>

	<section title="Initialization Vector">
	  <t>
	    Generate a random 128 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111, 116, 104, 101]
	  </t>
	  <t>
	    Base64url encoding this value yields the Encoded JWE Initialization Vector value:
	  </t>
<figure><artwork><![CDATA[
  AxY8DCtDaGlsbGljb3RoZQ
]]></artwork></figure>
	</section>

	<section title="Plaintext Encryption">
	  <t>
	    Encrypt the Plaintext with AES CBC using
	    the CEK and the JWE Initialization Vector to produce the Ciphertext.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[71, 27, 35, 131, 163, 200, 19, 23, 38, 25, 33, 123, 46, 116, 132, 144,
 58, 150, 32, 167, 192, 195, 92, 25, 207, 101, 233, 105, 181, 121, 63, 4,
 44, 162, 82, 176, 17, 171, 150, 97, 147, 68, 245, 13, 97, 100, 145, 25]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext">
	  <t>
	    Base64url encode the resulting Ciphertext to create the Encoded JWE Ciphertext.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  Rxsjg6PIExcmGSF7LnSEkDqWIKfAw1wZz2XpabV5PwQsolKwEauWYZNE9Q1hZJEZ
]]></artwork></figure>
	</section>

	<section title="Secured Input Value">
	  <t>
	    Concatenate
	    the Encoded JWE Header value, a period character ('.'),
	    the Encoded JWE Encrypted Key, a second period character,
	    the Encoded JWE Initialization Vector, a third period ('.') character, and
	    the Encoded JWE Ciphertext
	    to create the value to integrity protect.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDK0hTMjU2In0.
  ZmnlqWgjXyqwjr7cXHys8F79anIUI6J2UWdAyRQEcGBU-KPHsePM910_RoTDGu1I
  W40Dn0dvcdVEjpJcPPNIbzWcMxDi131Ejeg-b8ViW5YX5oRdYdiR4gMSDDB3mbkI
  nMNUFT-PK5CuZRnHB2rUK5fhPuF6XFqLLZCG5Q_rJm6Evex-XLcNQAJNa1-6CIU1
  2Wj3mPExxw9vbnsQDU7B4BfmhdyiflLA7Ae5ZGoVRl3A__yLPXxRjHFhpOeDp_ad
  x8NyejF5cz9yDKULugNsDMdlHeJQOMGVLYaSZt3KP6aWNSqFA1PHDg-10ceuTEtq
  _vPE4-Gtev4N4K4Eudlj4Q.
  AxY8DCtDaGlsbGljb3RoZQ.
  Rxsjg6PIExcmGSF7LnSEkDqWIKfAw1wZz2XpabV5PwQsolKwEauWYZNE9Q1hZJEZ
]]></artwork></figure>
	  <t>
	    The representation of this value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 48, 69, 120,
 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 81, 48, 74, 68, 75, 48, 104, 84, 77, 106, 85, 50,
 73, 110, 48, 46, 90, 109, 110, 108, 113, 87, 103, 106, 88, 121, 113, 119,
 106, 114, 55, 99, 88, 72, 121, 115, 56, 70, 55, 57, 97, 110, 73, 85,
 73, 54, 74, 50, 85, 87, 100, 65, 121, 82, 81, 69, 99, 71, 66, 85,
 45, 75, 80, 72, 115, 101, 80, 77, 57, 49, 48, 95, 82, 111, 84, 68,
 71, 117, 49, 73, 87, 52, 48, 68, 110, 48, 100, 118, 99, 100, 86, 69,
 106, 112, 74, 99, 80, 80, 78, 73, 98, 122, 87, 99, 77, 120, 68, 105,
 49, 51, 49, 69, 106, 101, 103, 45, 98, 56, 86, 105, 87, 53, 89, 88,
 53, 111, 82, 100, 89, 100, 105, 82, 52, 103, 77, 83, 68, 68, 66, 51,
 109, 98, 107, 73, 110, 77, 78, 85, 70, 84, 45, 80, 75, 53, 67, 117,
 90, 82, 110, 72, 66, 50, 114, 85, 75, 53, 102, 104, 80, 117, 70, 54,
 88, 70, 113, 76, 76, 90, 67, 71, 53, 81, 95, 114, 74, 109, 54, 69,
 118, 101, 120, 45, 88, 76, 99, 78, 81, 65, 74, 78, 97, 49, 45, 54,
 67, 73, 85, 49, 50, 87, 106, 51, 109, 80, 69, 120, 120, 119, 57, 118,
 98, 110, 115, 81, 68, 85, 55, 66, 52, 66, 102, 109, 104, 100, 121, 105,
 102, 108, 76, 65, 55, 65, 101, 53, 90, 71, 111, 86, 82, 108, 51, 65,
 95, 95, 121, 76, 80, 88, 120, 82, 106, 72, 70, 104, 112, 79, 101, 68,
 112, 95, 97, 100, 120, 56, 78, 121, 101, 106, 70, 53, 99, 122, 57, 121,
 68, 75, 85, 76, 117, 103, 78, 115, 68, 77, 100, 108, 72, 101, 74, 81,
 79, 77, 71, 86, 76, 89, 97, 83, 90, 116, 51, 75, 80, 54, 97, 87,
 78, 83, 113, 70, 65, 49, 80, 72, 68, 103, 45, 49, 48, 99, 101, 117,
 84, 69, 116, 113, 95, 118, 80, 69, 52, 45, 71, 116, 101, 118, 52, 78,
 52, 75, 52, 69, 117, 100, 108, 106, 52, 81, 46, 65, 120, 89, 56, 68,
 67, 116, 68, 97, 71, 108, 115, 98, 71, 108, 106, 98, 51, 82, 111, 90,
 81, 46, 82, 120, 115, 106, 103, 54, 80, 73, 69, 120, 99, 109, 71, 83,
 70, 55, 76, 110, 83, 69, 107, 68, 113, 87, 73, 75, 102, 65, 119, 49,
 119, 90, 122, 50, 88, 112, 97, 98, 86, 53, 80, 119, 81, 115, 111, 108,
 75, 119, 69, 97, 117, 87, 89, 90, 78, 69, 57, 81, 49, 104, 90, 74,
 69, 90]
	  </t>
	</section>

	<section title="JWE Integrity Value">
	  <t>
	    Compute the HMAC SHA-256 of this value using the CIK to create the JWE Integrity Value.
	    This result is:
	  </t>
	  <t>
[240, 181, 234, 49, 221, 9, 44, 107, 49, 49, 160, 121, 186, 131, 90, 50,
 152, 59, 185, 69, 191, 167, 141, 17, 149, 166, 71, 11, 3, 8, 203, 57]
	  </t>
	</section>

	<section title="Encoded JWE Integrity Value">
	  <t>
	    Base64url encode the resulting JWE Integrity Value to create the Encoded JWE Integrity Value.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  8LXqMd0JLGsxMaB5uoNaMpg7uUW_p40RlaZHCwMIyzk
]]></artwork></figure>
	</section>

	<section title="Complete Representation">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Integrity Value
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDK0hTMjU2In0.
  ZmnlqWgjXyqwjr7cXHys8F79anIUI6J2UWdAyRQEcGBU-KPHsePM910_RoTDGu1I
  W40Dn0dvcdVEjpJcPPNIbzWcMxDi131Ejeg-b8ViW5YX5oRdYdiR4gMSDDB3mbkI
  nMNUFT-PK5CuZRnHB2rUK5fhPuF6XFqLLZCG5Q_rJm6Evex-XLcNQAJNa1-6CIU1
  2Wj3mPExxw9vbnsQDU7B4BfmhdyiflLA7Ae5ZGoVRl3A__yLPXxRjHFhpOeDp_ad
  x8NyejF5cz9yDKULugNsDMdlHeJQOMGVLYaSZt3KP6aWNSqFA1PHDg-10ceuTEtq
  _vPE4-Gtev4N4K4Eudlj4Q.
  AxY8DCtDaGlsbGljb3RoZQ.
  Rxsjg6PIExcmGSF7LnSEkDqWIKfAw1wZz2XpabV5PwQsolKwEauWYZNE9Q1hZJEZ.
  8LXqMd0JLGsxMaB5uoNaMpg7uUW_p40RlaZHCwMIyzk
]]></artwork></figure>
	</section>

	<section title="Validation">
	  <t>
	    This example illustrates the process of creating a JWE with a
	    composite Authenticated Encryption algorithm created from a non-Authenticated Encryption algorithm by
	    adding a separate integrity check calculation.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Note that since the RSAES-PKCS1-V1_5 computation includes random values,
	    the encryption results above will not be completely reproducible.
	    However, since the AES CBC computation is deterministic, the JWE Encrypted Ciphertext
	    values will be the same for all encryptions performed using these inputs.
	  </t>
	</section>
      </section>


      <section title="Example JWE using AES Key Wrap and AES GCM" anchor="KeyWrapExample">
	<t>
	  This example encrypts the plaintext
	  "The true sign of intelligence is not knowledge but imagination."
	  to the recipient using AES Key Wrap and AES GCM.
	  The representation of this plaintext is:
	</t>
	<t>
[84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32, 111, 102,
 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99, 101, 32, 105, 115,
 32, 110, 111, 116, 32, 107, 110, 111, 119, 108, 101, 100, 103, 101, 32, 98,
 117, 116, 32, 105, 109, 97, 103, 105, 110, 97, 116, 105, 111, 110, 46]
	</t>

	<section title="JWE Header">
	  <t>
	    The following example JWE Header declares that:
	    <list style="symbols">
	      <t>
		the Content Master Key is encrypted to the recipient
		using the AES Key Wrap algorithm with a 128 bit key to produce the JWE
		Encrypted Key and
	      </t>
	      <t>
		the Plaintext is encrypted using the AES GCM
		algorithm with a 128 bit key to produce the Ciphertext.
	      </t>
	    </list>
	  </t>

	  <figure><artwork><![CDATA[
  {"alg":"A128KW","enc":"A128GCM"}
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Header">
	  <t>
	    Base64url encoding the bytes of the UTF-8 representation of
	    the JWE Header yields this Encoded JWE Header value:
	  </t>

	  <figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0
]]></artwork></figure>
	</section>

	<section title="Content Master Key (CMK)">
	  <t>
	    Generate a 128 bit random Content Master Key (CMK).
	    In this example, the value is:
	  </t>
	  <t>
[64, 154, 239, 170, 64, 40, 195, 99, 19, 84, 192, 142, 192, 238, 207, 217]
	  </t>
	</section>

	<section title="Key Encryption">
	  <t>
	    Encrypt the CMK with the shared symmetric key using the AES Key Wrap
	    algorithm to produce the JWE Encrypted Key.
	    In this example, the shared symmetric key value is:
	  </t>
	  <t>
[25, 172, 32, 130, 225, 114, 26, 181, 138, 106, 254, 192, 95, 133, 74, 82]
	  </t>

	  <t>
	    The resulting JWE Encrypted Key value is:
	  </t>
	  <t>
[164, 255, 251, 1, 64, 200, 65, 200, 34, 197, 81, 143, 43, 211, 240, 38,
 191, 161, 181, 117, 119, 68, 44, 80]
	  </t>
	</section>

	<section title="Encoded JWE Encrypted Key">
	  <t>
	    Base64url encode the JWE Encrypted Key to produce the Encoded JWE Encrypted Key.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  pP_7AUDIQcgixVGPK9PwJr-htXV3RCxQ
]]></artwork></figure>
	</section>

	<section title="Initialization Vector">
	  <t>
	    Generate a random 96 bit JWE Initialization Vector.
	    In this example, the value is:
	  </t>
	  <t>
	    [253, 220, 80, 25, 166, 152, 178, 168, 97, 99, 67, 89]
	  </t>
	  <t>
	    Base64url encoding this value yields the Encoded JWE Initialization Vector value:
	  </t>
<figure><artwork><![CDATA[
  _dxQGaaYsqhhY0NZ
]]></artwork></figure>
	</section>

	<section title='"Additional Authenticated Data" Parameter'>
	  <t>
	    Concatenate
	    the Encoded JWE Header value, a period character ('.'),
	    the Encoded JWE Encrypted Key, a second period character ('.'), and
	    the Encoded JWE Initialization Vector
	    to create the "additional authenticated data"
	    parameter for the AES GCM algorithm.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.
  pP_7AUDIQcgixVGPK9PwJr-htXV3RCxQ.
  _dxQGaaYsqhhY0NZ
]]></artwork></figure>
	  <t>
	    The representation of this value is:
	  </t>
	  <t>
[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,
 83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
 77, 84, 73, 52, 82, 48, 78, 78, 73, 110, 48, 46, 112, 80, 95, 55,
 65, 85, 68, 73, 81, 99, 103, 105, 120, 86, 71, 80, 75, 57, 80, 119,
 74, 114, 45, 104, 116, 88, 86, 51, 82, 67, 120, 81, 46, 95, 100, 120,
 81, 71, 97, 97, 89, 115, 113, 104, 104, 89, 48, 78, 90]
	  </t>
	</section>

	<section title="Plaintext Encryption">
	  <t>
	    Encrypt the Plaintext with AES GCM using the CMK as the encryption key,
	    the JWE Initialization Vector,
	    and the "additional authenticated data" value above,
	    requesting a 128 bit "authentication tag" output.
	    The resulting Ciphertext is:
	  </t>
	  <t>
[227, 12, 89, 132, 185, 16, 248, 93, 145, 87, 53, 130, 95, 115, 62, 104,
 138, 96, 109, 71, 124, 211, 165, 103, 202, 99, 21, 193, 4, 226, 84, 229,
 254, 106, 144, 241, 39, 86, 148, 132, 160, 104, 88, 232, 228, 109, 85, 7,
 86, 80, 134, 106, 166, 24, 92, 199, 210, 188, 153, 187, 218, 69, 227]
	  </t>
	  <t>
	    The resulting "authentication tag" value is:
	  </t>
	  <t>
[154, 35, 80, 107, 37, 148, 81, 6, 103, 4, 60, 206, 171, 165, 113, 67]
	  </t>
	</section>

	<section title="Encoded JWE Ciphertext">
	  <t>
	    Base64url encode the resulting Ciphertext to create the Encoded JWE Ciphertext.
	    This result (with line breaks for display purposes only) is:
	  </t>
<figure><artwork><![CDATA[
  4wxZhLkQ-F2RVzWCX3M-aIpgbUd806VnymMVwQTiVOX-apDxJ1aUhKBoWOjkbVUH
  VlCGaqYYXMfSvJm72kXj
]]></artwork></figure>
	</section>

	<section title="Encoded JWE Integrity Value">
	  <t>
	    Base64url encode the resulting "authentication tag" to create the Encoded JWE Integrity Value.
	    This result is:
	  </t>
<figure><artwork><![CDATA[
  miNQayWUUQZnBDzOq6VxQw
]]></artwork></figure>
	</section>

	<section title="Complete Representation">
	  <t>
	    Assemble the final representation:
	    The Compact Serialization of this result is the
	    concatenation of
	    the Encoded JWE Header,
	    the Encoded JWE Encrypted Key,
	    the Encoded JWE Initialization Vector,
	    the Encoded JWE Ciphertext, and
	    the Encoded JWE Integrity Value
	    in that order, with the five strings
	    being separated by four period ('.') characters.
	  </t>
	  <t>
	    The final result in this example
	    (with line breaks for display purposes only) is:
	  </t>
	  <figure><artwork><![CDATA[
  eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIn0.
  pP_7AUDIQcgixVGPK9PwJr-htXV3RCxQ.
  _dxQGaaYsqhhY0NZ.
  4wxZhLkQ-F2RVzWCX3M-aIpgbUd806VnymMVwQTiVOX-apDxJ1aUhKBoWOjkbVUH
  VlCGaqYYXMfSvJm72kXj.
  miNQayWUUQZnBDzOq6VxQw
]]></artwork></figure>
	</section>

	<section title="Validation">
	  <t>
	    This example illustrates the process of creating a JWE with
	    symmetric key wrap and an Authenticated Encryption algorithm.
	    These results can be used to validate JWE decryption implementations for these algorithms.
	    Also, since both the AES Key Wrap and AES GCM computations are deterministic,
	    the resulting JWE value will be the same for all encryptions performed using these inputs.
	    Since the computation is reproducible, these results can also be used to validate
	    JWE encryption implementations for these algorithms.
	  </t>
	</section>
      </section>


      <section title='Example Key Derivation for "enc" value "A128CBC+HS256"' anchor="KeyDeriv1">
	<t>
	  This example uses the Concat KDF to derive the
	  Content Encryption Key (CEK) and Content Integrity Key (CIK)
	  from the Content Master Key (CMK) in the manner described in
	  Section 4.8.1 of <xref target="JWA"/>.
	  In this example,
	  a 256 bit CMK is used to derive a 128 bit CEK and a 256 bit CIK.
	</t>
	<t>
	  The CMK value used is:
	</t>
	<t>
[4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207]
	</t>

	<section title="CEK Generation">
	  <t>
	    These values are concatenated to produce the round 1 hash input:
	    <list style='symbols'>
	      <t>
		the round number 1 as a 32 bit big endian integer ([0, 0, 0, 1]),
	      </t>
	      <t>
		the CMK value (as above),
	      </t>
	      <t>
		the output bit size 128 as a 32 bit big endian number ([0, 0, 0, 128]),
	      </t>
	      <t>
		the bytes of the UTF-8 representation of the <spanx style="verb">enc</spanx> value
		<spanx style="verb">A128CBC+HS256</spanx> --
		[65, 49, 50, 56, 67, 66, 67, 43, 72, 83, 50, 53, 54],
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epu</spanx> (encryption PartyUInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epv</spanx> (encryption PartyVInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the bytes of the ASCII representation of the label "Encryption" --
		[69, 110, 99, 114, 121, 112, 116, 105, 111, 110].
	      </t>
	    </list>

	    Thus the round 1 hash input is:
	  </t>
	  <t>
[0, 0, 0, 1,
 4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207,
 0, 0, 0, 128,
 65, 49, 50, 56, 67, 66, 67, 43, 72, 83, 50, 53, 54,
 0, 0, 0, 0, 0, 0, 0, 0,
 69, 110, 99, 114, 121, 112, 116, 105, 111, 110]
	  </t>
	  <t>
	    The SHA-256 hash of this value, which is the round 1 hash output, is:
	  </t>
	  <t>
[203, 165, 180, 113, 62, 195, 22, 98, 91, 153, 210, 38, 112, 35, 230, 236,
 181, 193, 129, 233, 251, 107, 70, 80, 36, 150, 216, 251, 182, 29, 104, 150]
	  </t>
	  <t>
	    Given that 128 bits are needed for the CEK and the hash has produced 256 bits,
	    the CEK value is the first 128 bits of that value:
	  </t>
	  <t>
[203, 165, 180, 113, 62, 195, 22, 98, 91, 153, 210, 38, 112, 35, 230, 236]
	  </t>
	</section>
	
	<section title="CIK Generation">
	  <t>
	    These values are concatenated to produce the round 1 hash input:
	    <list style='symbols'>
	      <t>
		the round number 1 as a 32 bit big endian integer ([0, 0, 0, 1]),
	      </t>
	      <t>
		the CMK value (as above),
	      </t>
	      <t>
		the output bit size 256 as a 32 bit big endian number ([0, 0, 1, 0]),
	      </t>
	      <t>
		the bytes of the UTF-8 representation of the <spanx style="verb">enc</spanx> value
		<spanx style="verb">A128CBC+HS256</spanx> --
		[65, 49, 50, 56, 67, 66, 67, 43, 72, 83, 50, 53, 54],
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epu</spanx> (encryption PartyUInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epv</spanx> (encryption PartyVInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the bytes of the ASCII representation of the label "Integrity" --
		[73, 110, 116, 101, 103, 114, 105, 116, 121].
	      </t>
	    </list>

	    Thus the round 1 hash input is:
	  </t>
	  <t>
[0, 0, 0, 1,
 4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106, 206,
 107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44, 207,
 0, 0, 1, 0,
 65, 49, 50, 56, 67, 66, 67, 43, 72, 83, 50, 53, 54,
 0, 0, 0, 0, 0, 0, 0, 0,
 73, 110, 116, 101, 103, 114, 105, 116, 121]
	  </t>
	  <t>
	    The SHA-256 hash of this value, which is the round 1 hash output, is:
	  </t>
	  <t>
[218, 24, 160, 17, 160, 50, 235, 35, 216, 209, 100, 174, 155, 163, 10, 117,
 180, 111, 172, 200, 127, 201, 206, 173, 40, 45, 58, 170, 35, 93, 9, 60]
	  </t>
	  <t>
	    Given that 256 bits are needed for the CIK and the hash has produced 256 bits,
	    the CIK value is that same value:
	  </t>
	  <t>
[218, 24, 160, 17, 160, 50, 235, 35, 216, 209, 100, 174, 155, 163, 10, 117,
 180, 111, 172, 200, 127, 201, 206, 173, 40, 45, 58, 170, 35, 93, 9, 60]
	  </t>
	</section>
      </section>


      <section title='Example Key Derivation for "enc" value "A256CBC+HS512"' anchor="KeyDeriv512">
	<t>
	  This example uses the Concat KDF to derive the
	  Content Encryption Key (CEK) and Content Integrity Key (CIK)
	  from the Content Master Key (CMK) in the manner described in
	  Section 4.8.1 of <xref target="JWA"/>.
	  In this example,
	  a 512 bit CMK is used to derive a 256 bit CEK and a 512 bit CIK.
	</t>
	<t>
	  The CMK value used is:
	</t>
	<t>
[148, 116, 199, 126, 2, 117, 233, 76, 150, 149, 89, 193, 61, 34, 239, 226,
 109, 71, 59, 160, 192, 140, 150, 235, 106, 204, 49, 176, 68, 119, 13, 34,
 49, 19, 41, 69, 5, 20, 252, 145, 104, 129, 137, 138, 67, 23, 153, 83,
 81, 234, 82, 247, 48, 211, 41, 130, 35, 124, 45, 156, 249, 7, 225, 168]
	</t>

	<section title="CEK Generation">
	  <t>
	    These values are concatenated to produce the round 1 hash input:
	    <list style='symbols'>
	      <t>
		the round number 1 as a 32 bit big endian integer ([0, 0, 0, 1]),
	      </t>
	      <t>
		the CMK value (as above),
	      </t>
	      <t>
		the output bit size 256 as a 32 bit big endian number ([0, 0, 1, 0]),
	      </t>
	      <t>
		the bytes of the UTF-8 representation of the <spanx style="verb">enc</spanx> value
		<spanx style="verb">A256CBC+HS512</spanx> --
		[65, 50, 53, 54, 67, 66, 67, 43, 72, 83, 53, 49, 50],
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epu</spanx> (encryption PartyUInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epv</spanx> (encryption PartyVInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the bytes of the ASCII representation of the label "Encryption" --
		[69, 110, 99, 114, 121, 112, 116, 105, 111, 110].
	      </t>
	    </list>

	    Thus the round 1 hash input is:
	  </t>
	  <t>
[0, 0, 0, 1,
 148, 116, 199, 126, 2, 117, 233, 76, 150, 149, 89, 193, 61, 34, 239, 226,
 109, 71, 59, 160, 192, 140, 150, 235, 106, 204, 49, 176, 68, 119, 13, 34,
 49, 19, 41, 69, 5, 20, 252, 145, 104, 129, 137, 138, 67, 23, 153, 83,
 81, 234, 82, 247, 48, 211, 41, 130, 35, 124, 45, 156, 249, 7, 225, 168,
 0, 0, 1, 0,
 65, 50, 53, 54, 67, 66, 67, 43, 72, 83, 53, 49, 50,
 0, 0, 0, 0, 0, 0, 0, 0,
 69, 110, 99, 114, 121, 112, 116, 105, 111, 110]
	  </t>
	  <t>
	    The SHA-512 hash of this value, which is the round 1 hash output, is:
	  </t>
	  <t>
[157, 19, 75, 205, 31, 190, 110, 46, 117, 217, 137, 19, 116, 166, 126, 60,
 18, 244, 226, 114, 38, 153, 78, 198, 26, 0, 181, 168, 113, 45, 149, 89,
 107, 213, 109, 183, 207, 164, 86, 131, 51, 105, 214, 29, 229, 32, 243, 46,
 40, 53, 123, 4, 13, 7, 250, 48, 227, 207, 167, 211, 147, 91, 0, 171]
	  </t>
	  <t>
	    Given that 256 bits are needed for the CEK and the hash has produced 512 bits,
	    the CEK value is the first 256 bits of that value:
	  </t>
	  <t>
[157, 19, 75, 205, 31, 190, 110, 46, 117, 217, 137, 19, 116, 166, 126, 60,
 18, 244, 226, 114, 38, 153, 78, 198, 26, 0, 181, 168, 113, 45, 149, 89]
	  </t>
	</section>
	
	<section title="CIK Generation">
	  <t>
	    These values are concatenated to produce the round 1 hash input:
	    <list style='symbols'>
	      <t>
		the round number 1 as a 32 bit big endian integer ([0, 0, 0, 1]),
	      </t>
	      <t>
		the CMK value (as above),
	      </t>
	      <t>
		the output bit size 512 as a 32 bit big endian number ([0, 0, 2, 0]),
	      </t>
	      <t>
		the bytes of the UTF-8 representation of the <spanx style="verb">enc</spanx> value
		<spanx style="verb">A256CBC+HS512</spanx> --
		[65, 50, 53, 54, 67, 66, 67, 43, 72, 83, 53, 49, 50],
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epu</spanx> (encryption PartyUInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the Datalen value of zero for the omitted
		<spanx style="verb">epv</spanx> (encryption PartyVInfo) value
		([0, 0, 0, 0]),
	      </t>
	      <t>
		the bytes of the ASCII representation of the label "Integrity" --
		[73, 110, 116, 101, 103, 114, 105, 116, 121].
	      </t>
	    </list>

	    Thus the round 1 hash input is:
	  </t>
	  <t>
[0, 0, 0, 1,
 148, 116, 199, 126, 2, 117, 233, 76, 150, 149, 89, 193, 61, 34, 239, 226,
 109, 71, 59, 160, 192, 140, 150, 235, 106, 204, 49, 176, 68, 119, 13, 34,
 49, 19, 41, 69, 5, 20, 252, 145, 104, 129, 137, 138, 67, 23, 153, 83,
 81, 234, 82, 247, 48, 211, 41, 130, 35, 124, 45, 156, 249, 7, 225, 168,
 0, 0, 2, 0,
 65, 50, 53, 54, 67, 66, 67, 43, 72, 83, 53, 49, 50,
 0, 0, 0, 0, 0, 0, 0, 0,
 73, 110, 116, 101, 103, 114, 105, 116, 121]
	  </t>
	  <t>
	    The SHA-512 hash of this value, which is the round 1 hash output, is:
	  </t>
	  <t>
[81, 249, 131, 194, 25, 166, 147, 155, 47, 249, 146, 160, 200, 236, 115, 72,
 103, 248, 228, 30, 130, 225, 164, 61, 105, 172, 198, 31, 137, 170, 215, 141,
 27, 247, 73, 236, 125, 113, 151, 33, 0, 251, 72, 53, 72, 63, 146, 117,
 247, 13, 49, 20, 210, 169, 232, 156, 118, 1, 16, 45, 29, 21, 15, 208]
	  </t>
	  <t>
	    Given that 512 bits are needed for the CIK and the hash has produced 512 bits,
	    the CIK value is that same value:
	  </t>
	  <t>
[81, 249, 131, 194, 25, 166, 147, 155, 47, 249, 146, 160, 200, 236, 115, 72,
 103, 248, 228, 30, 130, 225, 164, 61, 105, 172, 198, 31, 137, 170, 215, 141,
 27, 247, 73, 236, 125, 113, 151, 33, 0, 251, 72, 53, 72, 63, 146, 117,
 247, 13, 49, 20, 210, 169, 232, 156, 118, 1, 16, 45, 29, 21, 15, 208]
	  </t>
	</section>
      </section>

    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for encrypting JSON content were also explored by
	<xref target="JSE">JSON Simple Encryption</xref> and
	<xref target="I-D.rescorla-jsms">JavaScript Message Security
	Format</xref>, both of which significantly influenced this draft.
	This draft attempts to explicitly reuse as many of the relevant concepts from
	<xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	and <xref target="RFC5652">RFC 5652</xref> as possible,
	while utilizing simple compact JSON-based data structures.
      </t>
      <t>
	Special thanks are due to John Bradley and Nat Sakimura for
	the discussions that helped inform the content of this
	specification and to Eric Rescorla and Joe Hildebrand for
	allowing the reuse of text from <xref
	target="I-D.rescorla-jsms"/> in this document.
      </t>
      <t>
	Thanks to Axel Nennker, Emmanuel Raviart, Brian Campbell, and Edmund Jay
	for validating the examples in this specification.
      </t>
      <t>
        This specification is the work of the JOSE Working Group,
	which includes dozens of active and dedicated participants.
	In particular, the following individuals contributed ideas,
        feedback, and wording that influenced this specification:
      </t>
      <t>
	Richard Barnes,
	John Bradley,
	Brian Campbell,
	Breno de Medeiros,
	Dick Hardt,
	Jeff Hodges,
	Edmund Jay,
	James Manger,
	Tony Nadalin,
	Axel Nennker,
	Emmanuel Raviart,
	Nat Sakimura,
	Jim Schaad,
	Hannes Tschofenig,
	and Sean Turner.
      </t>
      <t>
	Jim Schaad and Karen O'Donoghue chaired the JOSE working group and
	Sean Turner and Stephen Farrell served as Security area directors
	during the creation of this specification.
      </t>
    </section>

    <section title="Open Issues" anchor="TBD">
      <t>
	[[ to be removed by the RFC editor before publication as an RFC ]]
      </t>

      <t>
	The following items remain to be considered or done in this draft:

	<list style="symbols">
	  <t>
	    Should all header fields continue to be required
	    to be understood by implementations using them
	    or should a means of declaring that specific header fields
	    may be safely ignored if not understood should be defined?
	  </t>
	</list>
      </t>
    </section>

    <section title='Document History' anchor="History">
      <t>
	[[ to be removed by the RFC editor before publication as an RFC ]]
      </t>

      <t>
	-08
	<list style='symbols'>
	  <t>
	    Replaced uses of the term "AEAD" with "Authenticated Encryption", since
	    the term AEAD in the RFC 5116 sense implied the use of a particular
	    data representation, rather than just referring to the class of
	    algorithms that perform authenticated encryption with associated data.
	  </t>
	  <t>
	    Applied editorial improvements suggested by
	    Jeff Hodges and Hannes Tschofenig.
	    Many of these simplified the terminology used.
	  </t>
	  <t>
	    Clarified statements of the form "This header parameter is OPTIONAL"
	    to "Use of this header parameter is OPTIONAL".
	  </t>
	  <t>
	    Added a Header Parameter Usage Location(s) field to the
	    IANA JSON Web Signature and Encryption Header Parameters registry.
	  </t>
	  <t>
	    Added seriesInfo information to Internet Draft references.
	  </t>
	</list>
      </t>
      <t>
	-07
	<list style='symbols'>
	  <t>
	    Added a data length prefix to PartyUInfo and PartyVInfo values.
	  </t>
	  <t>
	    Updated values for example AES CBC calculations.
	  </t>
	  <t>
	    Made several local editorial changes to clean up loose ends
	    left over from to the decision to only support
	    block encryption methods providing integrity.
	    One of these changes was to explicitly state that the
	    <spanx style="verb">enc</spanx> (encryption method) algorithm
	    must be an Authenticated Encryption algorithm with a specified key length.
	  </t>
	</list>
      </t>
      <t>
	-06
	<list style='symbols'>
	  <t>
	    Removed the <spanx style="verb">int</spanx> and
	    <spanx style="verb">kdf</spanx> parameters and defined the new composite
	    Authenticated Encryption algorithms <spanx style="verb">A128CBC+HS256</spanx> and
	    <spanx style="verb">A256CBC+HS512</spanx> to replace the former
	    uses of AES CBC, which required the use of separate integrity
	    and key derivation functions.
	  </t>
	  <t>
	    Included additional values in the Concat KDF calculation -- the
	    desired output size and the algorithm value,
	    and optionally PartyUInfo and PartyVInfo values.
	    Added the optional header parameters
	    <spanx style="verb">apu</spanx> (agreement PartyUInfo),
	    <spanx style="verb">apv</spanx> (agreement PartyVInfo),
	    <spanx style="verb">epu</spanx> (encryption PartyUInfo), and
	    <spanx style="verb">epv</spanx> (encryption PartyVInfo).
	    Updated the KDF examples accordingly.
	  </t>
	  <t>
	    Promoted Initialization Vector from being a header parameter to being
	    a top-level JWE element.
	    This saves approximately 16 bytes in the compact serialization,
	    which is a significant savings for some use cases.
	    Promoting the Initialization Vector out of the header also avoids repeating
	    this shared value in the JSON serialization.
	  </t>
	  <t>
	    Changed <spanx style="verb">x5c</spanx> (X.509 Certificate Chain)
	    representation from being a single string to being an array of strings,
	    each containing a single base64 encoded DER certificate value,
	    representing elements of the certificate chain.
	  </t>
	  <t>
	    Added an AES Key Wrap example.
	  </t>
	  <t>
	    Reordered the encryption steps so CMK creation is first, when required.
	  </t>
	  <t>
	    Correct statements in examples about which algorithms produce
	    reproducible results.
	  </t>
	</list>
      </t>
      <t>
	-05
	<list style='symbols'>
	  <t>
	    Support both direct encryption using a
	    shared or agreed upon symmetric key, and the use of a
	    shared or agreed upon symmetric key to key wrap the CMK.
	  </t>
	  <t>
	    Added statement that
	    "StringOrURI values are compared as case-sensitive strings
	    with no transformations or canonicalizations applied".
	  </t>
	  <t>
	    Updated open issues.
	  </t>
	  <t>
	    Indented artwork elements to better distinguish them from the body text.
	  </t>
	</list>
      </t>
      <t>
	-04
	<list style='symbols'>
	  <t>
	    Refer to the registries as the primary sources of defined
	    values and then secondarily reference the sections
	    defining the initial contents of the registries.
	  </t>
	  <t>
	    Normatively reference
	    <xref target="W3C.CR-xmlenc-core1-20120313">XML Encryption 1.1</xref>
	    for its security considerations.
	  </t>
	  <t>
	    Reference draft-jones-jose-jwe-json-serialization
	    instead of draft-jones-json-web-encryption-json-serialization.
	  </t>
	  <t>
	    Described additional open issues.
	  </t>
	  <t>
	    Applied editorial suggestions.
	  </t>
	</list>
      </t>
      <t>
        -03
        <list style='symbols'>
	  <t>
	    Added the <spanx style="verb">kdf</spanx> (key derivation function) header parameter
	    to provide crypto agility for key derivation.
	    The default KDF remains the Concat KDF with the SHA-256 digest function.
	  </t>
	  <t>
	    Reordered encryption steps so that the Encoded JWE Header
	    is always created before it is needed as an input to the Authenticated Encryption
	    "additional authenticated data" parameter.
	  </t>
	  <t>
	    Added the <spanx style="verb">cty</spanx> (content type) header parameter
	    for declaring type information about the secured content,
	    as opposed to the <spanx style="verb">typ</spanx> (type) header parameter,
	    which declares type information about this object.
	  </t>
	  <t>
	    Moved description of how to determine whether a header is
	    for a JWS or a JWE from the JWT spec to the JWE spec.
	  </t>
	  <t>
	    Added complete encryption examples for both Authenticated Encryption and non-Authenticated Encryption algorithms.
	  </t>
	  <t>
	    Added complete key derivation examples.
	  </t>
	  <t>
	    Added "Collision Resistant Namespace" to the terminology section.
	  </t>
	  <t>
	    Reference ITU.X690.1994 for DER encoding.
	  </t>
	  <t>
	    Added Registry Contents sections to populate registry values.
	  </t>
	  <t>
	    Numerous editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    When using Authenticated Encryption algorithms (such as AES GCM),
	    use the "additional authenticated data" parameter
	    to provide integrity for the header, encrypted key, and
	    ciphertext and use the resulting "authentication tag"
	    value as the JWE Integrity Value.
	  </t>
	  <t>
	    Defined KDF output key sizes.
	  </t>
	  <t>
	    Generalized text to allow key agreement to be employed
	    as an alternative to key wrapping or key encryption.
	  </t>
	  <t>
	    Changed compression algorithm from gzip to DEFLATE.
	  </t>
	  <t>
	    Clarified that it is an error when a <spanx style="verb">kid</spanx>
	    value is included and no matching key is found.
	  </t>
	  <t>
	    Clarified that JWEs with duplicate Header Parameter Names
	    MUST be rejected.
	  </t>
	  <t>
	    Clarified the relationship between
	    <spanx style="verb">typ</spanx> header parameter values
	    and MIME types.
	  </t>
	  <t>
	    Registered application/jwe MIME type and "JWE" typ header parameter value.
	  </t>
	  <t>
	    Simplified JWK terminology to get replace the "JWK Key Object" and
	    "JWK Container Object" terms with simply "JSON Web Key (JWK)"
	    and "JSON Web Key Set (JWK Set)" and to eliminate potential
	    confusion between single keys and sets of keys.
	    As part of this change, the Header Parameter Name for a
	    public key value was changed from
	    <spanx style="verb">jpk</spanx> (JSON Public Key) to
	    <spanx style="verb">jwk</spanx> (JSON Web Key).
	  </t>
	  <t>
	    Added suggestion on defining additional header parameters
	    such as <spanx style="verb">x5t#S256</spanx> in the future
	    for certificate thumbprints using hash algorithms other
	    than SHA-1.
	  </t>
	  <t>
	    Specify RFC 2818 server identity validation, rather than
	    RFC 6125 (paralleling the same decision in the OAuth specs).
	  </t>
	  <t>
	    Generalized language to refer to Message Authentication Codes (MACs)
	    rather than Hash-based Message Authentication Codes (HMACs)
	    unless in a context specific to HMAC algorithms.
	  </t>
          <t>
            Reformatted to give each header parameter its own section heading.
          </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
          <t>
           Added an integrity check for non-Authenticated Encryption algorithms.
          </t>
	  <t>
	    Added <spanx style="verb">jpk</spanx> and <spanx
	    style="verb">x5c</spanx> header parameters for including
	    JWK public keys and X.509 certificate chains directly in
	    the header.
	  </t>
	  <t>
	    Clarified that this specification is defining the JWE
	    Compact Serialization.  Referenced the new JWE-JS spec,
	    which defines the JWE JSON Serialization.
	  </t>
	  <t>
	    Added text "New header parameters should be introduced
	    sparingly since an implementation that does not understand
	    a parameter MUST reject the JWE".
	  </t>
	  <t>
	    Clarified that the order of the encryption and decryption
	    steps is not significant in cases where there are no
	    dependencies between the inputs and outputs of the steps.
	  </t>
	  <t>
	    Made other editorial improvements suggested by JOSE
	    working group participants.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created the initial IETF draft based upon
            draft-jones-json-web-encryption-02 with no normative
            changes.
          </t>
	  <t>
	    Changed terminology to no longer call both digital
	    signatures and HMACs "signatures".
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
