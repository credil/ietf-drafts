<?xml version="1.0" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc ipr="trust200902" category="info" docName="draft-adjih-dragoncast-00">

  <front>

    <title abbrev="Broadcast With Network Coding: DRAGONCAST"> 
        Broadcast With Network Coding: DRAGONCAST</title>
    <author initials="C.A." surname="Adjih" fullname="Cedric Adjih">
      <organization>Inria</organization>
      <address>
        <phone>+33-136-635-215</phone>
        <email>Cedric.Adjih@inria.fr</email>
      </address>
    </author>
    <author initials="SY.C." surname="Cho" fullname="Songyean Cho">
      <organization>Samsung Electronics Co.,LTD.(*)
  </organization>
      <address>
<postal><street>(*) Author(Songyean Cho)'s contribution was done
before </street><street>joining Samsung Electronics.</street></postal>
        <email>Songyean.Cho@gmail.com</email>
      </address>
    </author>
    <author initials="E.B." surname="Baccelli" fullname="Emmanuel Baccelli">
      <organization>Inria</organization>
      <address>
        <phone>+33-169-335-511</phone>
        <email>Emmanuel.Baccelli@inria.fr</email>
	<uri>http://www.emmanuelbaccelli.org/</uri>
      </address>
    </author>
    <date />  <!-- day='23' month='November' year='2012'/  -->
    <area>Internet Research Task Force (IRTF)</area>
    <workgroup>Network Coding Research Group (NCWCRG)</workgroup>
    <keyword>I-D</keyword>
    <keyword>Internet Draft</keyword>

<!-- <t><vspace blankLines="6" /></t> -->
<abstract>
<t>
  This document describes a Network Coding (NC) based
  broadcast protocol suitable mainly for wireless networks,
  including mobile ad hoc networks (MANET).

  It provides data dissemination from a single source, based on
  intra-flow network coding and for Internet Protocol (IP).
  It is designed to minimize the assumptions
  over the working environment and thus may operates over
  dynamically evolving environments. 

<!--  It is based on three building blocks:
  a mechanism to permit real-time decoding of network coding,
  a policy to adjust the network coding transmission packet rates,
  and a control plane for initiating, maintaining and 
  ensuring the termination of the broadcast. -->
</t>
</abstract>
</front>

<!-- ====================================================================== -->
<!-- ====================================================================== -->

<middle>
<section anchor='introduction' title='Introduction'>

<t> The goal of this document is to describe a protocol for broadcast
in wireless networks with network coding.</t>

<t> It is best suited to multi-hop wireless networks. Compared to
wired networks, they have specific properties, see for instance
<xref target="I-D.baccelli-multihop"/>, including:
  <list style="hanging">
  <t>- Wireless 'neighborcast': one wireless transmission by a node may reach 
   several receivers. This property may be used to optimize broadcast.</t>
  <t>- Time-variation: the visibility between two nodes may evolves
  with time, due to node mobility, physical changes in the 
  propagation environment or other reasons.</t>
  <t>- Unreliability of wireless communications: due to wireless channel 
  conditions or properties, transmissions losses (packet erasures) 
  potentially occur.</t>
</list>
</t>

<t> In wireless networks, applications sometimes require the communication 
primitive of broadcasting information to the entire network. As an example,
in the context of MANETs, the Simplified Multicast Forwarding (SMF) 
<xref target="RFC6621"/> has been proposed for this purpose. </t>

<t> For applications where a single source sends a large volume of
information to the entire network, it will be split in several packets,
which will then be broadcast to the entire network. In this case,
network coding can provide two features: natural error correction,
and efficiency (in terms of the number of transmissions).
A large literature on this topic has evidenced the benefits of network 
coding and explored design and implementation aspects.</t>

<!-- From an information-theoretic point of view, the case of broadcast
with a single source in a static network is well understood,
see for instance Deb. et al \cite{bib:DEHKKLMR05}
or Lun et al. \cite{bib:LMKE07} and their references.
In practical networks, the simple method
\emph{random linear coding} from Ho et al. \cite{bib:HKMKE03} may be used
but several features should be added.  -->

<t> In this document, we present DRAGONCAST (D.R.A.G.O.N., "Dynamic
Rate Adaptation from Gap with Other Nodes"), one such protocol for
broadcasting with network coding.</t>

<t> It is based on intra-flow coding.  It attempts to maximize
simplicity and universality: it does not use explicitly or implicit
knowledge relative to the topology (such as the direction or distance
to the source, the loss rate of the links, ...), hence is perfectly
suited to the most dynamic wireless networks.</t>

</section>

<!-- ====================================================================== -->

<section title='Terminology'>


<texttable anchor="table-abbreviation">
<ttcol>Abbreviation</ttcol><ttcol>Definition</ttcol>
<c> MANET        </c><c> Mobile Ad Hoc Network </c>
<c> NHDP         </c><c> Neighborhood Discovery Protocol </c>
<c> OLSR         </c><c> Optimized Link State Routing </c>
<c> SMF          </c><c> Simplified Multicast Forwarding </c>
<c> TLV          </c><c> Type-Length-Value encoding </c>
<c></c><c></c>
<c> DRAGON       </c><c> Dynamic Rate Adaptation from Gap with Other Nodes </c>
<c> SEW          </c><c> Sliding Encoding Window </c>
<c></c><c></c>
<c> PME          </c><c> Protocol Message Element </c>
<c> F-PME        </c><c> Flow Protocol Message Element </c>
<c> S-PME        </c><c> State Protocol Message Element </c>
<c> ED-PME       </c><c> Encoded Data Protocol Message Element </c>
</texttable>


<t>
The following table summarizes the definitions and
notations related to network coding in general and to DRAGONCAST.
More details on network coding can be found in <xref target="NC-base"/>.
</t>

<texttable anchor="table-definition">
  <ttcol>Name</ttcol><ttcol>Definition</ttcol>
  <c>Coded Packet</c><c>Linear combination of source packets</c>
  <c>Encoding Vector</c><c>Coefficients in the linear combination 
                     of source packets</c>
  <c>Vector</c><c>abbrev. for "Information Vector", coded packet</c>
  <c>Innovative</c><c>A coded packet that brings new information</c>
</texttable>

<texttable anchor="table-notation">
  <ttcol>Name</ttcol><ttcol>Notation</ttcol>
  <c>Source packets</c>
     <c> P(1), ..., P(k) </c>
  <c>Linear combination of packets</c>
     <c>a(1) P(1) + ... + a(k) P(k)</c>
  <c>Set of coded packets at a node v</c> 
     <c>q(v,i) = a(v,i,1) P(1) + ... + a(v,i,M) P(M)</c>
</texttable>

</section>

<!-- ====================================================================== -->

<section title='Protocol Overview'>
<t> DRAGONCAST is a protocol for broadcasting a set of packets from
one source to a entire network with network coding (various parts are
described in <xref target="CA08a"/>, <xref target="CA08b"/>, 
<xref target="C08"/>).  The protocol is distributed and requires minimal
coordination.</t>

<t> The base functioning is simple: the broadcast is initiated by
transmissions for the source. Every node in the network retransmits
coded packets with a changing interval between transmissions.  At the
same time, every node collects received coded packets, and performs
decoding as they are received. Finally, termination is automatically
detected when all the nodes have successfully received all data.</t>

<t> DRAGONCAST is based on several building blocks that 
are in two categories. The first category concerns the protocol
aspects themselves:

<list style="symbols">
  <t> DRAS (DRAgoncast Signaling): the signaling for the control
  plane for DRAGONCAST. The signaling is mostly present on a header to
  each coded packet (e.g piggybacking). It includes with information
  relative to the state of the node, in addition to the packet encoding
  information. This allows each node to maintains information about the
  state of its neighbors.</t>
  <t> DRALIB (DRAgoncast Local Information Base): this information base
  maintains information about the flows, the decoding process,
  and the state of the neighbors</t>
  <t> DRAGONCAST: the protocol itself with message generation and
  message processing</t>
</list>

The second category is relative to policy, that is building blocks
that define high level protocol behavior:
<list style="symbols">
  <t> DRAGON: a dynamic packet rate adjustment policy.  Every node is
  retransmitting coded packets with a certain packet rate; this rate is
  adjusted dynamically. Essentially, the rate of the node increases if
  it detects some nodes in the current neighborhood are "falling behind" in
  the decoding process. This is called a "dimension gap", and the proposed
  adaptation algorithm is a Dynamic Rate Adjustment from Gap with Other Nodes
  (DRAGON), a heuristic.</t>
  <t> SEW: a real-time decoding method denoted SEW (Sliding Encoding
  Window).  It does not requires the concept of generation; instead, the
  knowledge of the state of neighbors is used to constrain the content
  of generated coded packets and allow real-time decoding. SEW maintains
  a buffer of the currently undecoded packets.</t>
</list>

The <xref target="fig-DCBB"/> represents the organization of the different
building blocks.
</t>

<figure anchor="fig-DCBB"
   title="Organization of the DRAGONCAST Building Blocks">
<artwork>
                                               Application (source)
................................................^..................
                                                V
  +---------------------------+    +---------------------------+
  |                           |    |                           |
  |         DRAGON            |    |           SEW             |
  |                           |    |                           |
  |   Packet Rate Selection   |    |    Packet Encoding and    |
  |                           |    | Real-time Packet Decoding |
  +---------------------------+ +->|                           |
               ^                |  +---------------------------+
Policy         |         +------+               ^     
...............|.........|......................|..................
Protocol       V         v                      v        
  +---------------------------+    +---------------------------+
  |                           |    |                           |
  |        DRAGONCAST         |    |          DRALIB           |
  |                           +&lt;--->                           |
  |         Protocol          |    |   Local Information Base  |
  |                           |    |                           |
  +---------------------------+    +---------------------------+
               ^ 
               |                      .............................
               v                      .          Operating System
  +--------------+------------+       .
  |                           |       .     +--------------+
  |          DRAS             |       .     |              |
  |                           +&lt;----------->+   IP Stack   | 
  |       Signaling           |       .     |              |
  |                           |       .     +--------------+
  +---------------------------+       .
</artwork>
</figure>

<t>

</t>




<!-- .............................. -->

<!-- ====================================================================== -->


<!-- ====================================================================== -->


<!-- .............................. -->

<section anchor="general" title="General Functioning">

<t>
The source initiates broadcasting by sending
its original data packets with a format specified 
in <xref target="DRAS"/>.
</t>
<t>
When the source sends data packets, it produces packets of a predefined,
constant size, using padding if necessary.
Other nodes initiate transmission of encoded data
upon receiving the first coded packet, and stay in a transmission
state where they will retransmit coded packets with an interval decided by
packet rate selection algorithms. Precisely, when intermediate nodes
receive a data packet that is a source packet or a coded packet,
they start scheduling encoded data transmission. 
</t>

<t>
The scheduling
interval is decided by the policy DRAGON from <xref target="packet-rate-sel"/>.
Transmitted packets by intermediate nodes are coded packets
generated using random linear coding with a header specified in
<xref target="DRAS"/>.
Data transmission
continues until nodes detect the termination condition, i.e. that 
themselves and all their neighbors have successfully decoded the data stream.
</t>


<t>
General operations of the protocol are described in the following
algorithm:
<list style="numbers">
  <t> Source data transmission scheduling: the source transmits
  sequentially D vectors (packets) of a generation with rate C</t>
  <t> Nodes' data transmission start condition: the nodes start
  transmitting a vector when they receive the first vector.</t>
  <t> Nodes' data storing condition: the nodes store a received vector
  in their local buffer only if the received vector has new and
  different information from the vectors that the nodes already
  have.</t>
  <t> Nodes' termination conditions: the nodes
  continue transmitting until themselves and their current
  known neighbors in their local information base have enough
  vectors to recover the D source packets.</t>
  <t> Nodes' data transmission scheduling: every node retransmits
  linear combinations of the vectors in its local buffer after
  waiting for a delay computed from the rate selection.</t>
  <t> Nodes' data transmission restart condition: When one node
  receives a notification indicating that one neighboring node
  requires more vectors to recover the D source packets and it
  has already stopped data transmission, the node re-enters in a
  transmission state.</t>
</list>
</t>

</section>



<section anchor="DC-principles" title='Protocol Principles and Definitions'>
<t>
DRAGONCAST uses the following concepts and definitions:
<list style="symbols">
  <t>Source: a source is a node that will broadcast information to the
  network. This information is called a "flow". A source may have an
  arbitrary number of flows, however each flow will be coded
  independently (intra-flow coding).</t>
  <t>Flow: a flow is the unit of transmission of the protocol
  DRAGONCAST.  The flow represents a sequence of bytes at the source
  that need to be broadcast. The source divides the flow in a sequence
  of packets of equal size (padding may be used). The packets are
  numbered, and can be identified by their packet index. The packets of
  one flow may optionally divided in several generations (one per
  default).</t>
  <t>Generation: a generation is a subset of a consecutive packets of one flow.
  </t>

</list>

</t>
</section>

</section>

<!-- ====================================================================== -->

<section anchor="DRAS" title='DRAS: DRAGONCAST Signaling'>
<t>
<!-- DRAGONCAST Signaling relies on a specific packet format defined
in the next section. -->

DRAGONCAST uses one single packet format based on a sequence of
Type-Value including several protocol elements.
The general packet format is represented in <xref target="fig-packet-format"/>.

<figure anchor="fig-packet-format">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Packet size          |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
  |                                                               |
  |               Protocol Message Element (PME)                  |
  |                                               +-+-+-+-+-+-+-+-+
  |                                               |               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
  |                                                               |
  :                              ...                              :
  |                                                               |
  |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                                                               |
  |               Protocol Message Element (PME)                  |
  |                                               +-+-+-+-+-+-+-+-+
  |                                               |               
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               
</artwork>
</figure>



The following protocol elements are defined: 
<list style="symbols">
  <t>The Flow Protocol Message Element (F-PME), 
  <xref target="fig-pme-flow-format"/>: it specifies information identifying the
  flow and associated (constant) parameters.</t>
  <t>The State Protocol Message Element (S-PME), 
  <xref target="fig-pme-state-format"/>: it specifies information relative to
  the state of the sender with respect to the decoding process.</t>
  <t>The Encoded Data Protocol Message Element (ED-PME),
  <xref target="fig-pme-encoded-data-format"/>: it specifies
  parameters of the encoding, along with the coding vector and
  include the coded packet data.</t>
</list>
</t>



<t>
They are used as the basis for DRAGONCAST Packets. Control
information is sent in-band, prepended to encoded packets.  In the
normal flow of the protocol, the majority of transmitted packets are
"Data Packets".

In the current version of the specification, the packet MUST respect
exactly one of the following formats:
<list style="symbols">
  <t>A regular data packet (with coded content): it MUST include
  the three following elements, in this order exactly: F-PME, S-PME, ED-PME
  </t>
  <t>A termination control packet (e.g. without coded content): it
  MUST first include the two following elements, in this order exactly:
  F-PME, S-PME.</t>
</list>
</t>

<t>
<figure anchor="fig-pme-flow-format" title="Format of the Flow PME">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Type: FLOW                    |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
  |                     Flow Identifier (64 bits)                 |
  |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                               |     Generation Identifier     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |      Source Packet Rate       | Generation Number of Packets  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Sliding Encoding Window Size  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
The Flow PME includes the following fields:
<list style="symbols">
  <t>Flow Identifier (Flow-ID): an identifier of size 8 bytes for the flow.
  Its semantics is opaque to DRAGONCAST.</t>
  <t>Generation Identifier: DRAGONCAST includes support for splitting a flow
  (with a given Flow-ID), which allows flows with more than
   65535 packets, and also allows to optionally operate with generations.</t>
  <t>Source Packet Rate: expressed as the average inter-departure of the
     coded packets in milliseconds (e.g. "10 packets per second" yields
     the value 100).</t>
  <t>Generation Number of Packets: total number of packets in the Generation
     with the given Generation ID.</t>
  <t>Sliding Encoding Window Size: the size of the encoding window, 
     when generating coded packets.</t>
</list>
</t>

<t>
<figure anchor="fig-pme-state-format" title="Format of the State PME">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Type: STATE                   |      Rank of Transmitter      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           Lifetime            |     Number of Neighbors       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          High Index           |          Low Index            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                                                               |
  |                     Transmitter Address                       |
  |                                                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
The State PME specifies state information of transmitter with respect
to the generation identified by a preceding F-PME and includes:
<list style="symbols">
  <t>Rank of Transmitter: denotes the current amount of
  innovative data of the transmitter for the generation.</t>
  <t>Lifetime: denotes duration during which the information in
  this packet (that is, the rank and the fact that transmitter is a
  neighbor of a node receiving this packet) is considered valid
  (after this it will expire).</t>
  <t>Number of neighbors: denotes the number of neighbors heard, that 
  are not yet expired.</t>
  <t>High Index: specifies the highest index present in a undecoded
   linear combination in the decoding table.</t>
  <t>Low Index: specifies the lowest index present in a undecoded
  linear combination in the decoding table. Hence all source packets
  with lower indices have been decoded.</t>
  <t>Transmitter Address: the IP address of the transmitter of the message.</t>
</list>

</t>

<t>
<figure anchor="fig-pme-encoded-data-format" 
  title="Format of the Encoded Data PME">
<artwork>
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |Type: ENCODED_DATA             | Encoding Type and Parameters  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Encoding Vector Data Size   |     Coded Packet Data Size    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  | Encoding Vector Index Offset  |                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
  |                     Encoding Vector Data                      |
  :                              ...                              :
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Coded Packet Data                       |
  :                              ...                              :
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
</figure>
The Encoded Data PME holds actual coded packet content:
<list style="symbols">
  <t>Encoding Type and Parameters: in this version of the
  specification, the fields contains one of the constants ENCODING_GF_2,
  ENCODING_GF_4, ENCODING_GF_16 ENCODING_GF_256. This represents the
  fact that the fields GF(2), GF(4), GF(16), or GF(256) respectively are
  used as basis for the linear combination.  As a result, the
  coefficients are respectively coded on 1, 2, 4 or 8 bits.  </t>
  <t>Encoding Vector Data Size: the size of the information
  representing the encoding vector, in bytes. As indicated above, one byte
  will hold an integral number of vector coefficients.  </t>
  <t>Coded Packet Data Size: the size of data packets.</t>
</list>
</t>

<t>
Constants: <!-- XXX -->
  ENCODING_GF_2 = 0
  ENCODING_GF_4 = 1 
  ENCODING_GF_16 = 2
  ENCODING_GF_256 = 3
</t>

</section>

<!-- ====================================================================== -->

<section anchor="DRALIB" title='DRALIB: DRAGONCAST Local Information Base'>
<t>
A node maintains a Local Information Base that records information
about its decoding process, and the state of the neighbors.
</t>
<t>
The protocol state is maintained per flow: a flow is uniquely identified
by a flow identifier. In addition, DRAGONCAST supports the concept of
partitioning a flow into generations. 
In this version of the specification, each generation
is considered as an independent "flow".
</t>
<t>
The different information bases of DRALIB are structured hierarchically
as follows:
<list style="symbols">
  <t>Flow Information Set. Each flow is independently associated 
      a Flow Information Tuple, which contains one or several 
      generations. Their state is maintained in a:
     <list style="symbols">
     <t>Generation Information Set. Each generation contains 
        the state of the neighbors with respect to the propagation and
        the decoding of the generation, stored in a:
	<list style="symbols">
	 <t>Neighbor Information Set, describing the neighbors.
Such information may also be provided by another protocol, such as
OLSR <xref target="RFC3626"/> or NHDP <xref target="RFC6130"/> </t>
	</list>
        In addition, for decoding purposes, it includes the:
        <list style="symbols">
        <t>Decoding Information Base</t>
        </list>
     </t>
     </list>
  </t>
</list>
</t>

<!-- section anchor="flow-set" title="Flow Information Set" -->
<t>
Each node maintains a Flow Information Set, which contains 
collected information about current flows.
Specifically, the Flow Information Set consists of Flow Information Tuples
each which records:
<list style="symbols">
<t>Flow Information Tuple</t>
<t>F_flow_identifier: the identifier of the flow</t>
<t>F_source_rate: the packet rate of the source</t>

<t>F_generation_set: the Generation Information Set associated to the flow</t>
</list>
</t>
<!-- /section -->

<!-- section anchor="generation-set" title='Generation Information Set' -->
<t>
Each node maintains, for each of its Flow Information Tuple,
a Generation Information Set, which contains information specific
to a generation:
<list style="symbols">
<t>Generation Information Tuple</t>
<t>G_generation_identifier: an integer (generations are numbered from 0)</t>
<t>G_generation_size: number of coded packets in the generation</t>
<t>G_encoding_window_size: the size of the sliding encoding window (for SEW)</t>
<t>G_decoding: the Decoding Information Base associated to this generation</t>
<t>G_neighbor_set: the Neighbor Information Set associated to 
this generation</t>
</list>
</t>
<!-- /section -->


<!-- section anchor="neighbor-set" title="Neighbor Information Set" -->
<t>For each generation, a node maintains a Neighbor Information Set,
which contains its known neighbors (with an expiration time), and
information related to their state.</t>
<t>Specifically, the Neighbor Information Set consists of Neighbor Tuples, 
each of
which contain information about a single neighbor, for a given flow
and for a given generation, as follows:
<list style="symbols">
<t>Neighbor Tuple</t>
<t>N_neighbor_address: address of the neighbor (heard) node</t>
<t>N_neighbor_rank: the rank of the neighbor</t>
<t>N_high_index: high index of the neighbor</t>
<t>N_low_index: low index of the neighbor</t>
<t>N_validity_time: the validity time of the tuple (after which it expires)</t>
</list>
</t>
<!-- /section -->

<!-- section anchor="decoding-information-base" title="Decoding Information Base" -->
<t>
For each generation, a node maintains a Decoding Information Base
with the following content:
<list style="symbols">
<t>D_coded_packet_set: a set of coded packets. For each, the node maintains:
   <list style="symbols">
   <t>Encoding vector</t>
   <t>Coded packet content</t>
   </list>
</t>
</list>
During the decoding process, the decoding module (SEW) performs
real-time decoding by performing Gaussian elimination on the list of 
coded packets.


</t>
<!-- /section -->


</section>

<!-- ====================================================================== -->


<section title="DRAGONCAST Protocol Functioning">

<section title="Source Packet Generation">
<t>
A node that acts as a data source for a flow, also runs a
instance of the DRAGONCAST protocol for that flow
(e.g. has a Flow Tuple with all associated information).
</t>
<t>
In addition,
it adds periodically source packets in the associated Flow Information Base
respecting the source rate.
</t>
</section>

<section title="Packet Processing">
<t>
Whenever a node receives an encoded packet:

<list style="symbols">
<t> It updates its Flow Information
Base related to the associated flow. This includes rank and expiration time.
</t>
<t> It notifies SEW for real-time decoding. In turn, SEW will forward
  any decoded packets to the application.</t>
<t> It notifies DRAGON which may update the transmission packet rate 
  of the flow.</t> 
</list>
</t>
</section>

<section title="Packet Generation">
<t>
For every "active" flow in its Flow Information Base, a node will
generate coded packets, with an interval between packets defined
by DRAGON (from the computed packet rate).
</t>
<t>
If for a given flow and generation, in the associated
neighbor set, no neighbor is known to require coded packets,
the packet is generated without encoded packet (without Encoded Data PME).
</t>
<t>
From information in its Local Information Base, every node is able to
determines if it needs to sends packets, as described 
in <xref target="C08"/>.
</t>
</section>


</section>

<!-- ====================================================================== -->

<section anchor="packet-rate-sel" title='DRAGON: Packet Rate Selection'>


<t>In this section, we describe one packet rate selection algorithms,
proposed for DRAGONCAST.</t>


<section title="DRAGON Rationale">

<t> The heuristic DRAGON has been proposed and analyzed in
<xref target="CA08a"/>, and is inspired by Fragouli et al.
<xref target="FWB06"/>. We briefly summarize it in this section for
completeness.  The starting point of our heuristic DRAGON, is that the
observation that, for real-time decoding, the rank of nodes inside the
network should be close to the index of the last source packet, and
that in any case, they should at least evolve in parallel.</t>

<t> Thus, one would expect the rank of a node to grow at the same pace
as the source transmission, as in the example of optimal rate
selections for static networks.
Decreasing the rates of intermediate nodes by a too large factor,
would not permit the proper propagation of source packets in real
time. On the contrary, increasing excessively their rates, would
not increase the rate of the decoded packets (naturally bounded by
the source rate) while it would decrease energy-efficiency (by
increasing the amount of redundant transmissions).</t>

<t> The idea of the proposed rate selection is to find a balance
between these two inefficient states. As we have seen, ideally the
rank of a node would be comparable to the lastly sent source packet.
Since we wish to have a simple decentralized algorithm, instead of
comparing with the source, we compare indirectly the rank of a node
with the rank of all its perceived neighbors.</t>

<t> The key idea is to perform a control so that the rank of neighbor
nodes would tend to be equalized: if a node detects that one neighbor
had a rank which is too low in comparison with its own, it would tend
to increase its rate. Conversely, if all its neighbors have greater
ranks than itself, the node need not to send packets in fact.</t>
</section>


<section title="DRAGON (Dynamic Rate Adaptation from Gap with Other Nodes)">

<t>
In this section, we describe the proposed heuristic, DRAGON, as
a packet rate selection.

It is based on the following definitions. Precisely, let:
<list style="symbols">
<t>D(v,t) denote the rank of a node v at time t</t>
<t>N(v,t) denote the number of neighbors of one node</t>
<t>g(v,t) denote the maximum gap of rank with its neighbors, 
  normalized by the number of neighbors</t>
</list>

Then g(v,t) is evaluated as:
<list style="symbols">
<t>g(v,t) = maximum, for all neighbors u, of { (D(v,t) - D(u,t)) / N(u,t) }</t>
</list>
</t>

<t>
We propose the following rate selection, DRAGON (Dynamic
Rate Adaptation from Gap with Other Nodes), which adjusts the
rates dynamically, based on that gap of rank between one node and
its neighbors as follows:

The packet rate of node v is set to C(v,t) at time t as:
<list style="symbols">
<t>if g(v,t) > 0 then: C(v,t) = A g(v,t) 
where A is some constant.</t>
<t>Otherwise, the node stops sending encoded packets until
g(v,t) becomes larger than 0.</t>
</list>
</t>

<t>
When computing the packet rate selection, DRAGONCAST Local Information Base
supplies the information necessary: for each neighbor, the rank and
the number of neighbors of the last packet received, are maintained 
in the Neighbor Set. Although they might not necessarily reflect the exact
values at the computation time, they are provide an estimate.
</t>

<!-- 
%This heuristic has some strong similarities, with the reasonings
%presented in \refsec{sec:IRON}. Consider the cut at one
%destination $v$: then
Consider the total rate of the transmissions
that one node would receives from its neighbors:
the \emph{local received rate}.
In a static network with the previous rate selection:
\dragon{} ensures that every node will
receive a total rate at least equal to the average gap of one node
and its neighbors scaled by $\alpha$. That is, the local received
rate, at time $\tau$ verifies: \NotRR{\vspace{-2mm}}
$$\mathrm{Local~Received~Rate} \ge \alpha \left( \frac{1}{|H_v|}
   \sum_{u \in H_v} D_u(\tau)-D_v(\tau) \right)\vspace{-2mm}$$

This would ensure that the gap with the neighbors would be closed
in time $\approx \le \frac{1}{\alpha}$ if the neighbors did not
receive new innovative packets. Notice that this is independent
from the size of the gap: the greater the gap, the higher the
rate. 
%If all these things are considered,
Overall, the time for closing the
gap would be identical. This is only an informal argument to
describe the mechanisms of DRAGON; however experimental results in
\refsec{sec:simulations}, illustrate the proper behavior of the
algorithm, and its synergy with SEW.
%rates is improved by
-->

</section>

</section>

<!-- ====================================================================== -->

<section anchor="SEW" title='Real-time Decoding: Sliding Encoding Window (SEW)'>

<t> In this section, we describe the method of DRAGONCAST for real-time
decoding, which allows recovery of some source packets without
requiring to decode all source packets at once. 
It is related to the method from Sundararajan et al. <xref target="SSMMB09"/>
described for TCP.
</t>
<t>
The real-time decoding method, Sliding Encoding Window (SEW) relies on
implicit cooperation between neighbor nodes, in order to ensure the
possibility of decoding. 
(Technically, as described in <xref target="CA08a"/>, it ensures the
existence of a low triangle in global encoding vectors saved in a node
during the online Gauss elimination process).
</t>

<t>
The key of SEW, is to ensure the existence of an early decoding part;
to do so, every node in DRAGONCAST keeps track of the state of its
neighbors, in order to only send packets,
The method SEW relies on two principles:
<list style="symbols">
<t>SEW coding rule: generates only coded packets that are linear
combinations of the first L source packets, where L is a quantity that
increases with time.</t>
<t>SEW decoding rule: when decoding, performs a Gaussian elimination,
in such a way that one coded packet is only used to eliminate the
source packet with the highest possible index (i.e. the latest source
packet).</t>
</list>
</t>

<t>
Before detailing the insights behind these rules, we first give definition:
the high index of a node, and the low index of a node.  
As explained in <xref target="NC-base"/>, a coded
packet is a linear combination of source packets. 
<!-- If we assume
that the most recently generated source packet has always the highest
sequence number,
that is if the source is successively sending
packets $P_1$, $P_2$, $P_3$, \ldots with sequence numbers $1$, $2$, $3$,
\ldots, then it is meaningful to
identify the highest and lowest such sequence number in the global encoding
vector of any coded packet.
%the sequence numbers of source
%packets coded in a coded packet. -->
We define the highest and lowest index of a linear combination, 
as the minimum and maximum  of the coded packets respectively.
For instance, a packet Q = P(3) + P(5) + P(7) + P(8), the highest index
is 8 and the lowest index is 3.
</t>

<t>
Because all encoded packets have their own
highest index and lowest index, we can also compute the maximum of the
highest index of all not-yet decoded packets in a node, as well as the
minimum of the lowest index. We refer to the maximum and
the minimum as high index of a node and low
index  of a node. Notice that a node will generally have
decoded the source packets from 1 up to its low index.
</t>

<t>
The intent of the SEW coding rule is to use knowledge about the
state of neighbors of one node, namely their high and low index. A
node restricts the generated packets to a subset of the packets of
the source, until it is confirmed that perceived neighbors of the
node are able to decode nearly all of them, up to a margin K.
Notice that once all its neighbors may decode up to the first
L-K packets, it is unnecessary for the node to include packets
P(1), ... P(L) in its generated combinations.
</t>

<t>
Hence, the general idea of SEW is that it restricts the mixed original
packets within an encoded packet from a window of a fixed size K.  In
other words, a node encodes only source packets inside a fixed
Encoding Window as:
<list style="hanging">
<t>i-th generated packet q(v,i) = a(v,i,k) P(k) + .... + a(v,i,k_K) P(k+K)</t>
</list>
where the { P(j) } is the set of packets generated by the source,
The sequence of coefficients for q(v,i) is 
the following global encoding vector:
[ 0, 0, ..., a(v,i,k), a(v,i,k+1), ..., a(v,i,k+K), ...,0,0].
A node will repeat transmissions of new random combinations within
the same window, until its neighbors have progressed in the decoding process.
</t>

<t>
The intent of the SEW decoding rule, is to guarantee proper
functioning of the Gaussian elimination. An example of SEW
decoding rule is the following: assume that node v has received
packets q(1) and q(2), for instance q(1) = P(1) + P(9) and q(2) =
P(1) + P(2) + P(3). Then q(1) would be used to eliminate P(9) for
newly incoming packets (the highest possible index is 9), and
q(2) would be used to eliminate P(3) from further incoming
packets. On the contrary, if the SEW decoding rule was not applied
and if q(1) were used to eliminate P(1), then it would be used
to eliminate it in q(2), and would result into the computation of
q(2) - q(1) = P(2) + P(3) - P(9); this quantity now requires
elimination of P(9), an higher index than the initial one in
q(2). In contrast the SEW decoding rule guarantees the following
invariant: during the Gaussian elimination process, the highest
index of every currently non-decoded packet will always stay
identical or decrease.</t>

<t>
Provided that neighbor state is properly exchanged and known,
as a result, the combination of the SEW coding rule and the SEW decoding rule,
guarantee that ultimately every node will be able to decode
the packets in the window starting from its lowest index; that is,
they guarantee early decoding.</t>

<t>
Notice that improper knowledge of neighbor state might impact
the performance of the method but not
its correctness: if a previously unknown neighbor is detected
(for instance due to mobility), the receiving node will properly
adjust its sending window. Conversely, in DRAGONCAST, obsolete
neighbor information, for instance about disappeared neighbors,
will ultimately expire.
</t>

</section>





<!-- ====================================================================== -->

<section anchor="security" title="Security Considerations">
<t>
This document does not have any security considerations.
</t>
</section>
<section anchor="iana" title="IANA Considerations">
<t>
This document does not have any IANA actions. 
</t>
</section>


<!-- ====================================================================== -->
<!-- ====================================================================== -->



<!-- ====================================================================== -->


<!-- ====================================================================== -->
<!-- ====================================================================== -->
</middle>

<back>

<!-- ====================================================================== -->


<references title="Informative References">

<!-- ?rfc include='reference.I-D.draft-baccelli-manet-multihop-communication-02.xml'? -->
<?rfc include='reference.RFC.3626.xml'?>
<?rfc include='reference.RFC.6130.xml'?>
<?rfc include='reference.RFC.6621.xml'?>

<reference anchor='I-D.baccelli-multihop'>
<front>
<title>Multi-hop Ad Hoc Wireless Communication</title>

<author initials='E' surname='Baccelli' fullname='Emmanuel Baccelli'>
    <organization />
</author>

<author initials='C' surname='Perkins' fullname='Charles Perkins'>
    <organization />
</author>

<date month='July' day='11' year='2013' />

<abstract><t>This document describes characteristics of communication between nodes in a multi-hop ad hoc wireless network, that protocol engineers and system analysts should be aware of when designing solutions for ad hoc networks at the IP layer.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-baccelli-manet-multihop-communication-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-baccelli-manet-multihop-communication-02.txt' />
</reference>


 
<!-- .............................. -->

<reference anchor="CA08a">
  <front>
    <title>Wireless Broadcast with Network Coding: Dynamic Rate Selection</title>
    <author initials="S-Y.C." surname="Cho"
                    fullname="Song-Yean Cho">
    </author>
    <author initials="C.A." surname="Adjih" fullname="Cedric Adjih">
    </author>
    <date year="2008" month="June"/>
  </front>
  <seriesInfo name="Conference "
	      value="MedHocNet 2008" />
</reference>

<reference anchor="CA08b">
  <front>
    <title>Wireless Broadcast with Network Coding: DRAGONCAST</title>
    <author initials="S-Y.C." surname="Cho" fullname="Song-Yean Cho">
    </author>
    <author initials="C.A." surname="Adjih" fullname="Cedric Adjih">
    </author>
    <date year="2008" month="July"/>
  </front>
  <seriesInfo name="Inria Research Report "
	      value="RR-6569" />
</reference>

<reference anchor="C08">
  <front>
    <title>Efficient Information Dissemination in Wireless Multi-Hop 
           Networks</title>
    <author initials="S-Y.C." surname="Cho" fullname="Song-Yean Cho">
    </author>
    <date year="2008" month="Sept"/>
  </front>
  <seriesInfo name="Ecole Polytechnique"
	      value="PhD thesis" />
</reference>

<!-- .............................. -->

<reference anchor="HKMKE03">
  <front>
  <title>The Benefits of Coding over Routing in a Randomized Setting</title>
    <author initials="T.H." surname="Ho" fullname="T. Ho">
    </author>
    <author initials="R.K." surname="Koetter" fullname="R. Koetter">
    </author>
    <author initials="M.M." surname="Medard" fullname="M. Medard">
    </author>
    <author initials="D.K." surname="Karger" fullname="D. Karger">
    </author>
    <author initials="M.E." surname="Effros" fullname="M. Effros">
    </author>
    <date year="2003" month="Jun"/>
  </front>
  <seriesInfo name="International Symposium on Information Theory"
    value="2003" />
</reference>

<reference anchor="CWJ03">
  <front>
  <title>Practical Network Coding</title>
    <author initials="P.A.C." surname="Chou" fullname="P. Chou">
    </author>
    <author initials="Y.W." surname="Wu" fullname="Y. Wu">
    </author>
    <author initials="K.J." surname="Jain" fullname="K. Jain">
    </author>
    <date year="2003" month="Oct"/>
  </front>
  <seriesInfo name="Forty-third Annual Allerton Conference on Communication,
Control, and Computing"
    value="2003" />
</reference>

<reference anchor="FWB06">
  <front>
  <title>A Network Coding Approach to Energy Efficient Broadcasting</title>
    <author initials="C.F." surname="Fragouli" fullname="C. Fragouli">
    </author>
    <author initials="J.W." surname="Widmer" fullname="J. Widmer">
    </author>
    <author initials="J.-Y. L." surname="Le Boudec" fullname="J.-Y. Le Boudec">
    </author>
    <date year="2006" month="Apr"/>
  </front>
  <seriesInfo name="INFOCOM" value="2006" />
</reference>


<reference anchor="SSMMB09">
  <front>
  <title>Network Coding Meets TCP</title>
    <author initials="J.K.S." surname="Sundararajan" 
	    fullname="J.K. Sundararajan">
    </author>
    <author initials="D.S." surname="Shah" fullname="D. Shah">
    </author>
    <author initials="M.M." surname="Medard" fullname="M. Medard">
    </author>
    <author initials="M.M." surname="Mitzenmacher" fullname="M. Mitzenmacher">
    </author>
    <author initials="J.B." surname="Barros" fullname="J. Barros">
    </author>
    <date year="2009" month="Apr"/>
  </front>
  <seriesInfo name="INFOCOM" value="2009" />
</reference>

</references>

<!-- ====================================================================== -->


<section anchor='NC-base' title='Network Coding Fundamentals'>

<t>
This section introduces network coding concepts and terminology.
</t>


<t> Network coding differs from classical routing by permitting coding
at intermediate nodes.  One possible coding algorithm is linear coding
that performs only linear transformations through addition and
multiplication <!-- (see Li et al. \cite{bib:SYR03} and Koetter et
al. \cite{bib:KM03}). --> Precisely, linear coding assumes identically
sized packets and views the packets as vectors on a fixed Galois
field. It becomes then possible to perform linear combination of
packets.</t>

<section anchor='linear-coding' title="Linear Coding">
<t> In the case of single source broadcast, all packets initially
originate from one source: the source has k packets, which may be seen
equivalently as k vectors P(1), ..., P(k) from the vector space over a
Galois Field.

<!-- For instance
if one (short) packet consists of the bytes [0x12, 0x3A, 0XB5], it
will be seen as the vector (1,2,3,10,11,5) over GF(16) --> </t>


<t> With network coding, any coded packet received by node, at any point
of time, is a linear combination of some source packets. The i-th
received coded packet at a node v is necessarily a linear combination
of the source packets P(1), .... P(k) and can be written as:
<list style="hanging">
<t>q(v,i) = a(v,i,1) P(1) + ... + a(v,i,k) P(k)</t>
</list>
The sequence of coefficients for a coded packet q(v,i) (denoted
"information vector", or simply "vector") 
is itself a vector [a(v,i,1), a(v,i,2), ..., a(v,i,n)]
(denoted "global encoding vector").
</t>


<t> With linear coding, when one node generates a coded packet, it
performs a linear combination of the packets that it possesses (the
set of received packets { q(v,i) }) with some set of coefficients 
(g(1), ...., g(M)). It then transmits the result:
<list style="hanging">
<t>generated_coded_packet = g(1) q(v,1) + ... + g(M) q(v,M).</t>
</list>
Since the vectors q(v,1), ... q(v,M) are in turn linear combinations
of the source packets P(1),... P(k), the generated coded packet, can
be expressed itself as a linear combination of these, yielding its
global encoding vector.</t>

<t> In practice, a special header containing the global coding vector of the
transmitted code packet may be added as proposed by Chou et al. 
<xref target="CWJ03"/>.</t>
</section>

<section anchor='RLC' title="Random Linear Coding">
<t> As shown above, when a node generates a coded packet with linear
coding, an issue is how to select coefficients. Whereas centralized
deterministic methods exist, <!-- % \cite{Jaggi}, -->
Ho and al. <xref target="HKMKE03"/> presented a novel coding
algorithm, which does not require any central coordination. The coding
algorithm is random linear coding: when a node transmits a packet, it
selects randomly the set of coefficients { g(i) }, which will be used
to perform a linear combination of the vectors q(v,M) as indicated
above.</t>
</section>

<section title="Decoding, Vector Space, and Rank">

<t>A node v will recover the source packets P(1), ... P(k) its the
received packets q(v,1), ... q(v,M), considering the matrix of
coefficients a(v,i,j) for i=1,...M and j=1,..k from <xref
target="NC-base"/>. Decoding amounts to inverting this matrix,
for instance with Gaussian elimination.  <!-- %This may be performed
online using Gauss-Jordan elimination \cite{LI_LI}.  %provided that
they contains sufficient information. --> </t>

<t>Thinking in terms of coding vectors, at any point of time, it is
possible to associate with one node v, the vector space, Q(v) spawned
by the coding vectors, and which is identified with the matrix. The
dimension of that vector space, denoted D(v), is also the rank of the
matrix.  In the rest of this document, by abuse of language, we will
call "rank of a node", that rank and dimension.</t>

<t>The rank of a node is a direct metric for the amount of useful
received packets, and a received packet is called innovative when it
increases the rank of the receiving node. Ultimately a node can decode
all source packets when its rank is equal to the the total number of
source packets.  <!-- XXX When a node will recover the source packets
at once only at the end of network coding transmission, the decoding
process is called as "block decoding". --> </t>
</section>

</section>





<section anchor="acknowledgements" title="Acknowledgements">

<t>
  This document also stems from contributions of and
  from discussions with <!-- the following people,
  in alphabetical order-->: 
  Philippe Jacquet.
</t>

</section>

</back>

</rfc>
