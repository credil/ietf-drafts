<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!-- General -->
<?rfc strict="yes" ?>   <!-- Enforce Internet-Drafts nits & DTD validity? -->
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!-- References -->
<?rfc symrefs="yes"?>   <!-- Show symbolic links (yes) or numbers (no). -->
<?rfc sortrefs="yes" ?> <!-- Sort references? -->
<!-- Comments -->
<?rfc comments="yes" ?> <!-- Display <cref> elements? -->
<?rfc inline="yes" ?>   <!-- Place comments inline (yes) or in comments section (no). -->
<?rfc editing="no" ?>   <!-- Insert editing marks? -->
<!-- Table of Contents -->
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocompact="yes"?>
<!-- End of directives; start of RFC. -->
<rfc category="info" ipr="trust200902" docName="draft-lanz-cicm-lm-01"><front>
  <title abbrev="CICM Logical Model">
    Common Interface to Cryptographic Modules (CICM) Logical Model
  </title>
  <author fullname="Daniel J. Lanz" initials="D." surname="Lanz">
    <organization abbrev="MITRE">The MITRE Corporation</organization>
    <address>
      <email>dlanz@mitre.org</email>
    </address>
  </author>
  <author fullname="Lev Novikov" initials="L." surname="Novikov">
    <organization abbrev="MITRE">The MITRE Corporation</organization>
    <address>
      <email>lnovikov@mitre.org</email>
    </address>
  </author>
  <date year="2011" month="July" />
  <area>Security</area>
  <workgroup>Internet Engineering Task Force</workgroup>
  <abstract>
    <t>This document defines an abstract model for high assurance
    cryptographic modules. It defines the relevant terminology
    and high-level descriptions of the types of services and
    operations offered by such modules. The goal is to provide a
    common vocabulary for discussing the programming of high assurance
    modules.</t>
    <t>Comments are solicited and should be addressed to the mailing
    list at cicm@ietf.org.</t>
  </abstract>
</front><middle><!-- Content. -->
  <section title="Introduction">
		<section title="Background">
			<t>Sensitive data is increasingly under attack,
			whether in transit or at rest. The computer security community has
			responded to these threats by using cryptography to secure
			sensitive data. To counter the growing number and types of threats
			against systems processing sensitive data, module vendors have
			engineered a diverse set of cryptographic modules.</t>
			<t>Systems that require cryptographic protection may use
			various cryptographic services including data encryption, signature
			generation, hashing, and keystream generation. Cryptographic
			modules providing these services and the key material they hold
			must be managed. All of these services have proprietary interfaces
			that differ significantly among module types, leading to the
			following problems:</t>
			<t><list style="symbols">
				<t>Replacement of one module type for another and reuse of
				module-dependent software are inhibited as applications require
				extensive modifications to adapt to new module types and their
				proprietary interfaces.</t>
				<t>Developers of systems that host cryptographic modules must
				accommodate different cryptographic module interfaces for
				different types of cryptographic modules.</t>
				<t>Test tools and procedures developed for one module usually
				will not work with other modules.</t>
				<t>Security evaluators must learn multiple module developers'
				interfaces, increasing evaluation time and expense.</t>
			  </list></t>
			<t>To address these problems, this document outlines a logical model
      for the Common Interface to Cryptographic	Modules (CICM) specification
      which offers module developers a set of standard programming interfaces
      for the set of operations supported by high	assurance
      cryptographic modules. Although many Application
			Programming Interfaces (APIs) intended for commercial cryptography
			are available, the CICM specification was designed for high
			assurance environments, but may be used in other environments as
			well.</t>
			<t>Modules do not require changes to support the use of CICM. A
			module-specific abstraction layer between the library implementing
			CICM interfaces and the module performs the needed translations
			between the CICM model of a module and the model presented by a
			specific module. This abstraction component may be provided by the
			module developer, a module embedder/integrator, or another
			interested party. This arrangement is analogous to manufacturers of
			computer peripheral devices providing platform or operating
			system-specific drivers for their peripheral devices.</t>
			<t>The benefits of using standard interfaces to access
      cryptographic services include:</t>
			<t><list style="symbols">
			  <t>Provide a common, logical model of cryptographic modules that
			  is straightforward to learn and easy to use.</t>
			  <t>Enable the replacement of one cryptographic module for
			  another without significant modifications to the client programs
			  that interact and use the cryptographic module, assuming certain
			  compatibility characteristics between the modules exist.</t>
			  <t>Accommodate binding to multiple programming languages.</t>
			  <t>Enforce the correct use of the API; in particular, interfaces
			  must be used in the intended order, imposable at compile time or
			  recognizable via static analysis.</t>
			  <t>Support high assurance evaluation by enabling evaluators to
			  quickly validate that a particular implementation uses only the
			  required functions in the manner they were intended.</t>
			</list></t>
		</section>
    <section title="Language Independent">
      <t>CICM is defined using Interface Definition Language (IDL)
      <xref target="IDL" />, a specification language that describes
      a software interface in a language-neutral way. The specification
        currently does not specify normative bindings for specific
        programming languages, although bindings for common languages can
        be generated from the IDL provided with the specification. However,
        normative bindings for one or more popular programming languages
        will be made available in a future release of the
        specification.</t>
      <t>The use of IDL
      in CICM is not intended to either prescribe or preclude a particular
      communications protocol such as General Inter-ORB Protocol (GIOP) <xref target="CORBA" />
      between programs in different address	spaces or on different devices.</t>
    </section>

		<section title="Audience">
			<t>The CICM specification is written for computer
			programmers, software engineers, and technical architects with a
			background in data security and cryptography. Knowledge of
			object-oriented programming concepts is useful when reading IDL
			definitions. Software engineers may use the specification when
			developing software that integrates with cryptographic modules.
			Technical architects may use the specification when designing
			systems that incorporate cryptographic modules to secure data
			within the system or between systems.</t>
			<t>Although the specification is targeted to software developers
			who will access module services using a compliant implementation,
			it also addresses module developers and others who implement
			library and other support software.</t>
		</section>
		<section title="Scope of the Specification">
			<t>The CICM model should provide a common
			way to access the following services offered by cryptographic
			modules:
			<list style="symbols">
			  <t>Cryptographic module management: Includes retrieving
			  information about a specific module, managing access control,
			  managing module events, and loading and managing software
			  packages on modules.</t>
			  <t>Key management: Includes the generation, storage, protection,
			  and removal of key material, and support for message exchanges
			  used in key agreement and key transfer protocols.</t>
			  <t>Channel management: A channel defines a specific
			  cryptographic transform and encapsulates all attributes
			  associated with that transform. Channel management includes
			  channel instantiation, channel control throughout its lifetime,
			  providing data to a channel for transformation, and extracting
			  transformed data from a channel.</t>
			</list></t>
			<t>The following elements are not addressed:
			<list style="symbols">
			  <t>Hardware interfaces, protocols, or design</t>
			  <t>Details of specific protocols (The
			  model provides a means to move protocol messages into and
			  out of a module, but does not dictate low level protocol.)</t>
			  <t>Internal structure of certain types of data elements (e.g.,
			  software packages imported into a module, test results extracted
			  from a module)</t>
			  <t>Policy enforcement (The model provides a means to
			  convey policy elements to the module, but policy enforcement is
			  considered a module responsibility.)</t>
			  <t>Organization of the information stored and processed within a
			  module</t>
			  <t>Separation of commands/data for multiple security domains
			  that access a single CICM library instance (e.g., Multiple Levels
			  of Security).</t>
			</list></t>
		</section>
  </section>
		<section title="Use Cases">
			<t>A significant characteristic that differentiates
			CICM from other cryptographic interfaces such as
      Cryptoki <xref target="PKCS-11" />,
      GSS-API <xref target="RFC5554" />, and
      <xref target="JCA" /> is its ability to support
			cryptographic modules that separate two security domains. The use
			cases that follow capture this fundamental element of the CICM
			model. These use cases can be divided into two basic
			types:
			<list style="symbols">
			  <t>Cryptographic transformation of data initiated in one
			  security domain with the result made available in another
			  security domain</t>
			  <t>Cryptographic transformation of data within a single security
			  domain: Cryptographic hash or digital signature operations may be
			  initiated in the same security domain where the result is
			  received. Other single domain use cases include data
			  encryption/decryption for storage and keystream/random data
			  generation.</t>
			</list></t>
			<t>The data-in-transit and data-at-rest use cases illustrated below
			incorporate multiple security domains, while the final use case
			depicts a transformation within a single domain.</t>
			<section title="Data-in-Transit">
				<t>The figure below shows a hardware device
				with an embedded cryptographic module providing encryption and
				decryption services between a secure and non-secure network. The
				secure side protocol logic subsystems access cryptographic services
				using CICM. In this use case, the High Assurance IP Encryptor
				(HAIPE) device uses CICM to enable the internal protocol logic
				of the device to access cryptographic services; the network to
				which the HAIPE device is connected does not interface to the
				protocol encryptor using CICM.</t>
        <figure>
<artwork><![CDATA[
                  High Assurance IP Encryptor
        +----------------------------.-----------------+
        |    HAIPE              Cryptographic  HAIPE   |
Secure <-> Protocol <-> CICM <->  Module <-> Protocol <-> Non-Secure
Network |    Logic                   .         Logic   |   Network
        +----------------------------.-----------------+
                                     .
                               Security Domain
                                  Boundary
]]></artwork>
        <postamble>Figure 1. First Data-in-Transit Use Case, HAIPE</postamble>
        </figure>
				<t>The following figure depicts the same use case in its end-to-end
				configuration.</t>
<figure>
<artwork><![CDATA[
                                      Security Domain
                                         Boundary
                                            .
             +------------------------------.--------+
             |   HAIPE                      .        |
( Secure  ) <-> Protocol <-> CICM <-> Cryptographic <---+
( Network )  |   Logic                    Module     |  |
             +------------------------------.--------+  |
                                                        |
          +-------------> ( Non-Secure ) <--------------+
          |               (  Network   )
          |
          |  +--------.------------------------------+
          |  |        .                     HAIPE    |
          +---> Cryptographic <-> CICM <-> Protocol <-> ( Secure  )
             |      Module                  Logic    |  ( Network )
             +--------.------------------------------+
                      .
                Security Domain
                   Boundary
]]></artwork>
        <postamble>Figure 2. HAIPE Use Case in End-to-End Configuration</postamble>
        </figure>
				<t>A second data-in-transit use case shows a tactical secure radio
				with an embedded cryptographic module providing encryption and
				decryption services between a local host and a radio frequency
				environment. The functional blocks that make up the tactical secure
				radio are logically identical to those in the first example.</t>
<figure>
<artwork><![CDATA[
                     Tactical Secure Radio
      +----------------------------.---------------------+
Host <-> Information <-> CICM <-> Module <->   Waveform <-> RF
      |  Processing                .          Processing |
      +----------------------------.---------------------+
                                   .
                             Security Domain
                                Boundary
]]></artwork>
        <postamble>Figure 3. Second Data-in-Transit Use Case, Tactical Secure Radio</postamble>
        </figure>
			</section>
			<section title="Data-at-Rest">
				<t>The figure below shows a cryptographic module
				providing encryption services for data stored on a disk and
				decryption services for data read from a disk. A file system driver
				accesses cryptographic services using CICM.
				This use case could apply to a laptop computer that contains
				encrypted data; it would prevent access to sensitive data from a
				lost or stolen laptop.</t>
        <figure>
<artwork><![CDATA[
                    Host                         .
      +---------------------------------+        .
User <->   Word    <->  File  <-> CICM <-> Cryptographic <-> Disk
      |  Processor     System           |      Module
      +---------------------------------+        .
                                                 .
                                           Security Domain
                                              Boundary
]]></artwork>
        <postamble>Figure 4. Data-at-Rest Use Case</postamble>
        </figure>
			</section>
			<section title="Single Security Domain">
				<t>The following figure shows a cryptographic transform within a single security domain (it assumes
				that the transform does not change the classification of the data).
				The plaintext is conveyed to the module, transformed by an
				encryption algorithm, and results in ciphertext. This information
				is then returned to the same domain from which the plaintext
				originated. Other natural examples of a single domain use case
				include signing, which results in a digital signature; hashing,
				which results in a hash value; and keystream generation, which
				results in keystream data.</t>
        <figure>
<artwork><![CDATA[
      1. Query              2. Load
User <---------> Database <---------> Disk
                 Back end
                    |
                    +---------------> Cryptographic
                       3. Decrypt         Module
]]></artwork>
        <postamble>Figure 5. Single Security Domain Use Case</postamble>
        </figure>
			</section>
		</section>
  <section title="Module Management">
    <t>The fundamental element of the CICM model is the MODULE --
    an abstraction which refers to the cryptographic module and its capabilities.
    A single CICM library may provide access to multiple modules.</t>
    <t>Each module contains references to information about the module,
    including the module  manufacturer, serial number, and version numbers.
    Modules also defines attributes called MANAGERS that provide
    access to the services made available by the module.</t>

    <section title="Managing Module Authentication" anchor="mm-auth">
      <t>Modules may require a host
      or user to authenticate to the module before the module will enter
      an operational state, allowing it to accept commands and perform
      cryptographic transformations. In some cases, a specialized,
      removable hardware component will perform or participate in the
      authentication. This hardware component is termed a
       HARDWARE ACCESS TOKEN in CICM nomenclature, although other
      communities may use different terminology. Most implementations
      that use hardware access tokens will transfer key material between
      the token and module, independent of CICM. In cases where access
      tokens are not supported, a user may provide authentication
      credentials to the module via CICM. In still other cases,
      support for multi-factor authentication will require a token and a
      user login. Note that the user and token holder may be different
      entities.</t>
      <t>CICM provides interfaces that can be used separately or in
      combination with one another as appropriate for the system using
      them and for the authentication mechanisms offered by the module
      that is used by the system. Methods to manage module/token
      associations are available for systems where hardware access tokens
      are supported. Login methods and related user management methods
      are supported for systems that require user login.</t>

      <section title="Managing Hardware Access Tokens">
        <t>The TOKEN MANAGER defines
        methods that support associating a token with a module,
        disassociating a token from a module, and disassociating a module
        from a token. The manager also supports retrieving a list of token
        associations on a module and module associations on a token.</t>
      </section>
      <section title="Managing Users">
        <t>The USER MANAGER defines methods that
        support adding users to and removing users from a module user
        database, and associating a user with a module-defined ROLE. The
        manager also supports listing the user database, and the roles
        defined and supported by the module.</t>
      </section>
      <section title="Logging in to a Module from a Host">
        <t>The LOGIN MANAGER
        defines methods that enable a user configured on a module to login
        to and logout from a module.</t>
      </section>
    </section>
    <section title="Managing Software Packages">
      <t>The PACKAGE MANAGER defines
      methods that support importing and managing the executable images
      that reside on a cryptographic module. These methods enable module
      software/firmware PACKAGES to be imported and other software
      package management operations to be performed, including retrieving
      a list of packages, and activating or deleting a specific
      package.</t>
      <t>The package manager enables packages to be imported into a
      module in segments rather as an atomic unit. This supports modules
      that must make special provisions to import executable images due
      to internal storage space limitations.</t>
    </section>
    <section title="Managing Logs" anchor="mm-logs">
      <t>Modules generate log entries as they operate.
      The LOG MANAGER defines methods that support retrieving individual
      log entries or extracting an entire log from a module.
      Additionally, clients may clear individual log entries or the
      entire module log.</t>
    </section>
    <section title="Managing Tests">
      <t>Modules may incorporate built-in tests to
      validate that module functionality is operating as designed. Some
      tests may be externally initiated. The TEST MANAGER defines methods
      that support host-initiated module tests.</t>
    </section>
    <section title="Managing Module Events">
      <t>The MODULE EVENT MANAGER defines methods
      that support registering/unregistering module-generated event
      notifications received by a client program. Clients can register
      custom-developed CALLBACK procedures, called
       LISTENERS, for specific module events. When the condition
      associated with a specific listener presents itself, the registered
      listener is called.</t>
      <t>Examples of events for which listeners may be registered
      include:
      <list style="symbols">
        <t>Hardware access token has been inserted or removed.</t>
        <t>Module is ready to receive traffic.</t>
        <t>Alarm condition is raised.</t>
        <t>Hardware zeroization condition raised.</t>
        <t>Continuous module/engine health test failed.</t>
        <t>Usable lifespan of key expired.</t>
        <t>Change in module power state.</t>
      </list></t>
    </section>
  </section>
  <section title="Key Management">
    <t>Cryptographic modules use key material
    under their protection as one input to perform a cryptographic
    transformation. Keys
    <list style="symbols">
      <t>can originate at a Key Infrastructure Component that has a trust
      relationship with the module</t>
      <t>may be agreed upon between the module and another entity</t>
      <t>may be generated on the module itself</t>
      <t>may be derived from information presented to the module by a
      client program.</t>
    </list></t>
    <t>Once established on a module, they may be subject
      to client-initiated management operations or may be used as part
      of a cryptographic channel to effect cryptographic
      transformations.</t>
    <t>CICM treats SYMMETRIC KEYS and
    ASYMMETRIC KEYSETS separately. An asymmetric keyset may comprise an asymmetric
    key pair, the public and private key components of a keypair, the
    digital certificate corresponding to the keyset public key, one or
    more verification certificates in the certificate chain of trust,
    and related public domain parameters.</t>
    <t>The ASYMMETRIC KEY MANAGER and SYMMETRIC KEY MANAGER attributes allow for
    access to asymmetric keysets and symmetric keys, respectively.</t>

    <section title="Creating and Establishing Keys">
      <t>Keys may be moved into a
      module in one of several scenarios. Each scenario is described in
      detail below.</t>

      <section title="No Host Interaction Key Fill">
        <t>Specialized hardware devices
        designed to transfer key from a key infrastructure component to a
        specific cryptographic module may fill key into a module without
        host involvement and thus no API interaction. In some cases, this
        process does not support transferring key metadata with a key. This
        requires host and API interaction to apply metadata to the key
        inside the module upon completion of the fill.</t>
      </section>
      <section title="Client Program-Initiated">
        <t>In some cases, key fill devices
        require host interaction to initiate a key fill. In such cases,
        the target key storage location or key tagging information can be specified
        prior to the initiation of the fill.</t>
        <t>Keys may be imported directly or derived using
        a text-based secret provided by the user of the client program.
        Keys also may be generated on the module. Each case
        results in a persistent key.</t>
        <t>A key also is implicitly established each time a channel is
        created using an asymmetric keyset and upon renegotiation. Keys
        resulting from channel-based key agreement are ephemeral; they are
        not generally managed outside of a channel. Ephemeral keys also may
        be destroyed when a channel is destroyed.</t>
      </section>
      <section title="Module/Key Infrastructure Initiated" anchor="km-keyproto">
        <t>A facility to operate a
        key agreement protocol with an infrastructure component is
        supported. This facility also enables key material or key
        revocation information to be authenticated by one of the module's
        trust anchors, and then loaded into the module.</t>
      </section>
    </section>
    <section title="Exporting Keys">
      <t>Methods to export key material out of a
      module are supported. A module may require wrapping the key
      material prior to export or may disallow this operation.</t>

      <section title="Locating and Retrieving Information about a Key">
        <t>A method to
        locate a specific key on a module based upon identification
        information associated with the key is supported. In addition, the
        entire key database may be listed.</t>
      </section>
      <section title="Applying Metadata to Keys">
        <t>Key metadata may be retrieved and
        set for individual keys. Metadata elements include the key
        identifier, alias, and classification. Untagged keys that are
        imported via a fill device may require certain metadata to be
        applied after the conclusion of the load.</t>
      </section>
      <section title="Performing Operations on Keys">
        <t>A number of management
        operations on keys are supported. Keys may be wrapped
        (cryptographically protected) in preparation for export, or
        unwrapped after import. All key material on the module can be
        zeroized either on a key-by-key basis or as a whole. There are
        also operations to perform key conversions and updates.</t>
      </section>
      <section title="Enabling Remote Management">
        <t>CICM supports various key management-related protocol messages
        including remote key functions (e.g., remote zeroize or rekey),
        infrastructure-initiated key revocation, and trust anchor
        management.</t>
      </section>
    </section>
    </section>
  <section title="Channel Management" anchor="cm">
    <t>The CHANNEL is the fundamental
    construct under which one or more related cryptographic transforms
    are performed, and within which all details and attributes
    associated with the transform are encapsulated, including the path
    through the module. Most channels accept data from a port in the
    local security domain, transform the data, and output the result on
    a port in another security domain. A channel also may perform
    transformations within a single security domain, or may accept data
    for transformation in one domain and output the result in another.
    The channel type determines which ports must be specified when a
    channel is created.</t>
    <figure>
<artwork><![CDATA[
               Security Domain         Security Domain
                  Boundary                Boundary
                     .                       .
            +--------.--------+     +--------.--------+
 Client  --(a) Cryptographic (b)---(c) Cryptographic (d) -- Client
Program X   |      Module     |     |      Module     |    Program Y
            +--------.--------+     +--------.--------+
                     .                       .

            X local    X remote     Y remote    Y local
            port (a)   port (b)     port (c)   port (d)
]]></artwork>
      <postamble>Figure 6. Local and Remote Port
      Nomenclature for Channels that Operate in Two Security
      Domains</postamble>
    </figure>
    <t>Three classes of objects are fundamental to the creation and use
    of CICM channels. A
     CONTROLLER is used to configure and control a channel. A
     STREAM enables data to be sent to a module to be
    transformed, and transformed data to be received using a controller
    as a foundation. A
     CONDUIT is the sum of a controller and a stream. Thus, the
    term
     "channel" is only an abstraction representing the logical
    path through the module on which cryptographic transformations are
    performed.</t>
    <figure>
<artwork><![CDATA[
+----------------------------------------+
|                  Channel               |
|                                        |
|  +-----------------------+             |
|  |             +--------------------+  |
|  | Controller  | Conduit |   Stream |  |
|  +-----------------------+          |  |
|                +--------------------+  |
+----------------------------------------+
]]></artwork>
      <postamble>Figure 7. Relationship Between Channel,
      Conduit, Controller, and Stream</postamble>
    </figure>
    <t>This division of responsibility makes channels very flexible.
    One client program can be responsible for creating and managing
    channels with a controller, and another can send data over this
    pre-configured channel for transformation using a stream. In some
    environments, data to be transformed never enters the host to pass
    through the API. Instead, it is clocked directly through the
    module. In this situation, a controller is configured, but no
    stream is configured since it would never be used. In other cases,
    a client program is required to configure the channel and pass data
    through the channel it configured. In this case, the client program
    configures a conduit, which incorporates a controller and a
    stream.</t>
    <t>Both controllers and conduits accept symmetric keys, requiring
    that the client program configuring the channel and its remote peer
    share the same secret key. Alternatively, all peers may hold their
    own respective asymmetric keysets, requiring a key negotiation
    which, upon successful completion, results in each peer holding an
    ephemeral symmetric key. CICM supports a NEGOTIATOR for this purpose.
    A successful negotiation results in a negotiated
    controller or conduit.</t>
    <t>CICM supports the following channel types:
    <list style="symbols">
      <t>Encryption/decryption, including selective bypass</t>
      <t>Signature generation/verification</t>
      <t>Message Authentication Code (MAC)
      generation/verification</t>
      <t>Cryptographic hashing</t>
      <t>Keystream generation</t>
      <t>Random/pseudo-random data generation</t>
      <t>Key wrap</t>
      <t>Full bypass.</t>
    </list></t>
    <t>CICM also supports hybrid channel types. A channel that
    simultaneously supports encryption and signature, resulting in both
    ciphertext and a final signature value, is a hybrid channel.</t>
    <t>Each of the types above differs in the way it is configured, its
    configuration options, and how it handles the cryptographic
    transformation of data. Consider the following examples portraying
    the diversity of the channel types:
    <list style="symbols">
      <t>The encryption channel accepts plaintext to be transformed,
      and can return the resulting ciphertext directly to the caller or
      route it a different security domain</t>
      <t>The random data generation channel requires no data for
      transformation, but emits a random stream</t>
      <t>The signature channel accepts an indeterminate amount of
      data, and returns an algorithm-specific fixed-sized value</t>
      <t>The hashing channel does not accept a cryptographic key as a
      parameter, as most of the other channel types do (keyed hashes
      are supported by MAC channels)</t>
      <t>The decryption channel accepts a state vector input
      parameter, but does not allow a state vector to be
      generated.</t>
    </list></t>
    <t>This diversity results from the fundamental characteristics of
    the cryptographic primitives that are being abstracted. The
    CHANNEL MANAGER defines the methods that support creating conduits,
    controllers, streams, and negotiators for each of the channel
    services listed above.</t>
    <section title="Creating Channels">
      <t>Creating a channel requires an awareness
      of the options available:
      <list style="symbols">
        <t>The type of cryptographic operation desired (encryption,
        hashing, keystream generation, etc.)</t>
        <t>How the channel will be used (control-only, send/receive data
        only, or both control and send/receive data)</t>
        <t>The type of key that will be used for channels that require a
        symmetric key or an asymmetric keyset (hybrid channels accept two
        keys).</t>
      </list></t>
      <t>Selecting among these options enables the client program
      developer to determine what channel interface to use.</t>

      <t>In cases where an asymmetric keyset is used, channels are created
      as a result of a key agreement protocol negotiation with a remote peer.
      To ensure that it is the expected peer, a human user at the client may
      validate information extracted from the peer's certificate.
      If the module uses a trusted display, the module communicates
      the peer information directly to the
      display. Based upon user input at the display, host-independent
      negotiation is continued or aborted. If no trusted display is
      available, the client program requests information about the remote
      peer, displays it at the host for user confirmation, and provides
      positive confirmation via the API that the peer is valid, allowing
      the negotiation to continue.</t>
      <section title="Encryption and Decryption">
        <t>CICM defines interfaces to
        support encryption and decryption between two security domains or
        within a single security domain. Additional variants are defined
        including hybrid channels that can concurrently compute integrity
        values. Another set of variants provides methods to perform
        encryption/decryption with selective bypass.</t>
        <t>If an asymmetric keyset is used to create a channel, a
        negotiation process is initiated, which results in a negotiated
        channel. Negotiated versions of hybrid channels also are available.
        For those negotiator versions that combine encryption with
        integrity value generation, negotiation applies only to the
        encryption key specified when the channel is negotiated, not the
        signature or MAC key.</t>
        <t>Channel-based multiple key wrap/unwrap support is provided via a
        special channels for that purpose.</t>
        <t>CICM also supports encryption/decryption channels that operate
        in coprocessor mode . These channels accept their input and return their
        output as part of the same method call. Where relevant, the
        integrity value or verification status (verified/not verified) is
        returned when the final block of the input has been presented for
        transformation.</t>
        <t>Duplex channel configurations that use the same key to perform
        encrypt and decrypt transformations also are supported. Negotiated
        versions of the duplex channel also are available.</t>
      </section>
      <section title="Bypass">
        <t>Bypass channels capable of defining a path through a
        module and then bypassing data from one security domain to a
        different domain are supported. Selective bypass also is supported
        on encryption and decryption channels.</t>
      </section>
      <section title="Integrity">
        <t>Interfaces to compute and validate integrity
        values using asymmetric key-derived digital signatures or symmetric
        key-derived MACs are available. A variant on the sign and verify
        interfaces accepts a previously generated hash value in place of a
        message.</t>
      </section>
      <section title="Hashing">
        <t>A channel to calculate a fixed-length cryptographic
        hash from an input message is available. Keyed hashes are supported
        by MAC channels.</t>
      </section>
      <section title="Keystream Generation">
        <t>Channels are supported to read keystream from a module.</t>
      </section>
      <section title="Random Data">
        <t>Separate interfaces are defined to retrieve
        random or pseudorandom data from a module.</t>
      </section>
    </section>
    <section title="Managing Channels">
      <t>Only conduits and controllers (not
      streams) can manage channels. Negotiators can manage the
      negotiation aspects of a channel.</t>
      <t>The management operations that can be performed on a channel are
      specific to each channel type, but the following general operations
      are supported:
      <list style="symbols">
        <t>Generating, extracting, and setting state vectors</t>
        <t>Resynchronization</t>
        <t>Initiating a key rollover</t>
        <t>Initiating a key update.</t>
      </list></t>
      <t>Negotiators support the following general operations:
      <list style="symbols">
        <t>Renegotiation</t>
        <t>Changing classification level/acknowledging change of
        classification level.</t>
      </list></t>
      <t>Managing state vectors is an important channel management
      capability. CICM provides a method to explicitly generate a state
      vector for those algorithms/modes that require a random
       initialization vector (IV), although modules may
      alternatively generate an IV as a byproduct of channel creation.
      CICM also provides a method to set the state vector on a channel.
      This may be used to:
      <list style="symbols">
        <t>Set the decrypt channel to the IV generated/used on the
        encrypt side of a channel.</t>
        <t>Provide a vector on a block-by-block basis for appropriate
        algorithms/modes or at each time epoch (e.g., time-of-day
        encryption). In addition, a method is available to take a special
        state vector called a
         synchronization vector to assist in resynchronizing a
        channel.</t>
      </list></t>
    </section>
    <section title="Using Channels">
      <t>Only conduits and streams (not controllers)
      can send data for transformation and receive cryptographically
      transformed data on a channel.</t>
      <t>The data operations that can be performed on a channel or stream
      are specific to each channel type, but the following general
      operations are supported:
      <list style="symbols">
        <t>Sending data on a channel to initiate a cryptographic
        transformation:
        <list style="symbols">
        <t>Blocking send: Call does not return until data has been
        sent or the operation times out.</t>
        <t>Non-blocking send: Call queues data for sending and returns
        immediately to the caller.</t>
        <t>Poll: Determines status of non-blocking send
        operation.</t>
        </list></t>
        <t>Receiving transformed data from a channel:
        <list style="symbols">
        <t>Blocking read: Blocks until data becomes available or the
        operation times out.</t>
        <t>Non-blocking read: Call queues a buffer to receive data and
        returns immediately.</t>
        <t>Poll: Determines status of non-blocking read
        operation.</t>
        <t>Notification via callback that data has become available
        using a channel event listener.</t>
        </list></t>
      </list></t>
      <t>Although it is possible for multiple client programs to use
      the same stream, the model provides no facilities to
      coordinate the parties participating in the communication.</t>
      <t>Certain channel services support receiving an "answer" from a
      channel. For example, signature and hashing channels accept
      variable amounts of data for transformation before returning a
      final, constant-sized "answer" (a signature or a hash) to the
      caller. HYBRID CHANNELS require sending/receiving data and
      receiving a final "answer" after a discrete unit of data has been
      transformed.</t>
      <t>The figure below depicts the use of a hybrid channel. Plaintext
      is sent through CICM for transformation. The module
      performs encrypt and sign transformations on the plaintext data.
      Ciphertext resulting from the encrypt transform emits from the
      module in a different security domain than the one in which it
      originated. When it is finished presenting data for transformation,
      the client program requests the signature that results from the
      transaction.</t>
      <figure>
<artwork><![CDATA[                          .
        Plaintext         .       Ciphertext
  Host  --------->  Cryptographic ---------->
        <---------      Module
         Signature        .
                          .
                    Security Domain
                       Boundary

]]></artwork>
        <postamble>Figure 8. Hybrid Sign-Encrypt Channel Operations</postamble>
      </figure>
      <t>Each type of channel supports a specific set of channel data
      operations. Channel types and the data operations they support are
      listed below:
      <list style="symbols">
        <t>Encrypt, selective bypass with encryption, and full bypass
        write channels: Write data in the local security domain for
        transformation and output in another security domain.</t>
        <t>Decrypt, selective bypass with decryption, and full bypass
        read channels: Read transformed data from one security domain
        into the local security domain.</t>
        <t>Coprocessor channels: Data is presented for transformation
        and the result received within the same security domain.</t>
        <t>Duplex channels: Read/write exchange between two security
        domains.</t>
        <t>Keystream and random data generation: Transformation within
        module results in data stream that emits in the local
        domain.</t>
      </list></t>
    </section>
    <section title="Grouping Channels">
      <t>Controllers and conduits can be grouped
      to enable certain characteristics to be shared. One characteristic
      may be the state vector associated with the channels. This supports
      environments where two or more channels with related security rules
      supporting a single operation are used within a system. Whenever a
      shared characteristic is changed on a controller or conduit in a
      group, the effect of this change is applied to all
      controllers/conduits in the group.</t>
    </section>
    <section title="Receiving Notification of Channel Events">
      <t>The CICM model
      defines methods that support managing module event notifications.
      Similar support is available at the granularity of an individual
      conduit/controller. Conduits and controllers define methods that
      support registering/unregistering channel-specific module-generated
      event notifications captured by a client program. Clients can
      register custom-developed callback procedures called
       listeners for specific channel events. When the condition
      associated with a specific listener presents itself, the registered
      listener is called.</t>
      <t>Examples of channel events for which listeners may be registered
      include:
      <list style="symbols">
        <t>Data is available.</t>
        <t>Synchronization with peer has been lost.</t>
        <t>Remote peer no longer available.</t>
        <t>General channel error encountered.</t>
      </list></t>
    </section>
    <section title="Destroying Channels">
      <t>Conduits and controllers may be
      destroyed when their services are no longer needed. A channel is
      destroyed without regard for users who may have pending operations
      on the channel. Any ephemeral keys associated with the channel also
      may be destroyed. A stream ceases to function when its associated
      controller is destroyed. A destroyed channel is removed from any
      channel groups to which it belongs without effect upon other
      controllers/conduits in the group.</t>
    </section>
  </section>
<section title="IANA Considerations">
  <t>[RFC Editor: Please remove this section prior to publication.]</t>
  <t>This document has no IANA actions.</t>
</section>
<section title="Security Considerations">
  <section title="Unauthorized Usage">
    <t>Cryptographic modules are typically protected assets and most have built-in
    mechanisms for preventing unauthorized usage. <xref target="mm-auth" /> discusses
    several mechanisms for preventing unauthorized usage including using hardware access tokens
    and user login. Specific implementations may also consider the use of access control
    lists.</t>
  </section>
  <section title="Inappropriate Usage">
    <t>The log manager described in <xref target="mm-logs" /> may be used by some modules to
    report certain types of usage which may act as a type of audit log thereby providing
    information about inappropriate usage.</t>
  </section>
  <section title="Confidentiality and Data Integrity">
    <t>Many of CICM's channel types provide confidentiality services such as encryption and decryption as well
    as data integrity services such as hashing, MACing, signing, and verifying.</t>
    <t>Hybrid channels provide a combination of confidentiality and data integrity service.</t>
  </section>
  <section title="Bypass">
    <t>There are four broad categories of bypass that are supported: reading and writing full bypass; encrypting
    and decrypting with selective bypass. These services must be used with caution in order to avoid
    accidental or malicious bypass of protected data.</t>
  </section>
  <section title="Entity Authentication">
    <t>As described in <xref target="cm" />, a negotiator is the primary mechanism
    for establishing that the peer entity is the one desired.</t>
    <t>Similarly, the mechanism described in <xref target="km-keyproto" /> ensures
    that the infrastructure component that is attempting to send data to the module
    is trusted.</t>
  </section>
</section>
</middle><back><!-- Back material. -->
  <references title="Informative References">
    <?rfc include="reference.RFC.4949" ?>
    <?rfc include="reference.RFC.5554" ?>
    <reference anchor="IDL">
      <front>
        <title>Information technology — Open Distributed Processing — Interface Definition Language</title>
        <author>
          <organization>International Standards Organization</organization>
        </author>
        <date year="1999" month="March" day="15" />
      </front>
      <seriesInfo name="ISO/IEC" value="14750:1999(E)" />
    </reference>
    <reference anchor="CORBA"><front>
      <title>Common Object Request Broker Architecture (CORBA) Specification, Version 3.1</title>
      <author>
        <organization>Object Management Group</organization>
      </author>
      <date year="2008" month="January" />
    </front></reference>
    <reference anchor="CNSSI-4009">
      <front>
        <title>National Information Assurance (IA) Glossary</title>
        <author>
          <organization>Committee on National Security Systems (U.S. Government)</organization>
        </author>
        <date month="revised June" year="2006" />
      </front>
      <seriesInfo name="CNSS Instruction" value="No. 4009" />
    </reference>
		<reference anchor="FIPS-140-2">
			<front>
				<title>Security Requirements for Cryptographic Modules</title>
				<author>
					<organization>Federal Information Processing
					Standards Publication (FIPS PUB) 140-2</organization>
				</author>
				<date month="May" day="25" year="2001" />
			</front>
		</reference>
    <reference anchor="PKCS-11">
      <front>
        <title>PKCS #11 v2.30: Cryptographic Token Interface Standard</title>
        <author><organization>RSA Laboratories</organization></author>
        <date year="2009" month="April" day="16" />
      </front>
    </reference>
    <reference anchor="GCS-API">
      <front>
        <title>Generic Cryptographic Service API</title>
        <author><organization>The OpenGroup</organization></author>
        <date year="1996" month="June" />
      </front>
    </reference>
    <reference anchor="JCA">
      <front>
        <title>Java Cryptography Architecture</title>
        <author><organization>Oracle</organization></author>
        <date year="2002" month="August" day="2" />
      </front>
    </reference>
  </references>
	<section anchor="terms" title="Terms">
    <t>This section contains a list of terms and their corresponding definitions as used in this model.
    Following the formatting convention in <xref target="RFC4949" />, each term is preceded by a dollar sign ($)
    and a space to facilitate automated searching.</t>
		<t>$ alarm<list><t>Output signal that denotes that the module has entered an alarm state. An alarm condition may prohibit a module from performing cryptographic operations.</t></list></t>
		<t>$ asymmetric key<list><t>Pair of related keys, a public key known to everyone and a private key known only to the owning entity. See symmetric key and asymmetric keyset.</t></list></t>
		<t>$ asymmetric keyset<list><t>May comprise one more of the following components: an asymmetric key pair, the public and private key components of a keypair, the digital certificate corresponding to the keyset public key, one or more verification certificates in the certificate chain of trust, and related public domain parameters. See also asymmetric key.</t></list></t>
		<t>$ asynchronous notification<list><t>Delivery of an indication of a condition or event where, from the point of view of the recipient (the client program), the delivery occurs asynchronously via a callback. See also event and event notification.</t></list></t>
		<t>$ attribute<list><t>State associated with an instance of an interface.</t></list></t>
		<t>$ authentication<list><t>Security measure designed to establish the validity of a transmission, message, or originator, or a means of verifying an individual's authorization to receive specific categories of information (<xref target="CNSSI-4009" />).</t></list></t>
		<t>$ authorization<list><t>Access privileges granted to a user, program, or process (<xref target="CNSSI-4009" />).</t></list></t>
		<t>$ blocking<list><t>A call to a method is blocking if the method does not return program control to the caller until either the operation has completed or an error is recognized. See also non-blocking.</t></list></t>
		<t>$ buffer<list><t>Collection of binary data.</t></list></t>
		<t>$ bypass<list><t>In cryptography, this is an operation whereby all of the data is passed from one security domain through the cryptographic module to the other security domain without having a cryptographic transformation applied to it. See also selective bypass.</t></list></t>
		<t>$ callback<list><t>Procedure provided by the client program that is to be invoked when an appropriate condition or event is recognized. See also asynchronous notification.</t></list></t>
		<t>$ certificate<list><t>Digitally signed document that binds a public key with an identity. The certificate contains, at a minimum, the identity of the issuing Certification Authority, the user identification information, and the user's public key (<xref target="CNSSI-4009" />).</t></list></t>
		<t>$ certificate revocation list (CRL)<list><t>List of certificate serial numbers corresponding to certificates that have been revoked or are no longer valid.</t></list></t>
		<t>$ channel<list><t>Abstraction under which one or more cryptographic transforms are performed and within which all details associated with the transform are encapsulated, including the path through the module. See also conduit, controller, and stream.</t></list></t>
		<t>$ channel type<list><t>Cryptographic transform to be applied on a channel.</t></list></t>
		<t>$ client program<list><t>Program linked to a CICM library running as a single process on a host computer system that accesses cryptographic services and/or to manages a cryptographic module.</t></list></t>
		<t>$ conduit<list><t>Abstraction that encapsulates channel control and data flow. See also channel, controller, and stream.</t></list></t>
		<t>$ controller<list><t>Abstraction used to configure and control a channel. See also channel, conduit, and stream.</t></list></t>
		<t>$ coprocessor mode<list><t>Mode of operation in which cryptographic transformations are performed within a single security domain. For example, in coprocessor mode, a client program provides plaintext to a module, the plaintext is transformed, and the resulting ciphertext is returned to the same client program.</t></list></t>
		<t>$ cryptographic module<list><t>Abstraction of hardware, firmware, or software components that makes cryptographic services available to client programs via one or more channels.</t></list></t>
		<t>$ cryptographic synchronization<list><t>Process by which a receiving decrypting cryptographic logic attains the same internal state as the transmitting encrypting logic.</t></list></t>
		<t>$ cryptographic transform<list><t>The specific cryptographic process that is to be applied to a stream of data or is used to generate keystream or random data, often (but not always) based upon a cryptographic key. Transforms include encryption, decryption, signing, keystream generation, hashing, and random data generation.</t></list></t>
		<t>$ driver<list><t>Conceptual component residing on a host that enables the exchange of commands and data between the client program and a module. Module-specific abstraction layer that serves as a translation mechanism between the individual functions defined in the CICM library and the commands specific to a given cryptographic module. This component also provides a conduit for data between a host and a module.</t></list></t>
		<t>$ ephemeral symmetric key<list><t>Symmetric cryptographic key generated as part of a key negotiation process. Ephemeral keys may be destroyed when the channel or session utilizing the ephemeral key completes. Ephemeral keys are not visible if a client program lists the keys on a module. See also static key.</t></list></t>
		<t>$ event<list><t>Situation occurring on a module or a channel for which a client program may be notified.</t></list></t>
		<t>$ event notification<list><t>Call from the host runtime system to a client program announcing that a specific situation has occurred. See callback and asynchronous notification.</t></list></t>
		<t>$ grade<list><t>Negotiated classification level of a channel.</t></list></t>
		<t>$ hardware access token<list><t>Removable device used to provide locking and unlocking features for the cryptographic capabilities of a cryptographic module.</t></list></t>
		<t>$ host<list><t>Computer system upon which a client program linked to a CICM library executes.</t></list></t>
		<t>$ hybrid channel<list><t>Channel that simultaneously supports two fundamental cryptographic services; for example, an encryption with signature channel transforms data, resulting in both ciphertext and a final signature value.</t></list></t>
		<t>$ iterator<list><t>Software construct that enables a software program to walk through a list of related items.</t></list></t>
		<t>$ key<list><t>See symmetric key and asymmetric key.</t></list></t>
		<t>$ key agreement protocol<list><t>Protocol that allows two or more participants to negotiate an ephemeral symmetric key without disclosing the resulting key material to non-participants. The protocol is conducted in such a way that all participants influence the outcome.</t></list></t>
		<t>$ key encryption key<list><t>Key that encrypts or decrypts another key for transmission or storage.</t></list></t>
		<t>$ key fill device<list><t>Devices that read-in, transfer, and store key material.</t></list></t>
		<t>$ key fill interface<list><t>Set of protocols, electrical connections, and physical characteristics that comprise the connecting link between a key fill device and a cryptographic module. CICM enables a key fill interface to be configured and actions to be initiated on a key fill device via the key fill interface.</t></list></t>
		<t>$ key infrastructure<list><t>Set of hardware, software, people, policies, and procedures needed to create, manage, store, distribute, and revoke key material.</t></list></t>
		<t>$ key rollover<list><t>Process of moving from one key to another in a pre-defined sequence of keys; may also be referred to as "key supersession."</t></list></t>
		<t>$ key tag<list><t>Identification information associated with certain types of electronic key (<xref target="CNSSI-4009" />).</t></list></t>
		<t>$ key unwrap<list><t>Process whereby an encrypted cryptographic key is decrypted using a cryptographic module and a different key.</t></list></t>
		<t>$ key update<list><t>Deterministic one-way transformation of a symmetric key (and its current update count) to a new key.</t></list></t>
		<t>$ key wrap<list><t>Process whereby a cryptographic key is encrypted by a cryptographic module using a separate key in a manner sufficient to protect the key at the level of its classification.</t></list></t>
		<t>$ keystream<list><t>Sequence of symbols produced by a cryptographic module using a cryptographic key to combine with plain text to produce cipher text, control transmission security processes, or produce key (<xref target="CNSSI-4009" />).</t></list></t>
		<t>$ listener<list><t>Method registered by the client program that will be called upon the occurrence of a specific module event.</t></list></t>
		<t>$ local port<list><t>Port on module in same security domain in which client program is located to which commands are presented and through which data is sent/received. See also remote port.</t></list></t>
		<t>$ manager<list><t>Specialized attributes that encapsulate different classes of module, key and channel management functionality.</t></list></t>
		<t>$ message authentication code (MAC)<list><t>Data associated with an authenticated message allowing a receiver to verify the integrity of the message (<xref target="CNSSI-4009" />).</t></list></t>
		<t>$ method<list><t>Single CICM library function that performs a specific task.</t></list></t>
		<t>$ namespace<list><t>An abstract container that holds related interfaces.</t></list></t>
		<t>$ non-blocking<list><t>A method is non-blocking if it initiates an operation and then returns control to the caller, usually before the outcome of the operation has been determined. See also blocking.</t></list></t>
		<t>$ opaque data object<list><t>Binary object accepted by or returned from a method call whose structure is imposed by some entity unrelated to the CICM specification.</t></list></t>
		<t>$ package<list><t>Software, FPGA image, policy database, configuration parameters, or other types of executable or interpretable code that may be imported into and removed from a module.</t></list></t>
		<t>$ persistent key<list><t>See static key.</t></list></t>
		<t>$ policy<list><t>Precise specification of the security rules under which a cryptographic module will operate.</t></list></t>
		<t>$ port<list><t>Identifier that designates a logical interface through which data moves into and out of a cryptographic module. See also local port and remote port.</t></list></t>
		<t>$ remote port<list><t>Port in non-local security domain from which transformed data is received. See also local port.</t></list></t>
		<t>$ role<list><t>A designation to which users are assigned that identifies a job type defined in terms of the privileges of that user.</t></list></t>
		<t>$ security domain<list><t>System or group of systems operating under a common security policy. Communication between domains is controlled in a well-defined manner.</t></list></t>
		<t>$ selective bypass<list><t>Portion of the traffic through a channel that is not to be cryptographically transformed. Also commonly referred to as "header bypass."</t></list></t>
		<t>$ static key<list><t>Cryptographic key imported into or established on a module that will remain on the module until it is explicitly removed. See also ephemeral key.</t></list></t>
		<t>$ stream<list><t>An abstraction representing an entity utilizing an existing controller to enable data to be sent to a module to be transformed and transformed data to be received using a controller as a foundation.</t></list></t>
		<t>$ symmetric key<list><t>Usually a sequence of random or pseudorandom bits used initially to set up and periodically change the operations performed in crypto-equipment for the purpose of encrypting or decrypting electronic signals (<xref target="CNSSI-4009" />). See asymmetric key.</t></list></t>
		<t>$ system<list><t>Hardware and software components, including the cryptographic module, that meet a specific set of security-related requirements.</t></list></t>
		<t>$ tamper<list><t>Output signal from module that denotes it has detected a tamper event.</t></list></t>
		<t>$ token<list><t>See hardware access token.</t></list></t>
		<t>$ trusted display<list><t>Hardware component independent of a host to enter or display information to be directly sent to/received from a cryptographic module.</t></list></t>
		<t>$ zeroize<list><t>Input signal instructing the module to clear its memory of any sensitive cryptographic material. CICM supports both a module zeroize (destroying all key material on module) and zeroizing an individual key. </t></list></t>
	</section>
</back></rfc>