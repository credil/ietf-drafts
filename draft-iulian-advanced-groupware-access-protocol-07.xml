<?xml version="1.0"?>

<!-- <!DOCTYPE rfc SYSTEM "rfc2629.dtd" [ <!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml"> 
	<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml"> 
	<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml"> 
	<!ENTITY RFC2821 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2821.xml"> 
	<!ENTITY RFC5545 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5545.xml"> 
	<!ENTITY RFC3921 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3921.xml"> 
	<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"> 
	<!ENTITY RFC3629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml"> 
	<!ENTITY RFC4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml"> 
	<!ENTITY RFC1952 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1952.xml"> 
	<!ENTITY RFC2426 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2426.xml"> 
	<!ENTITY RFC5545 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5545.xml"> 
	<!ENTITY RFC3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml"> 
	<!ENTITY RFC2782 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2782.xml"> 
	<!ENTITY ISO.8601.1988 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.ISO.8601.1988.xml"> 
	]> -->

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>
<?rfc strict="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="no"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="info" docName="draft-iulian-advanced-groupware-access-protocol-07"
	ipr="trust200902" obsoletes="" updates="" submissionType="IETF"
	xml:lang="en">
	<!-- ***** FRONT MATTER ***** -->
	<front>
		<title abbrev="AGAP">Advanced Groupware Access Protocol</title>
		<author fullname="Iulian Radu" initials="I.R." role="editor"
			surname="Radu">
			<organization />
			<address>
				<email>iulian.radu@gmx.at</email>
			</address>
		</author>
		<date year="2013" />

		<!-- Meta-data Declarations -->
		<area>General</area>
		<workgroup>Internet Engineering Task Force</workgroup>
		<keyword>AGAP</keyword>
		<keyword>Groupware Access Protocol</keyword>
		<keyword>Advanced Groupware Access Protocol</keyword>
		<abstract>
			<t>The Advanced Groupware Access Protocol, (AGAP) allows a client to
				access
				and store electronic mail messages, contacts, events, files, and
				configurations
				on a server. The electronic mail messages can be grouped in folders.
				AGAP also
				provides the capability for an offline client to resynchronize with the
				server.
			</t>
			<t>
				AGAP does not specify a means of posting electronic mail messages;
				this function is handled by a mail transfer protocol such as
				<xref target="RFC2821">SMTP</xref>
				. It also does not specify a means for
				exchanging messages with contacts that are reported as being online; this
				function is handled by an instant messaging protocol such as
				<xref target="RFC3921">XMPP</xref>
				.
			</t>
			<t>AGAP includes the following operations for electronic mail
				messages:
				creating, deleting, renaming, moving and coping mail folders; checking for
				new
				messages; permanently removing messages; moving and coping messages between
				folders; fetching information about a message; setting and clearing
				tags for
				messages; searching in messages; retrieving only a part of a message;
				marking messages as SPAM; deleting attachments from a message.
			</t>
			<t>AGAP includes the following operations to manipulate the contacts:
				creating, deleting, moving, coping, tagging, and searching contacts;
				checking if
				a contact is online; fetching information about a contact.
			</t>
			<t>AGAP includes the following operations related to the use of the
				events: creating, deleting, moving, coping and tagging events in
				calendar; fetching events details; searching for events.
			</t>
			<t>
				All entries are read and written in format XML encoded
				<xref target="RFC3629">UTF-8</xref>
				and each entry is identified by a unique alphanumeric identifier.
			</t>
			<t>AGAP is designed to support access only to a single server per
				connection. It is also designed to balance the volume of text
				exchanged between
				the server and clients and its readability by humans for debugging.
			</t>
		</abstract>
	</front>
	<!-- ***** MIDDLE MATTER ***** -->
	<middle>
		<section title="How to Read This Document" toc="default">
			<section title="Organization of This Document" toc="default">
				<t>This document is written from the point of view of someone
					implementing an AGAP client or server, and also from the point of
					view
					of a server administrator. The protocol overview (chapter 2) presents
					all aspects related to a correct implementation (like the maximum
					length of a command or response line, charset used). The material
					in
					chapter 3 through 5 provides the states in which can be a connection
					at a moment, respectively what commands are valid in each state and
					their
					valid responses. Chapter 6 makes a summary of the return codes for each
					command.
					The implementers find in chapter 7 samples of conversations so that
					they can
					test the compliance of their applications with this standard.
				</t>
			</section>
			<section title="Conventions Used in This Document" toc="default">
				<t>
					Document conventions are noted in this chapter.
					The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
					"SHOULD",
					"SHOULD NOT","MAY", and "OPTIONAL" in this document are to be interpreted
					as
					described in
					<xref target="RFC2119">'Key words for use in RFCs to Indicate
						Requirement
						Levels'
					</xref>
					. The word "CAN" (not "MAY") is used to refer to a possible
					circumstance or situation, as opposed to an optional facility of
					the protocol.
				</t>
				<t>
					"User" is used to refer to a human user. "Client" refers to the
					software being run by the user. "Server" refers to the software
					responding to the
					client requests. In examples, "C:" and "S:" indicate lines sent by the
					client
					and server respectively. "Connection" refers to the entire sequence of
					client/server interaction from the initial establishment of the
					network
					connection until its termination. "Conversation" is an exchange of commands
					and responses between the client and the server. "Account" defines
					all folders and
					their content that can be accessed from Authenticated State. All
					references to
					characters order is according to the
					<xref target="RFC3629">UTF-8</xref>
					specification.
				</t>
			</section>
		</section>
		<section title="Protocol Overview" toc="default">
			<section title="Charset Used for Commands and Responses" toc="default">
				<t>
					All data exchanged between the server and the client is done using
					strings encoded
					<xref target="RFC3629">UTF-8</xref>
					. If the server or client
					send a string incorrect encoded then the other side can close
					immediately
					the connection.
				</t>
			</section>
			<section title="Maximal Length of a Command or Response Line"
				toc="default">
				<t>A command or response consists of a line of text that has a
					maximal length of
					1024 characters (including line end). A line of text is ended with the
					character LF
					(0x0A). There can be optionally a CR character (0x0D) before the LF
					character.
					If the server or client sends a line with a length greater of 1024
					then the other
					side can close immediately the connection.
				</t>
			</section>
			<section title="Numbers in Commands and Responses" toc="default">
				<t>The numbers that are used in commands are signed integers on 32
					bits.
					The valid values are between -2,147,483,648 and 2,147,483,647.
				</t>
			</section>
			<section title="Regular Expressions in Commands" toc="default"
				anchor="regexp">
				<t>
					Following is a resume of all regular expression rules that CAN be
					used by the commands defined in this standard:
					<figure align="center" anchor="Regex">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
    Logical operators:
XY       X followed by Y
X|Y      Either X or Y
 
    Predefined character class:
.        Any character (does not match line terminators)
 
    Characters:
x        The character x
\\       The backslash character
\xhh     The character with hexadecimal value 0xhh
\uhhhh   The character with hexadecimal value 0xhhhh
\t       The tab character ('\x09')
\n       The newline (line feed) character ('\x0A')
\r       The carriage-return character ('\x0D')
 
    Character classes:
[abc]     a, b, or c (simple class)
[^abc]    Any character except a, b, or c (negation)
[a-zA-Z]  a through z or A through Z, inclusive (range)
 
    Boundary matchers:
^        The beginning of a line
$        The end of a line
\b       A word boundary
\B       A non-word boundary
 
    Greedy quantifiers:
X?       X, once or not at all
X*       X, zero or more times
X+       X, one or more times
X{n}     X, exactly n times
X{n,}    X, at least n times
X{n,m}   X, at least n but not more than m times
 
    Reluctant quantifiers:
X??      X, once or not at all
X*?      X, zero or more times
X+?      X, one or more times
X{n}?    X, exactly n times
X{n,}?   X, at least n times
X{n,m}?  X, at least n but not more than m times
              ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Unique Identification Numbers (UID)" toc="default">
				<t>The length of an UID is between 1 and 32 characters.</t>
				<t>The UIDs MUST to be unique only between items from the same
					folder.</t>
				<t>The characters accepted for building an UID are only
					all 26 Latin letters (A-Z) in lowercase and uppercase and all
					10 Latin digits (0-9). An UID is case sensitive and it is the same
					for
					each connections, except after server change it and announce the
					change by changing the ECID assigned to the corresponding folder.
				</t>
				<t>
					Any new item MUST have a bigger UID as all other existing items in
					the selected folder.
					The sorting is made according
					<xref target="RFC3629">UTF-8</xref>
					(digits before
					letters and uppercase letters before the lowercase letters -
					0..9A..Za..z). A
					shorter UID is before a longer one (9234 before 02345) and any zero (0)
					before a
					number is take into account by the server when two UIDs are compared.
				</t>
				<t>We get an approximately maximum number of 4.50+e+17 unique
					combinations
					for 32 characters long UIDs. We get a maximum number of 3381098545
					unique combinations for 8 characters long UIDs.
				</t>
			</section>
			<section title="Folder Change Identification Numbers (FCID)"
				toc="default" anchor="FCID">
				<t>An FCID has the same format as a normal UID and each new value of
					an FCID is
					bigger as the precedent one (as is described for UIDs). An FCID is
					changed for a
					folder when the structure of the folder is changed (subfolders are added
					or removed).
					The FCID of a folder is not changed if it is changed the (sub)child of
					one of its children.
				</t>
			</section>
			<section title="Entries Change Identification Numbers (ECID)"
				toc="default" anchor="ECID">
				<t>An ECID has the same format as a normal UID and each new value of
					an ECID is
					bigger as the precedent one (as is described for UIDs). If the last ECID
					has already
					had the biggest valid UID value then its new value can be the first
					valid UID value.
					An ECID is changed for a folder when items ware added or removed. Or
					when the server
					had changed the UIDs assigned to the items. This can be necessary if,
					for example, there
					is a new item and already last valid UID was assigned to an other
					item. The new UIDs
					must keep the items in the same order as before the renumbering.
				</t>
			</section>
			<section title="Representation of Text and Binary Content in XML Bodies"
				toc="default">
				<t>
					Binary content must be encoded using the
					<xref target="RFC4648">BASE64</xref>
					method and the corresponding tag must have the ENCODED attribute
					set to "base64".
				</t>
				<t>
					A text content can be passed as it is (
					<xref target="RFC3629">UTF-8</xref>
					) or it
					can be encoded using the
					<xref target="RFC4648">BASE64</xref>
					method. The corresponding
					tag must have the ENCODED attribute set to "utf-8", in case of plain
					text, and to
					"base64", if the content was encoded using the BASE64 method.
				</t>
			</section>
			<section title="SRV record" toc="default">
				<t>
					An SRV record (Service record) defines the location in the DNS
					(Domain
					Name System) of a server providing a specified service.
					It is defined in
					<xref target="RFC2782">RFC 2782</xref>
					. A non-secured port is searched with _agap and a secured port with
					_agaps
					as _service name.
				</t>
				<t>
					An SRV record has the form:
					<figure>
						<preamble></preamble>
<artwork align="left">_service._proto.name ttl IN SRV priority weight port target</artwork>
						<postamble></postamble>
					</figure>
					<list style="symbols">
						<t>service - the symbolic name of the desired service;</t>
						<t>proto - the transport protocol of the desired service (TCP or
							UDP);
						</t>
						<t>name - the domain name for which this record is valid;</t>
						<t>ttl - standard DNS time to live field (usually 86400);</t>
						<t>priority - the priority of the target host (lower value means
							more preferred);
						</t>
						<t>weight - a relative weight for records with the same priority;
						</t>
						<t>port - the TCP or UDP port on which the service is present;
						</t>
						<t>target - the canonical hostname of the machine providing the
							service.
						</t>
					</list>
				</t>
				<t>
					The following textual entry can be used to specify the location of
					an
					AGAP service:
					<figure>
						<preamble></preamble>
<artwork align="left">_agap._tcp.example.com. 86400 IN SRV 0 5 143 agapserver.example.com.</artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					The following textual entry can be used to specify the location of
					a
					secured AGAP port (via SSL):
					<figure>
						<preamble></preamble>
<artwork align="left">_agaps._tcp.example.com. 86400 IN SRV 0 5 993 agapserver.example.com.</artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Folders" toc="default">
				<section title="Naming" toc="default">
					<t>
						All folder names are case sensitive and they are encoded according
						to
						<xref target="RFC3629">UTF-8</xref>
						.
					</t>
					<t>A backslash (\) does not escape the character after it (it has
						no
						special meaning).
					</t>
					<t>
						For building a folder name, the user CAN use all
						<xref target="RFC3629">UTF-8</xref>
						characters with a value bigger then 0x1f (white space is the first
						allowed character), but
						with the exception of the slash (/ 9x2F), back slash (\ 0x5C),
						multiplication sign (* 0x2A),
						and question mark (? 0x3F).
					</t>
					<t>The following folder names are also not accepted: '.', and '..'.
					</t>
				</section>
				<section title="Hierarchy" toc="default">
					<t>None of the reserved folders can have subfolders, exception
						makes
						the TRASH that must to store also deleted folders and FILESHARE that
						holds
						ordinary files.
					</t>
					<t>The character used for delimiting path levels is the slash (/).
						A path that starts with '/' represents an absolute path. All other
						are relative to currently selected folder (with SLCT).
					</t>
					<t>If there is no folder currently selected then the client MUST
						use only absolute paths. It is recommended for a client to use
						always
						absolute paths.
					</t>
				</section>
				<section title="Folder Types" toc="default">
					<t>
						The following folder types are defined by this standard:
						<list style="symbols">
							<t>calendar - CALE - holds events;</t>
							<t>configuration - CONF - holds user accounts configuration (the
								client is free to store
								all information it needs for providing roaming);
							</t>
							<t>contacts - ADDR - holds contact information;</t>
							<t>files - FILE - holds files that have no special meanings for
								the server;</t>
							<t>filter - FILT - holds the definition of a filter (it does not
								allow subfolders);</t>
							<t>folder - FOLD - contains only subfolders;</t>
							<t>journal - JRNL - holds journal entries;</t>
							<t>message - MESG - holds e-mail messages;</t>
							<t>notes - NOTE - holds short texts;</t>
							<t>tasks - TASK - holds tasks.</t>
						</list>
					</t>
					<t>Each of these types allow for subfolders in them.</t>
				</section>
				<section title="Reserved Folders" toc="default">
					<t>
						All the following reserved folders are located in the root of
						the user's account:
						<list style="symbols">
							<t>CALENDAR - CALE - holds the main calendar of the user
								(PUBLIC);</t>
							<t>CONFIGURATION - CONF - holds account configuration;</t>
							<t>CONTACT - ADDR - holds the main contact list (PUBLIC);</t>
							<t>DRAFT - MESG - holds templates for e-mail messages;</t>
							<t>FILESHARE - FILE - holds shared files (PUBLIC);</t>
							<t>INBOX - MESG - holds all new e-mail messages (PUBLIC);</t>
							<t>JOURNAL - JRNL - holds the main journal (PUBLIC);</t>
							<t>JUNK - MESG - holds all e-mail messages marked as SPAM or
								VIRUSED by user or the server;</t>
							<t>NOTE - NOTE - holds short texts (PUBLIC);</t>
							<t>OUTBOX - MESG - holds all e-mail messages that wait to be
								sent;</t>
							<t>SENT - MESG - holds copy of sent e-mail messages;</t>
							<t>TASK - TASK - holds the main tasks list (PUBLIC);</t>
							<t>TRASH - MESG - holds all deleted e-mail messages;</t>
						</list>
					</t>
					<t>A client can use different names for these folders when display
						them
						so that the client application can use localization and standard or
						customized names for them. If this is the case, then the user
						cannot
						create a folder, in the root of his account, with the same name as the
						real (reserved) name of the folder.
					</t>
				</section>
			</section>
			<section title="Tags" toc="default">
				<section title="Syntax" toc="default">
					<t>The client can set tags for folder and folder entries. The tags
						of
						a folder are reported by the STAT command and can be read with
						GFTG.
						The tags of an entry can be get with GTAG. The tags of a server can
						be
						set with SFTG, and the tags for folder entries with STAG.
					</t>
					<t>The format of a tag is a name optionally followed by the equal
						sign (=)
						and a value. Each time a tag is set, the new value replace the old
						one.
						All tags that have no value assigned are returned only as names.
						Assigning
						an empty value to a tag makes it to return a name followed by the
						equal sign
						and no value. Setting a tag without a value for an entry which
						previously
						had the same tag with a value makes the tag to lose its value and to
						be
						returned as name only (without the equal sign).
					</t>
					<t>The characters accepted for building a TAG are only all 26 Latin
						letters
						(A-Z) in uppercase, all 10 Latin digits (0-9) and the minus sign (-). A
						TAG
						is case insensitive. Its length is between 1 and 32 characters.
					</t>
					<t>The characters accepted for a TAG value are only all 26 Latin
						letters (A-Z)
						in lowercase and uppercase, all 10 Latin digits (0-9), plus the
						minus (-),
						underscore (_) and dot (.) characters. A TAG value is case sensitive.
						Its length is between 1 and 32 characters.
					</t>
					<t>The server returns always the TAG names in uppercase, even if
						the
						client set them using a lowercase version. The server should convert
						silently any lowercase character in a TAG name (sent by client) to
						its
						corresponding uppercase character.
					</t>
				</section>
				<section title="Reserved Tag Names" toc="default">
					<t>
						The following tag names have a meaning set by this standard for
						folders:
						<list style="symbols">
							<t>FIX-TAGS - the tags of this folder cannot be changed with
								FTGS;</t>
							<t>NO-COPY - the content of this folder cannot be copied with
								CPYF, COPY, or FCPY
								but can be deleted with DELF, DELE, or FDEL or moved with MOVF,
								MOVE, or FMOV;
							</t>
							<t>NO-DELETE - the folder or the content of this folder cannot be
								deleted with
								DELF, DELE or FDEL but can be copied with CPYF, COPY, or FCPY or
								moved with
								MOVF, MOVE, or FMOV;
							</t>
							<t>NO-DELF - this folder cannot be deleted with DELF but its
								content can be deleted
								with DELF, DELE, or FDEL if the tag NO-DELETE is not assigned to the
								folder;
							</t>
							<t>NO-FOLDERS - this entry cannot have subfolders, so the user
								cannot create
								subfolders in it with MAKE;
							</t>
							<t>NO-MOVE - the content of this folder cannot be moved with
								MOVF, MOVE, or FMOV
								but can be deleted with DELF, DELE, or FDEL or copied with CPYF,
								COPY, or FCPY;
							</t>
							<t>NO-RENAME - the name of this folder cannot be changed with
								NAME;</t>
							<t>READ-ONLY - the user can read it with RETR and delete it with
								DELF, DELE, or FDEL
								but cannot write in it with STOR, CPYF, COPY, FCPY, MOVF, MOVE, or
								FMOV,
								create subfolders in it with MAKE or change the tags of its content
								with STAG, or FTAG;
							</t>
							<t>RESERVED - it is a folder reserved by this standard; the user
								can
								write in it with STOR but cannot delete it with DELF or rename it
								with NAME;
							</t>
						</list>
					</t>
					<t>When the user do a DELF for a folder with the tag NO-DELF but
						without the tag
						NO-DELETE then the non-folder content will gone be deleted but not the
						folder.
					</t>
					<t>When the user do a DELF for a folder with the tag NO-DELETE then
						the folder
						and its content will not gone be deleted (the tag NO-DELF is
						ignored).
					</t>
					<t>Implicit a folder can be read only by its owner.</t>
					<t>
						The following tag names have a meaning set by this standard for
						messages:
						<list style="symbols">
							<t>ANSWERED - a replay was sent for this item;</t>
							<t>FORWARDED - the message was forwarded by the user;</t>
							<t>SEEN - the message was sow by the user;</t>
							<t>SPAM - this e-mail message is marked as spam;</t>
						</list>
					</t>
				</section>
			</section>
			<section title="Folder's Access Rights and Access Control List (ACL)"
				toc="default">
				<t>An access right is represented by a letter between a and z,
					respectivelly between A and Z.
					A lowercase letter represents a different right then its uppercase
					version.
				</t>
				<t>
					This document defines following rights:
					<list style="symbols">
						<t>r - it is allowed to read folder's attributes and tags;</t>
						<t>A - it is allowed to add entries to the folder;</t>
						<t>D - it is allowed to delete entries from folder;</t>
						<t>L - it is allowed to find which entries (IDs) holds the folder;
						</t>
						<t>R - it is allowed to read the folder's entries</t>
					</list>
				</t>
				<t>The ACL of a folder is made from pairs of rights and an account
					name.
					The rights are checked only at the access moment in the state STORING
					and PRESENCE.
				</t>
				<t>
					The account name is a regexp as defined in chapter
					<xref target="regexp" format="counter" />
					<xref target="regexp" format="title" />
					.
				</t>
			</section>
			<section title="The Responses for Each Type of Folder" toc="default">
				<section title="Format and Conventions" toc="default">
					<t>All responses are in XML format. The tags and their attributes
						names are written only in uppercase. The values for attributes
						only in lowercase.
						The exception are header entries for a message. The tags keep the
						case from the
						message.
					</t>
					<t>
						The content is encoded in
						<xref target="RFC3629">UTF-8</xref>
						format.
					</t>
					<t>Each type of folder returns its entries in a different format.
					</t>
					<t>Each tag written in uppercase must to be send as it is, each tag
						written in lowercase
						will be replaced with the right value at the time of generation.
					</t>
					<t>Each tag that have a question mark will be present only once if
						it is the case and
						without the question mark.
					</t>
					<t>Each tag that have a star will be present, possible many times,
						only if it is the
						case and without the star.
					</t>
					<t>If a command is correct but the server cannot execute it because
						of
						an internal error, then the server returns the code 401.
					</t>
				</section>
				<section title="Response for Calendar Folders" toc="default">
					<t>
						The format is derived from the one defined for VEVENT and VALARM
						by the
						<xref target="RFC5545">iCalendar</xref>
						standard.
					</t>
					<t>
						The following example corresponds to this VEVENT definition:
						<figure align="center" anchor="Respons_Event">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
BEGIN:VEVENT
UID:20110531T114600Z-123456@agap.at
DTSTAMP:20110531T121000Z
DTSTART:20110607T180000Z
DTEND:20110607T240000Z
SUMMARY:AGAP RFC Party
DESCRIPTION:Celebration of a new revision!\n0.4
END:VEVENT
                ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example event:
						<figure align="center" anchor="Example_Event">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<VEVENT>
    <UID>20110531T114600Z-123456@agap.at</UID>
    <DTSTAMP>2011-05-31 12:10:00</DTSTAMP>
    <DTSTART>2011-06-07 18:00:00</DTSTART>
    <DTEND>2011-06-07 24:00:00</DTEND>
    <SUMMARY>AGAP RFC Party</SUMMARY>
    <DESCRIPTION>Celebration of a new revision!
0.4</DESCRIPTION>
    <ALARM>20110607T170000Z-20110531T114600Z-123456@agap.at</ALARM>
</VEVENT>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						The following example corresponds to this alarm definition related
						to the previous event:
						<figure align="center" anchor="Respons_Alarm_Event">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
BEGIN:VALARM
TRIGGER;RELATED=START:20110607T170000Z
REPEAT:3
DURATION:PT15M
ACTION:AUDIO
ATTACH;FMTTYPE=audio/mpeg;VALUE=BINARY;ENCODING=BASE64:
 ABCDEFGHIJ==
END:VALARM
                ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example alarm:
						<figure align="center" anchor="Example_Alarm_Event">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<VALARM>
    <UID>20110607T170000Z-20110531T114600Z-123456@agap.at</UID>
    <RELATED-TO>
       20110531T114600Z-123456@agap.at</RELATED-TO>
    <TRIGGER related="start">2011-06-07 17:00:00</TRIGGER>
    <REPEAT>3</REPEAT>
    <DURATION>900</DURATION>
    <ACTION>AUDIO</ACTION>
    <ATTACH fmttype="audio/mpeg" encoded="base64">
        ABCDEFGHIJ==</ATTACH>
</VALARM>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>The
						BEGIN:VEVENT is replaced with &lt;VEVENT&gt; and END:VEVENT is
						replaced with &lt;/VEVENT&gt;. The BEGIN:VALARM is replaced with
						&lt;VALARM&gt; and END:VALARM is replaced with &lt;/VALARM&gt;.
						Each type in VEVENT/VALARM has a corresponding tag in uppercase. All
						attributes are lowercase. Any escaped semicolon or comma in VEVENT/VALARM
						is also passed prefixed with a backslash in XML. Any \n is replaced with
						a real end of line. The VEVENT/VALARM attributes LANGUAGE, VALUE and
						CHARSET must not be present in XML. The attribute ENCODING="BASE64" is
						replaced with ENCODED="base64", any other encoding scheme is silently
						dropped. The client can also send an attribute ENCODED="utf-8" as this
						is the default encoding for tags. The format for a timestamp is:
						yyyy-mm-ddThh:mm:ssZ. All times are UTC/GMT times according
						<xref target="ISO.8601.1988">Representation of dates and times</xref>.
						As VEVENT/VALARM attribute VALUE is missing then the format of the value is
						detected automatically based on the context. For example, a value starting
						with 'http://' corresponds to a 'VALUE=uri'; an 'ENCODED="base64"'
						corresponds to a 'VALUE=binary'. Were VEVENT/VALARM standar accepts a date or a
						date-time then we expect to receive a timestamp (date-time). There are not
						accepted tags that corresponds to VEVENT/VALARM types having 'VALUE=uri:CID:',
						so referincing parts that cannot exists in this XML. The DURATION must be
						always a relative value in seconds. As a VALARM is no more a
						child of a VEVENT we need to link the two entities. A VEVENT with an
						associated VALARM must include an ALARM tag having the UID of the associated
						VALARM. A VALARM must have an UID defined and a RELATED-TO tag holding
						the UID of the associated VEVENT. An VEVENT can have only one VALARM associated.
					</t>
				</section>
				<section title="Response for Configuration Folders" toc="default">
					<t>
						A response holding the configuration has the following structure:
						<figure align="center" anchor="Respons_Conf">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<CONFIGURATION>
    <name>value</name>...
</CONFIGURATION>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Conf">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<CONFIGURATION>
    <CHECK-EACH-MIN>10</CHECK-EACH-MIN>
    <QUOTA>1024</QUOTA>
</CONFIGURATION>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
				</section>
				<section title="Response for Contact Folders" toc="default">
					<t>
						The format is derived from the one defined by the
						<xref target="RFC2426">vCard</xref>
						standard.
					</t>
					<t>
						The following example corresponds to this VCARD definition:
						<figure align="center" anchor="Respons_Contact">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
BEGIN:VCARD
VERSION:3.0
FN:Iulian Radu
N:Radu;Iulian;;Dipl.Ing.;
ORG:Example Com\, Inc.;European Division
EMAIL;TYPE=internet,home:iulian.radu@gmx.at
TZ:+01:00
REV:20110531T184600Z
LOGO;TYPE=JPEG;ENCODING=b:ABCDEFGHIJ==
LABEL;TYPE=work;TYPE=parcel,intl:1. Operngasse\n1010 Wien\nAustria
END:VCARD
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Contact">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<VCARD>
   <VERSION>3.0</VERSION>
   <FN>Iulian Radu</FN>
   <N>Radu;Iulian;;Dipl.Ing.;</N>
   <ORG>Example Com, Inc.;European Division</ORG>
   <EMAIL type="internet,home">iulian.radu@gmx.at</EMAIL>
   <TZ>+01:00</TZ>
   <REV>2011-05-31 18:46:00</REV>
   <LOGO type="image/jpeg" encoded="base64">ABCDEFGHIJ==</LOGO>
   <LABEL type="work,parcel,intl">1. Operngasse
1010 Wien
Austria</LABEL>
</VCARD>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>The
						BEGIN:VCARD is replaced with &lt;VCARD&gt; and END:VCARD is
						replaced with &lt;/VCARD&gt;. Each type in VCARD has a
						corresponding
						tag. As in RFC all types are defined in uppercase so are also defined
						all tags. All attributes are lowercase. All values of attribute TYPE
						from a VCARD must to be gathered together in a single list and passed
						as attribute TYPE to the corresponding tag (they are delimited by commas).
						Any escaped semicolon or comma in VCARD is also passed prefixed with a
						backslash in XML. Any \n is replaced with a real end of line. The VCARD
						attributes LANGUAGE, VALUE, CONTEXT and CHARSET must not be present in
						XML. The attribute ENCODING="b" is replaced with ENCODED="base64", any
						other encoding scheme is silently dropped. The client can also send an
						attribute ENCODED="utf-8" as this is the default encoding for tags. The
						format for a date is: YYYY-MM-DD. The format for a time is: HH:MM:SS. The
						format for a timestamp is: yyyy-mm-ddThh:mm:ssZ. All times are UTC/GMT
						times according
						<xref target="ISO.8601.1988">Representation of dates and times</xref>.
						As VCARD attribute VALUE is missing then the format of the value is
						detected automatically based on the context. For example, a value starting
						with 'http://' corresponds to a 'VALUE=uri'; an 'ENCODED="base64"'
						corresponds to a 'VALUE=binary'. Were VCARD standar accepts a date or a
						date-time then we expect to receive a timestamp (date-time). It is not
						accepted an attribute SOURCE for VCARD type as the content of this VCARD must be defined
						inside of the XML. Also are not accepted tags that corresponds to VCARD
						types having 'VALUE=uri:CID:', so referincing parts that cannot exists in this XML.
					</t>
				</section>
				<section title="Response for File Folders" toc="default">
					<t>
						A response holding the content of a file has the following
						structure:
						<figure align="center" anchor="Respons_File">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<FILE>
    <NAME>name</NAME>
    <CONTENT encoded="utf-8|base64">content</CONTENT>
</FILE>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>The valid encodings type are: utf-8 and base64. The default
						encoding is base64.</t>
					<t>
						Example:
						<figure align="center" anchor="Example_File">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<FILE>
    <NAME>Example.txt</NAME>
    <CONTENT encoded="base64">c3VyZS4=</CONTENT>
</FILE>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
				</section>
				<section title="Response for Filter Folders" toc="default">
					<t>
						An entryTag can be: AND, OR, NOT, UID, TAG, IS, REGEX. The value
						associated to
						entryTag is specified as an XML text node. The IS and REGEX tags have two
						attributes:
						PATH and OP. Their values are set as for a filter command (see chapter
						<xref target="filter_syntax" format="counter" />
						<xref target="filter_syntax" format="title" />
						for more information). The tag RULES group all its rules in an AND
						group.
					</t>
					<t>There must be assigned at least one folder and must be present
						at least a rule.
						Optionally can be gived a description using ABOUT tag. Cannot be assigned as
						folders for being searched folders of the following types: FILT,
						FOLD.
					</t>
					<t>
						A response holding the content of a file has the following
						structure:
						<figure align="center" anchor="Respons_Filter">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<FILTER>
    <ABOUT>...</ABOUT>?
    <FOLDERS>
        <FOLDER>...</FOLDER>...
    </FOLDERS>
    <RULES>
        <entryTag>...</entryTag>...
    </RULES>
</FILTER>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Filter">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<FILTER>
    <ABOUT>A sample FILT filter.</ABOUT>
    <FOLDERS>
        <FOLDER>/INBOX</FOLDER>
        <FOLDER>/Spam</FOLDER>
    </FOLDERS>
    <RULES>
        <OR>
            <IS path="/MESSAGE/HEADER/subject" op="=">Viagra</IS>
            <AND>
                <UID>UIDx1234:UIDx4321</UID>
                <TAG>SPAM</TAG>
            </AND>
        </OR>
    </RULES>
</FILTER>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
				</section>
				<section title="Response for Journal Folders" toc="default">
					<t>
						The format is derived from the one defined for VJOURNAL by the
						<xref target="RFC5545">iCalendar</xref>
						standard.
					</t>
					<t>
						The following example corresponds to this VJOURNAL definition:
						<figure align="center" anchor="Respons_Journal">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
BEGIN:VJOURNAL
UID:20110531T184600Z-123456@agap.at
DTSTAMP:20110607T135238Z
DTSTART:20110607T135238Z
SUMMARY:Revise AGAP Internet-Draft
DESCRIPTION:1. The draft was revised\, saved and
 closed.\n2. It is ready to be published.\n
ATTACH;FMTTYPE=text/plain;VALUE=BINARY;ENCODING=BASE64:
 ABCDEFGHIJ==
END:VJOURNAL
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Journal">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<VJOURNAL>
    <UID>20110531T184600Z-123456@agap.at</UID>
    <DTSTAMP>2011-06-07 13:52:38</DTSTAMP>
    <DTSTART>2011-06-07 13:52:38</DTSTART>
    <SUMMARY>Revise AGAP Internet-Draft</SUMMARY>
    <DESCRIPTION>1. The draft was revised, saved and closed.
2. It is ready to be published.
</DESCRIPTION>
    <ATTACH fmttype="text/plain" encoded="base64">
        ABCDEFGHIJ==</ATTACH>
</VJOURNAL>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>The
						BEGIN:VJOURNAL is replaced with &lt;VJOURNAL&gt; and END:VJOURNAL is
						replaced with &lt;/VJOURNAL&gt;. Each type in VJOURNAL has a corresponding
						tag in uppercase. All attributes are lowercase. Any escaped semicolon
						or comma in VJOURNAL is also passed prefixed with a backslash in XML. Any
						\n is replaced with a real end of line. The VJOURNAL attributes
						LANGUAGE, VALUE and CHARSET must not be present in XML. The attribute
						ENCODING="BASE64" is replaced with ENCODED="base64", any other
						encoding scheme is silently dropped. The client can also send an attribute
						ENCODED="utf-8" as this is the default encoding for tags. The format for
						a timestamp is: yyyy-mm-ddThh:mm:ssZ. All times are UTC/GMT times according
						<xref target="ISO.8601.1988">Representation of dates and times</xref>.
						As VTODO attribute VALUE is missing then the format of the value is
						detected automatically based on the context. For example, a value starting
						with 'http://' corresponds to a 'VALUE=uri'; an 'ENCODED="base64"'
						corresponds to a 'VALUE=binary'. Were VJOURNAL standar accepts a date or a
						date-time then we expect to receive a timestamp (date-time). There are not
						accepted tags that corresponds to VJOURNAL types having 'VALUE=uri:CID:',
						so referincing parts that cannot exists in this XML.
					</t>
				</section>
				<section title="Response for Message Folders" toc="default">
					<t>
						A response holding the content of a message has the following
						structure:
						<figure align="center" anchor="Respons_Mesg">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<MESSAGE>
    <HEADER>
        <header-entry-once>value</header-entry-once>...
        <header-entry-multi>value 1
 value 2
 ...     
 value n...</header-entry-multi>...
    </HEADER>
    <TEXT? encoded="utf-8|base64">main text</TEXT>
    <HTML? encoded="utf-8|base64">main html</HTML>
    <ATTACHMENT-{id}*>
        <HEADER>
            ...
        </HEADER>
        <BODY encoded="utf-8|base64">
            ...
        </BODY>
    </ATTACHMENT-{id}>...
</MESSAGE>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>The first attachment id has value 1.</t>
					<t>The id of on item tag shows the order of the entries in the
						original message.</t>
					<t>The default content encoding is utf-8. It is assumed that the
						content for TEXT
						and HTML is encoded in UTF-8 when the ENCODED attribut has the value
						base64.
					</t>
					<t>The entries in the header of the main message and attachments
						are
						the same with the one from the e-mail message.
					</t>
					<t>There can be at most 2,147,483,647 attachments defined and their
						numbers must
						be sequential starting with 1.
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Mesg">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<MESSAGE>
    <HEADER>
        <from>example@no-spam.com</from>
        <to>example@example.com</to>
        <received>
            <item>
from mail.yahoo.com by example.com; Tue, 16 Mar 2010 12:14:24 +0100
            </item>
            <item>
from no-spam.com by mail.yahoo.com; Mon, 15 Mar 2010 11:13:23 +0100
            </item>
        </received>
        <content-type>multipart/mixed; boundary="XYZ"</content-type>
        <subject>A basic example</subject>
    </HEADER>
    <TEXT>Please see the attachments.</TEXT>
    <HTML>
&lt;b&gt;Please&lt;/b&gt; see the &lt;u&gt;attachments&lt;/u&gt;.
    </HTML>
    <ATTACHMENT-1/>
      <HEADER>
        <content-type>text/plain</content-type>
      </HEADER>
      <BODY encoded="utf-8">See the picture.</BODY>
    </ATTACHMENT-1>
    <ATTACHMENT-2>
      <HEADER>
        <content-type>image/jpeg</content-type>
        <content-transfer-encoding>base64</content-transfer-encoding>
      </HEADER>
      <BODY encoded="base64">c3VyZS4=</BODY>
    </ATTACHMENT-2>
</MESSAGE>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						The previous example corresponds to a message with the following
						structure:
						<list style="symbols">
							<t>
								multipart/mixed
								<list style="symbols">
									<t>
										multipart/alternative
										<list style="symbols">
											<t>text/plain</t>
											<t>text/html</t>
										</list>
									</t>
									<t>text/plain</t>
									<t>image/jpeg</t>
								</list>
							</t>
						</list>
					</t>
				</section>
				<section title="Response for Note Folders" toc="default">
					<t>
						A response holding the content of the note has the following
						structure:
						<figure align="center" anchor="Respons_Note">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<NOTE>
    <SUBJECT>...</SUBJECT>
    <CONTENT type="text/..." encoded="utf-8|base64">...</CONTENT>
</NOTE>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>Note: the subject can be any short text. The content can be
						encoded UTF-8 or BASE64. Implicit is content encoded in utf-8.
						The type can be any subtype of 'text/*'. Implicit is 'text/plain'.
						It is recommended to be used only 'text/plain' and 'text/html'.
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Note">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<NOTE>
    <SUBJECT>Important!</SUBJECT>
    <CONTENT type="text/plain" encoded="utf-8">
        To review the code.</CONTENT>
</NOTE>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
				</section>
				<section title="Response for Task Folders" toc="default">
					<t>
						The format is derived from the one defined for VTODO by the
						<xref target="RFC5545">iCalendar</xref>
						standard.
					</t>
					<t>
						The following example corresponds to this VTODO definition:
						<figure align="center" anchor="Respons_Task">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
BEGIN:VTODO
UID:20110531T184600Z-123456@agap.at
DTSTAMP:20110531T184600Z
DTSTART:20110607T120000Z
DUE:20110607T140000Z
COMPLETED:20110607T135238Z
SUMMARY:Revise AGAP Internet-Draft
PRIORITY:1
STATUS:NEEDS-ACTION
ATTACH;FMTTYPE=text/plain;VALUE=BINARY;ENCODING=BASE64:
 ABCDEFGHIJ==
END:VTODO
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example:
						<figure align="center" anchor="Example_Task">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<VTODO>
    <UID>20110531T184600Z-123456@agap.at</UID>
    <DTSTAMP>2011-05-31 18:46:00</DTSTAMP>
    <DTSTART>2011-06-07 12:00:00</DTSTART>
    <DUE>2011-06-07 14:00:00</DUE>
    <COMPLETED>2011-06-07 13:52:38</COMPLETED>
    <SUMMARY>Revise AGAP Internet-Draft</SUMMARY>
    <PRIORITY>1</PRIORITY>
    <STATUS>NEEDS-ACTION</STATUS>
    <ATTACH fmttype="text/plain" encoded="base64">
        ABCDEFGHIJ==</ATTACH>
    <ALARM>20110607T170000Z-20110531T184600Z-123456@agap.at</ALARM>
</VTODO>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						The following example corresponds to this alarm definition related
						to the previous task:
						<figure align="center" anchor="Respons_Alarm_Task">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
BEGIN:VALARM
TRIGGER;RELATED=START:20110607T170000Z
REPEAT:3
DURATION:PT15M
ACTION:AUDIO
ATTACH;FMTTYPE=audio/mpeg;VALUE=BINARY;ENCODING=BASE64:
 ABCDEFGHIJ==
END:VALARM
                ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example alarm:
						<figure align="center" anchor="Example_Alarm_Task">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<VALARM>
    <UID>20110607T170000Z-20110531T184600Z-123456@agap.at</UID>
    <RELATED-TO>
       20110531T184600Z-123456@agap.at</RELATED-TO>
    <TRIGGER related="start">2011-06-07 17:00:00</TRIGGER>
    <REPEAT>3</REPEAT>
    <DURATION>900</DURATION>
    <ACTION>AUDIO</ACTION>
    <ATTACH fmttype="audio/mpeg" encoded="base64">
        ABCDEFGHIJ==</ATTACH>
</VALARM>
              ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>The
						BEGIN:VTODO is replaced with &lt;VTODO&gt; and END:VTODO is
						replaced with &lt;/VTODO&gt;. The BEGIN:VALARM is replaced with
						&lt;VALARM&gt; and END:VALARM is replaced with &lt;/VALARM&gt;.
						Each type in VTODO/VALARM has a corresponding tag in uppercase.
						All attributes
						are lowercase. Any escaped semicolon or comma in VTODO/VALARM is also
						passed prefixed with a backslash in XML. Any \n is replaced with a
						real end of line. The VTODO/VALARM attributes LANGUAGE, VALUE and
						CHARSET must not be present in XML. The attribute ENCODING="BASE64"
						is replaced with ENCODED="base64", any other encoding scheme is silently
						dropped. The client can also send an attribute ENCODED="utf-8" as this is
						the default encoding for tags. The format for a timestamp is:
						yyyy-mm-ddThh:mm:ssZ. All times are UTC/GMT times according
						<xref target="ISO.8601.1988">Representation of dates and times</xref>.
						As VTODO/VALARM attribute VALUE is missing then the format of the value is
						detected automatically based on the context. For example, a value starting
						with 'http://' corresponds to a 'VALUE=uri'; an 'ENCODED="base64"'
						corresponds to a 'VALUE=binary'. Were VTODO/VALARM standars accept a date or a
						date-time then we expect to receive a timestamp (date-time). There are not
						accepted tags that corresponds to VTODO/VALARM types having 'VALUE=uri:CID:',
						so referincing parts that cannot exists in this XML. The DURATION must be
						always a relative value (starts with a P or -P). As a VALARM is no more a
						child of a VTODO we need to link the two entities. A VTODO with an
						associated VALARM must include an ALARM tag having the UID of the associated
						VALARM. A VALARM must have an UID defined and a RELATED-TO tag holding the
						UID of the associated VTODO. An VTODO can have only one VALARM associated.
					</t>
				</section>
			</section>
		</section>
		<section title="States" toc="default">
			<section title="Not-authenticated State" toc="default">
				<t>This is the default state when a new connection is made to the
					server.
					The client becomes a welcome message.
				</t>
				<t>From this state the client can use the command 'AUTH mechanism'
					to move in
					the 'Pre-authentication State'. This is the only other state in which
					the
					server can go.
				</t>
				<t>The client can use the command 'STLS' for commuting in the
					encrypted mode
					of the channel. After STLS the server remains in the
					'Not-authenticated State'.
					There is no command for switching back to clear-text communication.
				</t>
				<t>The client can use the command 'SGZP' for commuting in the
					compressed mode
					of the channel. After SGZP the server remains in the
					'Not-authenticated State'.
					There is no command for switching back to not-compressed communication.
				</t>
				<t>A client can use at the same time the both modes (encrypted and
					compressed).</t>
				<t>The client can use the command 'QUIT' for terminating the
					connection.</t>
				<t>For finding what extensions are installed in server, the client
					can use the
					'CAPA' command.
				</t>
			</section>
			<section title="Pre-authentication State" toc="default">
				<t>This is the state where a client authenticate itself and move to
					the
					'Authenticated State' or returns to the 'Not-authenticated State'.
				</t>
				<t>This standard defines only one method for AUTH: PLAIN. Following
					is a
					description of the commands flow used by this authentication mechanism.
				</t>
				<t>The client must send a 'USER account' followed by a 'PASS
					password' (if
					the server confirms the acceptance of the account name). If the pair
					account
					and password is accepted then the server move to the state
					'Authenticated State'
					and the folder INBOX is selected by server. If this folder does not
					exist then
					the server moves in the 'Not-Selected State' and the client must to
					select an
					existing folder for operating with this account.
					If this pair is rejected then the server returns to the
					'Not-authenticated State'.
					That means that the client must to send a new 'AUTH mechanism' for
					trying a new
					authentication.
				</t>
				<t>The client can use the command 'QUIT' for terminating the
					connection.</t>
				<t>A client can enter into this state only after a successful 'AUTH'
					command in
					'Not-authenticated State'.
				</t>
			</section>
			<section title="Authenticated (and Selected) State" toc="default">
				<t>This is the state from which a client operates with the content
					of an account.</t>
				<t>From this state the client can use the command 'EXIT' to move in
					the 'Not-authenticated State'. After an unsuccessful SLCT, the
					server
					goes in 'Not-selected State'.
				</t>
				<t>The client can use the command 'QUIT' for terminating the
					connection.</t>
				<t>Check the following chapter for finding which commands can be
					performed from
					this state.
				</t>
				<t>A client can enter into this state only after a successful
					authentication in
					the 'Pre-authenticated State' or after a successful 'SLCT' command in
					the
					'Authenticated State' or 'Not-selected State'.
				</t>
			</section>
			<section title="(Authenticated but) Not-selected State" toc="default">
				<t>This is the state from which a client must to select a folder for
					performing
					further operations.
				</t>
				<t>From this state the client must use the command 'SLCT' to select
					a folder and to move in
					the 'Authenticated State'. This is the only other state in which the
					server can go.
				</t>
				<t>The client CAN use the command 'LIST' for finding valid folder
					names that eventually
					CAN be selected with 'SLCT' command.
				</t>
				<t>The client CAN use the command 'QUIT' for terminating the
					connection.</t>
				<t>A client CAN enter into this state only after an unsuccessful
					'SLCT' command
					or if the INBOX folder does not exists and it cannot be selected
					automatically
					after a successful authentication.
				</t>
			</section>
			<section title="Presence State" toc="default">
				<t>This is the state in which a client can only ask information
					about the presence of an
					user/account.
				</t>
				<t>In this state the client can use only the command 'PGET' to ask
					for presence information
					of an account (inclusive finding when a meeting can be scheduled) and
					the command 'QUIT'
					for terminating the connection.
				</t>
			</section>
			<section title="Storing State" toc="default">
				<t>This is the state in which a client can only add items (for
					example: messages, events)
					in an account which it is not his/her.
				</t>
				<t>In this state the client can use only the command 'FSTO' to find
					and store the item into a folder of
					specified type from specified user and the command 'QUIT' for terminating
					the connection.
				</t>
			</section>
		</section>
		<section title="Commands" toc="default">
			<section title="Semantic and Syntax" toc="default">
				<t>Each command has its name from 4 letters and it is matched
					case-insensitive.</t>
				<t>Each command is separated by its arguments by a 0x20 character.
					Also, each argument is separated from its adjacent arguments by a
					0x20 character.
				</t>
				<t>The minimal response has only the return code without any text.
				</t>
				<t>A list of elements is enclosed between parentheses (round
					brackets).</t>
			</section>
			<section title="Syntax of a Tag List" toc="default">
				<t>A tag list is used by the following commands: FTAG, GTAG, SFTG
					and STAG.</t>
				<t>A tag list defines what action to be done with its tags.</t>
				<t>Syntax: ACTION TAG TAG=VALUE ...</t>
				<t>
					ACTION:
					<list style="symbols">
						<t>= - set only these tags;</t>
						<t>+ - add these tags</t>
						<t>- - delete these tags.</t>
					</list>
				</t>
				<t>Note: When it is used the delete tags action and for a tag is set
					a value then the tag
					is deleted only if the current value match the value found in the
					delete command.
					If in delete command is specified a value for a tag which actually
					has no value
					set then this tag is not deleted. If in delete command is specified
					only the name of a tag
					without a value and the tag has a value assigned then the tag is deleted.
				</t>
				<t>
					Example:
					<figure align="center" anchor="Example_Tag_List">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG UIDx1234 = SEEN SPAM=YES
C: STAG UIDx1234 + SEEN FLAG=RED OWNER=RAI
C: STAG UIDx1234 - FLAG JUNK OWNER=JOHN SEEN=
            ]]></artwork>
						<postamble></postamble>
					</figure>
					Note: After this three commands we have only the following tags:
					SEEN SPAM=YES JUNK OWNER=RAI.
				</t>
			</section>
			<section title="Syntax of a Filter" toc="default" anchor="filter_syntax">
				<section title="Syntax of a Filter for a Command" toc="default">
					<t>A filter of this type is used by the following commands:
						FCPY, FDEL, FTAG, FIND and FMOV.
					</t>
					<t>A filter defines rules for matching entries.
						It is defined as lines with rules and it is ended by an empty line.
					</t>
					<t>The keywords of the filter are case insensitive matched
						(ex.: UID and Uid are the same).
					</t>
					<t>A rule must be completely defined in the same line (exception
						are
						grouping, AND, OR, and NOT rules).
					</t>
					<t>
						Accepted rules:
						<list style="symbols">
							<t>( ) - grouping for AND and OR;</t>
							<t>AND - all following rules are with AND bonded (until the end
								of the current group). It is the implicit rule when the first
								rule
								is not an AND or an OR;
							</t>
							<t>OR - all following rules are with OR bonded (until the end
								of the current group);
							</t>
							<t>NOT - invert the result of the following rule;</t>
							<t>UID uid - one UID;</t>
							<t>UID uid_begin_range:uid_end_range - inclusive range
								(uid_end_range is optional and if it missing
								then it is assumed the maximum valid UID: 32 of lower-case letter
								z);
							</t>
							<t>TAG tag_name - a tag of an entry;</t>
							<t>TAG tag_name=tag_value - an entry's tag with a value
								(tag_value is the complete value);</t>
							<t>IS field_path op string - a field from the content (as XML)
								with an exact matched text
								(string is written between ' and ' can be escaped with \');
								op can be: &lt;, &lt;=, =, !=, &gt;=, &gt;;</t>
							<t>REGEX field_path op regex_string - a field from the content
								(as XML) with a regular expression
								matched text (regex_string is written between ' and ' can be escaped
								with \');
								op can be: =, !=; the regex_string can match only a part of the
								content.
							</t>
							<t>NEW - it is true if an entry is marked as new; after a new
								entry was reported or retrieved
								(by DATT, FIND, FRTR, RETC, RETR or a filter folder) it will be
								marked as no longer being new and
								it will not be matched by a new search for new entries.
							</t>
						</list>
					</t>
					<t>The field_path is a PATH as it is returned by RETR and must point to a not
						binary end leaf. It contains only tag names separated with /. Example:
						/MESSAGE/HEADER/subject, /MESSAGE/HEADER/received, /MESSAGE/TEXT,
						/MESSAGE/HTML, /MESSAGE/ATTACHMENT-1/HEADER/type, /MESSAGE/ATTACHMENT-1/BODY.
						There is an exception, for FILT folder types the path /FILTER/FOLDERS
						returns the list of folders with a folder path per line and the path
						/FILTER/FOLDERS/FOLDER is invalid. 
					</t>
					<t>Searching for a TAG without associating and a value to it will
						match all entries having this tag, even if it have values set for it.
					</t>
					<t>It can be searched only in the body of attachments that have a
						content type of type 'text/*'.</t>
					<t>
						Example 1:
						These filters find all messages with the UID between UIDx0001:UIDx1000
						and that were seen and
						marked as being spam or having a virus (the AND is redundant in the
						second case).
						Both filter definitions are equivalent.
						<figure align="center" anchor="Example_Filter_1">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
C: UID UIDx0001:UIDx1000 OR ( TAG SPAM TAG HAS=VIRUS ) TAG SEEN
C: UID UIDx0001:UIDx1000 AND( OR ( TAG SPAM TAG HAS=VIRUS ) TAG SEEN)
            ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example 2:
						<figure align="center" anchor="Example_Filter_2">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
C: IS /MESSAGE/HEADER/subject = 'From University'
C: REGEX /MESSAGE/HEADER/FROM != '[^0-9]+@example\.com$'
C: IS /VCARD/FN = 'Anonymous'
C: REGEX /VCARD/ORG = '^[A-Za-z]+[0-9]$'
            ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
				</section>
				<section title="Syntax of a Filter for a FILT Folder" toc="default">
					<t>A filter of this type is used by the following command: STOR.
					</t>
					<t>A filter defines rules for matching the different messages from
						different folders. It is defined as an XML with target folders and
						rules.
					</t>
					<t>The keywords of the filter are case sensitive matched (ex.:
						UID and Uid are not the same). They are always lowercase.
					</t>
					<t>
						Accepted rules:
						<list style="symbols">
							<t>AND - all its entries must be matched;</t>
							<t>OR - at least one of its entries must be matched;</t>
							<t>NOT - invert the result of its child rule;</t>
							<t>UID uid - one UID;</t>
							<t>UID uid_begin_range:uid_end_range - inclusive range; </t>
							<t>TAG tag_name - a tag;</t>
							<t>TAG tag_name=tag_value - a tag with a value (tag_value is the
								complete value);</t>
							<t>IS field_path op string - a field from the content (as XML)
								with an exact matched text
								(string is written between ' and ' can be escaped with \');
								op can be: &lt;, &lt;=, =, !=, &gt;=, &gt;;</t>
							<t>REGEX field_path op regex_string - a field from the content
								(as XML) with a regular expression
								matched text (regex_string is written between ' and ' can be escaped
								with \');
								op can be: =, !=; the regex_string can match only a part of the
								content.
							</t>
						</list>
					</t>
					<t>The field_path is a PATH as it is returned by RETR and must point to a not
						binary end leaf. It contains only tag names separated with /. Example:
						/MESSAGE/HEADER/subject, /MESSAGE/HEADER/received, /MESSAGE/TEXT, 
						/MESSAGE/HTML, /MESSAGE/ATTACHMENT-1/BODY.
						There is an exception, for FILT folder types the path /FILTER/FOLDERS
						returns the list of folders with a folder path per line and the path
						/FILTER/FOLDERS/FOLDER is invalid. 
					</t>
					<t>Searching for a TAG without associating and a value to it will
						match all entries
						that have this tag even if it have values set for it (the empty string
						is also
						considered matched).
					</t>
					<t>
						The following two examples corresponds to the two examples from
						the previous chapter:
						<figure align="center" anchor="Example_Filter_3">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<FILTER>
    <FOLDERS>
        <FOLDER>/INBOX</FOLDER>
    </FOLDERS>
    <RULES>
        <AND>
            <UID>UIDx0001:UIDx0010</UID>
            <OR>
                <TAG>SPAM</TAG>
                <TAG>HAS=VIRUS</TAG>
            </OR>
            <TAG>SEEN</TAG>
        </AND>
    </RULES>
</FILTER>
            ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
					<t>
						Example 2:
						<figure align="center" anchor="Example_Filter_4">
							<preamble></preamble>
							<artwork align="left"><![CDATA[
<FILTER>
  <FOLDERS>
    <FOLDER>/INBOX</FOLDER>
  </FOLDERS>
  <RULES>
    <OR>
      <IS path="/MESSAGE/HEADER/subject" op="=">From University</IS>
      <REGEX path="/MESSAGE/HEADER/FROM" op="!=">
         [^0-9]+@example\.com$</REGEX>
      <IS path="/VCARD/FN" op="=">Anonymous</IS>
      <REGEX path="/VCARD/ORG" op="=">^[A-Za-z]+[0-9]$</REGEX>
    </OR>
  </RULES>
</FILTER>
            ]]></artwork>
							<postamble></postamble>
						</figure>
					</t>
				</section>
			</section>
			<section title="The Welcome Message - not-authenticated state"
				toc="default">
				<t>Results: 200 401 410 531</t>
				<t>Result 200 - the client is accepted for sending commands;</t>
				<t>Result 401 - there was an internal error;</t>
				<t>Result 410 - too many connections;</t>
				<t>Result 531 - the client is rejected permanently.</t>
				<t>Description: When a client connects to the server it receives a
					welcome message.
					This message begins with a response code that shows if the client is
					accepted for
					sending commands.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Welcome_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 200 Welcome localhost [127.0.0.1]
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Welcome_401">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 401 Internal error, please contact our administrator
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Welcome_410">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 410 Sorry, too many connections, please retry later
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Welcome_531">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 531 Your hostname/IP (localhost:127.0.0.1) is blacklisted
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command QUIT - all states" toc="default">
				<t>Name: quit</t>
				<t>Arguments: none</t>
				<t>Result: 200</t>
				<t>Description: The QUIT command close the connection between the
					client and server.</t>
				<t>
					Example:
					<figure align="center" anchor="Example_Quit">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: QUIT
S: 200 OK Bye
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command AUTH mechanism - not-authenticated state"
				toc="default">
				<t>Name: authenticate</t>
				<t>Argument: mechanism</t>
				<t>Results: 200 510 511</t>
				<t>Result 200 - the mechanism is known and accepted.</t>
				<t>Result 510 - unknown command.</t>
				<t>Result 511 - the mechanism is unknown/unsupported.</t>
				<t>Description: Choose an authentication method.
					The name of the mechanism can contain only latin letters (A-Z), digits
					(0-9), the signs minus (-) and underscore (_).
					It is case insensitive.
					All supported mechanisms must to be advertised in CAPA's list of
					capabilities as AUTH-MechanismNameInUpperCase.
				</t>
				<t>The PLAIN Authentication Mechanism: the client send the username
					and password in clear text using
					the commands USER and PASS.
				</t>
				<t>The MD5 and SHA1 Authentication Mechanisms: the server send an
					additional line starting with a dot and
					providing a prefix that will gone be used by the client to send back to the
					server an MD5 or SHA-1
					value computed on the string build from this prefix and user's password.
					This prefix can have
					between 1 and 256 characters. Allowed characters are any UTF-8 characters
					having a code bigger the
					decimal value 31 (first valid character is space). The initial dot is not
					part of the prefix.
					The client send the username and the computed hash using the commands
					USER and HASH.
				</t>
				<t>The PRESENCE Authentication Mechanism: this mechanism is used by
					a client to query the presence of
					an user having an account on the server. If the server knows to
					forward the request to other servers
					(in case that requested account in not local) then it can return the
					answer from the remote server.
					The client send the username and password in clear text using the
					commands USER and PASS. For an
					anonymous access the server can accept as username anonymous and as password
					the email address of the
					connecting user. Once the username and password are accepted, the server
					enters in the presence state and
					the client can execute only the commands PGET and QUIT.
				</t>
				<t>The PRESENCE-MD5 and PRESENCE-SHA1 Authentication Mechanisms:
					these mechanisms are working similar with
					MD5 and SHA1 authentication mechanisms, only that move the server in
					the same status as PRESENCE authentication
					mechanism.
				</t>
				<t>The STORING Authentication Mechanism: this mechanism is used by a
					client to store items in accounts
					which are not his/hers. The client send the username and password in
					clear text using the commands USER
					and PASS. For an anonymous access the server can accept as username
					anonymous and as password the email address
					of the connecting user. Once the username and password are accepted,
					the server enters in the storing state and
					the client can execute only the commands FSTO and QUIT.
				</t>
				<t>The STORING-MD5 and STORING-SHA1 Authentication Mechanisms: these
					mechanisms are working similar with
					MD5 and SHA1 authentication mechanisms, only that move the server in
					the same status as STORING authentication
					mechanism.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Auth_200_plain">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PLAIN
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send PASS
C: PASS email@example.com
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_md5">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH MD5
S: .Hash prefix ... for user's password
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send HASH
C: HASH 79054025255fb1a26e4bc422aef54eb1
S: 200 OK Authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_sha1">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH SHA1
S: .Hash prefix ... for user's password
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send HASH
C: HASH de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b4
S: 200 OK Authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_Presence">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PRESENCE
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send PASS
C: PASS email@example.com
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_Presence_Md5">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PRESENCE-MD5
S: .Hash prefix ... for user's password
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send HASH
C: HASH 79054025255fb1a26e4bc422aef54eb1
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_Presence_Sha1">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PRESENCE-SHA1
S: .Hash prefix ... for user's password
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send HASH
C: HASH de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b4
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_Storing">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH STORING
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send PASS
C: PASS email@example.com
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_Storing_Md5">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH STORING-MD5
S: .Hash prefix ... for user's password
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send HASH
C: HASH 79054025255fb1a26e4bc422aef54eb1
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_200_Storing_Sha1">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH STORING-SHA1
S: .Hash prefix ... for user's password
S: 200 OK Send USER
C: USER anonymous
S: 200 OK Send HASH
C: HASH de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b4
S: 200 OK User anonymous authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Auth_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH unknown
S: 511 UNKNWON method
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command CAPA - not-authenticated state" toc="default">
				<t>Name: capabilities</t>
				<t>Arguments: none</t>
				<t>Result: 200</t>
				<t>Description: Ask for the parts of this standards or extensions
					supported by the server.</t>
				<t>
					Following is a list with all capabilities defined and covered by
					this document. If the
					server do no present an entry from the following list then the client
					must assume that the
					sever is unable to do the associated operations of the missing entry.
					<list style="symbols">
						<t>ADDR - contact information;</t>
						<t>AUTH-PLAIN - suport plain authentication;</t>
						<t>AUTH-PRESENCE - suport authentication for asking about
							presence;</t>
						<t>AUTH-PRESENCE-MD5 - suport authentication for asking about
							presence;</t>
						<t>AUTH-PRESENCE-SHA1 - suport authentication for asking about
							presence;</t>
						<t>AUTH-MD5 - suport MD5 authentication;</t>
						<t>AUTH-SHA1 - suport SHA1 authentication;</t>
						<t>AUTH-STORING - suport authentication for receiving items;</t>
						<t>AUTH-STORING-MD5 - suport authentication for receiving items;
						</t>
						<t>AUTH-STORING-SHA1 - suport authentication for receiving items;
						</t>
						<t>CALE - events;</t>
						<t>CHNG - list the FCID of all folders;</t>
						<t>CONF - user accounts configuration;</t>
						<t>FACL - ACL for folders;</t>
						<t>FILE - storing files;</t>
						<t>FILT - definition of a filter;</t>
						<t>STOR - accepts storing from external sources;</t>
						<t>JRNL - journal entries;</t>
						<t>MESG - e-mail messages;</t>
						<t>NOTE - short texts;</t>
						<t>PNFO - presence;</t>
						<t>SGZP - server accepts compression;</t>
						<t>STLS - server can encrypt the communication channel;</t>
						<t>TASK - tasks.</t>
					</list>
				</t>
				<t>
					Example:
					<figure align="center" anchor="Example_Capa">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: CAPA
S: .GZIP
S: .TLS
S: .Extension1
S: .Extension.2 argument1
S: .Extension-3 argument1 argument2
S: 200 OK CAPA completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command SGZP - not-authenticated state" toc="default">
				<t>Name: start using GZip</t>
				<t>Arguments: none</t>
				<t>Results: 200 510</t>
				<t>Result 200 - the communication is now compressed.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>
					Description: Change the communication in compressed mode using
					<xref target="RFC1952">GZIP</xref>
					as compression method. If this command is
					executed from the compression mode then it simply returns a 200 response
					code.
					The response to this command is using still the not-compressed mode of
					the channel.
					The compression becomes effective only after a 200 response line was
					send by the server.
				</t>
				<t>Note: With GZIP the data is compressed using the LZ77 algorithm
					and Huffman coding.
					Starting using this mode is like starting to write clear texts into a GZIP
					format archive
					and reading texts from a GZIP format archive. The compression is used
					both by the client and
					the server and they start to use it with the next line they send after
					the 200 response line
					received from the server.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Sgzp_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SGZP
S: 200 OK Using GZIP
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Sgzp_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SGZP
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command STLS - not-authenticated state" toc="default">
				<t>Name: start using TLS</t>
				<t>Arguments: none</t>
				<t>Results: 200 510</t>
				<t>Result 200 - the communication is now encrypted.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Description: Change the communication in mode TLS. If this
					command is
					executed from the encrypted mode then it simply returns a 200 response
					code.
					The response to this command is using still the not-encrypted mode of
					the channel.
					The encryption becomes effective only after a 200 response line was
					send by the server.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Stls_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STLS
S: 200 OK Using TLS
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stls_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STLS
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command HASH - pre-authenticated state (MD5 and SHA1)"
				toc="default">
				<t>Name: hash</t>
				<t>Argument: hash_code</t>
				<t>Result: 200 510 511 512</t>
				<t>Result 200 - the pair user/hash was successfully authenticated.
				</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid hash.</t>
				<t>Result 512 - first send USER and then HASH.</t>
				<t>Description: Send the hash code associated to the previous
					authentication method
					(MD5 or SHA1), previous USER and provided prefix.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Hash_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH MD5
S: .prefix is-here!
S: 200 OK Send USER
C: USER account
S: 200 OK Send HASH
C: HASH 79054025255fb1a26e4bc422aef54eb1
S: 200 OK Authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Hash_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: USER account
S: 200 OK Send HASH
C: HASH
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Hash_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: USER account
S: 200 OK Send HASH
C: HASH 79054025255fb1a26e4bc422aef54eb1
S: 511 WRONG user/hash pair
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Hash_512">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH SHA1
S: .prefix is-here!
S: 200 OK Send USER
C: HASH de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3
S: 512 EXPECTED USER
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command PASS - pre-authenticated state (PLAIN)"
				toc="default">
				<t>Name: password</t>
				<t>Argument: password</t>
				<t>Result: 200 510 511 512</t>
				<t>Result 200 - the pair user/password was successfully
					authenticated.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid password.</t>
				<t>Result 512 - first send USER and then PASS.</t>
				<t>Description: Send the password associated to the previous USER.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Pass_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: USER account
S: 200 OK Send PASS
C: PASS password
S: 200 OK Authenticated
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pass_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: USER account
S: 200 OK Send PASS
C: PASS
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pass_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: USER account
S: 200 OK Send PASS
C: PASS password
S: 511 WRONG user/password pair
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pass_512">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PLAIN
S: 200 OK AUTH completed
C: PASS password
S: 512 EXPECTED USER
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section
				title="Command USER - pre-authenticated state (PLAIN, MD5 and SHA1)"
				toc="default">
				<t>Name: user</t>
				<t>Argument: account</t>
				<t>Result: 200</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the user is accepted and expecting the password.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid account.</t>
				<t>Description: Send an account name for authentication and
					authorization.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_User_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PLAIN
S: 200 OK Send USER
C: USER account
S: 200 OK Send PASS
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_User_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PLAIN
S: 200 OK Send USER
C: USER
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_User_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AUTH PLAIN
S: 200 OK Send USER
C: USER account
S: 511 INVALID username
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command AACL - authenticated state" toc="default">
				<t>Name: add a ACL for selected folder</t>
				<t>Arguments: rights account</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the command was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - the rights are incorrect or the account is missing.
				</t>
				<t>Description: Add a new ACL to the current list of ACLs for
					selected folder
					or replace the old rights if exists an entry for this account.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Aacl_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AACL ADR *@mydomain.com
S: 200 OK The ACL was successfully added
C: AACL R *@mydomain.com
S: 200 OK The ACL was successfully replaced
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Aacl_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AACL
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Aacl_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: AACL GR user@domain.com
S: 511 UNKNOWN right G
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command APBL - authenticated state" toc="default">
				<t>Name: set currently selected folder as public folder for its type
				</t>
				<t>Arguments: none</t>
				<t>Result: 200 410 510</t>
				<t>Result 200 - the command was successful.</t>
				<t>Result 410 - for the moment the selected folder cannot be added
					to the list of public folders.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Description: Add currently selected folder to the list of public
					folders.</t>
				<t>Note: If there was already set a folder for this type then the
					previously
					folder is removed from the list.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Apbl_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: APBL
S: 200 OK Folder /MyCalendar was made PUBLIC for CALE
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Apbl_410">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: APBL
S: 410 Please retry to add it later
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Apbl_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: APBL
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command CHNG - authenticated and not-selected state"
				toc="default">
				<t>Name: report the FCID (Folder Change ID) for all folders</t>
				<t>Arguments: path?</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the command was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - the path is invalid.</t>
				<t>Description: Return a list with the FCID of all folders or of the
					specified path.</t>
				<t>Note: For no path in the list is included and the root folder for
					all other folders as slash ('/').</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Chng_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: CHNG
S: .0BIH /
S: .0009 /Temporary
S: .0001 /Temporary/1980
S: .0BIG /INBOX
S: .0123 /ARCHIVE
S: .0003 /ARCHIVE/2010
S: .0003 /ARCHIVE/2011
S: .00aA /ARCHIVE/2010/OLD
S: 200 OK CHNG completed
C: CHNG /Temporary/1980
S: .0001 /Temporary/1980
S: 200 OK CHNG completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>Note: A change in /ARCHIVE/2010 will change the FCID of
					/ARCHIVE/2010, but
					not the FCID of /ARCHIVE nor /.
				</t>
				<t>
					<figure align="center" anchor="Example_Chng_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: CHNG
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Chng_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: CHNG /no/path
S: 511 UNKNOWN path
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command COPY - authenticated state" toc="default">
				<t>Name: copy entry</t>
				<t>Arguments: UID_source path_destination_folder</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the copy was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - unknown uid, invalid destination folder or path not
					absolute.</t>
				<t>Description: Copy an item from currently selected folder into
					another
					folder (by UID). You cannot copy from a folder having the tag NO-COPY or
					into
					a folder with the tag READ-ONLY.
				</t>
				<t>Note: For copying a folder the client must use CPYF.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Copy_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: COPY UIDx1234 /ARCHIVE_FOLDER/TODAY
S: 200 OK COPY completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Copy_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: COPY
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Copy_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: COPY UIDx1234 ARCHIVE_FOLDER/TODAY
S: 511 INVALID UID
C: COPY MSGx1234 ARCHIVE_FOLDER/1970
S: 511 INVALID Destination
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command CPYF - authenticated state" toc="default">
				<t>Name: copy folder</t>
				<t>Arguments: path_destination_folder</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the copy was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid destination folder, destination is not an
					absolute path
					or destination does not exists.
				</t>
				<t>Description: Copy the content of a folder into another folder.
				</t>
				<t>Note: In the destination folder are copied all non-folder entries
					found in the source.
					If the user needs to copy the content of the source folder in another
					folder then he must
					to create first a new folder with the MAKE command and then use the
					CPYF command.
					If the user wants to copy the folders found in the source then he
					must to do
					recursively MAKE and CPYF for each subfolder.
				</t>
				<t>
					Examples (in TODAY are copied only the messages from INBOX):
					<figure align="center" anchor="Example_Cpyf_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /INBOX
S: 200 Selected /INBOX
C: CPYF /ARCHIVE_FOLDER/TODAY
S: 200 OK CPYF completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Cpyf_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: CPYF
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Cpyf_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: CPYF MISSING
S: 511 INVALID Destination
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command DACL - authenticated state" toc="default">
				<t>Name: delete an ACL from selected folder</t>
				<t>Argument: account</t>
				<t>Result: 200 220 510 511</t>
				<t>Result 200 - the command was successful and the account was
					removed from ACL.</t>
				<t>Result 220 - the command was successful, but the account was not
					found in ACL.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - the account is missing or incorrect.</t>
				<t>Description: Delete an ACL from currently selected folder ACLs.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Dacl_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DACL *@mydomain.com
S: 200 OK The ACL was successfully deleted
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Dacl_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DACL user@domain.com
S: 220 Entry not found
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Dacl_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DACL
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Dacl_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DACL @domain.com
S: 511 UNKNOWN entry format
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command DATT - authenticated state (MESG folder type)"
				toc="default">
				<t>Name: delete attachment</t>
				<t>Arguments: UID AttNum</t>
				<t>Result: 200 510 511 521</t>
				<t>Result 200 - the attachment was successfully deleted.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - unknown uid or uid is not for a message.</t>
				<t>Result 521 - wrong attachment number.</t>
				<t>Description: Delete from a message an attachment. The first
					attachment has number 1. If the deleted attachment is not the last
					one then the
					remaining attachments are renumbered. There is no guarantee that an
					attachment
					will keep its previous number had before the successful DATT command.
				</t>
				<t>Note: It cannot be undone.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Datt_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DATT UIDx1234 1
S: 200 OK Attachment deleted
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Datt_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DATT
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Datt_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DATT UIDx1234 1
S: 511 INVALID UID
C: DATT UIDx1234 0
S: 511 INVALID Attachment number
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Datt_521">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DATT UIDx1234 10
S: 521 There are not so many attachments
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command DELE - authenticated state" toc="default">
				<t>Name: delete entry</t>
				<t>Argument: UID</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the entry was successfully deleted.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - unknown uid.</t>
				<t>Description: Delete an item by uid.</t>
				<t>Note: It cannot be undone.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Dele_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DELE UIDx1234
S: 200 OK Message deleted
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Dele_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DELE
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Dele_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DELE 1234
S: 511 INVALID UID
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command DELF - authenticated state" toc="default">
				<t>Name: delete folder</t>
				<t>Arguments: none</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the folder was successfully deleted.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - no folder was selected or currently selected folder
					is a reserved folder.</t>
				<t>Description: Delete currently selected folder and all its content
					and subfolders.
					A reserved folder cannot be deleted, but a read-only folder yes. If
					the operation is
					successful then after it no folder is selected.
				</t>
				<t>Note: It cannot be undone.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Delf_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DELF
S: 200 OK Folder '/delete/me' was deleted
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Delf_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DELF
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Delf_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DELF
S: 511 Please select first a folder
C: DELF
S: 511 /INBOX cannot be deleted
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command DPBL - authenticated state" toc="default">
				<t>Name: remove currently selected folder from the list of public
					folders</t>
				<t>Arguments: none</t>
				<t>Result: 200 220 410 510</t>
				<t>Result 200 - the command was successful and currently selected
					folder was removed from the list of public folders.</t>
				<t>Result 220 - the command was successful, but currently selected
					folder was not in the list of public folders.</t>
				<t>Result 410 - for the moment the selected folder cannot be removed
					from the list of public folders.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Description: Remove currently selected folder from the list of
					public folders (if it is already there).</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Dpbl_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DPBL
S: 200 OK Folder /MyCalendar is no longer public
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Dpbl_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DPBL
S: 220 OK Folder /MyCalendar was not in the list
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Dpbl_410">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DPBL
S: 410 Please retry to remove it later
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Dpbl_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: DPBL
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command EXIT - authenticated state" toc="default">
				<t>Name: exit</t>
				<t>Arguments: none</t>
				<t>Result: 200</t>
				<t>Description: Return the server to the Not-authenticated State.
				</t>
				<t>
					Example:
					<figure align="center" anchor="Example_Exit">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: EXIT
S: 200 OK EXIT completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FCNT - authenticated state" toc="default">
				<t>Name: find entries and returns how many entries matched the
					filter</t>
				<t>Argument: filter*</t>
				<t>Result: 110 200 220 511</t>
				<t>Result 110 - the client can send the filter.</t>
				<t>Result 200 - the find was successful.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 511 - wrong filter.</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders)
					that correspond to a filter and return the number of matched items. If
					the search is
					done for a filter folder then the server does not expect any filter and
					apply the current
					filter (if any). If there is no filter in the filter folder then it is
					returned 0 and the
					220 code. If there is no match for the filter then it is returned 0
					and the 220 code.
				</t>
				<t>Note: For not FILT folders, the filter is delivered after the
					acceptance of the command. An empty filter matches all items from
					that folder.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Fcnt_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /MESG-Folder
C: FCNT
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: .3
S: 200 OK FCNT completed (3 matches)
C: SLCT /FILT-Folder
C: FCNT
S: .3
S: 200 OK FCNT completed (3 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fcnt_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCNT
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: .0
S: 220 OK FCNT completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fcnt_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCNT
S: 110 OK SEND filter definition (end it with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FCPY - authenticated state" toc="default">
				<t>Name: find and copy entries</t>
				<t>Arguments: path_destination_folder filter*</t>
				<t>Result: 110 200 210 220 510 511</t>
				<t>Result 110 - the client can send the filter.</t>
				<t>Result 200 - the find and copy was successful for all found UIDs.
				</t>
				<t>Result 210 - the find and copy was successful but not for all
					found UIDs.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid destination folder, wrong filter, or no
					right to copy.</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders) that correspond to a filter and copy them to a new
					folder.
					The tags are also copied. You cannot copy from a folder having the tag
					NO-COPY
					or into a folder with the tag READ-ONLY. If there is no match for the
					filter then
					it is returned a 200 code.
				</t>
				<t>Note: The filter is delivered after the acceptance of the command
					(response code 110).
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Fcpy_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCPY /ARCHIVE/SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 200 OK FCPY completed (10 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fcpy_210">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCPY /ARCHIVE/SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 210 OK FCPY completed (8 from 10 were copied - out of space)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fcpy_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCPY /ARCHIVE/SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: 220 OK FCPY completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fcpy_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCPY
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fcpy_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FCPY MISSING
S: 511 INVALID folder or path not absolute
C: FCPY SEND
S: 110 OK SEND filter definition (end it with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FDEL - authenticated state" toc="default">
				<t>Name: find and delete entries</t>
				<t>Argument: filter*</t>
				<t>Result: 110 200 210 220 511</t>
				<t>Result 110 - the client can send the filter.</t>
				<t>Result 200 - the find and delete was successful for all found
					UIDs.</t>
				<t>Result 210 - the find and delete was successful but not for all
					found UIDs.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 511 - wrong filter (inclusive empty filter) or no right to
					delete.</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders) that correspond to a filter and delete them (no
					copy in TRASH).
					You cannot delete from a folder having the tag NO-DELETE. If there is
					no match
					for the filter then it is returned a 200 code.
				</t>
				<t>Note: The filter is delivered after the acceptance of the command
					(response code 110).
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Fdel_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FDEL
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 200 OK FDEL completed (10 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fdel_210">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FDEL
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 210 OK FDEL completed (only 8 from 10 matches were deleted)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fdel_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FDEL
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: 220 OK FDEL completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fdel_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FDEL
S: 110 OK SEND filter definition (end it with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FIND - authenticated state" toc="default">
				<t>Name: find entries</t>
				<t>Argument: filter*</t>
				<t>Result: 110 200 220 511</t>
				<t>Result 110 - the client can send the filter.</t>
				<t>Result 200 - the find was successful.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 511 - wrong filter.</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders)
					that correspond to a filter and return their UIDs. If the search is
					done for a filter
					folder then the server does not expect any filter and apply the current
					filter (if any).
					If there is no filter in the filter folder then it is returned only
					the return code.
					The answer consists of the UIDs and, for a filter folder, they are
					followed by a 0x20
					character and the absolute path for which are the corresponding UID. If
					there is no match
					for the filter then it is returned a 220 code.
				</t>
				<t>Note: For not FILT folders, the filter is delivered after the
					acceptance of the command. An empty filter matches all items from
					that folder.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Find_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /MESG-Folder
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: .UIDx1234
S: .UIDx1235
S: .UIDx2340
S: 200 OK FIND completed (3 matches)
C: SLCT /FILT-Folder
C: FIND
S: .UIDx1234 /INBOX
S: .UIDx1234 /Trash
S: .UIDx1235 /Trash
S: 200 OK FIND completed (3 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Find_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: 220 OK FIND completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Find_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FMOV - authenticated state" toc="default">
				<t>Name: find and move</t>
				<t>Arguments: path_destination_folder filter*</t>
				<t>Result: 110 200 210 220 510 511</t>
				<t>Result 110 - the client can send the filter.</t>
				<t>Result 200 - the find and move was successful for all found UIDs.
				</t>
				<t>Result 210 - the find and move was successful but not for all
					found UIDs.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid destination folder, wrong filter, or no
					right to move.</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders) that correspond to a filter and move them to a new
					folder.
					The tags are also moved. You cannot move from a folder having the tag
					NO-MOVE or
					into a folder with the tag READ-ONLY. If there is no match for the
					filter then
					it is returned a 200 code.
				</t>
				<t>Note: The filter is delivered after the acceptance of the command
					(response code 110).
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Fmov_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FMOV /ARCHIVE/SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 200 OK FMOV completed (10 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fmov_210">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FMOV /ARCHIVE/SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 210 OK FMOV completed (8 from 10 moved - out of space)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fmov_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FMOV /ARCHIVE/SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: 220 OK FMOV completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fmov_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FMOV
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fmov_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FMOV MISSING
S: 511 INVALID folder or not absolute path
C: FMOV /SEND
S: 110 OK SEND filter definition (end it with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FRTR - authenticated state" toc="default">
				<t>Name: find entries and retrieve fields</t>
				<t>Argument: filter* part*</t>
				<t>Result: 110 200 220 511</t>
				<t>Result 110 - the client can send the filter and the items parts.
				</t>
				<t>Result 200 - the find was successful.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 511 - wrong filter or items parts.</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders) that correspond to a filter and return their UIDs
					together with
					the requested parts from them. If the search is done for a filter
					folder then the
					server does not expect any filter and apply the current filter (if any).
					If there
					is no filter in the filter folder then it is returned only the return
					code. If
					there are no parts specified then only the UIDs are returned. Each
					requested part
					becomes a number starting with 1 and being assigned in the same order as
					the fields.
					It is defined a special part named TAGS which returns all tags
					associated to a UID.
					Each tag is returned on its own line prefixed with the starting number.
				</t>
				<t>Note: The number 0 is reserved for the UID. The answer consists
					of the UIDs and, for a
					filter folder, they are followed by a 0x20 character and the absolute
					path for which
					are the corresponding UID. If the item is marked as new then the UID
					is prefixed with a
					multiplication sign (*). The item is then marked as no longer being new. If there
					is no
					match for the filter then it is returned a 220 code.
				</t>
				<t>Note: For not FILT folders, the filter is delivered after the
					acceptance of the command.
					An empty filter matches all items from that folder.
				</t>
				<t>
					Examples: The first message has only a value in To, the second has
					two, and
					the last one none. The second message has no subject.
					<figure align="center" anchor="Example_Frtr_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /MESG-Folder
C: FRTR
S: 110 OK SEND filter&parts definition (end each with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
C: /MESSAGE/HEADER/subject
C: /MESSAGE/HEADER/from
C: /MESSAGE/HEADER/to
C: TAGS
C:
S: .0 UIDx1234
S: .1 Not so important
S: .2 contact@win.com
S: .3 you@example.com
S: .0 *UIDx1235
S: .2 spam@ultimate-spam.com
S: .3 you@example.com
S: .3 your_boss@example.com
S: .0 UIDx2340
S: .1 Please respond
S: .2 office@example.com
S: .4 SEEN
S: .4 EXPIRED=NO
S: 200 OK FRTR completed (3 matches)
C: FRTR
S: 110 OK SEND filter&parts definition (end each with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
C:
S: .0 UIDx1234
S: .0 UIDx1235
S: .0 UIDx2340
S: 200 OK FRTR completed (3 matches)
C: SLCT /FILT-Folder
C: FRTR
S: 110 OK SEND the parts definition (end it with an empty line)
C: /MESSAGE/HEADER/subject
C: /MESSAGE/HEADER/from
C:
S: .0 UIDx1234 /INBOX
S: .1 Please respond
S: .2 office@example.com
S: .0 UIDx1234 /Trash
S: .1 Very urgent
S: .2 spam@ultimate-spam.com
S: .0 *UIDx1235 /Trash
S: .1 Not so important
S: .2 contact@win.com
S: 200 OK FRTR completed (3 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Frtr_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FRTR
S: 110 OK SEND filter&parts definition (end each with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
C: /MESSAGE/HEADER
C:
S: 220 OK FRTR completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Frtr_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FRTR
S: 110 OK SEND filter&parts definition (end each with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
C: FRTR
S: 110 OK SEND filter&parts definition (end each with an empty line)
C: UID UIDx0001:UIDx9000
C:
C: INVALID/PATH
C:
S: 511 INVALID part definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FSTO - storing state" toc="default">
				<t>Name: find and write an item into a folder with a specified type
					from a certain user</t>
				<t>Arguments: FolderType Account</t>
				<t>Result: 110 200 410 510 511 541</t>
				<t>Result 110 - the requested folder was found and the client can
					send the item.</t>
				<t>Result 200 - the item was successfully stored or there was no
					content sent by the client.</t>
				<t>Result 410 - if the item cannot be stored.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid folder type, unknown account, the data is
					not a valid XML or
					its schema does not correspond to the type of the destination folder.
				</t>
				<t>Result 541 - the user does not have enough rights to store the
					item.</t>
				<t>Description: Locate a folder with a specified type in an user
					account for receiving items from
					other users and store there the item sent by the client. It behaves like
					STOR.
				</t>
				<t>Note: Do not send a message content using CDATA as it can hold
					empty lines
					and an empty line means for the server the end of the message to be
					stored.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Fsto_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FSTO MESG kontakt@agap.at
S: 110 Send the message ended with an empty line
C: <MESSAGE><HEADER>...</HEADER><TEXT>...</TEXT></MESSAGE>
C:
S: 200 OK Message stored with UID UIDx1234 into INBOX
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fsto_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FSTO
S: 510 UNKNOWN command
C: FSTO MESG
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fsto_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FSTO -1 kontakt@agap.at
S: 511 INVALID folder type
C: FSTO MESG nouser@agap.at
S: 511 UNKNOWN account name
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Fsto_541">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FSTO MESG kontakt@agap.at
S: 541 Not enough rights. Please contact your administrator.
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command FTAG - authenticated state" toc="default">
				<t>Name: find and tag entries</t>
				<t>Arguments: tag_list filter*</t>
				<t>Result: 110 200 210 220 510 511</t>
				<t>Result 110 - the client can send the filter.</t>
				<t>Result 200 - the find and set of tag(s) was successful for all
					found UIDs.</t>
				<t>Result 210 - the find and set of tag(s) was successful but not
					for all found UIDs.</t>
				<t>Result 220 - no entry matching the filter was found.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid tag list, wrong filter, or no right to tag.
				</t>
				<t>Description: Search for items only from currently selected folder
					(no subfolders)
					that correspond to a filter and change their tags. You cannot tag in a
					folder with the
					tag READ-ONLY. If there is no match for the filter then it is returned
					a 200 code.
				</t>
				<t>Note: The filter is delivered after the acceptance of the command
					(response code 110).
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Ftag_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FTAG + SEEN
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND NEW
C:
S: 200 OK FTAG completed (10 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Ftag_210">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FTAG + SEEN
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND NEW
C:
S: 210 OK FTAG completed (only 8 from 10 matches taged)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Ftag_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FTAG + SEEN
S: 110 OK SEND filter definition (end it with an empty line)
C: UID UIDx0001:UIDx9000 TAG SPAM
C:
S: 220 OK FIND completed (no matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Ftag_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FTAG
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Ftag_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FTAG SEEN
S: 511 INVALID tag list
C: FTAG + SEEN
S: 110 OK SEND filter definition (end it with an empty line)
C: LATER
C:
S: 511 INVALID filter definition
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command GACL - authenticated state" toc="default">
				<t>Name: get all ACLs for selected folder</t>
				<t>Arguments: none</t>
				<t>Result: 200</t>
				<t>Result 200 - the command was successful.</t>
				<t>Description: It returns a list with all defined ACLs for
					currently selected folder.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Gacl_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GACL
S: 200 OK No ACL were defined
C: GACL
S: .R anonymous
S: .RAD *@mydomain.com
S: .A partner@extdomain.com
S: 200 OK The ACL list
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command GFTG - authenticated state" toc="default">
				<t>Name: get tags of currently selected folder</t>
				<t>Arguments: none</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the tags for UID were successful displayed.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Description: Return the tags associated to currently selected
					folder.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Gftg_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GFTG
S: .SYNC
S: .HIDDEN=NO
S: 200 OK GFTG completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Gftg_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GFTG
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command GPBL - authenticated and not-selected state"
				toc="default">
				<t>Name: get the list of public folders</t>
				<t>Arguments: none</t>
				<t>Results: 200 510</t>
				<t>Result 200 - the list was successful delivered (even if it is
					empty).</t>
				<t>Result 510 - unknown command.</t>
				<t>Description: Return the list of all folders declared PUBLIC
					together
					with their type.
				</t>
				<t>Note: There should be only one folder for each type.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Gpbl_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GPBL
S: .MESG /INBOX
S: .CALE /CALENDAR
S: .ADDR /Public/CONTACT
S: .FILE /Project X/Public Files 
S: .JRNL /JOURNAL
S: .TASK /Project X/Tasks
S: 200 OK GPBL completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<figure align="center" anchor="Example_Gpbl_510">
					<preamble></preamble>
					<artwork align="left"><![CDATA[
C: GPBL
S: 510 UNKNOWN command
            ]]></artwork>
					<postamble></postamble>
				</figure>
			</section>
			<section title="Command GTAG - authenticated state" toc="default">
				<t>Name: get tag of a folder entry</t>
				<t>Arguments: UID</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the tags for UID were successful displayed.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid UID.</t>
				<t>Description: Return the tags associated to an item.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Gtag_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GTAG UIDx1000
S: .SEEN
S: .SPAM
S: 200 OK GTAG completed
C: GTAG UIDx1001
S: 200 OK GTAG completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Gtag_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GTAG
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Gtag_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: GTAG -1
S: 511 INVALID UID
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command LIST - authenticated and not-selected state"
				toc="default">
				<t>Name: list folders</t>
				<t>Arguments: path/filter?</t>
				<t>Results: 200 220 511</t>
				<t>Result 200 - the list was successful delivered.</t>
				<t>Result 220 - the list it is empty.</t>
				<t>Result 511 - filter is invalid, the specified path (that has no
					wildcard)
					does not exist, or the specified path before last folder name (which
					has an wildcard)
					does not exist.
				</t>
				<t>Description: List all folders that correspond to the filter (if
					it is provided),
					otherwise all direct children of currently selected folder together with
					their types.
					All returned folder names are prefixed with the type of the
					corresponding folder
					(as it is used by the MAKE command) followed by a white space and the
					absolute path to the
					folder.
				</t>
				<t>Filter's path': It is a relative (does not begins with /) or an
					absolute (begins with /) path.
					The slash sign (/) is used to delimit folders in the hierarchy. There
					can be only
					a star (*) and must to be located in the name of the last folder. Or
					two stars which must
					be the last characters of the filter and means that for each folder
					matching the filter are
					list all their direct and indirect subfolders. The server can return
					511 if it founds '.'
					or '..' as folder names or '\' in the filter definition.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_List_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LIST
S: .MESG YESTERDAY
S: .MESG YEAR-2000
S: 200 OK LIST completed (2 matches)
C: LIST /*
S: .MESG /INBOX
S: .MESG /TRASH
S: .CALE /CALENDAR
S: 200 OK LIST completed (3 matches)
C: LIST YEAR-2010/J*
S: .MESG /WORK/YEAR-2010/JUN
S: .MESG /WORK/YEAR-2010/JUL
S: 200 OK LIST completed (2 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_List_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LIST /archive*
S: 220 OK LIST completed (0 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_List_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LIST */*
S: 511 ERROR path filter can contain only one * in last folder name
C: LIST /ARCHIVE/2000
S: 511 ERROR The specified folder does not exist
C: LIST /ARCHIVE/2000/Documents *.doc
S: 511 ERROR The folder '/ARCHIVE/2000' does not exist
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command LSTX - authenticated and not-selected state"
				toc="default">
				<t>Name: list folders</t>
				<t>Arguments: path/filter?</t>
				<t>Results: 200 220 511</t>
				<t>Result 200 - the list was successful delivered.</t>
				<t>Result 220 - the list it is empty.</t>
				<t>Result 511 - filter is invalid, the specified path (that has no
					wildcard)
					does not exist, or the specified path before last folder name (which
					has an wildcard)
					does not exist.
				</t>
				<t>
					Description: List all folders that correspond to the filter (if it
					is provided),
					otherwise all direct children of currently selected folder together with
					their types.
					All returned folder names are prefixed with the type of the
					corresponding folder
					(as it is used by the MAKE command) followed by a flag indicating some
					information
					about that folder, its
					<xref target="FCID">FCID</xref>
					and
					<xref target="ECID">ECID</xref>
					, and the absolute path to that folder.
					Between each arguments are exactly only one white space.
				</t>
				<t>Note: If a folder does not have a ECID, it must to return always
					the same value,
					which must be in a valid UID format.
				</t>
				<t>Filter's path': It is a relative (does not begins with /) or an
					absolute (begins with /) path.
					The slash sign (/) is used to delimit folders in the hierarchy. There
					can be only
					a star (*) and must to be located in the name of the last folder. Or
					two stars which must
					be the last characters of the filter and means that each folder
					matching the filter is listed
					together with all its direct and indirect subfolders. The server can return
					511 if it founds '.'
					or '..' as folder names or '\' in the filter definition.
				</t>
				<t>
					The flag is a single char and can be only a digit (0-9) or a latin
					letter in lower
					(a-z) or upper case (A-Z) case-sensitive. This document defines the
					following flags:
					<list style="symbols">
						<t>0 - it have no subfolders and no items;</t>
						<t>1 - it have no subfolders, but it have items;</t>
						<t>2 - it have subfolders, but no items;</t>
						<t>3 - it have subfolders and items.</t>
					</list>
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Lstx_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LSTX
S: .MESG 1 FCIDx012 ECIDx001 YESTERDAY
S: .MESG 3 FCIDx123 ECIDx001 YEAR-2000
S: 200 OK LSTX completed (2 matches)
C: LSTX /*
S: .MESG 2 FCIDx321 ECIDx001 /INBOX
S: .MESG 0 FCIDx001 ECIDx001 /TRASH
S: .CALE 0 FCIDx222 ECIDx001 /CALENDAR
S: 200 OK LSTX completed (3 matches)
C: LSTX YEAR-2010/J*
S: .MESG 1 FCIDx009 ECIDx001 /WORK/YEAR-2010/JUN
S: .MESG 2 FCIDx309 ECIDx001 /WORK/YEAR-2010/JUL
S: 200 OK LSTX completed (2 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Lstx_220">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LSTX /archive*
S: 220 OK LSTX completed (0 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Lstx_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LSTX */*
S: 511 ERROR path filter can contain only one * in last folder name
C: LSTX /ARCHIVE/2000
S: 511 ERROR The specified folder does not exist
C: LSTX /ARCHIVE/2000/Documents *.doc
S: 511 ERROR The folder '/ARCHIVE/2000' does not exist
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command MAKE - authenticated and not-selected state"
				toc="default">
				<t>Name: make folder</t>
				<t>Arguments: type path</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the folder was successfully created.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid path, unknown/unsupported type or the parent
					of the new folder
					does not accept to have subfolders.
				</t>
				<t>Description: Create a folder of a certain type.</t>
				<t>
					Types: They are case insensitive
					<list style="symbols">
						<t>ADDR - it holds contacts;</t>
						<t>CALE - it holds calendar events;</t>
						<t>CONF - it holds user's settings for roaming.</t>
						<t>FILE - it holds normal folders and files;</t>
						<t>FILT - it holds the results of a filter defined by the user
							(there can be only
							one filter per folder);
						</t>
						<t>FOLD - it contains only subfolders;</t>
						<t>JRNL - it holds a journal;</t>
						<t>NOTE - it holds user's notes;</t>
						<t>MESG - it holds messages;</t>
						<t>TASK - it holds tasks;</t>
					</list>
				</t>
				<t>Note: If it requires parents that does not exist then the server
					will not create
					them for the client but it will return a 511 response code.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Make_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MAKE MESG /ARCHIVE/2010
S: 200 OK Folder created
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Make_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MAKE
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Make_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MAKE 1234
S: 511 ERROR Missing folder name
C: MAKE new 1234
S: 511 ERROR Unknown folder type
C: MAKE MESG /INBOX/1234
S: 511 ERROR The parent folder does not accept subfolders.
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command MOVE - authenticated state" toc="default">
				<t>Name: move entry</t>
				<t>Arguments: UID_source path_destination_folder</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the move was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - unknown uid or invalid destination folder.</t>
				<t>Description: Move an item into another folder (by UID). You
					cannot move
					from a folder having the tag NO-MOVE or into a folder with the tag
					READ-ONLY.
				</t>
				<t>Note: For moving a folder the client must use MOVF.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Move_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MOVE UIDx1234 ARCHIVE_FOLDER/TODAY
S: 200 OK MOVE completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Move_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MOVE
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Move_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MOVE UIDx1234 ARCHIVE_FOLDER/TODAY
S: 511 INVALID UID
C: MOVE MSGx1234 ARCHIVE_FOLDER/1970
S: 511 INVALID Destination
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command MOVF - authenticated state" toc="default">
				<t>Name: move folder</t>
				<t>Arguments: path_destination_folder</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the move was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid destination folder, destination is not an
					absolute path
					or destination does not exists.
				</t>
				<t>Description: Move the content of a folder into another folder.
				</t>
				<t>Note: In the destination folder are moved all non-folder entries
					found in the source.
					If the user needs to move the content of the source folder in another
					folder then he must
					to create first this new folder with the MAKE command and then use
					the MOVF command.
					If the user wants to move the folders found in the source then he
					must to do
					recursively MAKE, MOVF, and DELF for each subfolder.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Movf_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /INBOX
S: 200 Selected /INBOX
C: MOVF /ARCHIVE_FOLDER/TODAY
S: 200 OK MOVF completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Movf_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MOVF
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Movf_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MOVF MISSING
S: 511 INVALID destination
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command NAME - authenticated state" toc="default">
				<t>Name: rename folder</t>
				<t>Arguments: new_name</t>
				<t>Results: 200 510 511</t>
				<t>Result 200 - the rename was successful.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid new_name or trying to rename a reserved
					folder name.</t>
				<t>Description: Rename a folder. The currently selected folder
					remains selected
					even if the name was changed. A reserved folder cannot be renamed.
				</t>
				<t>Note: The new_name does not hold any path hierarchy.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Name_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /ARCHIVE/2001
S: 200 OK
C: NAME OLD-2001
S: 200 OK NAME completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Name_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: NAME
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Name_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /INBOX
S: 200 OK
C: NAME InBox
S: 511 ERROR The folder cannot be renamed (reserved name)
C: NAME /A/new-folder
S: 511 ERROR The argument must not be a path 
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command NOOP - authenticated state" toc="default">
				<t>Name: noop</t>
				<t>Arguments: none</t>
				<t>Result: 200</t>
				<t>Description: It does nothing (eventually announce what changes
					was done in current folder).</t>
				<t>
					Example:
					<figure align="center" anchor="Example_Noop">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: NOOP
S: 200 OK NOOP completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section
				title="Command PGET - authenticated, not-selected and presence state"
				toc="default">
				<t>Name: fetch presence information</t>
				<t>Arguments: USER user|BUSY user|FREE user|UID uid user</t>
				<t>Result: 110 200 510 511</t>
				<t>Result 110 - the client can send the list of timestamps and
					locations.</t>
				<t>Result 200 - the presence information for the user were found and
					returned or the uid was found and returned.</t>
				<t>Result 510 - unknown/unsupported command or not found uid.</t>
				<t>Result 511 - unknown/unsupported/missing arguments.</t>
				<t>Description: Fetch information about an user current availability,
					checks when an user is busy or free and returns the event entries.
				</t>
				<t>Note: If there is present an argument USER then the user wants to obtain
					information about the status of an other user or himself. If the server
					does not know how to obtain the information about this user then it returns
					an UNKNOWN as argument. Otherways can return a list with all set texts.
					After an HERE and AWAY is present when was this set, for an IDLE is the
					timestamp corresponding to the starting point of idle period. In answer can
					be present only one of these three. For a PSET FOR is returned an HERE for
					a PGET USER.
				</t>
				<t>Note: If there is present an argument BUSY or FREE then it is expected a list
					with timestamp periods and locations for which to be returned the list of busy,
					respectively free time frames. The end of list is marked by sending an empty line
					to server. Each list line has three fields: a start and inclusive end timestamp
					and a location. Between each argument is exactly only one space character (0x20).
					A timestamp has the format: YYYY-MM-DD hh:mm:ss and represents the time in UTC.
					The meaning of the timestamp fields could be found in
					<xref target="RFC3339">Date and Time on the Internet: Timestamps</xref>.
					A location is a string or the star character (*) for matching any location.
					The command returns a list with all available busy or free time frames for specified
					period and location. If there cannot be found any busy or free time frame then no
					list is returned, but only a 200 return code. The location name is compared which
					what was stored by the user, so there someone can write Vienna and someone else Wien,
					so the two of them cannot be found with a list having only one line and specifing
					a location. The answer is made of pairs of start and inclusive end
					timestamps followed by the UID correspondig to the event associated with this time
					period. In case there is no time period specified a 511 error is returned by server.
				</t>
				<t>Note: If there is present an argument UID then it is returned its associated content
				only if it is of type VEVENT.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Pget_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PGET USER user@example.com
S: .IDLE 2011-05-27 18:00:00 +1000
S: .STATUS Today I am doing HomeOffice
S: .AT Headquarter, 1010 Vienna, Austria
S: 200 OK USER found
C: PGET USER user2@example.com
S: .HERE 2011-05-27 18:00:00 +1000
S: .STATUS Today I am in Austria
S: .AT Headquarter, 1010 Vienna, Austria
S: 200 OK USER found
C: PGET USER user3@example.com
S: .AWAY 2011-05-27 18:00:00 +1000
S: 200 OK USER found
C: PGET USER user@domain.com
S: .UNKNOWN
S: 200 OK USER not found
C: PGET USER user@domain.com
S: .UNKNOWN
S: 200 OK USER not found

C: PGET BUSY user@domain.com
S: 110 Send the time periods and location ended with an empty line
C: 2012-01-01 09:00:00 2012-01-03 17:30:00 Vienna/AT
C: 2012-01-01 09:00:00 2012-01-03 17:30:00 Wien
C:
S: .2012-01-01 10:00:00 2012-01-02 23:59:59 UIDx1234
S: .2012-01-03 14:00:00 2012-01-03 16:30:00 UIDx1289
S: 200 OK 2 BUSY time periods found
C: PGET FREE user@domain.com
S: 110 Send the time periods and location ended with an empty line
C: 2012-01-01 09:00:00 2012-01-03 17:30:00 Vienna/AT
C: 2012-01-01 09:00:00 2012-01-03 17:30:00 Wien
C:
S: .2012-01-01 09:00:00 2012-01-01 09:59:59 UIDx234
S: .2012-01-03 00:00:00 2012-01-03 13:59:59 UIDx345
S: .2012-01-03 16:30:01 2012-01-03 17:30:00 UIDx456
S: 200 OK 3 FREE time periods found

C: PGET UID UIDx1234 user@domain.com
S: .<VEVENT>
S: .<UID>20110531T114600Z-123456@agap.at</UID>
S: .<DTSTAMP>2011-05-31T12:10:00Z</DTSTAMP>
S: .<DTSTART>2011-06-07T18:00:00Z</DTSTART>
S: .<DTEND>2011-06-07T24:00:00Z</DTEND>
S: .<SUMMARY>AGAP RFC Party</SUMMARY>
S: .<DESCRIPTION>Celebration of a new revision!
S: .0.4</DESCRIPTION>
S: .<ALARM>20110607T170000Z-20110531T114600Z-123456@agap.at</ALARM>
S: .</VEVENT>
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pget_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PGET USER user@domain.com
S: 510 Presence is not supported
C: PGET UID uid user
S: 510 Uid not found
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pget_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PGET
S: 511 Missing argument
C: PGET WRONG
S: 511 UNKNOWN argument WRONG
C: PGET USER
S: 511 Missing argument
C: PGET BUSY user
C:
S: 511 There must be defined at least one time period and location
C: PGET BUSY user
C: yyyy-01-01 09:00:00 2012-01-03 17:30:00 * 
C:
S: 511 Invalid time period definition
C: PGET BUSY user
C: yyyy-01-01 09:00:00 2012-01-03 17:30:00 
C:
S: 511 Missing location
C: PGET UID user
S: 511 Missing uid
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command PSET - authenticated and not-selected state"
				toc="default">
				<t>Name: announce presence</t>
				<t>Arguments: HERE|AWAY|FOR number unit_of_time|IDLE number
					unit_of_time|STATUS text|AT text</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the presence of the user was updated or requested
					information returned.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - unknown/unsupported/missing arguments.</t>
				<t>Description: Announce that the logged user is still online,
					eventually
					since when is idle. A QUIT command or disconnection means that the user
					is no longer online. In state PRESENCE only the "USER user"
					arguments are
					accepted.
				</t>
				<t>If there is present an argument HERE then that means the user is
					no
					longer idle. As there is no information for how long this status is
					valid,
					then it will remain valid until comes a new command which change it.
				</t>
				<t>If there is present an argument AWAY then that means the user is
					no
					longer connected. As there is no information for how long this status is
					valid,
					then it will remain valid until comes a new command which change it.
				</t>
				<t>If there is present an argument FOR then that means the user is
					suppose
					to be considered present for the given amount of time. The client is
					expected to
					send its updated status in this period. If comes no command to change
					the state
					in the specified time, then after this period the presence will be
					reported as unknown.
					The arguments are as by IDLE.
				</t>
				<t>If there is present an argument IDLE then that means the user is
					idle
					and the arguments must be: IDLE number unit_of_time. The number must
					be
					a positive number and the unit_of_time must be one of the following:
					sec, min, hour, day, year. As there is no information for how long
					this status
					is valid, then it will remain valid until comes a new command which
					change it.
				</t>
				<t>If there is present an argument STATUS then the user want to
					change
					the text that is associated with its presence online. After STATUS can
					follow any text. The text ends to the end of line. If there is no
					text
					then any previous text is deleted and no text is displayed as status
					text.
				</t>
				<t>If there is present an argument AT then that user want to change
					the text that is associated with its present location. After AT can
					follow any text. The text ends to the end of line. If there is no
					text
					then any previous text is deleted and no text is displayed as location
					text.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Pset_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PSET HERE
S: 200 OK You are online and not idle
C: PSET AWAY
S: 200 OK You are no more online
C: PSET FOR 5 min
S: 200 OK You are now online. Expecting an update in 5 minutes.
C: PSET IDLE 5 min
S: 200 OK You are idle since 5 minutes
C: PSET STATUS Today I am doing HomeOffice
S: 200 OK You changed your status text
C: PSET AT Headquarter, 1010 Vienna, Austria
S: 200 OK You changed your location text
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pset_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PSET HERE
S: 510 Unknown command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Pset_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PSET
S: 511 Missing argument
C: PSET WRONG
S: 511 UNKNOWN argument WRONG
C: PSET AT
S: 511 Missing argument
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command RETC - authenticated state (MESG and FILE folder types)"
				toc="default">
				<t>Name: retrieve</t>
				<t>Argument: UID</t>
				<t>Results: 200 510 511</t>
				<t>Result 200 - the message was found.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid UID or folder is not of type MESG or FILE.</t>
				<t>Description: Fetch from server information about the message or file
					entry with the given UID.
					Each line of answer is prefixed with a dot that it is not part of
					the returned object.
					RETC returns for an attachment its name and size in bytes instead of
					its content as RETR.
					RETC returns for an file its size in bytes instead of its content as RETR.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Retc_200_mesg">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETC UIDx1234
S: .<MESSAGE><HEADER>...</HEADER>
S: .<ATTACHMENT-1>
S: .<NAME>cid:A12</NAME>
S: .<SIZE>123456</SIZE>
S: .</ATTACHMENT-1>
S: .</MESSAGE>
S: 200 OK RETC completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Retc_200_file">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETC UIDx1234
S: .<FILE>
S: .<NAME>file-test.txt</NAME>
S: .<SIZE>123456</SIZE>
S: .</MESSAGE>
S: 200 OK RETC completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Retc_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETC
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Retc_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETC WrongUID
S: 511 INVALID UID
C: RETC UIDx1234
S: 511 RETC is allowed only for MESG or FILE folders
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command RETR - authenticated state" toc="default">
				<t>Name: retrieve</t>
				<t>Arguments for a FILT folder: none</t>
				<t>Arguments for other types: UID part?</t>
				<t>Results: 200 510 511</t>
				<t>Result 200 - the item was found or filter content was delivered.
				</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid UID or part name.</t>
				<t>Description: Fetch from server the item with the given UID. For
					a filter folder, it must be called without an UID and it returns the
					content of the filter.
					Each line of answer is prefixed with a dot that it is not part of the
					returned object.
				</t>
				<t>Part: It is a PATH as it is returned by RETR or RETC and must point to
					a not binary end leaf. It contains only tag names separated with /. 
					Example: /MESSAGE/HEADER/subject, /MESSAGE/HEADER/received, 
					/MESSAGE/HTML, /MESSAGE/ATTACHMENT-1/BODY.
					For an entry in the header with a multivalue are returned each value
					on its own line.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Retr_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETR UIDx1234
S: .<MESSAGE><HEADER>...</HEADER><TEXT>...</TEXT></MESSAGE>
S: 200 OK RETR completed
C: RETR UIDx1234 /MESSAGE/HEADER/subject
S: .Message's subject
S: 200 OK RETR completed
C: RETR UIDx1234 /MESSAGE/HEADER/received
S: .from s0001.srv.example.com [10.11.12.13] by mx.example.com
S: . (Postfix) with ESMTP id 01234567890 for <user@example.com>;
S: . Thu, 19 Nov 2009 01\:02\:03 +0100 (CET)
S: . by userpc (192.168.192.168) id 20091119010204A;
S: . Thu, 19 Nov 2009 01\:02\:04 +0100 (CET)
S: 200 OK RETR completed
C: RETR
S: .<FILTER>
S: .<FOLDERS><FOLDER>/Spam</FOLDER></FOLDERS>
S: .<RULES></RULES>
S: .</FILTER>
S: 200 OK RETR completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Retr_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETR
S: 510 UNKNOWN command (only FILT folders do not needs arguments)
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Retr_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: RETR WrongUID
S: 511 INVALID UID
C: RETR UIDx1234 ABC
S: 511 UNKNOWN part name
C: RETR UIDx1234
S: 511 RETR with UID is not allowed for a FILT folder
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command SFTG - authenticated state" toc="default">
				<t>Name: set the tags of currently selected folder</t>
				<t>Arguments: tag_list</t>
				<t>Result: 200 210 410 510 511 541</t>
				<t>Result 200 - all tags for current folder were successful set.</t>
				<t>Result 210 - not all tags for current folder were successful set.
				</t>
				<t>Result 410 - for the moment the flags cannot be saved.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid tag list.</t>
				<t>Result 541 - the tag FIX-TAGS does not allow to change the
					already set tags.</t>
				<t>Description: Set or delete tags of currently selected folder.</t>
				<t>Note: Setting the tag FIX-TAGS makes the tags of currently
					selected folder unchangable
					after this command. The tags can only be changed on the server.
				</t>
				<t>Note: A return code 210 is returned even when no flag could be
					set if the tag list
					is correct.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Sftg_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SFTG + SYNC
S: 200 OK SFTG completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Sftg_210">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SFTG - SYNC TEST
S: 210 OK SFTG did not removed TEST
C: SFTG - TEST
S: 210 OK SFTG did not removed TEST
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Sftg_410">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SFTG + SYNC
S: 410 Please retry to set them later
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Sftg_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SFTG
S: 510 UNKNOWN command
C: SFTG + SYNC
S: 510 Please select a folder first
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Sftg_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SFTG SYNC
S: 511 INVALID tag list
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_Sftg_541">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SFTG + SYNC
S: 541 Tag FIX-TAGS prevents the change of tags
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command SLCT - authenticated and not-selected state"
				toc="default">
				<t>Name: select a folder</t>
				<t>Argument: path</t>
				<t>Result: 200 510 511</t>
				<t>Result 200 - the folder was successfully selected.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - unknown path or '/'.</t>
				<t>Description: Select a folder. If the selection was not successful
					then
					no folder remains selected and the server switch in the 'Not-selected
					State'.
					The user cannot select the root (/) folder.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Slct_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /INBOX
S: 200 OK Folder selected
C: SLCT ARCHIVE/2000
S: 200 OK Folder selected
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Slct_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Slct_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT 1234
S: 511 INVALID folder
C: SLCT /
S: 511 You cannot select /
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command STAG - authenticated state" toc="default">
				<t>Name: set tags of entries</t>
				<t>Arguments: UID tag_list</t>
				<t>Result: 200 410 510 511</t>
				<t>Result 200 - the tags for UID were successful set.</t>
				<t>Result 410 - for the moment the flags cannot be saved.</t>
				<t>Result 510 - unknown/unsupported command.</t>
				<t>Result 511 - invalid UID.</t>
				<t>Description: Set or delete tags associated to an item.</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Stag_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG UIDx1000 + SEEN SYNC DAY=2012
S: 200 OK STAG completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stag_410">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG UIDx1000 + SEEN SYNC DAY=2012
S: 410 Please retry to set them later
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stag_510">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG
S: 510 UNKNOWN command
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stag_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG -1
S: 511 INVALID UID
C: STAG 0x1 + SEEN
S: 511 UID not found
C: STAG UIDx1234 SEEN
S: 511 INVALID tag list (missing operator)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command STAT - authenticated state" toc="default">
				<t>Name: status</t>
				<t>Arguments: none</t>
				<t>Result: 200 512</t>
				<t>Result 200 - the status of the folder was successfully delivered.
				</t>
				<t>Result 512 - no folder is selected.</t>
				<t>Description: Return the absolute path of currently selected
					folder (PATH),
					its type (TYPE), its FCID, its ECID (only for folders with can hold
					items), the tags (TAGS)
					and eventually additional information associated with this type of
					folder. A change in a folder
					means that its structure was changed or there was a change of its items
					(like new messages,
					an event was canceled and automatically removed from a calender).
				</t>
				<t>
					Additional information:
					<list style="symbols">
						<t>ADDR - TOTAL;</t>
						<t>CALE - TOTAL;</t>
						<t>CONF - TOTAL.</t>
						<t>FILE - TOTAL;</t>
						<t>FILT - TOTAL;</t>
						<t>FOLD - none;</t>
						<t>JRNL - TOTAL;</t>
						<t>MESG - TOTAL and NEW;</t>
						<t>NOTE - TOTAL;</t>
						<t>TASK - TOTAL;</t>
					</list>
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Stat_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAT
S: .PATH /INBOX
S: .TYPE MESG
S: .FCID 1
S: .TAGS RESERVED
S: .TOTAL 10
S: .NEW 2
S: 200 OK Folder status displayed
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stat_512">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAT
S: 512 ERROR First select a folder
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command STOR - authenticated state" toc="default">
				<t>Name: store</t>
				<t>Arguments: none</t>
				<t>Result: 110 200 410 511</t>
				<t>Result 110 - the client can send the item.</t>
				<t>Result 200 - the item was successfully stored or there was no
					content sent by the client.</t>
				<t>Result 410 - if the item cannot be stored.</t>
				<t>Result 511 - if the data is not a valid XML or its schema does
					not correspond to the type of the destination folder.
				</t>
				<t>Description: Store a new item/filter into a folder.
					If it is written a new filter into a FILT folder, then the previous
					filter is deleted.
					If the new filter has an invalid XML structure or cannot be saved
					then the folder
					remains with the old filter (if any). The server can send a 410 or 511
					respons before the
					empty line is send, so the client must check after each sended line of
					content if
					the server had rejected the content.
				</t>
				<t>Note: Do not send a message content using CDATA as it can hold
					empty lines
					and an empty line means for the server the end of the message to be
					stored.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Stor_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STOR
S: 110 Send the message ended with an empty line
C: <MESSAGE><HEADER>...</HEADER><TEXT>...</TEXT></MESSAGE>
C:
S: 200 OK Message stored (UID is UIDx1234)
C: STOR
S: 110 Send the message ended with an empty line
C:
S: 200 OK Message not stored as it was empty
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stor_410">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STOR
S: 110 Send the message ended with an empty line
C: <MESSAGE><HEADER>...</HEADER><HTML>...</HTML></MESSAGE>
C:
S: 410 Cannot store it, not enough space
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Stor_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STOR
S: 110 Send the message ended with an empty line
C: msg
C:
S: 511 Cannot store it, the message has an incorrect format
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Command SUID - authenticated state" toc="default">
				<t>Name: last UID returned by STOR</t>
				<t>Arguments: none</t>
				<t>Results: 200 511</t>
				<t>Result 200 - the command was accepted and eventually an UID was
					returned.</t>
				<t>Result 511 - the command is not accepted in the actual state.</t>
				<t>Description: This command returns the last UID generated by a
					STOR command in the
					currently selected folder since it was last time selected. Selecting an
					other folder
					or leaving the actual state makes to forget last generated UID. By
					selecting a folder,
					storing an item and then reselecting the same folder makes the UID to be
					forgot. If there
					is no UID stored then is returned a 200 without any line holding an
					UID. A failling STOR
					also makes no UID to be remembered.
				</t>
				<t>
					Examples:
					<figure align="center" anchor="Example_Suid_200">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /Mbox
S: 200 Selected /Mbox
C: SUID
S: 200 OK There was no STOR since last SLCT
C: STOR
...
S: 200 OK STOR completed with UID UIDx1234
C: SUID
S: .UIDx1234
S: 200 OK SUID completed; found UIDx1234
C: SLCT /Mbox
S: 200 Selected /Mbox
C: SUID
S: 200 OK There was no STOR since last SLCT
C: STOR
...
S: 511 ERROR STOR ompleted with error
C: SUID
S: 200 OK There was no successfull STOR since last SLCT
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_Suid_511">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SUID
S: 511 ERROR SUID is not accepted in this state
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
		</section>
		<section title="Responses" toc="default">
			<section title="Semantic and Syntax" toc="default">
				<t>The Response-Code element is a 3-digit integer result code of the
					attempt to understand and satisfy the request. These codes are
					fully defined
					in the following section.
				</t>
				<t>After the Response-Code, can follow a 0x20 character and then a
					Reason-Phrase intended to give a short textual description of the
					returned
					code. The Response-Code is intended for automatic use. The Reason-Phrase
					is
					intended for humane persons that debug the connection.
				</t>
				<t>
					The first digit of the Response-Code defines the class of
					response. The last two digits do not have any categorization role. There are
					4
					values for the first digit:
					<list style="symbols">
						<t>1xx: Informational - Server waits for request continuation
							or send unrequested data;
						</t>
						<t>2xx: Success - The action was successfully executed;</t>
						<t>4xx: Server Error - The server failed to perform the request,
							retry later;</t>
						<t>5xx: Server Error - The server failed to perform the request,
							permanent error;</t>
					</list>
				</t>
				<t>There are commands that return a multi-line response. These are:
					CAPA, FIND, GTAG, LIST, RETR, and STAT. In this cases, the response
					code
					is at the beginning of the last line of the response. All other lines
					start with a dot (.).
				</t>
			</section>
			<section title="1xx Informational" anchor="respons_code_1xx"
				toc="default">
				<section title="100 Reserved" anchor="respons_code_100" toc="default">
					<t>Reserved.</t>
				</section>
				<section title="110 Continue" anchor="respons_code_110" toc="default">
					<t>The client SHOULD continue sending the rest of this
						request. This response informs the client that the server accepted the
						initial
						part of the request and it is waiting for the next part of the
						request. The
						server sends a final response after the request has been completely
						received
						and processed.
					</t>
				</section>
			</section>
			<section title="2xx Success" anchor="respons_code_2xx" toc="default">
				<section title="200 OK" anchor="respons_code_200" toc="default">
					<t>The request was successfully processed.</t>
				</section>
				<section title="210 Partial OK" anchor="respons_code_210"
					toc="default">
					<t>The request was successfully applied for at least one item but
						not
						for all requested items. (see FCPY, FDEL, FMOV, and FTAG)
					</t>
				</section>
				<section title="220 Nothing to do" anchor="respons_code_220"
					toc="default">
					<t>The request was successful, but none of the arguments were
						found.
						(see DACl, DPBL)
					</t>
				</section>
			</section>
			<section title="4xx Temporary Server Error" anchor="respons_code_4xx"
				toc="default">
				<section title="400 Reserved" anchor="respons_code_400" toc="default">
					<t>Reserved.</t>
				</section>
				<section title="401 Internal Error" anchor="respons_code_401"
					toc="default">
					<t>The request could not be processed because it was an internal
						error
						(ex.: something is wrong configured).
					</t>
				</section>
				<section title="410 Retry later" anchor="respons_code_410"
					toc="default">
					<t>The operation must to be retried later. This return code is used
						when the data
						cannot be stored because there was an error (ex.: not enough space on
						disk).
					</t>
				</section>
			</section>
			<section title="5xx Permanent Server Error" anchor="respons_code_5xx"
				toc="default">
				<section title="500 Reserved" anchor="respons_code_500" toc="default">
					<t>Reserved.</t>
				</section>
				<section title="510 Unknown Command" anchor="respons_code_510"
					toc="default">
					<t>The request could not be processed because this command is
						unknown or its syntax
						is wrong.
					</t>
				</section>
				<section title="511 Invalid Parameter Format" anchor="respons_code_511"
					toc="default">
					<t>The request could not be processed because the command has an
						invalid parameter.</t>
					<t>This answer can be returned even in the case when more than one
						0x20 character were
						present between command and its arguments or between arguments.
					</t>
				</section>
				<section title="512 Out of order" anchor="respons_code_512"
					toc="default">
					<t>This command has a valid syntax but must to be send after other
						command required
						by the logic of the server. (Ex.: PASS after USER in
						Pre-authenticated State.)
					</t>
				</section>
				<section title="521 Not found" anchor="respons_code_521"
					toc="default">
					<t>This command has a valid syntax but the searched argument does
						not exist
						or cannot be accessed. (Ex.: DATT did not found the attachment to
						delete.)
					</t>
				</section>
				<section title="531 Banned" anchor="respons_code_531" toc="default">
					<t>The client is not allowed to interact with the server. (Ex.: the
						client's
						IP is blacklisted.)
					</t>
				</section>
				<section title="541 Not enough rights" anchor="respons_code_541"
					toc="default">
					<t>The client is not allowed to do the command because of
						insufficient rights.
						If it had enough rights then the command would have been successful.
						(Ex.: the client cannot store a message with FSTO.)
					</t>
				</section>
			</section>
		</section>
		<section title="All Possible Response Codes for All Commands"
			toc="default">
			<section title="Not-authenticated State" toc="default">
				<t>The Welcome Message: 200 401 410 531</t>
				<t>AUTH: 510 511</t>
				<t>AUTH mechanism: 200 511</t>
				<t>CAPA: 200</t>
				<t>QUIT: 200</t>
				<t>SGZP: 200 510</t>
				<t>STLS: 200 510</t>
				<t>other: 510</t>
			</section>
			<section title="Pre-authenticating State (PLAIN method)" toc="default">
				<t>PASS: 510 511 512</t>
				<t>PASS password: 200 511 512</t>
				<t>QUIT: 200</t>
				<t>USER: 510 511</t>
				<t>USER account: 200 511</t>
				<t>other: 510</t>
			</section>
			<section title="Pre-authenticating State (MD5 and SHA1 methods)"
				toc="default">
				<t>HASH: 510 511 512</t>
				<t>HASH hashcode: 200 511 512</t>
				<t>QUIT: 200</t>
				<t>USER: 510 511</t>
				<t>USER account: 200 511</t>
				<t>other: 510</t>
			</section>
			<section title="Authenticated State" toc="default">
				<t>AACL: 510</t>
				<t>AACL arguments: 200 511</t>
				<t>APBL: 200 410</t>
				<t>CHNG: 200 510</t>
				<t>CHNG arguments: 200 511</t>
				<t>COPY: 510 511</t>
				<t>COPY arguments: 200 511</t>
				<t>CPYF: 510 511</t>
				<t>CPYF arguments: 200 511</t>
				<t>DACL: 510</t>
				<t>DACL arguments: 200 220 511</t>
				<t>DATT: 510 511</t>
				<t>DATT arguments: 200 511 521</t>
				<t>DPBL: 200 220 410</t>
				<t>DELE: 510 511</t>
				<t>DELE arguments: 200 511</t>
				<t>DELF: 510 511</t>
				<t>DELF arguments: 200 511</t>
				<t>EXIT: 200</t>
				<t>FCNT: 110</t>
				<t>FCNT arguments: 200 220 511</t>
				<t>FCPY: 110</t>
				<t>FCPY arguments: 200 210 220 511</t>
				<t>FDEL: 110</t>
				<t>FDEL arguments: 200 210 220 511</t>
				<t>FIND: 110</t>
				<t>FIND arguments: 200 220 511</t>
				<t>FMOV: 110</t>
				<t>FMOV arguments: 200 210 511</t>
				<t>FRTR: 110</t>
				<t>FRTR arguments: 200 220 511</t>
				<t>FTAG: 510</t>
				<t>FTAG arguments: 110 200 210 220 511</t>
				<t>GACL: 200</t>
				<t>GFTG: 200</t>
				<t>GPBL: 200</t>
				<t>GTAG: 510</t>
				<t>GTAG arguments: 200 511</t>
				<t>LIST: 200 220</t>
				<t>LIST arguments: 200 220 511</t>
				<t>LSTX: 200 220</t>
				<t>LSTX arguments: 200 220 511</t>
				<t>MAKE: 510 511</t>
				<t>MAKE arguments: 200 511</t>
				<t>MOVE: 510 511</t>
				<t>MOVE arguments: 200 511</t>
				<t>MOVF: 510 511</t>
				<t>MOVF arguments: 200 511</t>
				<t>NAME: 510 511</t>
				<t>NAME arguments: 200 511</t>
				<t>NOOP: 200</t>
				<t>PGET: 510 511</t>
				<t>PGET arguments: 110 200 510 511</t>
				<t>PSET: 510 511</t>
				<t>PSET arguments: 200 510 511</t>
				<t>QUIT: 200</t>
				<t>RETC: 510</t>
				<t>RETC arguments: 200 511</t>
				<t>RETR: 510 511</t>
				<t>RETR arguments: 200 511</t>
				<t>SLCT: 510 511</t>
				<t>SLCT arguments: 200 511</t>
				<t>SFTG: 510 511</t>
				<t>SFTG arguments: 200 410 511 541</t>
				<t>STAG: 510 511</t>
				<t>STAG arguments: 200 410 511</t>
				<t>STAT: 200 512</t>
				<t>STOR: 110 200 410 511</t>
				<t>SUID: 200 511</t>
				<t>other: 510</t>
			</section>
			<section title="Not-selected State" toc="default">
				<t>CHNG: 200 510</t>
				<t>CHNG arguments: 200 511</t>
				<t>GPBL: 200</t>
				<t>LIST: 200</t>
				<t>LIST arguments: 200 511</t>
				<t>PSET: 510 511</t>
				<t>PSET arguments: 200 510 511</t>
				<t>SLCT: 510 511</t>
				<t>SLCT arguments: 200 511</t>
				<t>other: 510</t>
			</section>
			<section title="Presence State" toc="default">
				<t>PGET: 510 511</t>
				<t>PGET arguments: 200 510 511</t>
				<t>QUIT: 200</t>
				<t>other: 510</t>
			</section>
			<section title="Storing State" toc="default">
				<t>FSTO: 510</t>
				<t>FSTO arguments: 110 200 410 510 511 541</t>
				<t>QUIT: 200</t>
				<t>other: 510</t>
			</section>
		</section>
		<section title="Example of Conversations" toc="default">
			<section title="Successful connection and authentication"
				toc="default">
				<t>
					<figure align="center" anchor="Example_1_1">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 200 Welcome
C: AUTH PLAIN
S: 200 OK Send USER
C: USER account
S: 200 OK Send PASS
C: PASS password
S: 200 OK Authenticated
C: STAT
S: .PATH /INBOX
S: .TYPE MESG
S: .TAGS RESERVED
S: .TOTAL 10
S: .NEW 2
S: 200 OK Folder status displayed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
				<t>
					<figure align="center" anchor="Example_1_2">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 200 Welcome
C: AUTH MD5
S: .Use this as prefix, please!
S: 200 OK Send USER
C: USER account
S: 200 OK Send HASH
C: HASH 79054025255fb1a26e4bc422aef54eb1
S: 200 OK Authenticated
C: STAT
S: .PATH /INBOX
S: .TYPE MESG
S: .TAGS RESERVED
S: .TOTAL 10
S: .NEW 2
S: 200 OK Folder status displayed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Successful connection but unsuccessful authentication"
				toc="default">
				<t>
					<figure align="center" anchor="Example_2">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 200 Welcome
C: AUTH PLAIN
S: 200 OK Send USER
C: USER account
S: 200 OK Send PASS
C: PASS password
S: 511 WRONG user/password pair
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Connection refused" toc="default">
				<t>
					<figure align="center" anchor="Example_3_1">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 531 Your IP is blacklisted
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_3_2">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 410 Too many connections, please retry later
            ]]></artwork>
						<postamble></postamble>
					</figure>
					<figure align="center" anchor="Example_3_3">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
S: 401 Internal error, the server has an error in its configuration
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Find what folders are available with messages"
				toc="default">
				<t>
					<figure align="center" anchor="Example_4">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LIST /*
S: .MESG /INBOX
S: .MESG /TRASH
S: .CALE /CALENDAR
S: 200 OK LIST completed (3 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Find all entries available in a folder" toc="default">
				<t>
					<figure align="center" anchor="Example_5">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /INBOX
S: 200 OK Folder selected
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C:
S: .UIDx1230
S: .UIDx1231
S: .UIDx1234
S: .UIDx1235
S: .UIDx2340
S: 200 OK FIND completed (5 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Retrieve a message" toc="default">
				<t>
					<figure align="center" anchor="Example_6">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /INBOX
S: 200 OK Folder selected
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C: NEW IS /HEADER/subject = 'Newsletter from Example.com'
C:
S: .UIDx1234
S: .UIDx1235
S: .UIDx2340
S: 200 OK FIND completed (3 matches)
C: RETR UIDx1234
S: .<MESSAGE><HEADER>
S: .<from>HCCP&lt;news@example.com&gt;</from>
S: .<to>newsletter@localhost.localdomain</to>
S: .<subject>Newsletter from Example.com</subject>
S: .</HEADER>
S: .<TEXT>This is your weekly newsletter.</TEXT>
S: .</MESSAGE>
S: 200 OK RETR completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Retrieve a contact" toc="default">
				<t>
					<figure align="center" anchor="Example_7">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /CONTACT
S: 200 OK Folder selected
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C: OR REGEX /VCARD/FN = 'RADU.*?'
C:    REGEX /VCARD/FN = '.*? Iulian'
C:
S: .CONx0001
S: 200 OK FIND completed (1 match)
C: RETR CONx0001
S: .<VCARD>
S: .   <VERSION>3.0</VERSION>
S: .   <FN>Iulian Radu</FN>
S: .   <N>Radu;Iulian;;Dipl.Ing.;</N>
S: .   <ORG>Example Com;European Division</ORG>
S: .   <EMAIL TYPE="internet,home">iulian.radu@gmx.at</EMAIL>
S: .   <TZ>+01:00</TZ>
S: .   <REV>2011-05-31T18:46:00Z</REV>
S: .</VCARD>
S: 200 OK RETR completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Retrieve an event" toc="default">
				<t>
					<figure align="center" anchor="Example_8">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /CALENDAR
S: 200 OK Folder selected
C: FIND
S: 110 OK SEND filter definition (end it with an empty line)
C: IS /VEVENT/SUMMARY = '*RFC*'
C:
S: .EVNx0001
S: 200 OK FIND completed (1 match)
C: RETR EVNx0001
S: .<VEVENT>
S: .    <UID>20110531T114600Z-123456@agap.at</UID>
S: .    <DTSTAMP>2011-05-31T12:10:00Z</DTSTAMP>
S: .    <DTSTART>2011-06-07T18:00:00Z</DTSTART>
S: .    <DTEND>2011-06-07T24:00:00Z</DTEND>
S: .    <SUMMARY>AGAP RFC Party</SUMMARY>
S: .    <DESCRIPTION>Celebration of a new revision!
S: .0.4</DESCRIPTION>
S: .    <ALARM>
S: .       20110607T170000Z-20110531T114600Z-123456@agap.at</ALARM>
S: .</VEVENT>
S: 200 OK RETR completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Store a message" toc="default">
				<t>
					<figure align="center" anchor="Example_9">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /OUTBOX
S: 200 OK Folder selected
C: STOR
S: 110 Send the message ended with an empty line
C: <MESSAGE><HEADER>
C: <from>HCCP&lt;news@example.com&gt;</from>
C: <to>newsletter@localhost.localdomain</to>
C: <subject>HCCP Newsletter</subject>
C: </HEADER>
C: <TEXT>This is your weekly newsletter.</TEXT>
C: </MESSAGE>
C:
S: 200 OK Message stored (UID is UIDx1234)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Store a contact" toc="default">
				<t>
					<figure align="center" anchor="Example_10">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /CONTACT
S: 200 OK Folder selected
C: STOR
S: 110 Send the contact info ended with an empty line
C: <VCARD>
C:    <VERSION>3.0</VERSION>
C:    <FN>Iulian Radu</FN>
C:    <N>Radu;Iulian;;Dipl.Ing.;</N>
C:    <ORG>Example Com;European Division</ORG>
C:    <EMAIl TYPE="internet,home">iulian.radu@gmx.at</EMAIL>
C:    <TZ>+01:00</TZ>
C:    <REV>2011-05-31T18:46:00Z</REV>
C: </VCARD>
C:
S: 200 OK Contact stored (UID is UIDx1234)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Store an event" toc="default">
				<t>
					<figure align="center" anchor="Example_11">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: SLCT /CALENDAR
S: 200 OK Folder selected
C: STOR
S: 110 Send the contact info ended with an empty line
C: <VEVENT>
C:     <UID>20110531T114600Z-123456@agap.at</UID>
C:     <DTSTAMP>2011-05-31T12:10:00Z</DTSTAMP>
C:     <DTSTART>2011-06-07T18:00:00Z</DTSTART>
C:     <DTEND>2011-06-07T24:00:00Z</DTEND>
C:     <SUMMARY>AGAP RFC Party</SUMMARY>
C:     <DESCRIPTION>Celebration of a new revision!
C: 0.4</DESCRIPTION>
C:     <ALARM>
C:        20110607T170000Z-20110531T114600Z-123456@agap.at</ALARM>
C: </VEVENT>
C:
S: 200 OK Event stored (UID is UIDx1234)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Mark messages as SPAM an move them in a new folder"
				toc="default">
				<t>
					<figure align="center" anchor="Example_12">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG UIDx1000 + SPAM
S: 200 OK STAG completed
C: MAKE MESG /Archive-SPAM
S: 200 OK Folder created
C: FMOV /Archive-SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: TAG SPAM
C:
S: 200 OK FMOV completed (19 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section
				title="Create a filter folder, find the matching entries of the filter and read its filter definition"
				toc="default">
				<t>
					<figure align="center" anchor="Example_13">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MAKE FILT /New-messages
S: 200 OK Folder created
C: STOR
S: 110 Send the filter content ended with an empty line
C: <FILTER>
C: <FOLDERS><FOLDER>/INBOX</FOLDER></FOLDERS>
C: <RULES>
C: <AND><NOT><TAG>SEEN</TAG></NOT></AND>
C: </RULES>
C: </FILTER>
C:
S: 200 OK Filter stored
C: SLCT /New-messages
S: 200 OK Folder selected
C: FIND
S: .UIDx1234 /INBOX
S: .UIDx1234 /Trash
S: .UIDx1235 /Trash
S: 200 OK FIND completed (3 matches)
C: RETR
S: .<FILTER>
S: .<FOLDERS><FOLDER>/INBOX</FOLDER></FOLDERS>
S: .<RULES><NOT><TAG>SEEN</TAG></NOT></RULES>
S: .</FILTER>
S: 200 OK RETR completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Create a folder and rename it" toc="default">
				<t>
					<figure align="center" anchor="Example_14">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: MAKE MESG /My/NewFolder
S: 200 OK Folder created
C: NOOP
S: 200 NOOP OK
C: SLCT /My/NewFolder
S: 200 OK Selected /My/NewFolder
C: NAME AFolder
S: 200 OK /My/NewFolder --> /My/AFolder
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Find the status for a folder" toc="default">
				<t>
					<figure align="center" anchor="Example_15">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: LIST /*
S: .MESG /INBOX
S: .MESG /TRASH
S: .CALE /CALENDAR
S: 200 OK LIST completed (3 matches)
C: SLCT /INBOX
S: 200 OK SELECT completed
C: STAT
S: .PATH /INBOX
S: .TYPE MESG
S: .TAGS RESERVED
S: .TOTAL 10
S: .NEW 5
S: 200 OK Folder status displayed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Set and check the tags of a message" toc="default">
				<t>
					<figure align="center" anchor="Example_16">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: STAG UIDx1000 + SEEN
S: 200 OK STAG completed
C: GTAG UIDx1000
S: .SPAM
S: .FLAG=RED
S: .SEEN
S: 200 OK GTAG completed
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Find messages that can be SPAM and delete them"
				toc="default">
				<t>
					<figure align="center" anchor="Example_17">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: FTAG + SPAM
S: 110 OK SEND filter definition (end it with an empty line)
C: REGEX header/subject = '[Vv][i1]agra'
C:
S: 200 OK FTAG completed (10 matches)
C: FDEL
S: 110 OK SEND filter definition (end it with an empty line)
C: UID 00000001:00001000 AND TAG SPAM
C:
S: 200 OK FDEL completed (10 matches)
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
			<section title="Connect for a short period" toc="default">
				<t>
					<figure align="center" anchor="Example_18">
						<preamble></preamble>
						<artwork align="left"><![CDATA[
C: PSET FOR 15 min
S: 200 Nice to se you back
C: PSET AT At Home
S: 200 So you are there
C: PSET STATUS Today I am doing HomeOffice
S: 200 So kind to share your thoughts with us
C: PGET USER coworker
S: .AWAY 2011-05-27 18:00:00 +1000
S: 200 Sorry, your buddy is not here
C: PSET AWAY
S: 200 Oh, so soon
            ]]></artwork>
						<postamble></postamble>
					</figure>
				</t>
			</section>
		</section>
	</middle>
	<!-- ***** BACK MATTER ***** -->
	<back>
		<!-- References split into informative and normative -->
		<references title="Normative References">
      &RFC2119;
      &RFC2629;
      &RFC3552;
		</references>
		<references title="Informative References">
			<!-- Here we use entities that we defined at the beginning. -->
      &RFC2821;
      &RFC3921;
      &RFC5545;
      &RFC3629;
      &RFC4648;
      &RFC1952;
      &RFC2426;
      &RFC3339;
      &RFC2782;
      &ISO.8601.1988;
		</references>
	</back>
</rfc>
