<?xml version="1.0" encoding="UTF-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629xslt/rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!-- Normative References -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"> <!-- MUST, SHOULD, MAY -->
<!ENTITY RFC3261 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml"> <!-- SIP -->
<!ENTITY RFC3263 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3263.xml"> <!-- Locating SIP Servers -->
<!ENTITY RFC3403 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3403.xml"> <!-- NAPTR -->
<!ENTITY RFC5234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml"> <!-- ABNF -->
<!ENTITY RFC6455 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6455.xml"> <!-- WebSocket -->
<!-- Informative References -->
<!ENTITY RFC2606 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2606.xml"> <!-- Reserved Top Level DNS Names -->
<!ENTITY RFC2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml"> <!-- HTTP -->
<!ENTITY RFC2617 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml"> <!-- HTTP Digest -->
<!ENTITY RFC3327 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3327.xml"> <!-- Path -->
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml"> <!-- URI -->
<!ENTITY RFC4168 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4168.xml"> <!-- SIP STCP -->
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml"> <!-- TLS -->
<!ENTITY RFC5626 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5626.xml"> <!-- Outbound -->
<!ENTITY RFC5627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5627.xml"> <!-- GRUU -->
<!ENTITY RFC6223 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6223.xml"> <!-- SUpport for Keep-Alive -->
<!ENTITY RFC6265 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6265.xml"> <!-- HTTP Cookie -->
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc tocappendix="yes" ?>

<rfc category="std" docName="draft-ietf-sipcore-sip-websocket-01" ipr="trust200902">
<!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>

    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->
    <title abbrev="WebSocket as a Transport for SIP">The WebSocket Protocol as a Transport for the Session Initiation Protocol (SIP)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Inaki Baz Castillo" initials="I.B.C." surname="Baz Castillo">
      <organization>Consultant</organization>
      <address>
        <postal>
          <street></street>
          <city>Barakaldo</city>
          <region>Basque Country</region>
          <code></code>
          <country>Spain</country>
        </postal>
        <email>ibc@aliax.net</email>
      </address>
    </author>

    <author fullname="Jose Luis Millan Villegas" initials="J.L.M.V" surname="Millan Villegas">
      <organization>Consultant</organization>
      <address>
        <postal>
          <street></street>
          <city>Bilbao</city>
          <region>Basque Country</region>
          <code></code>
          <country>Spain</country>
        </postal>
        <email>jmillan@aliax.net</email>
      </address>
    </author>

    <author fullname="Victor Pascual" initials="V.P." surname="Pascual">
      <organization>Acme Packet</organization>
      <address>
        <postal>
          <street>Anabel Segura 10</street>
          <city>Madrid</city>
          <region>Madrid</region>
          <code>28108</code>
          <country>Spain</country>
        </postal>
        <email>vpascual@acmepacket.com</email>
      </address>
    </author>


    <date month="June" year="2012" />
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
         in the current day and month for you. If the year is not the current one, it is
         necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
         purpose of calculating the expiry date).  With drafts it is normally sufficient to
         specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>IETF</area>
    <workgroup>SIPCORE Working Group</workgroup>
    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
         If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>SIP</keyword>
    <keyword>WebSocket</keyword>
    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>The WebSocket protocol enables two-way realtime communication between clients and servers. This document specifies a new WebSocket sub-protocol as a reliable transport mechanism between SIP (Session Initiation Protocol) entities and enables usage of the SIP protocol in new scenarios.</t>
    </abstract>

  </front>



  <middle>

    <section title="Introduction" anchor="introduction">

      <t>The WebSocket <xref target="RFC6455"/> protocol enables messages exchange between clients and servers on top of a persistent TCP connection (optionally secured with TLS <xref target="RFC5246"/>). The initial protocol handshake makes use of HTTP <xref target="RFC2616"/> semantics, allowing the WebSocket protocol to reuse existing HTTP infrastructure.</t>

      <t>Modern web browsers include a WebSocket client stack complying with The WebSocket API <xref target="WS-API"/> as specified by the W3C. It is expected that other client applications (those running in personal computers and devices such as smartphones) will also run a WebSocket client stack. The specification in this document enables usage of the SIP protocol in those new scenarios.</t>
 
      <t>This specification defines a new WebSocket sub-protocol (section 1.9 in <xref target="RFC6455"/>) for transporting SIP messages between a WebSocket client and server, a new reliable and message boundary transport for the SIP protocol, new DNS NAPTR <xref target="RFC3403"/> service values and procedures for SIP entities implementing the WebSocket transport. Media transport is out of the scope of this document.</t>

    </section>

    <section title="Terminology" anchor="terminology">

      <t>All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.</t>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

      <section title="Definitions" anchor="definitions">
        <t>
          <list style="hanging" hangIndent="6">
            <t hangText="SIP WebSocket Client:">A SIP entity capable of opening outbound connections with WebSocket servers and speaking the WebSocket SIP Sub-Protocol as defined by this document.</t>
            <t hangText="SIP WebSocket Server:">A SIP entity capable of listening for inbound connections from WebSocket clients and speaking the WebSocket SIP Sub-Protocol as defined by this document.</t>
          </list>
        </t>
      </section>

    </section>


    <section title="The WebSocket Protocol" anchor="the_websocket_protocol">

      <t>_This section is non-normative._</t>

      <t>WebSocket protocol <xref target="RFC6455"/> is a transport layer on top of TCP (optionally secured with TLS <xref target="RFC5246"/>) in which both client and server exchange message units in both directions. The protocol defines a connection handshake, WebSocket sub-protocol and extensions negotiation, a frame format for sending application and control data, a masking mechanism, and status codes for indicating disconnection causes.</t>

      <t>The WebSocket connection handshake is based on HTTP <xref target="RFC2616"/> protocol by means of a specific HTTP GET method with Upgrade request sent by the client which is answered by the server (if the negotiation succeeded) with HTTP 101 status code. Once the handshake is done the connection upgrades from HTTP to the WebSocket protocol. This handshake procedure is designed to reuse the existing HTTP infrastructure. During the connection handshake, client and server agree in the application protocol to use on top of the WebSocket transport. Such application protocol (also known as the "WebSocket sub-protocol") defines the format and semantics of the messages exchanged between both endpoints. It may be a custom protocol or a standarized one (as the WebSocket SIP Sub-Protocol proposed in this document). Once the HTTP 101 response is processed both client and server reuse the underlying TCP connection for sending WebSocket messages and control frames to each other in a persistent way.</t>

      <t>WebSocket defines message units as application data exchange for communication endpoints, becoming a message boundary transport layer. These messages can contain UTF-8 text or binary data, and can be split into various WebSocket text/binary frames.
        <list style="empty">
          <t>However, the <xref target="WS-API">WebSocket API</xref> for web browsers just includes callbacks that are invoked upon receipt of an entire message, regardless of whether it was received in a single or multiple WebSocket frames.</t>
        </list>
      </t>

    </section>


    <section title="The WebSocket SIP Sub-Protocol" anchor="the_websocket_sip_subprotocol">

      <t>The term WebSocket sub-protocol refers to the application-level protocol layered on top of a WebSocket connection. This document specifies the WebSocket SIP Sub-Protocol for carrying SIP requests and responses through a WebSocket connection.</t>

      <section title="Handshake" anchor="handshake">

        <t>The SIP WebSocket Client and SIP WebSocket Server need to agree on the WebSocket SIP Sub-Protocol during the WebSocket handshake procedure as defined in section 1.3 of <xref target="RFC6455"/>. The client MUST include the value "sip" in the Sec-WebSocket-Protocol header in its handshake request. The 101 reply from the server MUST contain "sip" in its corresponding Sec-WebSocket-Protocol header.</t>

        <t>Below is an example of the WebSocket handshake in which the client requests the WebSocket SIP Sub-Protocol support from the server:<figure><artwork><![CDATA[
  GET / HTTP/1.1
  Host: sip-ws.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Origin: http://www.example.com
  Sec-WebSocket-Protocol: sip
  Sec-WebSocket-Version: 13
]]></artwork></figure>
        </t>

        <t>The handshake response from the server supporting the WebSocket SIP Sub-Protocol would look as follows:<figure><artwork><![CDATA[
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  Sec-WebSocket-Protocol: sip
]]></artwork></figure>
        </t>

        <t>Once the negotiation is done, the WebSocket connection is established with SIP as the WebSocket sub-protocol. The WebSocket messages to be transmitted over this connection MUST conform to the established application protocol.</t>

      </section>

      <section title="SIP encoding" anchor="sip_encoding">

        <t>WebSocket messages are carried on top of WebSocket UTF-8 text frames or binary frames. The SIP protocol <xref target="RFC3261"/> allows both text and binary bodies in SIP messages. Therefore SIP WebSocket Clients and SIP WebSocket Servers MUST accept both WebSocket text and binary frames.</t>

      </section>

    </section>
 

    <section title="SIP WebSocket Transport" anchor="sip_websocket_transport">

      <section title="General" anchor="general">

        <t>WebSocket <xref target="RFC6455"/> is a reliable protocol and therefore the WebSocket sub-protocol for a SIP transport defined by this document is also a reliable transport. Thus, client and server transactions using WebSocket transport MUST follow the procedures and timer values for reliable transports as defined in <xref target="RFC3261"/>.</t>

        <t>Each complete SIP message MUST be carried within a single WebSocket message, and a WebSocket message MUST NOT contain more than one SIP message. Therefore the usage of the Content-Length header field is optional.
          <list style="empty">
            <t>This makes parsing of SIP messages easier on client side (typically web-based applications with a strict and simple API for receiving WebSocket messages). There is no need to establish boundaries (using Content-Length headers) between different messages. Same advantage is present in other message-based SIP transports such as UDP or <xref target="RFC4168">SCTP</xref>.</t>
          </list>
        </t>

      </section>

      <section title="Updates to RFC 3261" anchor="upgrades_to_rfc_3261">

        <section title="Via Transport Parameter" anchor="via_transport_parameter">

          <t>Via header fields carry the transport protocol identifier. This document defines the value "WS" to be used for requests over plain WebSocket protocol and "WSS" for requests over secure WebSocket protocol (in which the WebSocket connection is established using TLS <xref target="RFC5246"/> with TCP transport).</t>

          <t>The updated RFC 3261 augmented BNF (Backus-Naur Form) <xref target="RFC5234"/> for this parameter reads as follows:<figure><artwork><![CDATA[
  transport  =  "UDP" / "TCP" / "TLS" / "SCTP" / "TLS-SCTP"
                / "WS" / "WSS"
                / other-transport
  ]]></artwork></figure>
          </t>

        </section>

        <section title="SIP URI Transport Parameter" anchor="sip_uri_transport_parameter">

          <t>This document defines the value "ws" as the transport parameter value for a SIP URI <xref target="RFC3986"/> to be contacted using WebSocket protocol as transport.</t>

          <t>The updated RFC 3261 augmented BNF (Backus-Naur Form) for this parameter reads as follows:<figure><artwork><![CDATA[
  transport-param  =  "transport="
                      ( "udp" / "tcp" / "sctp" / "tls" / "ws"
                      / other-transport )
  ]]></artwork></figure>
          </t>

        </section>

      </section>

      <section title="Locating a SIP Server" anchor="locating_a_sip_server">

        <t><xref target="RFC3263">RFC 3263</xref> specifies the procedures which should be followed by SIP entities for locating SIP servers. This specification defines the NAPTR service value "SIP+D2W" for SIP WebSocket Servers that support plain WebSocket transport and "SIPS+D2W" for SIP WebSocket Servers that support secure WebSocket transport.
          <list style="empty">
            <t>Unfortunately neither JavaScript stacks nor WebSocket stacks running in current web browsers are capable of performing DNS NAPTR/SRV queries.</t>
          </list>
        </t>

        <t>In the absence of an explicit port and DNS SRV resource records, the default port for a SIP URI with "ws" transport parameter is 80 in case of SIP scheme and 443 in case of SIPS scheme.</t>

      </section>

    </section>


    <section title="Connection Keep Alive" anchor="connection_keep_alive">

      <t>_This section is non-normative._</t>

      <t>It is RECOMMENDED that the SIP WebSocket Client or Server keeps the WebSocket connection open by sending periodic WebSocket Ping frames as described in <xref target="RFC6455"/> section 5.5.2.
        <list style="empty">
          <t>Note however that The WebSocket API <xref target="WS-API"/> does not provide a mechanism for web applications running in a web browser to decide whether or not to send periodic WebSocket Ping frames to the server. The usage of such a keep alive feature is a decision of each web browser vendor and may depend on the web browser configuration.</t>
        </list>
      </t>

      <t>Any future WebSocket protocol extension providing a keep alive mechanism could also be used.</t>

      <t>The SIP stack in the SIP WebSocket Client MAY also use Network Address Translation (NAT) keep-alive mechanisms defined for SIP connection-oriented transports, such as the CRLF Keep-Alive Technique mechanism described in <xref target="RFC5626"/> section 3.5.1 or <xref target="RFC6223"/>.
        <list style="empty">
          <t>Implementing these techniques would involve sending a WebSocket message to the SIP WebSocket Server whose content is a double CRLF, and expecting a WebSocket message from the server containing a single CRLF as response.</t>
        </list>
      </t>
 
    </section>


    <section title="Authentication" anchor="authentication">

      <t>_This section is non-normative._</t>

      <t>Prior to sending SIP requests, the SIP WebSocket Client connects to the SIP WebSocket Server and performs the connection handshake. As described in <xref target="the_websocket_protocol"/> the handshake procedure involves a HTTP GET request replied with HTTP 101 status code by the server.</t>

      <t>In order to authorize the WebSocket connection, the SIP WebSocket Server MAY inspect the Cookie <xref target="RFC6265"/> header in the HTTP GET request (if present). In case of web applications the value of such a Cookie is usually provided by the web server once the user has authenticated itself with the web server by following any of the multiple existing mechanisms. As an alternative method, the SIP WebSocket Server could request HTTP authentication by replying with a HTTP 401 status code. The WebSocket protocol <xref target="RFC6455"/> covers this usage in section 4.1:
        <list style="empty">
          <t>If the status code received from the server is not 101, the client handles the response per HTTP <xref target="RFC2616"/> procedures, in particular the client might perform authentication if it receives 401 status code.</t>
        </list>
      </t>

      <t>Regardless whether the SIP WebSocket Server requires authentication during the WebSocket handshake or not, authentication MAY be requested at SIP protocol level. Therefore it is RECOMMENDED for a SIP WebSocket Client to implement HTTP Digest <xref target="RFC2617"/> authentication as stated in <xref target="RFC3261"/>.</t>

    </section>

 
    <section title="Examples" anchor="examples">

      <section title="Registration" anchor="registration">
        <t><figure><artwork><![CDATA[
Alice    (SIP WSS)    proxy.atlanta.com
|                             |
|HTTP GET (WS handshake) F1   |
|---------------------------->|
|101 Switching Protocols F2   |
|<----------------------------|
|                             |
|REGISTER F3                  |
|---------------------------->|
|200 OK F4                    |
|<----------------------------|
|                             |
]]></artwork></figure>
        </t>

        <t>Alice loads a web page using her web browser and retrieves a JavaScript code implementing the WebSocket SIP Sub-Protocol defined in this document. The JavaScript code (a SIP WebSocket Client) establishes a secure WebSocket connection with a SIP proxy/registrar (a SIP WebSocket Server) at proxy.atlanta.com. Upon WebSocket connection, Alice constructs and sends a SIP REGISTER by requesting Outbound and GRUU support. Since the JavaScript stack in a browser has no way to determine the local address from which the WebSocket connection is made, this implementation uses a random ".invalid" domain name for the Via sent-by and for the URI hostpart in the Contact header (see <xref target="implementation_guidelines_client"/>).</t>

        <t>Message details (authentication and SDP bodies are omitted for simplicity):</t>

<t><figure><artwork><![CDATA[
F1 HTTP GET (WS handshake)  Alice -> proxy.atlanta.com (TLS)

GET / HTTP/1.1
Host: proxy.atlanta.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: https://www.atlanta.com
Sec-WebSocket-Protocol: sip
Sec-WebSocket-Version: 13


F2 101 Switching Protocols  proxy.atlanta.com -> Alice (TLS)

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: sip


F3 REGISTER  Alice -> proxy.atlanta.com (transport WSS)

REGISTER sip:proxy.atlanta.com SIP/2.0
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bKasudf
From: sip:alice@atlanta.com;tag=65bnmj.34asd
To: sip:alice@atlanta.com
Call-ID: aiuy7k9njasd
CSeq: 1 REGISTER
Max-Forwards: 70
Supported: path, outbound, gruu
Contact: <sip:alice@df7jal23ls0d.invalid;transport=ws>
  ;reg-id=1
  ;+sip.instance="<urn:uuid:f81-7dec-14a06cf1>"


F4 200 OK  proxy.atlanta.com -> Alice (transport WSS)

SIP/2.0 200 OK
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bKasudf
From: sip:alice@atlanta.com;tag=65bnmj.34asd
To: sip:alice@atlanta.com;tag=12isjljn8
Call-ID: aiuy7k9njasd
CSeq: 1 REGISTER
Supported: outbound, gruu
Contact: <sip:alice@df7jal23ls0d.invalid;transport=ws>
  ;reg-id=1
  ;+sip.instance="<urn:uuid:f81-7dec-14a06cf1>"
  ;pub-gruu="sip:alice@atlanta.com;gr=urn:uuid:f81-7dec-14a06cf1"
  ;temp-gruu="sip:87ash54=3dd.98a@atlanta.com;gr"
  ;expires=3600
]]></artwork></figure>
        </t>
      </section>

      <section title="INVITE dialog through a proxy" anchor="invite_dialog_through_a_proxy">
        <t><figure><artwork><![CDATA[
Alice    (SIP WSS)    proxy.atlanta.com    (SIP UDP)       Bob
|                             |                             |
|INVITE F1                    |                             |
|---------------------------->|                             |
|100 Trying F2                |                             |
|<----------------------------|                             |
|                             |INVITE F3                    |
|                             |---------------------------->|
|                             |200 OK F4                    |
|                             |<----------------------------|
|200 OK F5                    |                             |
|<----------------------------|                             |
|                             |                             |
|ACK F6                       |                             |
|---------------------------->|                             |
|                             |ACK F7                       |
|                             |---------------------------->|
|                             |                             |
|                    Both Way RTP Media                     |
|<=========================================================>|
|                             |                             |
|                             |BYE F8                       |
|                             |<----------------------------|
|BYE F9                       |                             |
|<----------------------------|                             |
|200 OK F10                   |                             |
|---------------------------->|                             |
|                             |200 OK F11                   |
|                             |---------------------------->|
|                             |                             |
]]></artwork></figure>
        </t>
        
        <t>In the same scenario Alice places a call to Bob's AoR. The WebSocket SIP server at proxy.atlanta.com acts as a SIP proxy routing the INVITE to the UDP location of Bob, who answers the call and terminates it later.</t>

        <t>Message details (authentication and SDP bodies are omitted for simplicity):</t>
 
        <t><figure><artwork><![CDATA[
F1 INVITE  Alice -> proxy.atlanta.com (transport WSS)

INVITE sip:bob@atlanta.com SIP/2.0
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bK56sdasks
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 70
Supported: path, outbound, gruu
Route: <sip:proxy.atlanta.com:443;transport=ws;lr>
Contact: <sip:alice@atlanta.com
 ;gr=urn:uuid:f81-7dec-14a06cf1;ob>
Content-Type: application/sdp


F2 100 Trying  proxy.atlanta.com -> Alice (transport WSS)

SIP/2.0 100 Trying
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bK56sdasks
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com
Call-ID: asidkj3ss
CSeq: 1 INVITE


F3 INVITE  proxy.atlanta.com -> Bob (transport UDP)

INVITE sip:bob@203.0.113.22:5060 SIP/2.0
Via: SIP/2.0/UDP proxy.atlanta.com;branch=z9hG4bKhjhjqw32c
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bK56sdasks
Record-Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 69
Supported: path, outbound, gruu
Contact: <sip:alice@atlanta.com
  ;gr=urn:uuid:f81-7dec-14a06cf1;ob>
Content-Type: application/sdp


F4 200 OK  Bob -> proxy.atlanta.com (transport UDP)

SIP/2.0 200 OK
Via: SIP/2.0/UDP proxy.atlanta.com;branch=z9hG4bKhjhjqw32c
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bK56sdasks
Record-Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 69
Contact: <sip:bob@203.0.113.22:5060;transport=udp>
Content-Type: application/sdp


F5 200 OK  proxy.atlanta.com -> Alice (transport WSS)

SIP/2.0 200 OK
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bK56sdasks
Record-Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 INVITE
Max-Forwards: 69
Contact: <sip:bob@203.0.113.22:5060;transport=udp>
Content-Type: application/sdp


F6 ACK  Alice -> proxy.atlanta.com (transport WSS)

ACK sip:bob@203.0.113.22:5060;transport=udp SIP/2.0
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bKhgqqp090
Route: <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>,
  <sip:proxy.atlanta.com;transport=udp;lr>,
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 ACK
Max-Forwards: 70


F7 ACK  proxy.atlanta.com -> Bob (transport UDP)

ACK sip:bob@203.0.113.22:5060;transport=udp SIP/2.0
Via: SIP/2.0/UDP proxy.atlanta.com;branch=z9hG4bKhwpoc80zzx
Via: SIP/2.0/WSS df7jal23ls0d.invalid;branch=z9hG4bKhgqqp090
From: sip:alice@atlanta.com;tag=asdyka899
To: sip:bob@atlanta.com;tag=bmqkjhsd
Call-ID: asidkj3ss
CSeq: 1 ACK
Max-Forwards: 69


F8 BYE  Bob -> proxy.atlanta.com (transport UDP)

BYE sip:alice@atlanta.com;gr=urn:uuid:f81-7dec-14a06cf1;ob SIP/2.0
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
Route: <sip:proxy.atlanta.com;transport=udp;lr>,
  <sip:h7kjh12s@proxy.atlanta.com:443;transport=ws;lr>
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE
Max-Forwards: 70


F9 BYE  proxy.atlanta.com -> Alice (transport WSS)

BYE sip:alice@atlanta.com;gr=urn:uuid:f81-7dec-14a06cf1;ob SIP/2.0
Via: SIP/2.0/WSS proxy.atlanta.com:443;branch=z9hG4bKmma01m3r5
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE
Max-Forwards: 69


F10 200 OK  Alice -> proxy.atlanta.com (transport WSS)

SIP/2.0 200 OK
Via: SIP/2.0/WSS proxy.atlanta.com:443;branch=z9hG4bKmma01m3r5
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE


F11 200 OK  proxy.atlanta.com -> Bob (transport UDP)

SIP/2.0 200 OK
Via: SIP/2.0/UDP 203.0.113.22;branch=z9hG4bKbiuiansd001
From: sip:bob@atlanta.com;tag=bmqkjhsd
To: sip:alice@atlanta.com;tag=asdyka899
Call-ID: asidkj3ss
CSeq: 1201 BYE
]]></artwork></figure>
        </t>
      </section>

    </section>

   
    <section title="Security Considerations" anchor="security_considerations">

      <section title="Secure WebSocket Connection">
        <t>It is recommended to protect the privacy of the SIP traffic through the WebSocket communication by using a secure WebSocket connection (tunneled over TLS <xref target="RFC5246"/>).</t>
      </section>

      <section title="Usage of SIPS Scheme" anchor="usage_of_sips_scheme">
        <t>SIPS scheme within a SIP request dictates that the entire request path to the target be secured. If such a path includes a WebSocket node it MUST be a secure WebSocket connection.</t>
      </section>

    </section>


    <section title="IANA Considerations" anchor="iana_considerations">

      <section title="Registration of the WebSocket SIP Sub-Protocol">
        <t>This specification requests IANA to create the WebSocket SIP Sub-Protocol in the registry of WebSocket sub-protocols with the following data:
          <list style="hanging">
            <t hangText="Subprotocol Identifier:">sip</t>
            <t hangText="Subprotocol Common Name:">WebSocket Transport for SIP (Session Initiation Protocol)</t>
            <t hangText="Subprotocol Definition:">TBD, it should point to this document</t>
          </list>
        </t>
      </section>
      
      <section title="Registration of new Via transports">
        <t>This specification registers two new transport identifiers for Via headers:
          <list style="hanging" hangIndent="6">
            <t hangText="WS:">MUST be used when constructing a SIP request to be sent over a plain WebSocket connection.</t>
            <t hangText="WSS:">MUST be used when constructing a SIP request to be sent over a secure WebSocket connection.</t>
          </list>
        </t>
      </section>

      <section title="Registration of new SIP URI transport">
        <t>This specification registers a new value for the "transport" parameter in a SIP URI:
          <list style="hanging" hangIndent="6">
            <t hangText="ws:">Identifies a SIP URI to be contacted using a WebSocket connection.</t>
          </list>
        </t>
      </section>

      <section title="Registration of new NAPTR service field values">

        <t>This document defines two new NAPTR service field values (SIP+D2W and SIPS+D2W) and requests IANA to register these values under the "Registry for the SIP SRV Resource Record Services Field".  The resulting entries are as follows:<figure><artwork><![CDATA[
 Services Field        Protocol  Reference
 --------------------  --------  ---------
 SIP+D2W               WS        TBD: this document
 SIPS+D2W              WSS       TBD: this document
]]></artwork></figure>
        </t>

      </section>

    </section>


    <section title="Acknowledgements" anchor="acknowledgements">

      <t>Special thanks to the following people who participated in discussions on the SIPCORE and RTCWEB WG mailing lists and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): Hadriel Kaplan, Paul Kyzivat, Adam Roach, Ranjit Avasarala, Xavier Marjou, Kevin P. Fleming, Nataraju A. B.</t>

      <t>Special thanks to Alan Johnston, Christer Holmberg and Salvatore Loreto for their full reviews, and also to Saul Ibarra Corretge for his contribution and suggestions.</t>

    </section>


  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;
      &RFC3261;
      &RFC3263;
      &RFC3403;
      &RFC5234;
      &RFC6455;
    </references>

    <references title="Informative References">
      &RFC2606;
      &RFC2616;
      &RFC2617;
      &RFC3327;
      &RFC3986;
      &RFC4168;
      &RFC5246;
      &RFC5626;
      &RFC5627;
      &RFC6223;
      &RFC6265;

      <reference anchor="WS-API">
        <front>
          <title>The Web Sockets API</title>
          <author initials="I." surname="Hickson" fullname="Ian Hickson">
            <organization>Google, Inc.</organization>
          </author>
          <date month="May" year="2012" />
        </front>
      </reference>

    </references>

 
    <section title="Implementation Guidelines" anchor="implementation_guidelines">

      <t>_This section is non-normative._</t>

      <t>Let us assume a scenario in which the users access with their web browsers (probably behind NAT) to an intranet, perform web login by entering their user identifier and credentials, and retrieve a JavaScript code (along with the HTML code itself) implementing a SIP WebSocket Client.</t>

      <t>Such a SIP stack connects to a given SIP WebSocket Server (an outbound SIP proxy which also implements classic SIP transports such as UDP and TCP). The HTTP GET request sent by the web browser for the WebSocket handshake includes a Cookie <xref target="RFC6265"/> header with the value previously retrieved after the successful web login procedure. The Cookie value is then inspected by the WebSocket server for authorizing the connection. Once the WebSocket connection is established, the SIP WebSocket Client performs a SIP registration and common SIP stuf begins. The SIP registrar server is located behind the SIP outbound proxy.</t>

      <t>This scenario is quite similar to the one in which SIP UAs behind NAT connect to an outbound proxy and need to reuse the same TCP connection for incoming requests. In both cases, the SIP clients are just reachable through the outbound proxy they are connected to.</t>

      <t>Outbound <xref target="RFC5626"/> seems an appropriate solution for this scenario. Therefore these SIP WebSocket Clients and the SIP registrar implement both Outbound and Path <xref target="RFC3327"/>, and the SIP outbound proxy becomes an Outbound Edge Proxy (as defined in <xref target="RFC5626"/> section 3.4).</t>

      <t>SIP WebSocket Clients in this scenario receive incoming SIP requests via the SIP WebSocket Server they are connected to. Therefore, in some call transfer cases the usage of GRUU <xref target="RFC5627"/> (which should be implemented in both the SIP WebSocket Clients and SIP registrar) is valuable.
        <list style="empty">
          <t>If a REFER request is sent to a thirdy SIP user agent indicating the Contact URI of a SIP WebSocket Client as the target in the Refer-To header field, such a URI will be reachable by the thirdy SIP UA just in the case it is a globally routable URI. GRUU (Globally Routable User Agent URI) is a solution for those scenarios, and would enforce the incoming request from the thirdy SIP user agent to reach the SIP registrar which would route the request via the Outbound Edge Proxy.</t>
        </list>
      </t>


      <section title="SIP WebSocket Client Considerations" anchor="implementation_guidelines_client">

        <t>The JavaScript stack in web browsers does not have the ability to discover the local transport address which the WebSocket connection is originated from. Therefore the SIP WebSocket Client creates a domain consisting of a random token followed by .invalid top domain name, as stated in <xref target="RFC2606"/>, and uses it within the Via and Contact header.
          <list style="empty">
            <t>The Contact URI provided by the SIP clients requesting Outbound support is not later used for routing purposes, thus it is safe to set a random domain in the Contact URI hostpart.</t>
          </list>
        </t>

        <t>Both Outbound and GRUU specifications require the SIP client to indicate a Uniform Resource Name (URN) in the "+sip.instance" parameter of the Contact header during the registration. The client device is responsible for getting such a constant and unique value.
          <list style="empty">
            <t>In the case of web browsers it is hard to get a URN value from the browser itself. This scenario suggests that value is generated according to <xref target="RFC5626"/> section 4.1 by the web application running in the browser the first time it loads the JavaScript SIP stack code, and then it is stored as a Cookie within the browser.</t>
          </list>
        </t>
 
      </section>

      <section title="SIP WebSocket Server Considerations" anchor="implementation_guidelines_server">

        <t>The SIP WebSocket Server in this scenario behaves as a SIP Outbound Edge Proxy, which involves support for Outbound <xref target="RFC5626"/> and Path <xref target="RFC3327"/>.</t>

        <t>The proxy performs Loose Routing and remains in dialogs path as specified in <xref target="RFC3261"/>. Otherwise in-dialog requests would fail since SIP WebSocket Clients make use of their SIP WebSocket Server in order to send and receive SIP requests and responses.</t>

      </section>

    </section>

    <section title="HTTP Topology Hiding" anchor="http_topology_hiding">

      <t>_This section is non-normative._</t>

      <t><xref target="RFC3261">RFC 3261</xref> section 18.2.1 "Receiving Requests" states the following:
        <list style="empty">
          <t>When the server transport receives a request over any transport, it MUST examine the value of the "sent-by" parameter in the top Via header field value.  If the host portion of the "sent-by" parameter contains a domain name, or if it contains an IP address that differs from the packet source address, the server MUST add a "received" parameter to that Via header field value.  This parameter MUST contain the source address from which the packet was received.</t>
        </list>
      </t>

      <t>The requirement of adding the "received" parameter does not fit well into WebSocket protocol nature. The WebSocket handshake connection reuses existing HTTP infrastructure in which there could be certain number of HTTP proxies and/or TCP load balancers between the SIP WebSocket Client and Server, so the source IP the server would write into the Via "received" parameter would be the IP of the HTTP/TCP intermediary in front of it. This could reveal sensitive information about the internal topology of the provider network to the client.</t>

      <t>Thus, given the fact that SIP responses can only be sent over the existing WebSocket connection, the meaning of the Via "received" parameter added by the SIP WebSocket Server is of little use. Therefore, in order to allow hiding possible sensitive information about the provider infrastructure, the implementer could decide not to satisfy the requirement in <xref target="RFC3261">RFC 3261</xref> section 18.2.1 "Receiving Requests" and not add the "received" parameter to the Via header.
        <list style="empty">
          <t>However, keep in mind that this would involve a violation of the RFC 3261.</t>
        </list>
      </t>

    </section>

  </back>

</rfc>
