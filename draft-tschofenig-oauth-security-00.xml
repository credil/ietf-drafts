<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="no" ?>
<?rfc subcompact="no" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC5849 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY I-D.ietf-oauth-v2 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2.xml">
<!ENTITY I-D.ietf-oauth-json-web-token SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-json-web-token.xml">
<!ENTITY RFC4279 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4279.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC4962 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4962.xml">
<!ENTITY RFC4120 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml">
<!ENTITY RFC6125 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml">
<!ENTITY RFC5056 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml">
<!ENTITY I-D.tschofenig-oauth-hotk SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.tschofenig-oauth-hotk.xml">
<!ENTITY I-D.ietf-oauth-v2-http-mac SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2-http-mac.xml">
<!ENTITY I-D.hardjono-oauth-kerberos SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hardjono-oauth-kerberos.xml">
<!ENTITY I-D.iab-privacy-considerations SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.iab-privacy-considerations.xml">
<!ENTITY I-D.rescorla-stateless-tokens SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.rescorla-stateless-tokens.xml">
<!ENTITY I-D.ietf-oauth-v2-bearer SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2-bearer.xml">
]>
<rfc category="info" docName="draft-tschofenig-oauth-security-00.txt" ipr="trust200902">
  <front>
    <title abbrev="Enhancing OAuth 2.0 Security">OAuth 2.0 Security: Going Beyond Bearer Tokens </title>   
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Nokia Siemens Networks</organization>
      <address>
        <postal>
          <street>Linnoitustie 6</street>
          <city>Espoo</city>
          <code>02600</code>
          <country>Finland</country>
        </postal>
        <phone>+358 (50) 4871445</phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>
          <author fullname="Phil Hunt" initials="P." surname="Hunt">
      <organization>Oracle Corporation</organization>

      <address>
        <email>phil.hunt@yahoo.com</email>
      </address>
    </author>

    <date year="2012"/>
    <area>Security Area</area>
    <workgroup>OAuth</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>OAuth</keyword>
    <keyword>Signatures</keyword>
    <keyword>Security</keyword>
    <keyword>Message Authentication</keyword>
    <abstract>
      <t>The OAuth working group has finished work on the OAuth 2.0 core protocol as well as the Bearer Token specification. The Bearer Token is a TLS-based solution for ensuring that neither the interaction with the Authorization Server (when requesting a  token) nor the interaction with the Resource Server (for accessing a protected resource) leads to token leakage.
      There has, however, always been the desire to develop a security solution that is "better" than Bearer Tokens (or at least different) where the Client needs to show possession of some keying material when accessing a Resource Server. This document tries to capture the discussion and to come up with requirements to process the work on solutions.</t>
      
      <t>This document aims to discuss threats, security requirements and desired design properties of an enhanced OAuth security mechanism.</t>
    </abstract>
  </front>

  <middle>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="introduction" title="Introduction">
    <t>OAuth 1.0 <xref target="RFC5849"/> included a
      mechanism for putting a digital signature (when using asymmetric keys) and a keyed message digest (when using symmetric keys) to a resource request when presenting the OAuth access token.
      OAuth 2.0 <xref target="I-D.ietf-oauth-v2"/> generalized the protocol and the Bearer Token security specification <xref target="I-D.ietf-oauth-v2-bearer"/> is close to publication as an RFC.</t>
      
<t><xref target="oauth-simplified"/> shows the OAuth 2.0 exchange at an abstract level and illustrates the main entities. For most parts of this document the focus is on the interaction between the Client and the Authorization Server and between the Client and the Resource Server.</t>
          <t>  
          <figure anchor="oauth-simplified" title="OAuth: Abstract Protocol Flow">
            <artwork>
              <![CDATA[
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
                       ]]></artwork>
          </figure>
        </t>

<t>From a security point of view the following aspects of the OAuth 2.0 specification are worth mentioning:

<list style="symbols">
<t>Standardization of a JSON-based format and the content of the access token are still work in progress <xref target="I-D.ietf-oauth-json-web-token"/>. The same is true for the JSON-based security mechanisms.</t>
<t>The interaction to obtain an access token in step #1 mandates to implement and to use TLS with server-side authentication to protect the confidentiality of the transmitted information.</t>
</list>
</t>

    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="terminology" title="Terminology">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
        "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
        RFC 2119 <xref target="RFC2119"/>.</t>

<t>This document uses the terminology defined in RFC 4949 <xref target="RFC4949"/>. The terms 'keyed hash' and 'keyed message digest' are used interchangable. For privacy related matters we utilize the terminology defined in <xref target="I-D.iab-privacy-considerations"/>.</t>

<t>This document uses OAuth 2.0 terminology <xref target="I-D.ietf-oauth-v2"/>. In particular, the terms Client, Resource Server, Authorization Server, and Access Token are used.</t>
    </section>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="threats" title="Security and Privacy Threats">
   
   <t>The following list presents several common threats against protocols utilizing some form of tokens. This list of threats is based on NIST Special Publication 800-63 <xref target="NIST800-63"/>. We exclude a discussion of threats related to any form of identity proofing and authentication of the Resource Owner to the Authorization Server since these procedures are not part of the OAuth 2.0 protocol specificaiton itself.</t>
   <t><list style="hanging">
   <t hangText="Token manufacture/modification:"><vspace blankLines="1"/> An attacker may generate a bogus tokens or modify the token content (such as  authentication or attribute statements) of an existing token, causing Resource Server to grant inappropriate access to the Client. For example, an attacker may modify the token to extend the validity period. A Client may modify the token to have access to information that they should not be able to view.</t>
   <t hangText="Token disclosure:">Tokens may contain personal data, such as real name, age or birthday, payment information, etc.</t>
<!--    <t hangText="Token repudiation:">A token may be repudiated if the proper mechanisms are not in place.</t> -->
   <t hangText="Token redirect:"><vspace blankLines="1"/>An attacker uses the token generated for consumption by the Resource Server to obtain access to another Resource Server.</t>   <t hangText="Token reuse:"><vspace blankLines="1"/> An attacker attempts to use a token that has already been used once with a Resource Server. The attacker may be an eavesdropper who observes the communication exchange or, worse, one of the communication end points. A Client may, for example, leak access tokens because it cannot keep secrets confidential. A Client may also re-use access tokens for some other Resource Servers. Finally, a Resource Server may use a token it had obtained from a Client and use it with another Resource Server that the Client interacts with. A Resource Server, offering relatively unimportant application services, may attempt to use an access token obtained from a Client to access a high-value service, such as a payment service, on behalf of the Client using the same access token.</t>
</list> 
</t>

<t>We excluded one threat from the list, namely 'token repudiation'. Token repudiation refers to a property whereby a Resource Server is given an assurance that the Authorization Server cannot deny to have created a token for the Client. We believe that such a property is interesting but most deployments prefer to deal with the violation of this security property through business actions rather than by using cryptography.</t>
      
</section> 


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

<section anchor="mitigation" title="Threat Mitigation"> 

<t>The purpose of this section is to discuss ways to mitigate the threats without taking the current working group status into consideration.
</t>

<t>A large range of threats can be mitigated by protecting the content of the token, using a digital signature or a keyed message digest. Alternatively, the content of the token could be passed by reference rather than by value (requiring a separate message exchange to resolve the reference to the token content). To simplify the subsequent description we assume that the token itself is digitally signed by the Authorization Server and therefore cannot be modified. <!-- This also provides the basis for non-repudiation.--> </t>

<t>To deal with token redirect it is important for the Authorization Server to include the identifier of the intended recipient - the Resource Server. A Resource Server must not be allowed to accept access tokens that are not meant for its consumption. </t>

<t>To provide protection against token disclosure two approaches are possible, namely (a) not to include sensitive information inside the token or (b) to ensure confidentiality protection. The latter approach requires at least the communication interaction between the Client and the Authorization Server as well as the interaction between the Client and the Resource Server to experience confidentiality protection. As an example, Transport Layer Security with a ciphersuite that offers confidentiality protection has to be applied. Encrypting the token content itself is another alternative. In our scenario the Authorization Server would, for example, encrypt the token content with a symmetric key shared with the Resource Server.  
</t>

<t>To deal with token reuse more choices are available.</t>

<section anchor="confidentiality" title="Confidentiality Protection">

<t>In this approach confidentiality protection of the exchange is provided on the communication interfaces between the Client and the Resource Server, and between the Client and the Authorization Server. No eavesdropper on the wire is able to observe the token exchange. Consequently, a replay by a third party is not possible. An Authorization Server wants to ensure that it only hands out tokens to Clients it has authenticated first and who are authorized. For this purpose, authentication of the Client to the Authorization Server will be a requirement to ensure adequate protection against a range of attacks. This is, however, true for the description in <xref target="intended"/> and <xref target="confirmation"/> as well. Furthermore, the Client has to make sure it does not distribute the access token to entities other than the intended the Resource Server. For that purpose the Client will have to authenticate the Resource Server before transmitting the access token.
</t>

</section> 

<section anchor="intended" title="Sender Constraint">

<t>Instead of providing confidentiality protection the Authorization Server could also put the identifier of the Client into the protected token with the following semantic: 'This token is only valid when presented by a Client with the following identifer.' When the access token is then presented to the Resource Server how does it know that it was provided by the Client? It has to authenticate the Client! There are many choices for authenticating the Client to the Resource Server, for example by using client certificates in TLS <xref target="RFC5246"/>, or pre-shared secrets within TLS <xref target="RFC4279"/>. The choice of the preferred authentication mechanism and credential type may depend on a number of factors, including <list style="symbols"> 
<t>security properties</t>
<t>available infrastructure</t>
<t>library support</t>
<t>credential cost (financial)</t>
<t>performance</t>
<t>integration into the existing IT infrastructure</t>
<t>operational overhead for configuration and distribution of credentials</t>
</list> 
</t>
<t>This long list hints to the challenge of selecting at least one mandatory-to-implement Client authentication mechanism.</t>

</section> 

<section anchor="confirmation" title="Key Confirmation">

<t>A variation of the mechanism of sender authentication described in <xref target="intended"/> is to replace authentication with the proof-of-possession of a specific (session) key, i.e. key confirmation. In this model the Resource Server would not authenticate the Client itself but would rather verify whether the Client knows the session key associated with a specific access token. Examples of this approach can be found with the OAuth 1.0 MAC token <xref target="RFC5849"/>, Kerberos <xref target="RFC4120"/> when utilizing the AP_REQ/AP_REP exchange (see also <xref target="I-D.hardjono-oauth-kerberos"/> for a comparison between Kerberos and OAuth), the OAuth 2.0 MAC token <xref target="I-D.ietf-oauth-v2-http-mac"/>, and the Holder-of-the-Key approach <xref target="I-D.tschofenig-oauth-hotk"/>.</t>

<t>To illustrate key confirmation the first examples borrow from Kerberos and use symmetric key cryptography. Assume that the Authorization Server shares a long-term secret with the Resource Server, called K(Authorization Server-Resource Server). This secret would be established between them in an initial registration phase. When the Client requests an access token the Authorization Server creates a fresh and unique session key Ks and places it into the token encrypted with the long term key K(Authorization Server-Resource Server). Additionally, the Authorization Server attaches Ks to the response message to the Client (in addition to the access token itself) over a confidentiality protected channel. When the Client sends a request to the Resource Server it has to use Ks to compute a keyed message digest for the request (in whatever form or whatever layer). The Resource Server, when receiving the message, retrieves the access token, verifies it and extracts K(Authorization Server-Resource Server) to obtain Ks. This key Ks is then used to verify the keyed message digest of the request message.  
</t>

<t>Note that in this example one could imagine that the mechanism to protect the token itself is based on a symmetric key based mechanism to avoid any form of public key infrastructure but this aspect is not further elaborated in the scenario.</t>

<t>A similar mechanism can also be designed using asymmetric cryptography. When the Client requests an access token the Authorization Server creates an ephemeral public / privacy key pair (PK/SK) and places the public key PK into the protected token. When the Authorization Server returns the access token to the Client it also provides the PK/SK key pair over a confidentiality protected channel. When the Client sends a request to the Resource Server it has to use the privacy key SK to sign the request. The Resource Server, when receiving the message, retrieves the access token, verifies it and extracts the public key PK. It uses this ephemeral public key to verify the attached signature.</t>
</section> 
 
 
     <section title="Summary">

   <t> As a high level message, there are various ways how the threats can be mitigated and while the details of each solution is somewhat different they all ultimately accomplish the goal. </t>
   
   <t>The three approaches are: <list style="hanging">
   
   <t hangText="Confidentiality Protection:"><vspace blankLines="1"/>The weak point with this approach, which is briefly described in <xref target="confidentiality"/>, is that the Client has to be careful to whom it discloses the access token. What can be done with the token entirely depends on what rights the token entitles the presenter and what constraints it contains. A token could encode the identifier of the Client but there are scenarios where the Client is not authenticated to the Resource Server or where the identifier of the Client rather represents an application class rather than a single application instance. As such, it is possible that certain deployments choose a rather liberal approach to security and that everyone who is in possession of the access token is granted access to the data. 
   <!-- <vspace blankLines="1"/> 
   Furthermore, to secure the access token at rest; unauthorized disclosure could be harmful particularly when the token has a rather long lifetime. Intuitively, one would argue that access tokens are easy to mint and used for a small time duration only to reduce the risk of exposure.--> </t>
   
   <t hangText="Sender Constraint:"><vspace blankLines="1"/>The weak point with this approach, which is briefly described in <xref target="intended"/>, is to setup the authentication infrastructure such that Clients can be authenticated towards Resource Servers. Additionally, Authorization Server must encode the identifier of the Client in the token for later verification by the Resource Server. Depending on the chosen layer for providing Client-side authentication there may be additional challenges due Web server load balancing, lack of API access to identity information, etc. 
</t>
   <t hangText="Key Confirmation:"><vspace blankLines="1"/>The weak point with this approach, see <xref target="confirmation"/>, is the increased complexity: a complete key distribution protocol has to be defined.  
  </t>
   </list> 
   </t>

<t>In all cases above it has to be ensured that the Client is able to keep the credentials secret.</t> 
</section>
    
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

<section anchor="requirements" title="Requirements"> 

<t>In an attempt to address the threats described in <xref target="threats"/> the Bearer Token, which corresponds to the description in <xref target="confidentiality"/>, was standardized and the work on a JSON-based token format has been started <xref target="I-D.ietf-oauth-json-web-token"/>. The required capability to protected the content of a JSON token using integrity  and confidentiality mechanisms is currently work in progress in the IETF JOSE working group.</t>

<t>Consequently, the purpose of the remaining document is to provide security that goes beyond the Bearer Token offered security protection.</t>   

<t>Luckily this is not the first security protocol that has been designed. In trying to seek guidance the authors found RFC 4962 <xref target="RFC4962"/>, which gives useful guidelines for designers of authentication and key management protocols. While RFC 4962 was written with the AAA framework used for network access authentication in mind the offered suggestions are useful for the design of other key management systems as well. The following requirements list applies OAuth 2.0 terminology to the requirements outlined in RFC 4962.</t>
   
  <t>These requirements include 
   <list style="hanging">
   <t hangText="Cryptographic Algorithm Independent:"><vspace blankLines="1"/>  The key management protocol MUST be cryptographic algorithm
         independent.</t>
         
   <t hangText="Strong, fresh session keys:"><vspace blankLines="1"/> Session keys MUST be
         strong and fresh.  Each session deserves an independent session
         key, i.e., one that is generated specifically
         for the intended use. In context of OAuth this means that keying material is created in such a way that can only be used by the combination of a Client instance, protected resource, and authorization scope.</t>
         
   <t hangText="Limit Key Scope:"><vspace blankLines="1"/> Following the principle of least privilege, parties MUST NOT
         have access to keying material that is not needed to perform
         their role. Any protocol that is used to establish session keys MUST
         specify the scope for session keys, clearly identifying the
         parties to whom the session key is available.</t>
         
   <t hangText="Replay Detection Mechanism:"><vspace blankLines="1"/> The key management protocol exchanges MUST be replay
         protected. Replay protection allows a protocol message
         recipient to discard any message that was recorded during a
         previous legitimate dialogue and presented as though it
         belonged to the current dialogue.</t>
         
   <t hangText="Authenticate All Parties:"><vspace blankLines="1"/> Each party in the key management protocol MUST be
         authenticated to the other parties with whom they communicate.
         Authentication mechanisms MUST maintain the confidentiality of
         any secret values used in the authentication process. Secrets MUST NOT be sent to
         another party without confidentiality protection.</t>
         
   <t hangText="Authorization:"><vspace blankLines="1"/> Client and Resource Server authorization MUST be performed.  These
         entities MUST demonstrate possession of the appropriate keying
         material, without disclosing it.  Authorization is REQUIRED
         whenever a Client interacts with an Authorization Server.  The
         authorization checking prevents an elevation of privilege
         attack, and it ensures that an unauthorized authorized is
         detected.</t>
         
   <t hangText="Keying Material Confidentiality and Integrity:"><vspace blankLines="1"/> While preserving algorithm independence, confidentiality and
         integrity of all keying material MUST be maintained.</t>
         
   <t hangText="Confirm Cryptographic Algorithm Selection:"><vspace blankLines="1"/> The selection of the "best" cryptographic algorithms SHOULD be securely
         confirmed.  The mechanism SHOULD detect attempted roll-back
         attacks.</t>
         
   <t hangText="Uniquely Named Keys:"><vspace blankLines="1"/> Key management proposals require a robust key naming
         scheme, particularly where key caching is supported.  The key
         name provides a way to refer to a key in a protocol so that it
         is clear to all parties which key is being referenced.  Objects
         that cannot be named cannot be managed.  All keys MUST be
         uniquely named, and the key name MUST NOT directly or
         indirectly disclose the keying material.</t>
         
   <t hangText="Prevent the Domino Effect:"><vspace blankLines="1"/> Compromise of a single Client MUST NOT compromise keying material
         held by any other Client within the system, including session
         keys and long-term keys.  Likewise, compromise of a single
         Resource Server MUST NOT compromise keying material held by any
         other Resource Server within the system.  In the context of a key
         hierarchy, this means that the compromise of one node in the
         key hierarchy must not disclose the information necessary to
         compromise other branches in the key hierarchy.  Obviously, the
         compromise of the root of the key hierarchy will compromise all
         of the keys; however, a compromise in one branch MUST NOT
         result in the compromise of other branches.  There are many
         implications of this requirement; however, two implications
         deserve highlighting.  First, the scope of the keying material
         must be defined and understood by all parties that communicate
         with a party that holds that keying material.  Second, a party
         that holds keying material in a key hierarchy must not share
         that keying material with parties that are associated with
         other branches in the key hierarchy.         
         </t>
   <t hangText="Bind Key to its Context:"><vspace blankLines="1"/>  Keying material MUST be bound to the appropriate context.  The
         context includes the following.<list style="symbols"> 
         <t> The manner in which the keying material is expected to be
               used.</t>

         <t> The other parties that are expected to have access to the
               keying material.</t>

         <t> The expected lifetime of the keying material.  Lifetime
               of a child key SHOULD NOT be greater than the lifetime of
               its parent in the key hierarchy.</t>
         </list> 
         

         Any party with legitimate access to keying material can
         determine its context.  In addition, the protocol MUST ensure
         that all parties with legitimate access to keying material have
         the same context for the keying material.  This requires that
         the parties are properly identified and authenticated, so that
         all of the parties that have access to the keying material can
         be determined. The context will include the Client and the Resource Server identities in more
         than one form.</t>
         
   <t hangText="Authorization Restriction:"><vspace blankLines="1"/> If Client authorization is restricted, then the Client SHOULD be
         made aware of the restriction. </t>

   <t hangText="Client Identity Confidentiality:"><vspace blankLines="1"/> A Client has identity confidentiality when any party other than
   the Resource Server and the Authorization Server cannot sufficiently identify the Client within the
   anonymity set. In comparison to anonymity and pseudonymity, identity
   confidentiality is concerned with eavesdroppers and intermediaries. A key management protocol SHOULD provide this property.</t>
        
    <t hangText="Resource Owner Identity Confidentiality:"><vspace blankLines="1"/> Resource servers SHOULD be prevented from knowing the real or
      pseudonymous identity of the Resource Owner, since the Authorization Server
       is the only entity involved in verifying the Resource Owner's identity.</t>


   <t hangText="Collusion:"><vspace blankLines="1"/> Resource Servers that collude can be prevented from using information related to the Resource Owner to track the individual.  That is, two
      different Resource Servers can be prevented from determining that
      the same Resource Owner has authenticated to both of them.  This
      requires that each Authorization Server obtains different keying material as well as different access tokens
      with content that does not allow identification of the Resource Owner. </t>
   
   <t hangText="AS-to-RS Relationship Anonymity:"><vspace blankLines="1"/> The Authorization Server can be prevented from knowing which Resource Servers
      a Resource Owner interacts with.  This requires avoiding
      direct communication between the Authorization Server and the Resource Server
      at the time when access to a protected resource by the Client is
      made. Additionally, the Client must not provide information about the Resource Server in the access token request. 
      [QUESTION: Is this a desirable property given that it has other implications for security?]</t>
   </list>
   </t>
   
   <t>As an additional requirement a solution MUST enable support for channel bindings. The concept of channel binding, as defined in <xref target="RFC5056"/>, allows applications to establish that
   the two end-points of a secure channel at one network layer are the
   same as at a higher layer by binding authentication at the higher
   layer to the channel at the lower layer.</t>
   
   <t>Furthermore, there are performance concerns specifically with the usage of asymmetric cryptography. As such, the requirement can be phrases as 'faster is better'. [QUESTION: How are we trading the benefits of asymmetric cryptography against the performance impact?]</t>

   <t>Finally, there are threats that relate to the experience of the software developer as well as operational policies. For example, a frequently raised concern is the absent of verifying that the server's presented identity matches its reference identity so it can authenticate the communication endpoint and authorize it. Verifying the server identity in TLS is discussed at length in <xref target="RFC6125"/>. There are also various guesses about what application developers are able to implement correctly and easily and to what degree they can rely on third party libraries.[QUESTION: How do we reflect these requirements in the design?]</t>

</section> 


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="sec-cons" title="Security Considerations">
   
   <t>The main focus of this document is on security.</t>
   
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Next Steps">
    <t>From this description so far a few observations and next steps can be derived:</t>
    <t>
    <list style="numbers">
    
    <t>Bearer Tokens are a viable solution for protecting against the threats described in <xref target="threats"/>. Further standardization work on OAuth security mechanisms needs to provide additional security benefits on top of those provided by the bearer token solution.</t>
    
    <t>The requirements listed in <xref target="requirements"/> aim to provide a starting point for a discussion on a security solution that provides additional security and privacy benefits for OAuth 2.0.</t>
    
    <t>It is likely that implementers will find security solutions hard to implement and hard to configure right. Additional guidance and the availability to libraries may help to improve security on the Internet for OAuth-based implementations. Fundamentally, there is the question about a design that is based on symmetric vs. asymmetric cryptography. Ideally, only a single solution should be developed (or a very small number) since the differences between different variations of such as protocol are minor.</t>
     
    <t>A standardized solution for the token format is needed to mitigate a number of attacks and this work is already ongoing under the name of JWT <xref target="I-D.ietf-oauth-json-web-token"/>.</t>
    
    </list>
    </t>
    
    <t>To make progress with the above-mentioned items before the next IETF meeting in Atlanta I therefore suggest to (a) solicit for document reviews regarding the JWT document, and (b) progress the work on the extended OAuth security mechanism. Regarding the latter aspect consider the following questions: 
    
    <list style="hanging">
   
      <t hangText="Threats:"><vspace blankLines="1"/> <xref target="threats"/> lists a few security threats. Are these the threats you care about? Which threats missing?</t>

      <t hangText="Requirements:"><vspace blankLines="1"/>The working group has expressed interest to work on an extended OAuth security mechanism. Assuming that the group wants to develop a key distribution protocol (as described in <xref target="confirmation"/>) are the requirements listed in <xref target="requirements"/> complete? Who is interested to develop early prototypes of support the standards development?</t>

    </list>
    </t>


    </section>



    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="iana" title="IANA Considerations">

    <t>This document does not require actions by IANA.</t>
    
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Acknowledgments">
      <t>The authors would like to thank the OAuth working group for their discussion input.
      A group of regular OAuth participants met at the IETF #82 meeting in Vancouver to discuss this topic in preparation for the face-to-face meeting. The participants were: 
      <list style="symbols"> 
      <t>John Bradley</t>
      <t>Brian Campbell</t>
      <t>Phil Hunt</t>      
      <t>Leif Johansson</t>
      <t>Mike Jones</t>
      <t>Lucy Lynch</t>
      <t>Tony Nadalin</t>
      <t>Klaas Wierenga</t>
      </list> 
      </t>
     
     <t>This document reuses content from <xref target="RFC4962"/> and the author would like thank Russ Housely and Bernard Aboba for their work on that document.</t> 
      
     <t>Finally, I would like to thank Blaine Cook. This document was derived from an earlier draft that Blaine and I wrote.</t>     
    </section>
 </middle>

  <!-- ////////////////////////////////////////////////////////////////////////////////// -->

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>
          </author>
          <date month="March" year="1997"/>
        </front>
        <format octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt" type="TXT"/>
      </reference>
      
 &I-D.ietf-oauth-v2; &RFC4949;
 &I-D.ietf-oauth-v2-bearer; 
 &I-D.ietf-oauth-json-web-token;
 </references>

    <references title="Informative References">
&RFC4962; 
&I-D.iab-privacy-considerations;
&RFC4279;
&RFC5246;
&RFC4120;
&I-D.hardjono-oauth-kerberos;
<!-- &I-D.rescorla-stateless-tokens; --> 
&RFC5849;
&RFC5056;
&RFC6125;
&I-D.ietf-oauth-v2-http-mac;
&I-D.tschofenig-oauth-hotk;

    <reference anchor="NIST800-63">
        <front>
          <title>NIST Special Publication 800-63-1, INFORMATION SECURITY</title>
          <author fullname="William E. Burr" initials="W." surname="Burr">
            <organization>NIST</organization>
          </author>
          <author fullname="Donna F. Dodson" initials="D." surname="Dodson">
            <organization>NIST</organization>
          </author>
          <author fullname="Ray A. Perlner" initials="R." surname="Perlner">
            <organization>NIST</organization>
          </author>
          <author fullname="W. Timothy Polk" initials="T." surname="Polk">
            <organization>NIST</organization>
          </author>
          <author fullname="Sarbari Gupta" initials="S." surname="Gupta">
            <organization>NIST</organization>
          </author>
          <author fullname="Emad A. Nabbus" initials="E." surname="Nabbus">
            <organization>NIST</organization>
          </author>
          <date month="December" year="2008"/>
        </front>
        <format target="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-63-Rev.%201" type="HTML"/>
     </reference>
          
     </references> 
  </back>
</rfc>
