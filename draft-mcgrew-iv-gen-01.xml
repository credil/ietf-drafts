<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc1361 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1361.xml">
<!ENTITY rfc1918 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1918.xml">
<!ENTITY rfc3768 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3768.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2434 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2434.xml">
<!ENTITY rfc3711 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY rfc2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY rfc2202 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2202.xml">
<!ENTITY rfc4086 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY rfc4106 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4106.xml">
<!ENTITY rfc4107 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4107.xml">
<!ENTITY rfc4418 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4118.xml">
<!ENTITY rfc3686 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3686.xml">
<!ENTITY rfc4309 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4309.xml">
<!ENTITY rfc5116 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5116.xml">
<!ENTITY rfc5282 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5282.xml">
<!ENTITY rfc5288 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5288.xml">
<!ENTITY rfc5647 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5647.xml">
<!ENTITY rfc6054 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6054.xml">
<!ENTITY rfc6146 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6146.xml">
<!ENTITY rfc2104 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY rfc5295 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5295.xml">
<!ENTITY rfc3095 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3095.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<rfc category="std" docName="draft-mcgrew-iv-gen-01.txt" ipr="trust200902">
  <front>
    <title abbrev="Deterministic IV Generation">
      Generation of Deterministic Initialization Vectors (IVs) and Nonces 
    </title>

    <author fullname="David A. McGrew" initials="D.A.M." surname="McGrew">
      <organization>Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>510 McCarthy Blvd.</street>

          <city>Milpitas</city>

          <region>CA</region>

          <code>95035</code>

          <country>US</country>
        </postal>

        <phone>(408) 525 8651</phone>

        <email>mcgrew@cisco.com</email>

        <uri>http://www.mindspring.com/~dmcgrew/dam.htm</uri>
      </address>
    </author>

    <date month="October" year="2011" />

    <area>General</area>

    <keyword>Encryption, Authentication</keyword>

    <abstract>
      <t>
	Many cryptographic algorithms use deterministic IVs, including
	CTR, GCM, CCM, GMAC.  This type of IV is also called a
	(deterministic) nonce.  Deterministic IVs must be distinct, for
	each fixed key, to guarantee the security of the algorithm.
	This note describes best practices for the generation of such
	IVs, and summarizes how they are generated and used in
	different protocols.  Some problem areas are highlighted, and
	test considerations are outlined.  This note will be useful to
	implementers of algorithms using deterministic IVs, and to
	protocol or system designers using them.
      </t>
    </abstract>
  </front>
  
<middle>
<section title="Introduction">
  <t>
<!--    Many of the newer cryptographic algorithms use deterministic IVs,
    and these algorithms are used in standard protocols.  These
    standards use similar, but in some cases slightly different,
    formats.  Th
  --> This note describes deterministic IVs and nonces and how they
   are used in cryptographic algorithms (<xref target="algos"/>), then
   describes their use in protocols (<xref target="protos"/>), and
   then their use in standards (<xref target="stds"/>).
   Considerations for implementation (<xref target="impl"/>) and
   testing (<xref target="test"/>) are presented.  Issues and
   potential problems are discussed (<xref target="issues"/>).  The
   focus is on network security protocols, rather than on the security
   of data at rest, though many of the same considerations apply in
   both areas.
  </t>
   <section title="Conventions Used In This Document">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
   </section>
</section>

<section anchor="algos" title="Deterministic IVs in Algorithms">
  <t>
    Many cryptographic algorithms use Initialization Vectors, or IVs.
    An IV is provided to an algorithm along with a message to be
    processed; the IV initializes the algorithm to process the
    message.  Typically, there will be many IVs that are used with a
    single key.  Some algorithms, such as the Cipher Block Chaining
    (CBC) encryption mode, require that the IVs that it uses are
    completely unpredictable.  Such IVs are typically called random
    IVs, and they must be generated by a cryptographically strong
    random or pseudorandom process <xref target="RFC4086"/>.
    </t>
  <t>
    Another type of IVs are deterministic IVs.  These IVs are
    generated by a deterministic process.  The classic example of an
    algorithm that uses a deterministic IV is counter (CTR) mode
    encryption <xref target="CTR"/>. An algorithm that uses
    deterministic IVs requires that each IV provided as input to the
    algorithm be distinct, for a fixed key.
  </t>
  <t>
    A deterministic IV is sometimes called a nonce, or a deterministic
    nonce.  In cryptography, a nonce is a value that is used only
    once.  Many cryptographic protocols include a nonce in a message
    to enable its receiver to recognize whether or not the message has
    been previously received and processed.  From the point of view of
    a cryptographic algorithm that uses deterministic IVs, calling the
    IV a nonce emphasizes the role of the IV in the overall system.
    Calling that value a deterministic IV emphasizes its role in
    initializing the algorithm to process a new message.  Nonetheless,
    these are different monikers for the same thing.
  </t>
  <t>
    Authenticated Encryption is a symmetric encryption method that
    provides for the authenticity and integrity of the data that it
    protects, as well as its confidentiality <xref target="BN00"/>
    <xref target="R02"/>.  An authenticated encryption method that
    uses deterministic IVs will need to make sure that the IVs used
    for encryption are distinct.  However, when performing the
    decryption operation, there is no need to ensure that the IVs are
    distinct; the authenticated decryption operation does not impose
    that requirement.  The Authenticated Encryption methods used in
    standards include Galois Counter Mode <xref target="GCM"/> and
    Counter and CBC MAC mode <xref target="CCM"/>.
    </t>
  <t>
    Some Message Authentication Code (MACs) use deterministic IVs,
    including GMAC <xref target="GCM"/> and UMAC
    <xref target="RFC4118"/>.  The considerations for Authenticated
    Encryption also apply to these MAC algorithms: the IVs used in the
    generation of an authentication tag must be distinct, but there is
    no need to verify the distinctness of an IV prior to inputting
    that IV to a tag verification algorithm.
  </t>

</section>
<section anchor="protos" title="Deterministic IVs in Protocols">
  <t>
    The simplest way to implement a deterministic IV or nonce is to
    use a counter: initialize an integer variable to zero, then each
    time that an IV is needed, output the integer value, then store
    the incremented value after checking to make sure that no integer
    overflow occurred, so that no counter value is used twice.  The
    simplicity of this method has made it popular in practice, and
    recommended by standards.
  </t>
  <t>
    The straightforward method of using a counter is not sufficient
    when there are multiple encryption engines that are using the same
    encryption key.  This can be the case when encryption is
    distributed across multiple processors, or across multiple
    software threads, processes, or virtual machines.  It can also
    happen in cases where a protocol allows group keys.  In these
    cases, some mechanism is needed that ensures that IVs are distinct
    across all encryption engines that use the same key.  This is
    easily accomplished by including a fixed field in the IV that is
    distinct for each distinct encrypter.  (This is detailed in 
    <xref target="rec"/>.)
  </t>
  <t>
    When a deterministic IV is used to encrypt and/or authenticate a
    message, the receiver(s) of that message needs to know that IV in
    order to decrypt it and/or verify its authenticity.  A
    deterministic IV can be sent along with a message, which makes it
    plain to the receiver(s), or it can be left out of a message if
    the receiver(s) have enough information to reconstruct it.  
    Leaving the IV out of the message reduces the amount of data
    that must be communicated, which is advantageous.  On the
    other hand, if the IV is included in the message, the 
    receiver(s) need not be aware of the method by 
    which the sender has chosen the IVs.  
  </t>
  <t>
    In practice, some protocols have split the difference between the
    implicit method (in which the IV is absent and a receiver infers
    its value) and the explicit method (in which the entire IV is
    included with the message).  The IV is constructed out of two
    fields: an explicit field, which is conveyed along with the
    message, and an implicit field, which is coordinated between the
    encrypter and the decrypter using an "out of band" method.  (This
    is detailed in <xref target="implicit"/>.)  In most cases, the key
    management protocol that establishes the encryption key can also
    establish the implicit field.
  </t>
  <t>
    In a block cipher mode of operation that use deterministic IVs,
    the inputs to each of the block cipher invocations during the
    encryption process are determined by the IV provided to that
    process.  It is desirable to make the inputs to the block cipher
    unpredictable to an attacker, to the extent that is possible, to
    make cryptanalytic attacks more difficult and costly to attackers.
    This is true for several types of attacks, including time-memory
    tradeoff attacks and key collision attacks <xref target="MF00"/>,
    which are generic attacks that can reduce the cost of attacking
    any cipher, and cipher-specific attacks such as integral
    cryptanalysis <xref target="KW02"/>.  (It is worth noting that
    counter mode gives an attacker exactly what they want for integral
    cryptanalysis: a complete set of block cipher inputs that differ
    only in some bit positions.)  The cost of these attacks can be
    significantly increased by making the deterministic IV
    unpredictable to potential attackers.  This security benefit is
    one motivation for why the implicit field of the deterministic IV
    is kept secret in some protocols.
  </t>
  <t>
    It is not hard to adapt the simple methods for constructing
    deterministic IVs so that they produce IVs that are unpredictable.
    An easy way to do that is to have a secret value that is bitwise
    exclusive-ored into the IV after all of the other processing is
    done.  (This is detailed in <xref target="unpredict"/>.)  This secret
    value must be known to all encrypters and decrypters, and be
    established via some "out of band" mechanism.  In practice, it is
    typically established by the key management system.
  </t>
</section>
  <section anchor="stds" title="Deterministic IVs in Standards">
      <t> Many different protocols use deterministic IVs, including
	ESP <xref target="RFC4106"/>, TLS <xref target="RFC5288"/>, SSH
	<xref target="RFC5647"/>, and SRTP <xref target="RFC3711"/>.  The way
	that these protocols define their IVs is outlined
	in this section and is summarized in <xref target="iv_use"/>.
      </t>

      <section anchor="rec" title="Recommended IV/Nonce Format">
      <t>
	RFC 5116 defines the interface for Authenticated Encryption,
	which is the most common use of deterministic IVs at present.
	That RFC recommends an IV format, which is used by ESP, IKE,
	TLS, and SSH.  The recommended format has a total
	length of 12 octets, and consists of a Fixed Field and a
	Counter field, and is structured as in
	<xref target="nonceformat"/>.  (See Section 3.2 of
	<xref target="RFC5116"/> for the precise normative
	description.)
      </t>
       <figure anchor="nonceformat" title="Recommended IV/Nonce format.">
          <artwork><![CDATA[ 
   +-------------------------------+------------------------+
   |             Fixed             |         Counter        |
   +-------------------------------+------------------------+   
]]></artwork>
        </figure>
       <figure anchor="nonceformatX" title="An example output of recommended IV/nonce format, showing successive IVs where the Fixed field is 5DAD87F8.  ">
          <artwork><![CDATA[ 
                     Fixed      Counter
                    <------><-------------->
          1st       5DAD87F80000000000000001
          2nd       5DAD87F80000000000000002
          3rd       5DAD87F80000000000000003
          4th       5DAD87F80000000000000004
          5th       5DAD87F80000000000000005
          ...                  ...
]]></artwork>
        </figure>     

       <t>
        The Fixed field remains constant for all nonces that are
        generated for a given encryption device. If different devices
        are performing encryption with a single key, then each
        distinct device MUST use a distinct Fixed field, to ensure the
        uniqueness of the nonces.  
       </t>
       <t>
	 This format is suggested, but not required, by <xref target="CTR"/>.
       </t>
       </section>
      <section anchor="implicit" title="Partially Implicit IV/Nonce Format">
         <t>
	 The case in which the recommended format is used
	 with Partially Implicit Nonces has further details.  
	 In that case, the IV is structured as in <xref target="nonceexplicit"/>.
         </t>

      <figure anchor="nonceexplicit"
              title="Partially implicit IV/Nonce format">
        <artwork><![CDATA[ 
   +--------------+----------------+------------------------+
   | Fixed-Common | Fixed-Distinct |         Counter        |
   +--------------+----------------+------------------------+
    <- implicit -> <--------------- explicit -------------->
]]></artwork>
      </figure>      
       <figure anchor="partimplicitX" title="An example output of Partially Implicit IV/Nonce format, showing successive IVs where the Fixed-Common field is 5DAD87F8 and the Fixed-Distinct field is 1E0E.">
          <artwork><![CDATA[ 
                   Fixed  Fixed       
                   Common Distinct  Counter
                   <------><--><---------->
         1st       5DAD87F81E0E000000000001
         2nd       5DAD87F81E0E000000000002
         3rd       5DAD87F81E0E000000000003
         4th       5DAD87F81E0E000000000004
         5th       5DAD87F81E0E000000000005
         ...                 ...
]]></artwork>
        </figure>     
      <t>
	The portion of the IV that is stored or sent with the ciphertext is
	the explicit part.  The portion of the IV that is not sent with the
	ciphertext is the implicit part.
      </t>
      <t>
	The Fixed field is divided into two sub-fields: a Fixed-Common
	field and a Fixed-Distinct field.
      </t>
      <t>
	If different devices are performing encryption with a single key,
	then each distinct device MUST use a distinct Fixed-Distinct field.
	The Fixed-Common field is common to all IVs.  The Fixed-Distinct
	field and the Counter field MUST be in the explicit part of the
	IV.  The Fixed-Common field MAY be in the implicit part of the
	IV.
      </t>
      <t>
	ESP, IKE, TLS, and SSH conform to the RFC 5116 Partially Implicit
	Nonces format, though they do not require that the "Counter"
	field actually be an integer counter (instead, "anything that
	guarantees uniqueness can be used").  
	</t>
      <t>
	The partially implicit format can save on bandwidth or data
	storage requirements, because it avoids sending or storing the
	implicit part of the IV.  However, it limits the number of IVs
	that can be generated, because the implicit part is fixed, and
	it adds complexity to the system, by making the system
	coordinate the implicit part through out-of-band means.  Thus,
	new protocol and system designs SHOULD NOT use the partially
	implicit format unless a review of all of the issues shows
	that the bandwidth or storage savings are worth the
	complexity.  (An alternative strategy for bandwidth savings is
	discussed in <xref target="bandwidth"/>.)
	</t>
      </section>
      <section anchor="unpredict" title="Unpredictable IV/Nonce Format">
	<t>
	  This method is shown in <xref target="unpred"/>, in which
          the symbol (+) denotes the bitwise exclusive-or operation.
          (Here the Fixed field consists of the Fixed-Common field
          followed by the Fixed-Distinct field.)  This format uses a
          Randomizer, which is an octet string that is combined with
          the other fields to make the IVs unpredictable.  The length
          of the Randomizer must be no greater than the sum of the lengths
	  of the Fixed and Counter fields.  
	</t>
	<t>
	  The next IV in sequence is computed as follows. The Fixed
          field and the Counter field are concatenated.  If the length
          of the Randomizer is less than the combined length of the
          Fixed and Counter fields, then the Randomizer is padded on
          the right with enough zeros so that the padded value has a
          length that exactly matches that of the Fixed and Counter
          fields together.  The concatenated Fixed and Counter field
          is bitwise exclusive-ored with the padded Randomizer, and
          the resulting value is the IV.  The Counter is incremented,
          treating it as an unsigned integer with the most significant
          byte on the left, and the stored Counter field is set to the
          incremented value.  Then the IV is returned.  This is the
          method used by SRTP <xref target="RFC3711"/>, wherein the
          Randomizer field is called "Salt".  (We use the term Randomizer
	  instead of Salt, because the latter term is used with
	  slightly different meanings in some other specifications,
	  such as <xref target="RFC4309"/>.)
	</t>
<figure anchor="unpred" title="Unpredictable IV/Nonce Format.  ">
<artwork><![CDATA[
              +-----------------+-----------------+
              |     Fixed       |      Counter    |---+
              +-----------------+-----------------+   |
                                                      |
              +-----------------------------------+   v
              |             Randomizer            |->(+)
              +-----------------------------------+   |
                                                      |
              +-----------------------------------+   |
              |       Initialization Vector       |<--+
              +-----------------------------------+
  
]]></artwork>
</figure>
<figure anchor="unpredX" title="An example output of the Unpredictable IV/nonce format, showing successive IVs where the Fixed-Distinct field has the value 97B4AE8F and the Salt has value 0C8150CEF354678EE16FA2D1.">
          <artwork><![CDATA[ 
             Fixed  Fixed                                 
             Common Distinct   Counter            IV         
              <--><------><---------->  <----------------------> 
    1st       000097B4AE8F000000000001  0C81C77A5DDB678EE16FA2D0
    2nd       000097B4AE8F000000000002  0C81C77A5DDB678EE16FA2D3
    3rd       000097B4AE8F000000000003  0C81C77A5DDB678EE16FA2D2
    4th       000097B4AE8F000000000004  0C81C77A5DDB678EE16FA2D5
    5th       000097B4AE8F000000000005  0C81C77A5DDB678EE16FA2D4
    ...                     ...
]]></artwork>
        </figure>     
      </section>
      <section title="ESP">
      <t>
	In the IP Encapsulating Security Payload (ESP)
	<xref target="RFC3686"/><xref target="RFC4106"/><xref target="RFC4309"/>
	the implicit and explicit parts are four and eight bytes long,
	respectively.  The exception is <xref target="RFC4309"/>, for
	which the implicit part is three bytes in length.  The
	Fixed-Common field is four bytes, and its value is set by the
	Internet Key Exchange (IKE).  (This field is named
	inconsistently, being called Nonce in
	<xref target="RFC3686"/>, and Salt in <xref target="RFC4106"/>
	and <xref target="RFC4309"/>.)  When ESP is used with IKE,
	there is exactly one entity performing encryption, and the
	Fixed-Distinct part is usually not present (or equivalently,
	is has a length of zero bytes).  When ESP is used with a group
	key management protocol such as GDOI, the Fixed-Distinct field
	may be two or four bytes in length, and the value of the
	Fixed-Distinct field to be used by an encrypter is established
	by the group key management protocol <xref target="RFC6054"/>.
	The case in which IKE is used with ESP and there are multiple
	encryption engines is not specifically addressed by the
	standards, but it can be handled by the use of a nonzero
	Fixed-Distinct field.
      </t>
      </section>
      <section title="IKE">
      <t>
      The Internet Key Exchange (IKE) <xref target="RFC5282"/> uses
      the recommended IV/nonce format.  The Fixed-Common field is four
      bytes in length, and its value is set from the IKE Keying
      Material.  The Fixed-Distinct part is usually zero bytes, but it
      may be any number of bytes if there are multiple encrypters in
      use.
      </t>
      </section>
      <section title="TLS">
      <t>
      In Transport Layer Security (TLS) <xref target="RFC5288"/>, the
      Fixed-Common field is four bytes in length, and the
      Fixed-Distinct part is usually zero bytes, but it may be any
      number of bytes when there are multiple encrypters in use.
      Section 6.2 of <xref target="RFC5288"/> gives an example of TLS
      deterministic IV formation.
      </t>
      </section>
      <section title="SSH">
	<t>
	In the Secure Shell (SSH) protocol <xref target="RFC5647"/>
	the Fixed-Common field is not present, the Fixed-Distinct
	field is four bytes long, and the Counter field is eight bytes
	in length.  The implicit part is not present, and the explicit
	part contains the entire 12 byte IV.
	<!-- http://tools.ietf.org/html/rfc5647#section-7.1 -->	
      </t>
	</section>
      <section title="SRTP">
	<t>
	In the Secure Real-time Transport Protocol (SRTP)
	<xref target="RFC3711"/> and draft-ietf-avt-srtp-aes-gcm-01
	the IV formation is a bit more complex than RFC 5116.  It is
	essentially RFC 5116 format with the additional step of
	performing a bitwise exclusive-or operation with a Randomizer
	value.  (This step provides additional strength against
	cryptographic attacks that rely on predicting all or most of
	the IV.)  draft-ietf-avt-srtp-aes-gcm-01 uses a 12-byte IV,
	though RFC 3711 uses a 14-byte IV.
	</t>
	</section>
  <section title="Summary">
<t>
  The following table gives a synopsis of how standard protocols
  use deterministic IVs.
</t>
<texttable anchor="iv_use" title="Fields in Deterministic IVs, by Protocol.">
    <ttcol align='center'>Protocol</ttcol>
    <ttcol align='center'>IV (bytes)</ttcol>
    <ttcol align='center'>Fixed-Common (bytes)</ttcol>
    <ttcol align='center'>Fixed-Distinct (bytes)</ttcol>
    <ttcol align='center'>Counter (bytes)</ttcol>
    <c>ESP</c>
    <c> 12 </c>
    <c> 4  </c>
    <c> 0,1,2,[4]</c>
    <c> 8,7,6,[4]</c>
    <c> </c>
    <c> </c>
    <c> Not on wire</c>
    <c> On wire</c>
    <c> On wire </c>
    <c> </c>
    <c> </c>
    <c> Set by IKE </c>
    <c> </c>
    <c> </c>
    <c>ESP</c>
    <c> 11 </c>
    <c> 3  </c>
    <c> 0,1,2,[4]</c>
    <c> 8,7,6,[4]</c>
    <c> <xref target="RFC4309"/> </c>
    <c> </c>
    <c> Not on wire</c>
    <c> On wire</c>
    <c> On wire </c>
    <c> </c>
    <c> </c>
    <c> Set by IKE </c>
    <c> </c>
    <c> </c>
    <c>IKE</c>
    <c> 12 </c>
    <c> 4  </c>
    <c> Unspecified </c>
    <c> Unspecified </c>
    <c> </c>
    <c> </c>
    <c> Not on wire</c>
    <c> On wire</c>
    <c> On wire </c>
    <c> </c>
    <c> </c>
    <c> Set from KM </c>
    <c> </c>
    <c> </c>
    <c>TLS</c>
    <c> 12 </c>
    <c> 4  </c>
    <c> 0-8</c>
    <c> 8-0</c>
    <c> </c>
    <c> </c>
    <c> Not on wire</c>
    <c> On wire</c>
    <c> On wire </c>
    <c> </c>
    <c> </c>
    <c> Set by TLS </c>
    <c> </c>
    <c> </c>
    <c>SSH</c>
    <c> 12 </c>
    <c> 0  </c>
    <c> 4</c>
    <c> 8</c>
    <c> </c>
    <c> </c>
    <c> </c>
    <c> On wire</c>
    <c> On wire </c>
    <c> </c>
    <c> </c>
    <c> </c>
    <c> Unspecified </c>
    <c> </c>
    <c>SRTP-CTR </c>
    <c> 14 </c>
    <c> 4  </c>
    <c> 4 </c>
    <c> 6</c>
    <c> </c>
    <c> </c>
    <c> Not on wire </c>
    <c> Not on wire</c>
    <c> Not on wire </c>
    <c> </c>
    <c> </c>
    <c> Set by KM </c>
    <c> </c>
    <c> </c>
    <c>SRTP-GCM</c>
    <c> 12 </c>
    <c> 2  </c>
    <c> 4</c>
    <c> 6</c>
    <c> </c>
    <c> </c>
    <c> Not on wire</c>
    <c> Not on wire </c>
    <c> Not on wire </c>
    <c> </c>
    <c> </c>
    <c> Set by KM </c>
    <c> </c>
    <c> </c>
</texttable>

</section>

  </section>


<section anchor="impl" title="Implementation">
<t>
A cryptographic implementation typically consists of a self-contained
and testable module that implements all of the essential functionality
that it needs.  This functionality should include the generation of
deterministic IVs.
</t>
<t>
Because of the variety of ways in which IVs are formed in different
protocols, implementers may be tempted to put the generation of the IV
under the control of the protocol implementation.  That is, from the
point of view of the application making use of the encryption
algorithm, the IV is an input to that algorithm, as shown in
<xref target="archbad"/>.  Regardless, it is not good for security to
have the IV be generated outside the crypto module.  It is possible to
implement an IV Generator that can be used with all of the protocols
outlined above and use it inside of a cryptographic module.  In the
following we outline how that can be done.
</t>
<figure anchor="archbad" title="Architecture with IV generation outside of the cryptographic module, showing how the IV is entered into the cryptographic module during an encryption operation.   ">
<artwork><![CDATA[
        +----------------------+
        |  +--------------+    |      IV       +-------------+
        |  |              |<-------------------|             |
        |  |  Encryption  |    |   Plaintext   |             |
        |  |  Algorithm   |<-------------------| Application |
        |  |              |    |   Ciphertext  |             |
        |  |              |------------------->|             |
        |  +--------------+    |               +-------------+
        |                      |
        | Cryptographic Module |
        +----------------------+  
]]></artwork>
</figure>
<t>
The internal IV generator architecture is illustrated in
<xref target="archgood"/>.  The cryptographic module contains an IV
Generator sub-module that understands the IV formats outlined in
<xref target="protos"/>.  To initialize the IV generator, the
application inputs the parameter values to be used.  Once initialized,
the IV generator will produce successive IVs on request, and send
these values to the algorithm and to the calling application.  The
encryption algorithm will need the entire IV, but if the partially
implicit IV format is in use, only the explicit part of the IV needs
to be provided to the application.   The IV generator is responsible
for ensuring the distinctness of all of the IVs that it generates.  
</t>
<figure anchor="archgood" title="Architecture with IV generation inside of the cryptographic module, showing how the IV is generated internally during an encryption operation.  ">
<artwork><![CDATA[
        +----------------------+
        |  +--------------+    |
        |  | IV Generator |-----------+
        |  +--------------+    |      | IV (explicit part)
        |         | IV         |      | 
        |         v            |      |
        |  +--------------+    |      |        +-------------+
        |  |              |           +------->|             |
        |  |  Encryption  |    |   Plaintext   |             |
        |  |  Algorithm   |<-------------------| Application |
        |  |              |    |   Ciphertext  |             |
        |  |              |------------------->|             |
        |  +--------------+    |               +-------------+
        |                      |
        | Cryptographic Module |
        +----------------------+  
]]></artwork>
</figure>
<t>
More formally, an IV generator supports the operations of Initialize
and Output Next IV.  The Initialize operation prepares an IV Generator
for use with a particular set of parameters.  It takes the following
inputs:
<list>
  <t>
    A nonnegative integer indicating the number of bytes in the IV to
    be generated.  All of the IVs output from the Generator will have
    the same length.
  </t>
  <t>
    An octet string indicating the Fixed part of the IV; this value
    will be used as the initial part in each IV that is generated.
  </t>
  <t>
    A nonnegative integer indicating the number of bytes in the Fixed
    part of the IV.  This value must be no greater than the number of
    bytes in the IV.
  </t>
  <t>
    An octet string indicating the salt value to be exclusive-ored
    with the other fields of the IV.  If no salt is to be used when
    Generating IVs, then this parameter must not be present.
  </t>
  <t>
    A nonnegative integer indicating the number of bytes in the salt
    value.  If no salt value is used, this parameter must be zero.  If
    a salt value is used, this parameter must be no greater than
    the number of bytes in the IV.
  </t>
</list>
The Fixed field consists of the Fixed-Common field, followed by the
Fixed-Distinct field.  The Fixed field and Salt field are stored when
the IV generator is initialized; at that time, the Counter field is
initialized to zero.  The length of the Counter field is equal to the
length of the IV less the length of the Fixed field.  If the Salt
field is shorter than the IV, then it is padded on the right with
zeroes.  If no Salt is to be used, this is conceptually equivalent to
having a Salt value that is the all-zero value.
</t>
<t>
The Output Next IV operation returns the next IV in sequence, or it
returns an indication that there are no more IVs that are available.
During that operation, the IV is computed as follows.  First, the
stored Counter value MUST be checked to determine if an IV can be
generated; an IV can only be generated if the value of Counter + 1
does not exceed the maximum allowable value of the Counter field.  If
an IV cannot be generated, then the operation returns an indication
that there are no more IVs that are available.  Otherwise, the Fixed
field and the Counter field are concatenated, then they are bitwise
exclusive-ored with the Salt field, and the resulting value is the IV.
The Counter is incremented, treating it as an unsigned integer with
the most significant byte on the left, and the stored Counter field is
set to the incremented value.  Then the IV is returned.
</t>
<t>
The IV generator should also be able to output the length of the
explicit field, so that an algorithm can output only the explicit
part, when that is appropriate.
</t>
<section title="IV Verification">
<t>
In some protocols, the IV is constructed out of fields in the protocol
in such a way that it is difficult to have the IVs generated inside of
the cryptographic module, without requiring that module to contain
protocol-specific logic.  In this case, assurance of the uniqueness of
IVs can be provided by having the IVs be generated by the protocol,
but checked by the cryptographic module.  
</t>
<t>
This approach is taken by many implementations of Secure RTP
<xref target="RFC3711"/>.  The IV in that protocol is constructed in
a way that incorporates a sender identifier (the SSRC field) and the
protocol's sequence number.  To check the sequence number for
uniqueness, an implementation can make use of the anti-replay checking
that the protocol uses to check inbound packet.  An encrypter can use
this approach as well, to make sure that the sequence number used to
construct the IV is unique.  (Of course, it is necessary to have an IV
construction method such that the uniqueness of the sequence number
ensures the uniqueness of the IV.)  Since many cryptographic protocols
contain a function to perform anti-replay check based on a sequence
number, this is a convenient strategy.
</t>
</section>
</section>
  <section anchor="test" title="Testing">
    <t>
      The testing of a cryptographic module is an important step in
      assessing the assurance of that module.  The IV Generator
      defined in <xref target="impl"/> can be tested by an external
      system to verify that it is operating correctly.
    </t>
    <t>
      The recommended IV format can be tested by verifying that all
      of the IVs are distinct.   There are many ways that this 
      can be done; for instance, the command "sort | uniq -d" 
      on POSIX systems can be used to detect repeated lines
      in a file.      
    </t>
<!--
    <t>
      The partially implicit IV format can be tested by verifying that
      all of the explicit parts are distinct.
    </t>
-->    <t>
      An important aspect of an IV generator is that, when it has an N
      byte Counter field, it should not generate more than (256)^N
      IVs.  This property should be tested for small values of N (at
      least 1, 2, and 3), by calling the Output Next IV operation M
      times, for some M > (256)^N.  Note that some implementations may produce
      fewer than (256)^N IVs, e.g. due to their handling of the
      all-zero IV.  That would not affect security.      
    </t>
  <section title="Internal IV Generator">
    <t>
      When a cryptographic module uses an internal IV generator, only
      the explicit part of the IV needs to be output from the module.
      It is possible to test this use of the IV generator by
      interacting with an encryption algorithm that uses it
      (or an Authenticated Encryption algorithm, or a MAC).
    </t>
    <t>
      The encryption operation takes as input a plaintext, and returns
      a ciphertext and the explicit part of the IV.  To test that the
      IV generator is working properly, call the encryption operation
      repeatedly, each time with the same plaintext value, and verify
      that 1) all of the ciphertexts returned are distinct, and 2) all
      of the explicit parts that are returned are distinct.  The
      plaintext must be at least 32 bytes long, in order to avoid
      false positives.
    </t>
  </section>
  </section>

<section anchor="issues" title="Issues">
<section title="Choice of Fixed-Distinct Field">
<t>
  When considering what data should go into a Fixed-Distinct field, it
  is tempting to use system values such as network addresses because
  they appear to meet the criteria of uniqueness.  However, there are
  several significant problems with this idea.  System values that are
  taken from outside the cryptographic module may not actually be
  distinct, especially if an attacker can influence the system.
  System values can also change over time; even if they are actually
  distinct, they may not be fixed.  Lastly, the cryptographic system
  should have the freedom to put distinct data into the Fixed-Distinct
  fields, so that it can accommodate multiple encryption engines when
  they occur.
</t>
<t>
  <!-- For concreteness, we review the case of network addresses.  -->
  Internet Protocol (IP) version four addresses are four bytes in
  length, and thus can fit into the Fixed-Distinct field of a 12-byte
  IV.  However, an IP address is highly unsuitable for this purpose.
  Most networked devices use dynamically assigned IP addresses, with
  address assignment via an automatic configuration protocol such as
  the Dynamic Host Configuration Protocol (DHCP).  The addresses are
  determined by an external system and are communicated over an
  insecure protocol; furthermore, a DHCP address is only valid for a
  particular period of time, and may change after that lease has
  expired.  Even when an automatic configuration protocol is not in
  use, IP addresses are determined by the networking subsystem, and
  are not under the control of the cryptographic module.  Network
  Address Translation (NAT, <xref target="RFC1361"/>) is commonly used
  to modify the IP addresses of packets as they traverse a network
  boundary, for instance between a private address space
  <xref target="RFC1918"/> and the Internet.  Because of NAT, the IP
  address associated with a particular device will not be consistent
  throughout the network.  Multiple devices can use the same
  addresses; this technique is utilized in order to provide redundancy
  or load sharing (see the Virtual Router Redundancy Protocol
  <xref target="RFC3768"/> for instance).  Lastly, IPv4 is currently
  being replaced by version six of that protocol.  IPv6 addresses are
  sixteen bytes long; this is too long for inclusion in an IV, and
  the coexistence of both versions on the Internet is likely to
  increase the use of NAT for protocol translation
  <xref target="RFC6146"/>.  In summary, IP addresses are neither
  fixed nor distinct, and should not be used in a Fixed-Distinct
  field.
</t>
<t>
  Similar considerations hold for link layer addresses, Domain Name
  System (DNS) names, and TCP, UDP, and SCTP ports.
</t>
<t>
  A much better solution is to have the Fixed-Distinct field be
assigned by the security system.  For instance, if a cryptographic
module has multiple encrypters, it can assign that field appropriately
for each encrypter.
</t>
</section>
<section title="Size of the Fixed-Distinct Field">
<t>
  Deterministic IVs typically have an explicit part that is eight
  bytes in length.  (This size is natural to use with a block cipher
  that has a 16 byte block width, because no more than (256)^8 packets
  can be encrypted under a single key without encountering security
  degradation due to the birthday paradox.)  Because the
  Fixed-Distinct field must appear in the explicit part, larger
  Fixed-Distinct fields will reduce the number of IVs that can be
  generated.  This can be problematic, especially for high throughput
  situations.  For instance, the ESP protocol allows for up to 2^64
  packets to be encrypted under a single key, so it is desirable to
  use a Counter field that is close to eight bytes in length; this is
  why <xref target="RFC6054"/> encourages the use of short values in
  the Fixed-Distinct field.  <xref target="times"/> presents the
  lifetimes of a single key that can encrypt 2^32 packets, i.e.  a key
  being used with a four-byte Counter field.  At high data rates, keys
  must be replaced quickly.  
</t>
<t>
</t>
<texttable anchor="times" title="Key Lifetimes with a four-byte Counter field">
  <ttcol align='center'> </ttcol>
  <ttcol align='center'> Best Case </ttcol>
  <ttcol align='center'> Typical Case </ttcol>
  <ttcol align='center'> Worst Case </ttcol>
  <c> </c>
<c>  9000 byte packets </c>
<c>  850 byte packets  </c>
<c>  64 byte packets   </c>
<c>  1 Gbps	       </c>
<c>  3 days	       </c>
<c>  8.6 hours	       </c>
<c>  66 minutes	       </c>
<c>  10 Gbps	       </c>
<c>  8.6 hours	       </c>
<c>  52 minutes	       </c>
<c>  6.6 minutes       </c>
<c>  40 Gbps	       </c>
<c>  22 minutes	       </c>
<c>  13 minutes	       </c>
<c>  1.6 minutes       </c>
<c>  100 Gbps	       </c>
<c>  8.9 minutes       </c>
<c>  5.2 minutes       </c>
<c>  0.7 minutes       </c>
</texttable>
</section>

<section title="Security">
<t>
  As long as each deterministic IV is distinct, for each key, then
  security is assured.  However, when deterministic IVs are not
  distinct, security suffers.  
</t>
<t>
  The number of deterministic IVs is limited, regardless of how those
  IVs are generated.  What does an encrypter do when no more IVs are
  available?  It should retire the key that it is currently using, and
  establish another one.  This is the reason that the IETF Guidelines
  for Cryptographic Key Management <xref target="RFC4107"/> require
  that automated key management be used for algorithms with
  deterministic IVs.  For network security protocols, this has proven
  to be an effective strategy.  
</t>
<t>
  Particular care must be taken in Virtual Machine (VM) environments,
  because the VM cloning and rollback processes can cause inadvertent
  re-use of deterministic IVs.  This is just one of many security
  problems that can result from uncritical application of VM 
  mechanisms when cryptography is in use <xref target="GR05"/>.
</t>
</section>

<section anchor="bandwidth" title="Bandwidth Use">
<t>
An implicit or partially implicit IV uses less bandwidth than a
full-sized IV.  But as noted above, the (partially) implicit IV
format reduces the number of IVs that can be generated and
adds complexity to the system.  
</t>
<t>
An alternative approach to bandwidth savings in a protocol design is
to use a predictable IV format, such as that of <xref target="rec"/>,
and then apply header compression to the IV.  Header compression is
often used on bandwidth-constrained links, and it can be applied to
encrypted packets <xref target="RFC3095"/>.  The format of
<xref target="rec"/> can easily be handled by header compression.
This approach has several benefits: it makes IV generation simpler, it
allows bandwidth savings for environments in which it matters while
putting the complexity burden onto the systems that opt to realize
those savings, and it increases the number of IVs that can be used.
Specifications that use this design alternative SHOULD require the use of the
IV format in <xref target="rec"/>.
</t>
</section>

</section>

<!--
<section title="Perspective">
<t>
  This note focuses on problems in the use of deterministic IVs.
  It is perhaps worthwhile to consider issues with 
</t>
</section>
-->


  <section title="Security Considerations">
    <t>
      Cryptographic algorithms that rely on deterministic IVs or
      nonces must ensure the uniqueness of those values.  The
      recommendations in this note aim to help implementers
      achieve that goal.
      </t>
    <t>
      Implementations should use the nonce formats described in <xref target="protos"/>.
      The way in which these formats are used in standards is summarized in 
      <xref target="iv_use"/>.
    </t>
    <t>
      Implementations should use the internal IV generator described in <xref target="impl"/>.
    </t>
    <t>
      Almost all cryptographic systems can implement counter-based
      deterministic IVs.  In many cases, it is straightforward to
      generate deterministic IVs associated with a short-term key in
      use by a single encrypter, as in a typical point-to-point
      protocol.  Complications can arise, however, when there are
      multiple encrypters, or when a key is used for an extended
      period of time.  Cryptographic systems that cannot ensure IV
      distinctness should not use deterministic IVs, and should
      instead use a misuse-resistant mode of operation such as the
      Synthetic Initialization Vector (SIV) Authenticated Encryption
      mode of operation <xref target="RFC5295"/>, or a randomized
      algorithm such as the CBC mode of operation (though an
      additional authentication mechanism must be used with that
      option).  If authentication but not encryption is required, then
      it is possible to use an algorithm that does not require an IV,
      such as HMAC <xref target="RFC2104"/>.
    </t>

  </section>


    <section title="Acknowledgments">
      <t>
	Thanks to Greg Zaverucha and Peter Gutmann for comments.
      </t>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      &rfc1361;
      &rfc1918;
      &rfc2119;
      &rfc3768;

    <reference anchor="GCM">
        <front>
          <title>NIST Special Publication 800-38D: Recommendation for
                 Block Cipher Modes of Operation: Galois/Counter Mode
                 (GCM) and GMAC. </title>

          <author fullname="Morris Dworkin" initials="M." surname="Dworkin">
            <organization>U. S. National Institute of Standards and
            Technology (NIST)</organization>
          </author>

        </front>

        <seriesInfo name="U.S. National Institute of Standards and Technology"
              value="http://csrc.nist.gov/publications/nistpubs/800-38D/SP800-38D.pdf"      />
      </reference>

      <reference anchor="MF00">
        <front>
          <title>
	    Attacks on Additive Encryption of Redundant Plaintext and Implications
	    on Internet Security
	  </title>

          <author fullname="David McGrew" initials="D." surname="McGrew">
          </author>
          <author fullname="Scott Fluhrer" initials="S." surname="Fluhrer">
          </author>

        </front>

        <seriesInfo name="Proceedings of the Seventh Annual Workshop
              on Selected Areas in Cryptography (SAC 2000)"
              value="Spinger-Verlag"
              />
      </reference>




<!--      <reference anchor="GCM">
        <front>
          <title>The Galois/Counter Mode of Operation (GCM)</title>

          <author fullname="David A. McGrew" initials="D.A." surname="McGrew">
            <organization></organization>
          </author>

          <author fullname="John Viega" initials="J." surname="Viega">
            <organization></organization>
          </author>

          <date month="January" year="2004" />
        </front>

        <seriesInfo name="Submission to NIST"
                    value="http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/gcm/gcm-spec.pdf" />
      </reference>
-->


      <reference anchor="CCM">
        <front>
          <title>NIST Special Publication 800-38C: The CCM Mode for
          Authentication and Confidentiality</title>

          <author fullname="Morris Dworkin" initials="M." surname="Dworkin">
            <organization>U. S. National Institute of Standards and
            Technology (NIST)</organization>
          </author>
        </front>

        <seriesInfo name="U.S. National Institute of Standards and Technology"
                    value="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf" />
      </reference>

<!--
      <reference anchor="SHA1">
        <front>
          <title>FIPS 180-1: Secure Hash Standard,</title>

          <author fullname="U.S. National Institute of Standards and Technology (NIST)">
            <organization />
          </author>
        </front>

        <seriesInfo name="Federal Information Processing Standard (FIPS)"
                    value="http://www.itl.nist.gov/fipspubs/fip180-1.htm" />
      </reference>

-->

    </references>

    <references title="Informative References">

      &rfc5295;
      &rfc2104;
      &rfc3095;

      <reference anchor="BN00">
        <front>
          <title>Authenticated encryption: Relations among notions and
          analysis of the generic composition paradigm</title>

          <author fullname="Mihir Bellare and Chanathip Namprempre"
		  initials="M." surname="Bellare">
            <organization />
          </author>
	    <author initials="C." surname="Namprempre">
	      <organization />
	      </author>
        </front>

        <seriesInfo name="Proceedings of ASIACRYPT 2000, Springer-Verlag, LNCS 1976, pp. 531-545"
                    value="http://www-cse.ucsd.edu/users/mihir/papers/oem.html" />
      </reference>

      <reference anchor="R02">
        <front>
          <title>Authenticated encryption with Associated-Data</title>

          <author fullname="Phillip Rogaway"
		  initials="P." surname="Rogaway">
            <organization />
          </author>
        </front>

        <seriesInfo name="ACM Conference on Computer and Communication Security (CCS'02), pp. 98-107, ACM Press, 2002."
                    value="http://www.cs.ucdavis.edu/~rogaway/papers/ad.html" />
      </reference>


<!--
      <reference anchor="BOYD">
        <front>
          <title>
	  Protocols for Authentication and Key Establishment
	  </title>

          <author fullname="Colin Boyd" initials="C." surname="Boyd">
            <organization />
          </author>

          <author fullname="Anish Mathuria" initials="A." surname="Mathuria">
            <organization />
          </author>

        </front>

        <seriesInfo 
	   name="Springer, 2003"
           value="" />
      </reference>

      <reference anchor="EEM04">
        <front>
          <title>Breaking and provably repairing the SSH authenticated
          encryption scheme: A case study of the Encode-then-Encrypt-and-MAC
          paradigm</title>

          <author   initials="M." surname="Bellare">
            <organization />
          </author>
	    <author initials="C." surname="Namprempre">
	      <organization />
	      </author>
	    <author initials="T." surname="Kohno">
	      <organization />
	      </author>
        </front>

        <seriesInfo name="ACM Transactions on Information and System Security,"
                    value="http://www-cse.ucsd.edu/users/tkohno/papers/TISSEC04/" />
      </reference>

	<reference anchor="J02">
        <front>
          <title>On the Security of CTR + CBC-MAC</title>
	  <author initials="J." surname="Jonsson" fullname="Jakob Jonsson">
	      <organization/>
          </author>
	  <date  year="2002"/>
        </front>
        <seriesInfo name="Proceedings of the 9th Annual Workshop on Selected Areas on Cryptography," 
		    value="http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/ccm/ccm-ad1.pdf"/>
        </reference>

      <reference anchor="CMAC">
        <front>
          <title>NIST Special Publication 800-38B</title>

          <author fullname="M. Dworkin, U.S. National Institute of Standards and Technology (NIST))">
            <organization />
          </author>
        </front>

        <seriesInfo name=""
                    value="http://csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf" />
      </reference>


	<reference anchor="MV04">
        <front>
          <title>The Security and Performance of the Galois/Counter
          Mode (GCM)</title>
	  <author initials="D.A." surname="McGrew" fullname="David A. McGrew">
	      <organization/>
          </author>
	  <author initials="J." surname="Viega" fullname="John Viega">
	    <organization/>
	  </author>
	  <date month="December" year="2004"/>
        </front>
        <seriesInfo name="Proceedings of INDOCRYPT '04," value="http://eprint.iacr.org/2004/193"/>
        </reference>


-->

      <reference anchor="GR05">
	<front>
	  <title>
             When Virtual is Harder than Real: Security Challenges in
             Virtual Machine Based Computing Environments
	    </title>
	  <author fullname=" Tal Garfinkel" initials="T." surname="Garfinkel">
	  <organization />
	  </author>
	  <author fullname="Mendel Rosenblum" initials="M." surname="Rosenblum" >
	  <organization />
	  </author>
	  </front>
	  <seriesInfo
    name="Proceedings of the 10th Workshop on Hot Topics in Operating Systems"
    value="http://www.stanford.edu/~talg/papers/HOTOS05/virtual-harder-hotos05.pdf" 
	     />
	</reference>


      &rfc3711;

      &rfc4106;

      &rfc4309;

      &rfc5116;

      &rfc5282;

      &rfc5288;

      &rfc5647;

      &rfc6054;

      &rfc6146;




	<reference anchor="KW02">
        <front>
          <title>
	    Integral Cryptanalysis	    
	  </title>
	  <author initials="L." surname="Knudsen" fullname="Lars Knudsen">
	      <organization/>
          </author>
	  <author initials="D." surname="Wagner" fullname="David Wagner">
	    <organization/>
	  </author>
	  <date month="December" year="2001"/>
        </front>
        <seriesInfo name="9th International Workshop on Fast Software Encryption (FSE '02)" 
		    value="http://eprint.iacr.org/2004/193" />
        </reference>




      <reference anchor="CTR">
        <front>
          <title>NIST Special Publication 800-38: Recommendation for
            Block Cipher Modes of Operation
	  </title>

          <author fullname="Morris Dworkin" initials="M." surname="Dworkin">
            <organization />
          </author>
        </front>

        <seriesInfo name="U.S. National Institute of Standards and Technology"
                    value="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf" />
      </reference>






      &rfc4086;

      &rfc4418;

      &rfc3686;
      &rfc4107;


    </references>
  </back>
</rfc>
