<?xml version="1.0" encoding="US-ASCII"?>
<!-- $Id:$  -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->

  <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">

<!--  &RFC2460;  IP Version 6 -->
  <!ENTITY RFC2460 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2460.xml">

<!-- &RFC3596; DNS Extensions to Support IP Version 6 -->
  <!ENTITY RFC3596 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3596.xml">

<!-- &RFC3986;  Uniform Resource Identifier (URI) -->
  <!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">

<!-- &RFC4074; inappropriate AAAA replies -->
  <!ENTITY RFC4074 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4074.xml">

<!-- &RFC5625; DNS Proxy Implementation Guidelines -->
  <!ENTITY RFC5625 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5625.xml">

<!-- &RFC6145; NAT46 -->
  <!ENTITY RFC6145 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6145.xml">

<!-- &RFC6146; Stateful NAT64 -->
  <!ENTITY RFC6146 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6146.xml">

<!-- &RFC6147; DNS64 -->
  <!ENTITY RFC6147 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6147.xml">

<!-- &RFC6384; FTP64 -->
  <!ENTITY RFC6384 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6384.xml">

<!-- &RFC6877; 464XLAT -->
  <!ENTITY RFC6877 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6877.xml">

<!-- &RFC6535; BIH -->
  <!ENTITY RFC6535 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6535.xml">

<!-- &RFC6586; ipv6 only experience in ietf -->
  <!ENTITY RFC6586 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6586.xml">

]><!-- End of DOCTYPE -->


<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<?rfc strict="yes" ?>
<?rfc toc="no"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="yes" ?>
<rfc category="info" docName="draft-osamu-v6ops-ipv4-literal-in-url-00"
  ipr="pre5378Trust200902" submissionType="IETF">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

<front>

    <title abbrev="IPv4addr in URL">
        IPv4 Address Literal in URL
    </title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Osamu Nakamura" initials="O" role="" surname="Nakamura">
      <organization>Keio Univ./WIDE Project</organization>
      <address>
        <postal>
          <street>5322 Endo</street>
          <city>Fujisawa</city>
          <region>Kanagawa</region>
          <code>252-0882</code>
          <country>JP</country>
        </postal>
        <phone>+81 466 49 1100</phone>
        <email>osamu@wide.ad.jp</email>
      </address>
    </author>
    <author fullname="Hiroaki Hazeyama" initials="H" role="" surname="Hazeyama">      <organization>NAIST / WIDE Project</organization>
      <address>
        <postal>
          <street>8916-5 Takayama</street>
          <city>Ikoma</city>
          <region>Nara</region>
          <code>630-0192</code>
          <country>JP</country>
        </postal>
        <phone>+81 743 72 5111</phone>
        <email>hiroa-ha@is.naist.jp</email>
      </address>
    </author>
    <author fullname="Yukito Ueno" initials="Y" role="" surname="Ueno">
      <organization>Keio Univ./WIDE Project</organization>
      <address>
        <postal>
          <street>5322 Endo</street>
          <city>Fujisawa</city>
          <region>Kanagawa</region>
          <code>252-0882</code>
          <country>JP</country>
        </postal>
        <phone>+81 466 49 1100</phone>
        <email>eden@sfc.wide.ad.jp</email>
      </address>
    </author>
    <author fullname="Akira Kato" initials="A" role="" surname="Kato">
      <organization>Keio Univ. / WIDE Project</organization>
      <address>
        <postal>
          <street>Graduate School of Media Design, 4-1-1 Hiyoshi</street>
          <city>Kohoku</city>
          <region>Yokohama</region>
          <code>223-8526</code>
          <country>JP</country>
        </postal>
        <phone>+81 45 564 2490</phone>
        <email>kato@wide.ad.jp</email>
      </address>
    </author>

    <date year="2013" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
   in the current day and month for you. If the year is not the current one, it is 
   necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
   purpose of calculating the expiry date).  With drafts it is normally sufficient to 
   specify just the year. -->

    <area>Operation and Management</area>  <!-- XXXX -->

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>IPv6</keyword>
    <keyword>IPv4</keyword>
    <keyword>URL</keyword>
    <keyword>DNS64</keyword>
    <keyword>Stateful NAT64</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>
        In an IPv6-only environment with DNS64/NAT64 based translation
        service, there is no way to get access a URL whose domain
        name part includes an IPv4 address literal. 
        This memo discusses
        a few methods to rewrite the URL on an IPv6-only host 
        so that the URL is accessible from the IPv6-only host.
      </t>
    </abstract>
</front>

<middle>

<!-- ############################################################# -->

<section title="Introduction and Overview">

<t>
    When a host in an IPv6 only environment (an IPv6-only host) 
    has to access an IPv4-only destination, 
    a translator-based approach is a powerful tool. 
    The translator-based approach is usually composed of a DNS64 server 
    <xref target="RFC6147"/> and a stateful NAT64 translator 
    <xref target="RFC6146"/>. 

    The DNS64 server responds with an AAAA record of an
    IPv4 embedded IPv6 address with significant IPv6 prefix assigned
    to the NAT64 translator. 
    The IPv6-only host sends an IPv6 packet, which is translated by the 
    NAT64 box to an IPv4 packet. 

    The translation of responded IPv4 packet back into
    an IPv6 packet is also performed in the NAT64 translator.
</t>
<t>
    The NAT64 with DNS64 approach works well for most destinations. 
    It does not work well when the DNS response packet included NXDOMAIN
    or SERVFAIL to the AAAA query, partly described in
    <xref target="RFC4074"/>. Resolution of this case is out of
    scope of this memo.
</t>
<t>
    It is legitimate to embed an IPv4 address literal in an URL such
    as follows:
    <list hangIndent="4" style="empty">
      <t> http://192.0.2.10/index.html </t>
    </list>
    In the environment described above, the destination is not
    accessible from an IPv6-only host.
    This problem has already been reported in <xref target="RFC6586"/> 
    and other experiences. 
</t>
<t>
    The reason why we cannot access the destination specified by above
    notation is that no DNS lookup is performed in most cases, and
    no DNS64 service is able to tell an IPv4 embedded IPv6 address
    to the host.
    To perform DNS64/NAT64 translation against such an IPv4 address 
    literal notation, some mechanism will be required.
</t>
<t>
    This memo proposes a special-use TLD. 
    We denote the special-use TLD as ``.TLD'' which will be replaced
    with actual TLD based on discussion 
    in <xref target="tld-alternatives"/>. 
    The concept of ``.TLD'' is simple; 
    all IPv4 address literal notations are rewritten to 
    ``&lt;ipv4-address-literal&gt;.TLD'' on the IPv6-only host, 
    letting DNS servers and translators translate the IPv4 address 
    literal to appropriate IP address on each leaf network.
    For example, &lt;ipv4-address-literal&gt;.TLD in DNS64/NAT64 
    environment would be translated to a NAT64 prefix mapped address. 
</t>
<t>
    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in
    <xref target="RFC2119"/>.
 </t>
</section>

<!-- ############################################################# -->

<section anchor="scope" title="Scope of this memo">
<t>
  Before discussing solutions, we define the scope of this memo.
  We focus only on smooth migration to an IPv6-only environment with 
  the DNS64/NAT64 solution. Therefore, we focus on only 
  ``IPv4 address literal'' problem mentioned in <xref target="RFC6586"/>.
</t>
<t>
  The ``IPv6 address literal'' is out of scope of this memo,
  because an URL including IPv6 address literal can be accessible 
  in IPv6-only networks and in dual stack networks. 
  The solutions to keep IPv4-only hosts or IPv4-only applications 
  in IPv6 only environment are out of scope on this memo. 
</t>
</section>


<section anchor="special-tld" title="A special-use TLD for IPv4 Address Literal">
<t>
  When the part of IPv4 address literal is written to form 
  a pseudo FQDN, the DNS64 server can return an AAAA record 
  with the specified IPv4 address that is mapped to a NAT64 prefix. 
</t>
<t>
  Once an AAAA record is obtained, the IPv6-only host can send 
  an IPv6 packet to the destination. The IPv6 packet will be translated 
  via NAT64 translator in the same way as a regular IPv4-only 
  destination. 
</t>

 <section anchor="procedure" title="The procedure in detail">
<t> The procedure of the special-use TLD is as follows;
  <list style="symbols">
  <t> An host internally attaches ``.TLD'' to an IPv4 address literal. 
      For example, &lt;ipv4-address-literal&gt; is rewritten to 
      &lt;ipv4-address-literal&gt;.TLD.
  </t>
  <t> The host gets access to &lt;ipv4-address-literal&gt;.TLD 
      instead of &lt;ipv4-address-literal&gt;.
  </t>
  <t> As &lt;ipv4-address-literal&gt;.TLD looks like a regular FQDN,
      the IPv6-only host will query the FQDN to a DNS server.
  </t>
  <t> The DNS server recognizes that the FQDN 
      ``&lt;ipv4-address-literal&gt;.TLD'' is a special-use TLD. 
    Then, 
    <list style="symbols">
    <t> If the network is an IPv6-only network, and if the IPv6-only 
        network has a DNS64 server and NAT64 translator(s), then, 
        the DNS64 server SHOULD convert &lt;ipv4-address-literal&gt; 
        into a NAT64 prefix mapped address and 
        returns the NAT64 prefix mapped address as an AAAA record. 
    </t>
       <t> 
        If the network is an IPv4-only network, then, 
        the DNS4 server MAY remove ``.TLD'' and 
        returns an A record corresponding to 
        &lt;ipv4-address-literal&gt;. 
       </t>
       <t>
       If the network is a dual stack network, and if the dual stack 
        network does not have any DNS64/NAT64 function, then, 
        DNS4 server MAY remove ``.TLD'' and returns 
        &lt;ipv4-address-literal&gt; as an A record. 
      </t>
      <t>
        If the network is a dual stack network, and 
        if the dual stack network has any DNS64/NAT64 function, 
        then, 
        &lt;ipv4-address-literal&gt; MAY be returned as an A record 
        and NAT64 prefix mapped address MAY be returned as an AAAA record. 
      </t>
    </list>
  </t>
  <t> 
      After the name resolution procedure is completed, 
      the host will access the &lt;ipv4-address-literal&gt; 
      through an appropriate socket.
  </t>
  </list>
  </t>
  <t> 
    This solution would not require the modification of common shared 
    libraries on Operating Systems. 
    The DNS implementations have to support the special-use TLD 
    and the procedure mentioned above. 
    The modification of NAT64 or DHCP are not required. 
  </t>
 </section><!-- procedure -->

 <section anchor="example-manual" title="Use case 1: manual use">
    <t>
      For example, consider living on an IPv6-only network with 
      DNS64/NAT64, and receiving a message like 
     ``please download a file foo.doc from a ftp server 192.0.2.10''. 
      Usually, you don't have any method to get NAT64 information.
      Under the proposed mechanism, you can just type as follow;
      <list hangIndent="4" style="empty">
        <t> % ftp 192.0.2.10.TLD</t>
      </list>
    </t>
    <t>
       The packet would be transferred along with 
       <xref target="RFC6384"/>.
    </t>
 </section><!-- use case 1 -->

 <section anchor="example-browser-plug-in" title="Use case 2: browser plug-in">
    <t>
       An IPv4 address literal is often used in URL for 
       the lazy DNS operation,
       a temporary HTTP server or a hidden (private) server. 
       Taking into account user convenience,
       a browser plug-in can be developed that
       it converts the &lt;ipv4-address-literal&gt; on the hostname 
       part of an URL to &lt;ipv4-address-literal&gt;.TLD. It may
       suggested to turn this on when the host is on IPv6-only network,
       however, it may not be easy to detect it.
    </t>
 </section><!-- use case 2 -->

 <section anchor="other possible solutions" title="Other Possible Solutions">

 <t>
   Several possible solutions can be considered described below, however,
   most of them would not work between considerable fraction of
   IPv6 only networks and dual stack networks.
  </t>

  <section anchor="compat" title="IPv4-Compatible IPv6 Address">
    <t>
      The literally embedded IPv4 address is converted to an 
      IPv4-Compatible IPv6 address, and sent to the NAT64 converter 
      as usual. This solution requires application or common shared 
      library modification. 
    </t>
    <t>
      Also, the procedure for learning about the NAT64 prefix 
      to be used for a particular IPv4 destination is issued. 
      Looking up to some known IPv4-only anchor host is a possible 
      method.
      However, current ISC BIND DNS64 implementation can set 
      different NAT64 prefixes to different IPv4 address prefixes. 
      Therefore, this solution would not work well. 
   </t>
  </section><!-- compat -->

  <section anchor="adv-dns-dhc" title="Advertising NAT64 prefix by DHCP or DNS">
    <t> 
      Wing proposed a solution that advertises a NAT64 prefix 
      by DHCP or DNS in 
      <xref target="I-D.draft-wing-behave-learn-prefix-04"></xref>'' 
      in 2009. 
      But this solution is a little complex and requires various 
      modifications to DNS and DHCP implementations. 
      Wing's draft has already expired. 
    </t>
  </section><!-- adv dhcp or dns -->

  <section anchor="464xlat-bump" title="Using BIH or 464XLAT CLAT on a host ">
    <t>
      Bump in the Host (BIH) <xref target="RFC6535"></xref> and 
      464XLAT <xref target="RFC6877"></xref> are possible solutions, 
      both of which are aimed at retaining the usage of IPv4-only 
      applications in  IPv6-only environment. 
      BIH has a local translator function between 
      the socket API and the TCP/IP stack. 
      On the other hand, 464XLAT provides PLAT (Provider side XLAT) 
      <xref target="RFC6146"></xref> and CLAT (Customer side XLAT) 
      <xref target="RFC6145"></xref>. 
      Some mobile carriers have started CLAT CPE on smart phones. 
      Therefore, some CLAT plug-in on a browser or CLAT CPE on a host 
      may work. 
    </t>
    <t>
      The BIH case requires several extensions on Operating Systems, 
      so we have to wait many independent Operating System Open Source 
      Projects and/or commercial Operating System vendors support BIH 
      in their Operating Systems. 
    </t>
    <t>
      In case of the 464XLAT, 464XLAT assumes that a user always uses 
      a specific CLAT and PLAT pair. 
      If a user want to change or move various public wi-fi networks, 
      then, a global reachable PLAT might be placed and a CLAT on a host
      has to equip a function that switches the CLAT function depending 
      on the condition of the current network. 
    </t>
  </section><!-- BIH -->

 </section><!--- section other Possible Solutions -->

 <section anchor="tld-alternatives" title="special-use TLD alternatives">
   <t>
    A few candidates of the special-use TLD is discussed here.
   </t>

  <section anchor="dot-host" title="Use of .host special TLD">
    <t>
      A special string ``.host'' is attached to an IPv4 address literal 
      notation like ``192.0.2.10'' to form a pseudo FQDN such as 
      ``192.0.2.10.host''. 
      Also, IPv4 address and port number literal is often used, 
      for instance,
      ``192.0.2.10:8080'' becomes ``192.0.2.10.host:8080''. 
     </t>
  </section><!--- .host TLD --->

  <section anchor="ip4host" title="Use of .ip4host.arpa special TLD">
    <t>
      This idea is almost the same as ``.host'', 
      but uses ``ip4host.arpa'' top level labels rather than ``.host''. 
      While the pseudo FQDN is expected to appear only in the DNS 
      look up by an IPv6-only host, it may leak to the global Internet. 
      In order to avoid the query to the Root DNS servers, 
      use of the sub-domain of ".arpa" may be recommended.
      The generated pseudo FQDN looks like ``192.0.2.10.ip4host.arpa''.
     </t>
  </section><!-- ip4host.arpa -->

  <section anchor="dot-dns64" title="Use of .dns64 special TLD">
    <t>
    The special-use TLD is mainly aimed to force IPv4 address literal 
    notation to be translated by DNS64/NAT64 in IPv6-only environments. 
    Therefore, ``.dns64'' reflects the request for DNS64/NAT64 
    translation against an IPv4 address. 
    </t>
  </section><!-- ip4host.arpa -->

  <section anchor="our-recommendation" title="Our recommendation">
    <t>
      We, authors of this memo, discussed which special-use TLD is 
      suitable. 
      Our recommendation is to use ``.host'' from the view of usability.
      Of course, we will accept any feedbacks from the community such as
      IETF v6ops and dnsops working groups and users community.
   </t>
  </section><!-- our recommendation -->

 </section><!-- TLD alternatives -->
</section><!-- special tld -->

<section anchor="discussion" title="Discussions">
 <section anchor="ipv6-addr-literal" title="Usages of IPv6 address literal">
 <t>
  The special-use TLD may be applied to IPv6 address cases in same ways,
  however, such notation is not required in dual stack / IPv6-only 
  environment, generally. 
 </t>
 </section><!-- ipv6 addr literal -->

 <section anchor="misuse" title="Attached the special-use TLD to a regular FQDN">
 <t>
  Conceptually, the special-use TLD would be attached to only 
  IPv4 address literals, however, the special-use TLD may be attached 
  to a regular FQDN notation like ``foo.bar.com.TLD''.
  We propose that such misuses should be discarded on the DNS
  or applications on the host side. 
 </t>
 </section><!-- misuse -->

 <section anchor="embedded-in-content-part-of-url" title="An embedded IP address literal in the content part of URL">

 <t>
  In some case, &lt;ipv4-address-literal&gt; may be embedded into 
  the content part of a URL, however, it may be difficult for users or 
  browser plug-ins to recognize unambiguously that a string like 
  &lt;ipv4-address-literal&gt; surely means some IPv4 address. 
  From the point of view of IPv6 migration, embedded IP address literal 
  in the content part of an URL MUST be avoided. 
 </t>
 </section><!-- embedded -->

 <section anchor="validation" title="Prevention the leak of the special-use TLD">

 <t>
  When the special-use TLD ``.TLD'' is actually employed 
  in the operation, ``.TLD'' will leak to the public DNS infrastructure
  including root DNS servers as seen in ``.local''. 
  Therefore, once consensus is obtained, 
  the relevant TLD SHOULD be delegated to a set of DNS servers.
 </t>
 <t>
  Two possible DNS operation methods can be considered.
  One is to delegate the TLD to AS112 servers 
  <xref target="as112-servers"/>. 
  When one of the AS112 servers received a query with the special-use TLD, 
  it returns with NXDOMAIN. 
 </t>

 <t>
 The other possible DNS operation is to deploy a set of special purpose 
 DNS servers which accept queries with ``.TLD'' and
 synthesize an A record corresponding to the IPv4 address in the
 QNAME when it is a legitimate IPv4 address. Otherwise, NXDOMAIN
 is returned.
 </t>
 </section><!-- validation -->

</section><!-- discussion-->

 <section anchor="implementation strategy" title="Implementation Strategy">
<t>
It is suggested to implement the .TLD rewriting as in the following
order:

<list style="numbers">
  <t> Define .TLD 
   <list style="empty">
<t>
	Once the community agrees to accept the rewriting scheme described
	in this memo, it must fix the .TLD to be used.
</t>
</list>
</t>

<t>
    .TLD delegation 
   <list style="empty">
<t>
     	DNS queries with .TLD can leak to the DNS of the global Internet,
	it is highly suggested to delegate .TLD to a set of authoritative
  DNS servers as discussed in <xref target="validation"/>.
</t>
   </list>
</t>
<t>
     DNS64 modification 
   <list style="empty">
<t>
	DNS64 implementation is suggested to modify to respond corresponding
	AAAA record to a query with .TLD. This process can be done in parallel
	to the step 2 above.
</t>
</list>
</t>

<t>
   Start using .TLD rewriting 
   <list style="empty">
<t>
	After, at least the step 2 is completed, the TLD rewriting may be
	used in manually described in <xref target="example-manual"/> or automatically by browser
	plugins described in <xref target="example-browser-plug-in"/>.
</t>
<t>
 While further discussions and observation is required, we may
 discourage to use an URL in IPv4 literal embedded. Instead,
 we may encourage to use .TLD notation as a legitimate URL
 even in the server side.
</t>

</list>
</t>
</list>
</t>

</section><!-- discussion-->

<!-- ############################################################# -->

<!-- ############################################################# -->

<section title="Security Considerations">
<t>
  The recommendation contains security considerations related to DNS. 
  At the moment, we do not consider the affinity with DNSSEC.
</t>
</section>

<!-- ############################################################# -->

<section title="IANA Considerations">
<t>
    According to the discussion with communities, this memo may call 
    for changes or additions of special-use TLD to the IANA registry.
</t>
</section><!-- IANA consideration -->

<!-- ############################################################# -->

<section title="Acknowledgments">
<t>
    The authors thank all members of WIDE Project for their active
    discussion, implementation, and evaluation.
</t>
</section> <!-- ack -->

</middle>


  <back>
      <!-- References split into informative and normative -->

  <references title="Normative References">
      &RFC2119; <!--  Key words for use in RFCs -->
      &RFC4074; <!-- inappropriate AAAA replies -->
      &RFC6145; <!-- NAT46 -->
      &RFC6146; <!-- Stateful NAT64 -->
      &RFC6147; <!-- DNS64 -->
      &RFC6384; <!-- FTP64 -->
      &RFC6535; <!-- BIH -->
      &RFC6877; <!-- 464XLAT -->
      &RFC6586; <!-- ipv6 only experience in ietf -->
  </references>


  <references title="Informative References"> 
      <!-- Here we use entities that we defined at the beginning. -->
      <reference anchor="I-D.draft-wing-behave-learn-prefix-04"
                 target="draft-wing-behave-learn-prefix-04 (expired)">
        <front>
          <title>Learning the IPv6 Prefix of a Network's IPv6/IPv4 Translator</title>

          <author initials="D."  surname="Wing"></author>
          <date year="October 2009" />
          <keyword>draft-wing-behave-learn-prefix-04 (expired)</keyword>
        </front>
      </reference>

      <reference anchor="as112-servers"
                 target="https://www.as112.net/">
        <front>
          <title>AS112 Project</title>
          <author><organization>AS112 Project</organization></author>
          <date year="October 2009" />
        </front>
      </reference>

  </references> 

  <!-- ############################################################# -->
<!-- ##################################################################### -->

    <section anchor="Example code for Chrome" title="Sample extension for Google Chrome">
      <figure>
        <preamble></preamble>

        <artwork><![CDATA[
var wr = chrome.webRequest;

var v4Suffix = ".TLD";
var ipAddrRegex = /^(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-
4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|25[0-5])\.(\d|[01]?\d\d|2[0-4]\d|2
5[0-5])$/;

function onBeforeRequest(details) {
  var tmpuri = new URI(details.url);
  var tmphost = tmpuri.host();
  var finalUri = '';
  tmphost.replace(ipAddrRegex,function(str, p1, p2, p3, p4, offset, s){
    finalUri = tmpuri.host(p1+"."+p2+"."+p3+"."+p4+v4Suffix).toString();
  });
 if('' != finalUri) {
  console.log(finalUri);
  return {redirectUrl: finalUri};
 }
};

wr.onBeforeRequest.addListener(onBeforeRequest, {urls: ["https://*/*", 
"http://*/*", "ftp://*/*"]}, ["blocking"]);
            ]]></artwork>
      </figure>
    </section>

  </back>
</rfc>
