<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>         <!-- generate a table of contents -->
<?rfc tocompact="no"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>     <!-- use anchors instead of numbers for references -->
<?rfc sortrefs="yes" ?>   <!-- alphabetize the references -->
<?rfc rfcedstyle="yes"?>
<?rfc strict="yes"?>
<?rfc autobreaks="yes"?>
<?rfc compact="yes" ?>    <!-- conserve vertical whitespace -->
<?rfc subcompact="no" ?>  <!-- but keep a blank line between list items -->
<rfc ipr="trust200902" submissionType="independent" category="info" docName="draft-gieben-auth-denial-of-existence-dns-00">
<front>

<title abbrev="Authenticated Denial in DNS">Authenticated Denial of Existence in the DNS</title>

        <author initials='R.' surname='Gieben' fullname='R. (Miek) Gieben'>
            <organization>SIDN Labs</organization>
            <address>
                <postal>
                    <street>Meander 501</street>
                    <street></street>
                    <city>Arnhem</city> <region></region>
                    <code>6825 MD</code>
                    <country>NL</country>
                </postal>

                <phone></phone>
                <email>miek.gieben@sidn.nl</email>
                <uri>https://sidn.nl/</uri>
            </address>
        </author>

        <author initials='W.' surname='Mekking' fullname='W. (Matthijs) Mekking'>
            <organization>NLnet Labs</organization>

            <address>
                <postal>
                    <street>Science Park 400</street>
                    <street></street>
                    <city>Amsterdam</city> <region></region>
                    <code>1098 XH</code>
                    <country>NL</country>
                </postal>

                <phone></phone>
                <email>matthijs@nlnetlabs.nl</email>
                <uri>http://www.nlnetlabs.nl/</uri>
            </address>
        </author>

        <date month='Aug' year='2012' />

        <area>Internet</area>
        <keyword>DNSSEC</keyword>
        <keyword>Denial of Existance</keyword>
        <keyword>NSEC</keyword>
        <keyword>NSEC3</keyword>
        <abstract>
<!-- This document was prepared using Pandoc2rfc -->
<!-- https://github.com/miekg/pandoc2rfc -->

  
<t>
  Authenticated denial of existence allows a resolver to validate that a
  certain domain name does not exist. It is also used to signal that a
  domain name exists, but does not have the specific RR type you were
  asking for. This document attempts to answer two simple questions.
</t>
<t>
  When returning a negative DNSSEC response, a name server sometimes
  includes up to two NSEC records. With NSEC3 the maximum amount is
  three.
</t>
<t><list style="symbols">
  <t>
    
      Why do you need up to two NSEC records?
    
  </t>
  <t>
    
      And why does NSEC3 sometimes require an extra record?
    
  </t>
</list></t>
<t>
  The answer to the questions hinges on the concept of wildcards and the
  <spanx style="verb">closest encloser</spanx>. With NSEC, the name that is the
  <spanx style="verb">closest encloser</spanx> is implicitly given in the record
  that also denies the existence of the domain name. With NSEC3, due to
  its hashing, this information has to be given explicitly to a
  resolver. It needs one record to tell the resolver the closest
  encloser and then another to deny the existence of the domain name.
  Both NSEC and NSEC3 may need yet another record to deny or assert a
  wildcard presence. This results in a maximum of two NSEC and three
  NSEC3 records, respectively.
</t>

        </abstract>
</front>

<middle>
<!-- This document was prepared using Pandoc2rfc -->
<!-- https://github.com/miekg/pandoc2rfc -->

  
<section title="Introduction" anchor="introduction">
  
  <t>
    DNSSEC can be somewhat of a complicated matter, and there are
    certain areas of the specification that are more difficult to
    comprehend than others. One such area is "authenticated denial
    of existence".
  </t>
  <t>
    Authenticated denial of existence allows a DNSSEC enabled resolver
    to validate that a certain domain name does not exist. It is also
    used to signal that a domain name exists, but does not have the
    specific RR type you were asking for.
  </t>
  <t>
    The first is referred to as an NXDOMAIN
    <xref target="RFC2308"/> (non-existent domain) and the latter
    a NODATA <xref target="RFC2308"/> response.
  </t>
  <t>
    In this document we will explain how authenticated denial of
    existence works. We begin by explaining the current technique in the
    DNS and work our way up to DNSSEC. We explain the first steps taken
    in DNSSEC and describe how NXT, NSEC and NSEC3 work. NO, NSEC2 and
    DNSNR also briefly make their appearance, as they have paved the way
    for NSEC3.
  </t>
  <t>
    To complete the picture we also need to explain DNS wildcards as it
    complicates matters.
  </t>
  <t>
    Note: In this document domain names in zone file examples will have
    a trailing dot, in the running text they will not. This text is
    written for people who have a fair understanding of DNSSEC. This
    document does not explain NSEC3 opt-out and secure delegations.
  </t>
  <t>
    The following RFCs are not required reading, but they might help in
    understanding the problem space.
  </t>
  <t><list style="symbols">
    <t>
      
        RFC 5155 <xref target="RFC5155"/> - Hashed Authenticated
        Denial of Existence;
      
    </t>
    <t>
      
        RFC 4592 <xref target="RFC4592"/> - The Role of Wildcards
        in the DNS.
      
    </t>
  </list></t>
  <t>
    And these provide some general DNSSEC information.
  </t>
  <t><list style="symbols">
    <t>
      
        RFC 4033, RFC 4034, RFC 4035 <xref target="RFC4033"/>,
        <xref target="RFC4034"/>, <xref target="RFC4035"/>
        - DNSSEC Spec;
      
    </t>
    <t>
      
        RFC 4956 <xref target="RFC4956"/> - DNS Security (DNSSEC)
        Opt-In. This RFC has the status experimental, but is a good
        read.
      
    </t>
  </list></t>
  <t>
    And these three drafts give some background information on the NSEC3
    development.
  </t>
  <t><list style="symbols">
    <t>
      
        The NO RR
        <xref target="I-D.ietf-dnsext-not-existing-rr"/>;
      
    </t>
    <t>
      
        The NSEC2 RR <xref target="I-D.laurie-dnsext-nsec2v2"/>;
      
    </t>
    <t>
      
        The DNSNR RR <xref target="I-D.arends-dnsnr"/>.
      
    </t>
  </list></t>
</section>
<section title="Denial of Existence" anchor="denial-of-existence">
  
  <t>
    We start with the basics and take a look at NXDOMAIN handling in the
    DNS. To make it more visible we are going to use a small DNS zone,
    with 3 names (<spanx style="verb">example.org</spanx>,
    <spanx style="verb">a.example.org</spanx> and
    <spanx style="verb">d.example.org</spanx>) and 3 types (SOA, A and TXT). For
    brevity the class is not shown (defaults to IN), the NS records are
    left out and the SOA and RRSIG records are shortened. Resulting in
    the following unsigned zone file:
  </t>
  <figure><artwork>
example.org.        SOA ( ... )
a.example.org.      A 192.0.2.1
                    TXT "a record"
d.example.org.      A 192.0.2.1
                    TXT "d record"
</artwork></figure>
  <section title="NXDOMAIN" anchor="nxdomain">
    
    <t>
      If a resolver asks for the TXT type belonging to
      <spanx style="verb">a.example.org</spanx> to the name server serving this
      zone, it sends the following question:
      <spanx style="verb">a.example.org TXT</spanx>
    </t>
    <t>
      The name server looks in its zone data and generates an answer. In
      this case a positive one: "Yes it exists and this is the
      data", resulting in this reply:
    </t>
    <figure><artwork>
;; status: NOERROR, id: 28203

;; ANSWER SECTION:
a.example.org.      TXT "a record"

;; AUTHORITY SECTION:
example.org.        NS a.example.org.
</artwork></figure>
    <t>
      The <spanx style="verb">status: NOERROR</spanx> signals that everything is
      OK, <spanx style="verb">id</spanx> is an integer used to match questions
      and answers. In the ANSWER section we find our answer. The
      AUTHORITY section holds information of the name servers that have
      information concerning the <spanx style="verb">example.org</spanx> domain.
    </t>
    <t>
      If a resolver now asks for <spanx style="verb">b.example.org TXT</spanx> it
      gets an answer that this name does not exist:
    </t>
    <figure><artwork>
;; status: NXDOMAIN, id: 7042

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
</artwork></figure>
    <t>
      In this case we do not get an ANSWER section and the status is set
      to NXDOMAIN. From this the resolver concludes
      <spanx style="verb">b.example.org</spanx> does not exist.
    </t>
  </section>
  <section title="NODATA" anchor="nodata">
    
    <t>
      It is important to realize, that NXDOMAIN is not the only type of
      does-not-exist. A name may exist, but the type you are asking for
      may not. This occurrence of non-existence is called a NODATA
      <xref target="RFC2308"/> response. Let us ask our name
      server for <spanx style="verb">a.example.org AAAA</spanx>, and look at the
      answer:
    </t>
    <figure><artwork>
;; status: NOERROR, id: 7944

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
</artwork></figure>
    <t>
      The status is NOERROR meaning that the
      <spanx style="verb">a.example.org</spanx> name exists. But the reply does
      not contain an ANSWER section. Instead it has an AUTHORITY section
      which holds the SOA record of <spanx style="verb">example.org</spanx>. The
      resolver has to put these pieces of information together and
      conclude that <spanx style="verb">a.example.org</spanx> exists, but it does
      not have an <spanx style="verb">AAAA</spanx> record.
    </t>
  </section>
</section>
<section title="Secure Denial of Existence" anchor="secure-denial-of-existence">
  
  <t>
    The above has to be translated to the security aware world of
    DNSSEC. But there are a few requirements DNSSEC brings to the table:
  </t>
  <t><list style="numbers">
    <t>
      
        There is no online signing defined in DNSSEC. Although a name
        server is free to compute the answer and signature(s)
        on-the-fly, the protocol is written with a "first
        sign", "then load" attitude in mind. It is rather
        asymmetrical, but a lot of the design in DNSSEC stems from fact
        that you need to accommodate authenticated denial of existence.
        If the DNS didn't have NXDOMAIN, DNSSEC would be a lot simpler,
        but a lot less useful!
      
    </t>
    <t>
      
        The DNS packet header is not signed. This means that a
        <spanx style="verb">status: NXDOMAIN</spanx> can not be trusted. In fact
        the entire header may be forged, including the AD bit (AD stands
        for Authenticated Data, see RFC 3655
        <xref target="RFC3655"/>), which may give some food for
        thought;
      
    </t>
    <t>
      
        DNS wildcards complicate matters significantly. More about this
        in later sections.
      
    </t>
  </list></t>
  <t>
    The first requirement implies that all denial of existence answers
    need to be pre-computed, but it is impossible to precompute (all
    conceivable) non-existence answers. In the example above, you need a
    way to tell somebody who is asking for
    <spanx style="verb">b.example.org</spanx> that it does not exists without
    using the name <spanx style="verb">b.example.org</spanx> in the answer. This
    has been solved by introducing a record that defines an interval
    between two existing names. Or to put it another way: it defines the
    holes (non-existing names) in the zone. This record can be signed
    beforehand and given to the resolver.
  </t>
  <t><list style="hanging" hangIndent="3">
    <t>
      Given all these troubles, why didn't the designers of DNSSEC go
      for the (easy) route and allowed for online signing? Well, at the
      time (pre 2000), online signing was not feasible with the current
      hardware. Keep in mind that the larger servers get between 2000
      and 6000 queries per second (qps), with peaks up to 20,000 qps or
      more. Scaling signature generation to these kind of levels is
      always a challenge. Another issue was (and is) key management, for
      online signing to work you need access to the private key(s). This
      is considered a security risk.
    </t>
  </list></t>
  <t>
    The road to the current solution (NSEC/NSEC3) was long. It started
    with the NXT (next) record. The NO (not existing) record was
    introduced, but never made it to RFC. Later NXT was superseded by
    NSEC (next secure) record. From there it went through NSEC2/DNSNR to
    finally reach NSEC3 (next secure, version 3) in RFC 5155.
  </t>
  <section title="NXT" anchor="nxt">
    
    <t>
      The first attempt to specify authenticated denial of existence was
      NXT (RFC 2535 <xref target="RFC2535"/>). Section 5.1 of
      that RFC introduces the record:
    </t>
    <t><list style="hanging" hangIndent="3">
      <t>
        The NXT resource record is used to securely indicate that RRs
        with an owner name in a certain name interval do not exist in a
        zone and to indicate what RR types are present for an existing
        name.
      </t>
    </list></t>
    <t>
      By specifying what you do have, you implicitly tell what you don't
      have. NXT is superseded by NSEC. In the next section we explain
      how NSEC (and thus NXT) works.
    </t>
  </section>
  <section title="NSEC" anchor="nsec">
    
    <t>
      In RFC 3755 <xref target="RFC3755"/> all the DNSSEC types
      were given new names, SIG was renamed RRSIG, KEY became DNSKEY and
      NXT was simply renamed to NSEC and a few, minor issues were fixed
      in the process.
    </t>
    <t>
      Just as NXT, NSEC is used to describe an interval between names:
      it indirectly tells a resolver which names do not exist in a zone.
    </t>
    <t>
      For this to work, we need our <spanx style="verb">example.org</spanx> zone
      to be sorted in canonical ordering
      (<xref target="RFC4034"/>, Section 6.1), and then create
      the NSECs. We add three NSEC records, one for each name, and each
      one "covers" a certain interval. The last NSEC record
      points back to the first as required by the RFC. Also see
      <xref target="fig:the-nsec-r"/>.
    </t>
    <t><list style="numbers">
      <t>
        
          The first NSEC covers the interval between
          <spanx style="verb">example.org</spanx> and
          <spanx style="verb">a.example.org</spanx>;
        
      </t>
      <t>
        
          The second NSEC covers: <spanx style="verb">a.example.org</spanx> to
          <spanx style="verb">d.example.org</spanx>;
        
      </t>
      <t>
        
          The third NSEC points back to <spanx style="verb">example.org</spanx>,
          and covers <spanx style="verb">d.example.org</spanx> to
          <spanx style="verb">example.org</spanx> (i.e. the end of the zone).
        
      </t>
    </list></t>
    <t>
      As we have defined the intervals and put those in resource
      records, we now have something that can be signed.
    </t>
    <figure anchor="fig:the-nsec-r" align="center"><artwork>
                    example.org
                       **
                   +-- ** &lt;--+
                  /  .    .   \
                 /  .      .   \
                |  .        .  |
                v .          . |
                **            **
  a.example.org ** ---------&gt; ** d.example.org
  </artwork><postamble>The NSEC records of example.org. The arrows represent NSEC records, starting
  from the apex.
</postamble></figure>
    <t>
      This signed zone is loaded into the name server. It looks like
      this:
    </t>
    <figure><artwork>
example.org.        SOA ( ... )
                    DNSKEY ( ... )
                    NSEC a.example.org. SOA NSEC DNSKEY RRSIG
                    RRSIG(SOA) ( ... )
                    RRSIG(DNSKEY) ( ... )
                    RRSIG(NSEC) ( ... )
a.example.org.      A 192.0.2.1
                    TXT "a record"
                    NSEC d.example.org. A TXT NSEC RRSIG
                    RRSIG(A) ( ... )
                    RRSIG(TXT) ( ... )
                    RRSIG(NSEC) ( ... )
d.example.org.      A 192.0.2.1
                    TXT "d record"
                    NSEC example.org. A TXT NSEC RRSIG
                    RRSIG(A) ( ... )
                    RRSIG(TXT) ( ... )
                    RRSIG(NSEC) ( ... )
</artwork></figure>
    <t>
      If a DNSSEC aware resolver asks for
      <spanx style="verb">b.example.org</spanx>, it gets back a
      <spanx style="verb">status: NXDOMAIN</spanx> packet, which by itself is
      meaningless as the header can be forged. To be able to securely
      detect that <spanx style="verb">b</spanx> does not exist, there must also
      be an NSEC record which <spanx style="emph">covers</spanx> the name space
      where <spanx style="verb">b</spanx> lives:
    </t>
    <figure><artwork>
a.example.org.      NSEC d.example.org.
</artwork></figure>
    <t>
      does just do that: <spanx style="verb">b</spanx> should come after
      <spanx style="verb">a</spanx>, but the next owner name is
      <spanx style="verb">d.example.org</spanx>, so <spanx style="verb">b</spanx> does not
      exist.
    </t>
    <t>
      Only by making that calculation, can a resolver conclude that the
      name <spanx style="verb">b</spanx> does not exist. If the signature of the
      NSEC record is valid, <spanx style="verb">b</spanx> is proven not to exist.
      We have: <spanx style="emph">authenticated denial of existence</spanx>.
    </t>
  </section>
  <section title="NODATA Responses" anchor="nodata-responses">
    
    <t>
      NSEC records are also used in NODATA responses. In that case we
      need to look more closely at the type bit map. The type bit map in
      an NSEC record tells which types are defined for a name. If we
      look at the NSEC record of <spanx style="verb">a.example.org</spanx> (see
      the reply below for an example of the record) we see the following
      types in the bit map: A, TXT, NSEC and RRSIG. So for the name
      <spanx style="verb">a</spanx> this indicates we must have an A, TXT, NSEC
      and RRSIG record in the zone.
    </t>
    <t>
      With the type bit map of the NSEC record a resolver can establish
      that a name is there, but the type is not. A resolver asks for
      <spanx style="verb">a.example.org AAAA</spanx>. This is the reply that
      comes back:
    </t>
    <figure><artwork>
;; status: NOERROR, id: 44638

;; AUTHORITY SECTION:
example.org.        SOA ( ... )
example.org.        RRSIG(SOA) ( ... )
a.example.org.      NSEC d.example.org. A TXT NSEC RRSIG
a.example.org.      RRSIG(NSEC) ( ... )
</artwork></figure>
    <t>
      Now the resolver should check the AUTHORITY section and conclude
      that:
    </t>
    <t><list style="numbers">
      <t>
        
          <spanx style="verb">a.example.org</spanx> exists (because of the NSEC
          with that owner name) and;
        
      </t>
      <t>
        
          that the type (AAAA) does not as it is
          <spanx style="emph">not</spanx> listed in the type bit map.
        
      </t>
    </list></t>
    <t>
      By understanding NSEC records, you have mastered the basics of
      authenticated denial of existence.
    </t>
    <t>
      But there were two issues with NSEC (and NXT). The first is that
      it allows for zone walking. NSEC records point from one name to
      another, in our example: <spanx style="verb">example.org</spanx>, points to
      <spanx style="verb">a.example.org</spanx> which points to
      <spanx style="verb">d.example.org</spanx> which points back to
      <spanx style="verb">example.org</spanx>. So we can reconstruct the entire
      <spanx style="verb">example.org</spanx> zone even when zone transfers
      (AXFR) on the server are denied.
    </t>
    <t>
      The second issue is that when a large, delegation heavy, zone
      deploys DNSSEC, every name in the zone gets an NSEC plus RRSIG.
      This leads to a huge increase in the zone size (when signed). This
      would in turn mean that operators of large zones (or with a lot of
      zones) who are deploying DNSSEC, face up front costs. This could
      hinder DNSSEC adoption.
    </t>
    <t>
      These two issues eventually lead to NSEC3 which:
    </t>
    <t><list style="symbols">
      <t>
        
          Adds a way to garble the next owner name, thus thwarting
          zone-walking;
        
      </t>
      <t>
        
          Makes it possible to skip names for the next owner name. This
          feature is called opt-out. It means not all names in your zone
          get an NSEC3 plus ditto signature, making it possible to
          "grow into" your DNSSEC deployment. Describing
          opt-out is (currently) out of scope for this document. For
          those interested, opt-out is explained in RFC 4956
          <xref target="RFC4956"/>, which is curiously titled
          "(DNSSEC) Opt-In". Later this is incorporated into
          RFC 5155 <xref target="RFC5155"/>.
        
      </t>
    </list></t>
    <t>
      But before we delve in to NSEC3 lets first take a look at its
      predecessors, NO, NSEC2 and DNSNR.
    </t>
  </section>
  <section title="NO, NSEC2 and DNSNR" anchor="no-nsec2-and-dnsnr">
    
    <t>
      The NO record was the first to introduce the idea of hashed owner
      names. It also fixed other shortcomings of the NXT record. At the
      time (around 2000) zone walking was not considered important
      enough to warrant the new record. People were also worried that
      deployment would be hindered by developing an alternate means of
      denial of existence. Thus the effort was shelved and NXT remained.
      When the new DNSSEC specification was written, NSEC saw the light
      and inherited the two issues from NXT.
    </t>
    <t>
      Several years after that NSEC2 was introduced as a way to solve
      the two issues of NSEC. The NSEC2 draft contains the following
      paragraph:
    </t>
    <t><list style="hanging" hangIndent="3">
      <t>
        This document proposes an alternate scheme which hides owner
        names while permitting authenticated denial of existence of
        non-existent names. The scheme uses two new RR types: NSEC2 and
        EXIST.
      </t>
    </list></t>
    <t>
      When an authenticated denial of existence scheme starts to talk
      about EXIST records it is worth paying extra attention.
    </t>
    <t>
      NSEC2 solved the zone walking issue, by hashing (with SHA1 and a
      salt) the "next owner name" in the record, thereby
      making it useless for zone walking.
    </t>
    <t>
      But it did not have opt-out. Although promising, the proposal
      didn't make it because of issues with wildcards and the odd EXISTS
      resource record.
    </t>
    <t>
      The DNSNR RR was another attempt that used hashed names to foil
      zone walking and it also introduced the concept of opting out
      (called "Authoritative Only Flag") which limited the use
      of DNSNR in delegation heavy zones. This proposal didn't make it
      either, but it provided valuable insights into the problem.
    </t>
  </section>
  <section title="NSEC3" anchor="nsec3">
    
    <t>
      From the experience gained with NSEC2 and DNSNR, NSEC3 was forged.
      It incorporates both opt-out and the hashing of names. NSEC3
      solves any issues people might have with NSEC, but it introduces
      some additional complexity.
    </t>
    <t>
      NSEC3 did not supersede NSEC, they are both defined for DNSSEC. So
      DNSSEC is blessed with two different means to perform
      authenticated denial of existence: NSEC and NSEC3. In NSEC3 every
      name is hashed, including the owner name.
    </t>
    <t>
      SHA1 is always used for the hashing. To make it even more
      difficult to retrieve the original names, the hashing can be
      repeated several times each time taking the previous hash as
      input. To thwart rainbow table attacks, a custom salt is also
      added. In the NSEC3 for <spanx style="verb">example.org</spanx> we have
      hashed the names twice and use the salt <spanx style="verb">DEAD</spanx>.
      Lets look at typical NSEC3 record:
    </t>
    <figure><artwork>
15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. (
   NSEC3 1 0 2 DEAD 04SKNAPCA5AL7QOS3KM2L9TL3P5OKQ4C
        SOA RRSIG DNSKEY NSEC3PARAM )
</artwork></figure>
    <t>
      On the first line we see the hashed owner name:
      <spanx style="verb">15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org</spanx>,
      this is the hashed name of <spanx style="verb">example.org</spanx>. Note
      that even though we hashed <spanx style="verb">example.org</spanx>, the
      zone's name is added to make it look like a domain name again. So
      un-hashed it sort of looks like:
      <spanx style="verb">SHA1(example.org).example.org</spanx>.
    </t>
    <t>
      The next owner name <spanx style="verb">a.example.org</spanx> (line 2) is
      hashed to: <spanx style="verb">04SKNAPCA5AL7QOS3KM2L9TL3P5OKQ4C</spanx>.
      Note that <spanx style="verb">.example.org</spanx> is not added to the next
      owner name, as this name always falls in the current zone.
    </t>
    <t>
      The "1 0 2 DEAD" section of the NSEC3 states:
    </t>
    <t><list style="symbols">
      <t>
        
          Hash Algorithm = 1 (SHA1, this is the default, no other hash
          algorithms are defined for use in NSEC3);
        
      </t>
      <t>
        
          Opt Out = 0 (disabled);
        
      </t>
      <t>
        
          Hash Iterations = 2;
        
      </t>
      <t>
        
          Salt = "DEAD".
        
      </t>
    </list></t>
    <t>
      At the end we see the type bit map, which is identical to NSEC's
      bit map, that lists the types present at the original owner name.
      Note that the type NSEC3 is absent from the list in the example
      above. This is due to the fact that the original owner name
      (<spanx style="verb">example.org</spanx>) does not have the NSEC3 type. It
      only exists for the hashed name.
    </t>
    <t>
      Names like <spanx style="verb">1.h.example.org</spanx> hash to one label in
      NSEC3, <spanx style="verb">1.h.example.org</spanx> becomes:
      <spanx style="verb">117GERCPRCJGG8J04EV1NDRK8D1JT14K.example.org</spanx>
      when used as a owner name. This is an important observation. By
      hashing the names you loose the depth of a zone - hashing
      introduces a flat space of names, as opposed to NSEC.
    </t>
    <t>
      In fact the domain name used above:
      <spanx style="verb">1.h.example.org</spanx> creates an empty non-terminal.
      Empty non-terminals are domain names that exist but have no RR
      types associated with them but has one or more subdomains that do
      (<xref target="RFC5155"/>, Section 1.3).
    </t>
    <figure><artwork>
    1.h.example.org.    TXT "1.h record"
</artwork></figure>
    <t>
      Creates 2 names:
    </t>
    <t><list style="numbers">
      <t>
        
          <spanx style="verb">1.h.example.org</spanx> that has the type: TXT;
        
      </t>
      <t>
        
          <spanx style="verb">h.example.org</spanx> which has no types. This is
          the empty non-terminal. An empty non-terminal will get an
          NSEC3 records, but not an NSEC record.
        
      </t>
    </list></t>
  </section>
  <section title="Slaving an NSEC3 Zone" anchor="slaving-an-nsec3-zone">
    
    <t>
      A secondary server slaving a zone with NSEC3 records needs to find
      out the specifics (hash iterations and salt) to be able to hash
      incoming query names.
    </t>
    <t>
      To do this, it could scan the zone during the AXFR for NSEC3
      records and glance the NSEC3 parameters from them. However, it
      would need to make sure that there is at least one complete set of
      NSEC3 records for the zone using the same parameters. Therefore,
      it would need to inspect all NSEC3 records.
    </t>
    <t>
      A more graceful solution was designed. This solution was to create
      a new record, NSEC3PARAM, which must be placed at the apex of the
      zone. Its sole role is to provide a single, fixed place where a
      secondary name server can directly see the NSEC3 parameters used.
      If NSEC3 were designed in the early days of DNS (+/- 1985) this
      information was probably put in the SOA record.
    </t>
  </section>
  <section title="Wildcards in the DNS" anchor="wildcards-in-the-dns">
    
    <t>
      In the above sections we haven't revealed the entire story. There
      is a complication: wildcards. Wildcards have been part of the DNS
      since the first DNS RFCs. They allow to define
      <spanx style="emph">all</spanx> names for a certain type in one go. In
      our <spanx style="verb">example.org</spanx> zone we could for instance add
      a wildcard record:
    </t>
    <figure><artwork>
*.example.org.      TXT "wildcard record"
</artwork></figure>
    <t>
      For completeness our (unsigned) zone now looks like this:
    </t>
    <figure><artwork>
example.org.        SOA ( ... )
*.example.org.      TXT "wildcard record"
a.example.org.      A 192.0.2.1
                    TXT "a record"
d.example.org.      A 192.0.2.1
                    TXT "d record"
</artwork></figure>
    <t>
       If a resolver asks for
      <spanx style="verb">z.example.org TXT</spanx>, the name server will respond
      with an <spanx style="emph">expanded wildcard</spanx>, instead of an
      NXDOMAIN:
    </t>
    <figure><artwork>
;; status: NOERROR, id: 13658

;; ANSWER SECTION:
z.example.org.      TXT "wildcard record"
</artwork></figure>
    <t>
      Note however that the resolver can not detect that this answer
      came from a wildcard. It just sees the answer as-is. How will this
      answer look with DNSSEC?
    </t>
    <figure><artwork>
;; status: NOERROR, id: 51790

;; ANSWER SECTION:
z.example.org.      TXT "wildcard record"
z.example.org.      RRSIG(TXT) ( ... )

;; AUTHORITY SECTION:
d.example.org.      NSEC example.org. TXT RRSIG NSEC
d.example.org.      RRSIG(NSEC) ( ... )
</artwork></figure>
    <t>
      The RRSIG of the <spanx style="verb">z.example.org</spanx> TXT record
      indicates there is a wildcard configured. The RDATA of the
      signature lists a label count <xref target="RFC4034"/>,
      Section 3.1.3., of two (not visible in the answer above), but the
      owner name of the signature has three labels. This mismatch
      indicates there is a wildcard configured for the name
      <spanx style="verb">*.example.org</spanx>. The AUTHORITY section holds an
      NSEC. This NSEC proves that the queried name
      <spanx style="verb">z.example.org</spanx> does not exist, and wildcard name
      expansion was indeed allowed.
    </t>
    <t><list style="hanging" hangIndent="3">
      <t>
        An astute reader may notice that it appears as if a
        <spanx style="verb">z.example.org</spanx> RRSIG(TXT) is created out of
        thin air. This is not the case. The signature for
        <spanx style="verb">z.example.org</spanx> does not exist. The signature
        you are seeing is the one for <spanx style="verb">*.example.org</spanx>
        which does exist, only the owner name is switched to
        <spanx style="verb">z.example.org</spanx>. So even with wildcards, no
        signatures are created on the fly.
      </t>
    </list></t>
    <t>
      One thing you may notice is that this reply has an NSEC record in
      it <spanx style="emph">even</spanx> though it is not an NXDOMAIN nor
      NODATA reply. In this case it is there to tell the resolver this
      answer was synthesized from a wildcard.
    </t>
    <t>
      In the reply above we see that <spanx style="verb">z.example.org</spanx>
      was generated via wildcard expansion. The DNSSEC standard mandates
      that an NSEC (or NSEC3) is included in such responses. If it
      didn't, an attacker could poison the cache with false data.
    </t>
    <t>
      Suppose that the resolver would have asked for
      <spanx style="verb">a.example.org TXT</spanx>, an attacker could modify the
      packet in such way that it looks like the response was generated
      through wildcard expansion, even though there exists a record for
      <spanx style="verb">a.example.org TXT</spanx>:
      <spanx style="verb">a.example.org.  TXT "a record"</spanx>
    </t>
    <t>
      The tweaking simply consists of adjusting the ANSWER section to:
    </t>
    <figure><artwork>
;; status: NOERROR, id: 31827

;; ANSWER SECTION
a.example.org.      TXT "wildcard record"
a.example.org.      RRSIG(TXT) ( ... )
</artwork></figure>
    <t>
      Which would be a perfectly valid answer if we would not require
      the inclusion of an NSEC or NSEC3 record in the wildcard answer
      response. The resolver believes that
      <spanx style="verb">a.example.org TXT</spanx> is a wildcard record, and the
      real record is obscured. This is bad and defeats all the security
      DNSSEC can deliver. Because of this, the NSEC or NSEC3 should be
      present.
    </t>
    <t>
      Thus a resolver can detect such a spoofing attempt:
    </t>
    <t><list style="numbers">
      <t>
        
          If the NSEC(3) is not present, assume the answer is spoofed;
        
      </t>
      <t>
        
          If the NSEC(3) is there, check it. If the signature is not
          correct, assume a spoofed answer.
        
      </t>
    </list></t>
    <t>
      Another way of putting this is that DNSSEC is there to ensure the
      name server has followed the steps as outlined in
      <xref target="RFC1034"/>, Section 4.3.2 for looking up
      names in the zone. It explicitly lists wildcard lookup as one of
      these steps (3c), so with DNSSEC this must be communicated to the
      resolver: hence the NSEC(3) record.
    </t>
    <t>
      With NSEC the maximum number of NSEC records a resolver can get
      back is two: one for the denial of existence and another for the
      wildcard. We say maximum, because sometimes a single NSEC can
      prove both. With NSEC3 it is three, as to why, we will explain in
      the next section.
    </t>
  </section>
  <section title="Returning Three NSEC3s" anchor="returning-three-nsec3s">
    
    <t>
      With NSEC3 matters are even more complicated. So we have an NSEC3
      that denies the existence of the requested name and an NSEC3 that
      denies wildcard synthesis. What do we miss?
    </t>
    <t>
      The short answer is that due to the hashing in NSEC3 you loose the
      depth of your zone: everything is hashed into a flat plain. To
      make up for this loss of information you need an extra record. The
      more detailed explanation is quite a bit longer...
    </t>
    <t>
      To understand NSEC3 we will need two definitions:
    </t>
    <t><list style="hanging">
      <t hangText="Closest encloser:">
          
            Introduced in <xref target="RFC4592"/>, this is the
            first <spanx style="emph">existing</spanx> name (this may be an
            empty non-terminal) in the zone that is an ancestor of the
            name used in the query. Suppose the query name is
            <spanx style="verb">x.2.example.org</spanx> then
            <spanx style="verb">example.org</spanx> is the
            <spanx style="verb">closest encloser</spanx> in our example;
          
        </t>
      <t hangText="Next closer name:">
          
            Introduced in the NSEC3 RFC, this is the closest encloser
            with one more label added to the left. So if
            <spanx style="verb">example.org</spanx> is the closest encloser for
            the query name <spanx style="verb">x.2.example.org</spanx>,
            <spanx style="verb">2.example.org</spanx> is the
            <spanx style="verb">next closer name</spanx>.
          
        </t>
    </list></t>
    <t>
      An NSEC3 <spanx style="verb">closest encloser proof</spanx> consists of:
    </t>
    <t><list style="numbers">
      <t>
        
          An NSEC3 RR that <spanx style="strong">matches</spanx>
          the <spanx style="verb">closest encloser</spanx>. This means the
          un-hashed owner name of the record is the closest encloser.
          This bit of information tells a resolver: "The name you
          are asking for does not exist, the closest I have is
          this".
        
      </t>
      <t>
        
          An NSEC3 RR that <spanx style="strong">covers</spanx> the
          <spanx style="verb">next closer name</spanx>. This means it defines an
          interval in which the <spanx style="verb">next closer name</spanx>
          falls. This tells the resolver: "The name in your
          question falls in this interval, and therefor the name in your
          question does not exist. In fact, the closest encloser is
          indeed the closest I have".
        
      </t>
    </list></t>
    <t>
      Take the following example. We take our zone, but now with the
      following two records and it is signed with NSEC3. As said these
      records create two non-terminals: "h.example.org" and
      "3.example.org", but that is irrelevant for the theory
      here.
    </t>
    <figure><artwork>
1.h.example.org.    TXT "1.h record"
3.3.example.org.    TXT "3.3 record"
</artwork></figure>
    <t>
      The complete unsigned zone now looks like this.
    </t>
    <figure><artwork>
example.org.        SOA ( ... )
1.h.example.org.    TXT "1.h record"
3.3.example.org.    TXT "3.3 record"
</artwork></figure>
    <t>
      The resolver asks the following:
      <spanx style="verb">x.2.example.org TXT</spanx>. This leads to an NXDOMAIN
      response from the server, which contains three NSEC3 records. A
      list of hashed owner names can be found in
      <xref target="list-of-hashed-owner-names"/>. Also see
      <xref target="fig:x.2.exampl"/> the numbers in the figure
      correspond with the following NSEC3 records:
    </t>
    <figure><artwork>
15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. (
 NSEC3 1 0 2 DEAD 1AVVQN74SG75UKFVF25DGCETHGQ638EK SOA 
        RRSIG DNSKEY NSEC3PARAM )

75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ.example.org. (
 NSEC3 1 0 2 DEAD 8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ TXT
        RRSIG )

1AVVQN74SG75UKFVF25DGCETHGQ638EK.example.org. (
    NSEC3 1 0 2 DEAD 75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ )
</artwork></figure>
    <t>
      If we would follow the NSEC approach, the resolver is only
      interested in one thing. Does the hash of
      <spanx style="verb">x.2.example.org</spanx> fall in any of the intervals of
      the NSEC3 records it got?
    </t>
    <figure anchor="fig:x.2.exampl" align="center"><artwork>
                    example.org
                       ** 
                   +-- ** .....................
              [1] /  . /\ .                    .
                 /  .  |   .                    .
                |  .   |    .                    .
                v .    |     .                    . 
                **     |      **                  ++
  h.example.org ** ----+----&gt; ** 3.example.org    ++ 2.example.org
                .     /  [3]   . |                .
                .    /         . | [2]            . 
                .   /          . |                .
                .  /           . v                .
1.h.example.org **            **                  ++ 
                ** &lt;--------- ** 3.3.example.org  ++ x.2.example.org
</artwork><postamble>x.2.example.org does not exist. The arrows represent the NSEC3 records, the ones
numbered [1], [2] and [3] are the NSEC3s returned in our answer.
</postamble></figure>
    <t>
      The hash of <spanx style="verb">x.2.example.org</spanx> is
      <spanx style="verb">NDTU6DSTE50PR4A1F2QVR1V31G00I2I1</spanx>. Checking this
      hash on the first NSEC3 yields that it does not fall in between
      the interval: <spanx style="verb">15BG9L6359F5CH23E34DDUA6N1RIHL9H</spanx>
      and <spanx style="verb">1AVVQN74SG75UKFVF25DGCETHGQ638EK</spanx>. For the
      second NSEC3 the answer is also negative: the hash sorts outside
      the interval described by
      <spanx style="verb">75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ</spanx> and
      <spanx style="verb">8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ</spanx>. And the last
      NSEC3 also isn't of any help. What is a resolver to do? It has
      been given the maximum amount of NSEC3s and they all seem useless.
    </t>
    <t>
      A question that you might have at this point is why doesn't the
      server send an NSEC3 that covers the hash of
      <spanx style="verb">x.2.example.org</spanx>, so the resolver can validate
      in one step? While this indeed denies the existence of
      <spanx style="verb">x.2.example.org</spanx> it is only half the answer. As
      explained, a denial of existence answer needs to say something
      about whether or not a wildcard should have been expanded. And to
      communicate which wildcard that could have been, you need to tell
      the resolver what the closest encloser is.
    </t>
    <t>
      So this is where the closest encloser proof comes into play. And
      for the proof to work, the resolver needs to know what the
      <spanx style="verb">closest encloser</spanx> is. There must be an existing
      ancestor in the zone: a name must exist that is shorter than the
      query name. The resolvers keeps hashing, increasingly shorter
      names from the query name until an owner name of an NSEC3 matches.
      This owner name is the <spanx style="verb">closest encloser</spanx>.
    </t>
    <t>
      When the resolver has found the closest encloser, the next step is
      to construct the <spanx style="verb">next closer name</spanx>. This is the
      closest encloser with the last chopped label from query name
      prepended to it: "&lt;last chopped label&gt;.&lt;closest
      encloser&gt;". The hash of this name should be covered by the
      interval set in any of the other NSEC3 records.
    </t>
    <t>
      Then the resolver needs to check the presence of a wildcard. It
      creates the wildcard name by prepending the wildcard label to the
      closest encloser: "*.&lt;closest encloser&gt;", and use
      the hash of that.
    </t>
    <t>
      Going back to our example the resolver must first detect the NSEC3
      that matches the closest encloser. It does this by chopping up the
      query name, hashing each instance (with the same number of
      iterations and hash as the zone it is querying) and comparing that
      to the answers given. So it has the following hashes to work with:
    </t>
    <t><list style="hanging">
      <t hangText="x.2.example.org:">
          
            <spanx style="verb">NDTU6DSTE50PR4A1F2QVR1V31G00I2I1</spanx>, last
            chopped label: "&lt;empty&gt;";
          
        </t>
      <t hangText="2.example.org:">
          
            <spanx style="verb">7T70DRG4EKC28V93Q7GNBLEOPA7VLP6Q</spanx>, last
            chopped label: "x";
          
        </t>
      <t hangText="example.org:">
          
            <spanx style="verb">15BG9L6359F5CH23E34DDUA6N1RIHL9H</spanx>, last
            chopped label: "2";
          
        </t>
    </list></t>
    <t>
      Of these hashes only one matches the owner name of one of the
      NSEC3 records:
      <spanx style="verb">15BG9L6359F5CH23E34DDUA6N1RIHL9H</spanx>. This must be
      the closest encloser (un-hashed: <spanx style="verb">example.org</spanx>).
      That's the main purpose of that NSEC3 record: tell the resolver
      what the closest encloser is.
    </t>
    <t>
      From that knowledge the resolver constructs the next closer, which
      in this case is: <spanx style="verb">2.example.org</spanx>;
      <spanx style="verb">2</spanx> is the last label chopped, when
      <spanx style="verb">example.org</spanx> is the closest encloser. The hash
      of this name should be covered in any of the other NSEC3s. And it
      is, <spanx style="verb">7T70DRG4EKC28V93Q7GNBLEOPA7VLP6Q</spanx> falls in
      the interval set by:
      <spanx style="verb">75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ</spanx> and
      <spanx style="verb">8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ</spanx> (this is our
      second NSEC3).
    </t>
    <t>
      So what does the resolver learn from this?
    </t>
    <t><list style="symbols">
      <t>
        
          <spanx style="verb">example.org</spanx> exists;
        
      </t>
      <t>
        
          <spanx style="verb">2.example.org</spanx> does not exist.
        
      </t>
    </list></t>
    <t>
      And if <spanx style="verb">2.example.org</spanx> does not exist,
      <spanx style="verb">x.2.example.org</spanx> also does not exist. But only
      if there was no wildcard configured. So this is the last step:
      check if there is a wildcard configured at the closest encloser.
    </t>
    <t>
      The resolver hashes <spanx style="verb">*.example.org</spanx> to
      <spanx style="verb">22670TRPLHSR72PQQMEDLTG1KDQEOLB7</spanx>. Only the last
      NSEC3 covers this hash. The hash falls in the interval set by
      <spanx style="verb">1AVVQN74SG75UKFVF25DGCETHGQ638EK</spanx> and
      <spanx style="verb">75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ</spanx> (this is our
      third NSEC3). This means there is no wildcard at the closest
      encloser and <spanx style="verb">x.2.example.org</spanx> definitely does
      not exist.
    </t>
    <t>
      When we have validated the signatures, we reached our goal:
      authenticated denial of existence.
    </t>
    <t>
      Coming back to the original question: why do we need (up to) three
      NSEC3 records? The resolver needs to be explicitly told what the
      <spanx style="verb">closest encloser</spanx> is and this takes up a full
      NSEC3 record. Then the next closer name needs to be covered in an
      NSEC3 record, and finally an NSEC3 must say something about the
      wildcard. That makes three records.
    </t>
  </section>
</section>
<section title="List of Hashed Owner Names" anchor="list-of-hashed-owner-names">
  
  <t>
    The following owner names are used in this document. The origin for
    these names is <spanx style="verb">example.org</spanx>.
  </t>
  <texttable anchor="tab:hashed-own">
    
    
      
      
      
        
          <ttcol align="left">
            Original Name
          </ttcol>
          <ttcol align="left">
            Hashed Name
          </ttcol>
        
      
      
        
          <c>
            <spanx style="verb">@</spanx>
          </c>
          <c>
            <spanx style="verb">15BG9L6359F5CH23E34DDUA6N1RIHL9H</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">*</spanx>
          </c>
          <c>
            <spanx style="verb">22670TRPLHSR72PQQMEDLTG1KDQEOLB7</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">1.h</spanx>
          </c>
          <c>
            <spanx style="verb">117GERCPRCJGG8J04EV1NDRK8D1JT14K</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">2</spanx>
          </c>
          <c>
            <spanx style="verb">7T70DRG4EKC28V93Q7GNBLEOPA7VLP6Q</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">3.3</spanx>
          </c>
          <c>
            <spanx style="verb">8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">3</spanx>
          </c>
          <c>
            <spanx style="verb">75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">a</spanx>
          </c>
          <c>
            <spanx style="verb">04SKNAPCA5AL7QOS3KM2L9TL3P5OKQ4C</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">b</spanx>
          </c>
          <c>
            <spanx style="verb">IUU8L5LMT76JELTP0BIR3TMG4U3UU8E7</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">h</spanx>
          </c>
          <c>
            <spanx style="verb">1AVVQN74SG75UKFVF25DGCETHGQ638EK</spanx>
          </c>
        
        
          <c>
            <spanx style="verb">x.2</spanx>
          </c>
          <c>
            <spanx style="verb">NDTU6DSTE50PR4A1F2QVR1V31G00I2I1</spanx>
          </c>
        
      
    
  <postamble>
      Hashed owner names for the example.org zone.
    </postamble></texttable>
</section>
<section title="Security Considerations" anchor="security-considerations">
  
  <t>
    This document raises no security issues.
  </t>
</section>
<section title="IANA Considerations" anchor="iana-considerations">
  
  <t>
    This document has no actions for IANA.
  </t>
</section>
<section title="Acknowledgements" anchor="acknowledgements">
  
  <t>
    This document would not be possible without the help of Ed Lewis,
    Roy Arends, Wouter Wijngaards, Olaf Kolkman, Carsten Strotmann,
    Jan-Piet Mens, Peter van Dijk, Marco Davids, Esther Makaay and
    Antoin Verschuren. Also valuable, was the source code of Unbound
    (<spanx style="verb">validator/val_nsec3.c</spanx>). Extensive feedback was
    received from Karst Koymans.
  </t>
</section>

</middle>

<back>
<references title="Normative References">
    <?rfc include="bib/reference.RFC.1034" ?>
    <?rfc include="bib/reference.RFC.2308" ?>
    <?rfc include="bib/reference.RFC.4033" ?>
    <?rfc include="bib/reference.RFC.4034" ?>
    <?rfc include="bib/reference.RFC.4035" ?>
    <?rfc include="bib/reference.RFC.4592" ?>
    <?rfc include="bib/reference.RFC.5155" ?>
</references>

<references title="Informative References">
    <?rfc include="bib/reference.RFC.2535" ?>
    <?rfc include="bib/reference.RFC.3655" ?>
    <?rfc include="bib/reference.RFC.3755" ?>
    <?rfc include="bib/reference.RFC.4956" ?>
    <?rfc include="bib/reference.I-D.arends-dnsnr.xml" ?>
    <?rfc include="bib/reference.I-D.laurie-dnsext-nsec2v2.xml" ?>
    <?rfc include="bib/reference.I-D.ietf-dnsext-not-exsiting-rr.xml" ?>
</references>
</back>
</rfc>
