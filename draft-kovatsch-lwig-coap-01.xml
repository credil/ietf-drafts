<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<rfc ipr="trust200902" docName="draft-kovatsch-lwig-coap-01" category="info">

<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

  <front>
    <title>CoAP Implementation Guidance</title>

    <author initials="M." surname="Kovatsch" fullname="Matthias Kovatsch">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Universitätstrasse 6</street>
          <city>CH-8092 Zurich</city>
          
          
          <country>Switzerland</country>
        </postal>
        
        
        <email>kovatsch@inf.ethz.ch</email>
        
      </address>
    </author>
    <author initials="O." surname="Bergmann" fullname="Olaf Bergmann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          
          
          <country>Germany</country>
        </postal>
        
        
        <email>bergmann@tzi.org</email>
        
      </address>
    </author>
    <author initials="E." surname="Dijk" fullname="Esko Dijk">
      <organization>Philips Research</organization>
      <address>
        
        
        <email>esko.dijk@philips.com</email>
        
      </address>
    </author>
    <author initials="X." surname="He" fullname="Xuan He">
      <organization>Hitachi (China) R&amp;D Corp.</organization>
      <address>
        <postal>
          <street>301, Tower C North, Raycom, 2 Kexuyuan Nanlu</street>
          <city>Beijing, 100190</city>
          
          
          <country>P.R.China</country>
        </postal>
        
        
        <email>xhe@hitachi.cn</email>
        
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann" role="editor">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>D-28359 Bremen</city>
          
          
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        
        <email>cabo@tzi.org</email>
        
      </address>
    </author>

    <date year="2013" month="July" day="15"/>

    <area>Internet</area>
    <workgroup>LWIG Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>The Constrained Application Protocol (CoAP) is designed for
resource-constrained nodes and networks, e.g., sensor nodes in a low-power
lossy network (LLN). Yet to implement this Internet protocol on
Class 1 devices (i.e., ~ 10 KiB of RAM and ~ 100 KiB of ROM) also lightweight
implementation techniques are necessary. This document provides
lessons learned from implementing CoAP for tiny, battery-operated networked
embedded systems. The guidelines for transmission state management and
developer APIs can also help with the implementation of CoAP for less
constrained nodes.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The Constrained Application Protocol <xref target="I-D.ietf-core-coap"/> has been designed
specifically for machine-to-machine communication in networks with very
constrained nodes.  Typical application scenarios therefore include building
automation and the Internet of Things.  The major design objectives
have been set on small protocol overhead, robustness against packet
loss, and against high latency induced by small bandwidth shares or slow
request processing in end nodes.  To leverage integration of
constrained nodes with the world-wide Internet, the protocol design
was led by the REST architectural style that accounts for the scalability
and robustness of the Hypertext Transfer Protocol <xref target="RFC2616"/>.
<!-- We probably don't need a reference to REST here. --></t>

<t>Lightweight implementations benefit from this design in many
respects: First, the use of Uniform Resource Identifiers (URIs) for
naming resources and the transparent forwarding of their
representations in a server-stateless request/response protocol make
protocol translation to HTTP a straightforward task.  Second, the
set of protocol elements that are unavoidable for the core protocol
and thus must be implemented on every node has been kept very small,
minimizing the unnecessary accumulation of “optional” features.  Options
that – when present – are critical for message processing are
explicitly marked as such to force immediate rejection of messages
with unknown critical options.  Third, the syntax of protocol data
units is easy to parse and is carefully defined to avoid creation of
state in servers where possible.</t>

<t>Although these features enable lightweight implementations of the
Constrained Application Protocol, there is still a tradeoff between
robustness and latency of constrained nodes on one hand and resource
demands (such as battery consumption, dynamic memory needs, and
static code size) on the other.  The present document gives some guidance on
possible strategies to solve this tradeoff for very constrained
nodes (Class 1 in <xref target="I-D.ietf-lwig-terminology"/>).  The main focus is
on servers as this is deemed the predominant case where CoAP
applications are faced with tight resource constraints.</t>

<t>Additional considerations for the implementation of CoAP on tiny
sensors are given in <xref target="I-D.arkko-core-sleepy-sensors"/>.
<!-- Last version from Jan 2012. Should be merged as well. --></t>

</section>
<section anchor="message-processing" title="Message Processing">

<t>For constrained nodes of Class 1 or even Class 2, the most limiting
factors for (wireless) network communication usually are memory size
and battery lifetime.  Most applications therefore try to minimize
internal buffer space for both transmit and receive operations, and to
maximize sleeping cycles.</t>

<t>In the programming styles supported by very simple operating systems,
preemptive multi-threading is not an option.  Instead, all operations are
triggered by an event loop system, e.g., in a send-receive-dispatch cycle.
It is also common practice to allocate memory statically to ensure stable
behavior, as no memory management unit (MMU) or other abstractions are
available.  For a CoAP node, the two key parameters for memory usage are
the number of (re)transmission buffers and the maximum message size that
must be supported by each buffer.  Often the maximum message size is set
far below the 1280-byte MTU of 6LoWPAN to allow more than one open Confirmable
transmission at a time (in particular for observe notifications).
Note that implementations on constrained platforms often not even
support the full MTU.  Larger messages must then use block-wise
transfers <xref target="I-D.ietf-core-block"/>, while a good tradeoff between
6LoWPAN fragmentation and CoAP header overhead must be found.
Usually the amount of available free RAM dominates this decision.
For Class 1 devices, the maximum message size is typically 128 or 256
bytes plus an estimate of the maximum header size with a worst case option
setting.</t>

<section anchor="message-buffer-usage" title="Message Buffer Usage">

<t>The cooperative multi-threading of an event loop system allows to optimize
memory usage through in-place processing and reuse of buffers, in particular
the IP buffer provided by the OS.</t>

<t>CoAP servers can significantly benefit from in-place processing, as
they can create responses directly in the incoming IP buffer. Note that an
embedded OS usually only has a single buffer for incoming and outgoing IP
packets.
The first few bytes of the basic header are usually parsed into
an internal data structure and can be overwritten without harm.
Thus, empty ACKs and RST messages can promptly be assembled and sent using
the IP buffer. Also when a CoAP server only sends piggy-backed or
Non-confirmable responses, no additional buffer is required at the application
layer. This, however, requires careful timing so that no incoming data is
overwritten before it was processed. Because of cooperative multi-threading,
this requirement is relaxed, though. Once the message is sent, the IP buffer
can accept new messages again. This does not work for Confirmable messages,
however. They need to be stored for retransmission and would block any
further IP communication.</t>

<t>Depending on the number of requests that can be handled in
parallel, an implementation might create a stub response filled with
any option that has to be copied from the original request to the
separate response, especially the Token option.  The drawback of
this technique is that the server must be prepared to receive
retransmissions of the previous (Confirmable) request to which a new
acknowledgement must be generated.  If memory is an issue, a single
buffer can be used for both tasks: Only the message type and code
must be updated, changing the message id is optional.  Once the
resource representation is known, it is added as new payload at the
end of the stub response.  Acknowledgements still can be sent as
described before as long as no additional options are required to
describe the payload.</t>

</section>
<section anchor="header-option-parsing-and-management" title="Header Option Parsing and Management">

<t>There are two alternatives to handle the header: Either process the header on
the fly when an option is accessed or initially parse all values into an
internal data structure.</t>

<section anchor="on-the-fly-processing" title="On-the-fly Processing">

<t>The advantage of on-the-fly processing is that the compact encoding saves
memory and fully reuses the buffer for incoming messages. The basic message
header information should always be copied into an internal data structure, as
Message ID and/or Token are required for request/response matching and
generating the response. Once the message is accepted for further processing,
the set of options contained in the received message must be decoded to check
for unknown critical options.  To avoid multiple passes through the
option list, the option parser might maintain a bit-vector where each
bit represents an option number that is present in the received
request. With the wide and sparse range of option numbers, the number itself
cannot be used to indicate the number of left-shift operations to mask the
corresponding bit. Hence, an implementation-specific enum of supported options
should be used to mask the present options of a message in the bitmap.
In addition, the byte index of every option can be added to a sparse list
(e.g., a one-dimensional array) for fast retrieval.</t>

<!--
  This
particularly enables efficient reduced-function handling of options
that might occur more than once such as Uri-Path.  In this
implementation strategy, the delta is zero for any subsequent path
segment, hence the stored byte index for option 11 (Uri-Path) will be
overwritten to hold a pointer to the last occurrence of that option,
i.e., only the last path component actually matters.  (Of course,
this requires choosing resource names where the combination of (final
Uri-Path component, final Uri-Query component) is server-wide unique.

Note:
: Where skipping all but the last path segment is not feasible for
  some reason, resource identification could be ensured by some hash
  value calculated over the path segments.  For each segment
  encountered, the stored hash value is updated by the current option
  value.  This works if a cheap *perfect hashing* scheme can be found
  for the resource names.
-->
<!-- There are not that many repeatable options where this makes sense. -->

<t>Once the option list has been processed at least up to the highest
option number that is supported by the application, any known
critical option and all elective options can be masked out to
determine if any unknown critical option was present.  If this is the
case, this information can be used to create a 4.02 response
accordingly.  (Note that the remaining options also must be processed
to add further critical options included in the original request.)</t>

</section>
<section anchor="internal-data-structure" title="Internal Data Structure">

<t>Using an internal data structure for all parsed options has advantages when
processing the values, as they are already in a variable of corresponding type
and integers in host byte order. The incoming payload and byte strings of the
header can be accessed directly in its IP buffer using pointers. This approach
also benefits from a bitmap. Otherwise special values must be reserved to
encode an unset option, which might require a larger type than required for
the actual value range (e.g., a 32-bit integer instead of 16-bit).</t>

<t>The byte
strings (e.g., the URI) are usually not required when generating the response.
Thus, this alternative also facilitates the usage of the IP buffer for message
assembly – all important values are copied from the shared incoming/outgoing
buffer.</t>

<t>Setting options for outgoing messages is also easier with an internal data
structure. Application developers can set options independent from the option
number order required for the delta encoding. The CoAP encoding is then applied
in a serialization step before sending.
On-the-fly processing might require extensive memmove operations to insert new
header options or needs to restrict developers to set options in order.</t>

</section>
</section>
<section anchor="retransmissions" title="Retransmissions">

<t>CoAP’s reliable transmissions require the before-mentioned
retransmission buffers.  Messages, such as the requests of a client,
should be stored in serialized form.  For servers, retransmissions
apply for Confirmable separate responses and Confirmable
notifications <xref target="I-D.ietf-core-observe"/>.  As separate responses stem
from long-lasting resource handlers, the response should be stored
for retransmission instead of re-dispatching a stored request (which
would allow for updating the representation).  For Confirmable
notifications, please see Section 2.6, as simply storing the response
can break the concept of eventual consistency.</t>

<t>String payloads such as JSON require a buffer to print to.  By
splitting the retransmission buffer into header and payload part, it
can be reused.  First to generate the payload and then storing the
CoAP message by serializing into the same memory.  Thus, providing a
retransmission for any message type can save the need for a separate
application buffer.  This, however, requires an estimation about the
maximum expected header size to split the buffer and a memmove to
concatenate the two parts.</t>

<t>For platforms that disable clock tick interrupts in sleep states, the
application must take into consideration the clock deviation that occurs
during sleep (or ensure to remain in idle state until the message has been
acknowledged or the maximum number of retransmissions is reached).
Since CoAP allows up to four retransmissions with a binary
exponential back-off it could take up to 45 seconds until the send
operation is complete.  Even in idle state, this means substantial
energy consumption for low-power nodes.  Implementers therefore
might choose a two-step strategy: First, do one or two
retransmissions and then, in the later phases of back-off, go to sleep
until the next retransmission is due. In the meantime, the node could
check for new messages including the acknowledgement for any
Confirmable message to send.</t>

</section>
<section anchor="deduplication" title="Deduplication">

<t>If CoAP is used directly on top of UDP (i.e., in NoSec mode), it needs
to cope with the fact that the UDP
datagram transport can reorder and duplicate messages.
(In contrast to UDP, DTLS has its own duplicate detection.)
CoAP has been designed with protocol functionality such that rejection
of duplicate messages is always possible.
It is at the discretion of the receiver if it actually wants to make
use of this functionality.
Processing of duplicate messages comes at a cost, but so does the
management of the state associated with duplicate rejection.
Hence, a receiver may have good reasons to decide not to do the duplicate rejection.
If duplicate rejection is indeed necessary, e.g., for non-idempotent
requests, it is important to control the amount of state that needs to
be stored.</t>

<section anchor="managing-peer-mids" title="Managing Peer MIDs">

<t>CoAP’s duplicate rejection functionality can be straightforwardly
implemented in a CoAP
end-point by storing, for each remote CoAP end-point (“peer”) that it
communicates with, a list of recently received CoAP Message IDs (MIDs)
along with some timing information.
A CoAP message from a peer with a MID that is in the list for that peer
can simply be discarded.</t>

<t>The timing information in the list can then be used to time out
entries that are older than the <spanx style='emph'>expected extent of the re-ordering</spanx>,
an upper bound for which can be estimated by adding the <spanx style='emph'>potential
retransmission window</spanx> (<xref target="I-D.ietf-core-coap"/> section “Reliable
Messages”) and the time packets can stay alive in the network.</t>

<t>Such a straightforward implementation is suitable in case other CoAP
end-points generate random MIDs. However, this storage method may
consume substantial RAM in specific cases, such as:</t>

<t><list style='symbols'>
  <t>many clients are making periodic, non-idempotent requests to a
single CoAP server;</t>
  <t>one client makes periodic requests to a large number of CoAP
servers and/or requests a large number of resources; where servers
happen to mostly generate separate CoAP responses (not piggy-backed);</t>
</list></t>

<t>For example, consider the first case where the expected extent of re-ordering
is 50 seconds, and N clients are sending periodic POST
requests to a single CoAP server during a period of high system
activity, each on average sending one client request per second.
The server would need 100 * N bytes of RAM to store the MIDs only.
This amount of RAM may be significant on a RAM-constrained
platform. On a number of platforms, it may be easier to allocate some
extra program memory (e.g. Flash or ROM) to the CoAP protocol handler
process than to allocate extra RAM. Therefore, one may try to reduce
RAM usage of a CoAP implementation at the cost of some additional
program memory usage and implementation complexity.</t>

<t>Some CoAP clients generate MID values by a using a Message ID variable
<xref target="I-D.ietf-core-coap"/> that is incremented by one each time a new MID
needs to be generated.  (After the maximum value 65535 it wraps back
to 0.)  We call this behavior “sequential” MIDs.  One approach to
reduce RAM use exploits the redundancy in sequential MIDs for a more
efficient MID storage in CoAP servers.</t>

<t>Naturally such an approach requires, in order to actually reduce RAM
usage in an implementation, that a large part of the peers follow the
sequential MID behavior. To realize this optimization, the authors
therefore RECOMMEND that CoAP end-point implementers employ the
“sequential MID” scheme if there are no reasons to prefer another
scheme, such as randomly generated MID values.</t>

<t>Security considerations might call for a choice for (pseudo)randomized
MIDs. Note however that with truly randomly generated MIDs the
probability of MID collision is rather high in use cases as mentioned
before, following from the Birthday Paradox. For example, in a
sequence of 52 randomly drawn 16-bit values the probability of finding
at least two identical values is about 2 percent.</t>

<t>From here on we consider efficient storage implementations for MIDs in
CoAP end-points, that are optimized to store “sequential”
MIDs. Because CoAP messages may be lost or arrive out-of-order, a
solution has to take into
account that received MIDs of CoAP messages are not actually arriving
in a sequential fashion, due to lost or reordered messages. Also a
peer might reset and lose its MID counter(s) state. In addition, a
peer may have a single Message ID variable used in messages to many
CoAP end-points it communicates with, which partly breaks
sequentiality from the receiving CoAP end-point’s
perspective. Finally, some peers might use a randomly generated MID
values approach. Due to these specific conditions, existing sliding
window bitfield implementations for storing received sequence numbers
are typically not directly suitable for efficiently storing MIDs.</t>

<t><xref target="mid-store"/> shows one example for a per-peer MID storage design: a
table with a bitfield of a defined length <spanx style='emph'>K</spanx> per entry to store
received MIDs (one per bit) that have a value in the range
[MID_i + 1 , MID_i + K].</t>

<texttable title="A per-peer table for storing MIDs based on MID_i" anchor="mid-store">
      <ttcol align='left'>MID base</ttcol>
      <ttcol align='left'>K-bit bitfield</ttcol>
      <ttcol align='left'>base time value</ttcol>
      <c>MID_0</c>
      <c>010010101001</c>
      <c>t_0</c>
      <c>MID_1</c>
      <c>111101110111</c>
      <c>t_1</c>
      <c>… etc.</c>
      <c>&#160;</c>
      <c>&#160;</c>
</texttable>

<t>The presence of a table row with base MID_i (regardless of the
bitfield values) indicates that a value MID_i has been received at a
time t_i.  Subsequently, each bitfield bit k (0…K-1) in a row i
corresponds to a received MID value of MID_i + k + 1. If a bit k is
0, it means a message with corresponding MID has not yet been
received. A bit 1 indicates such a message has been received already
at approximately time t_i. This storage structure allows e.g. with
k=64 to store in best case up to 130 MID values using 20 bytes, as
opposed to 260 bytes that would be needed for a non-sequential storage
scheme.</t>

<t>The time values t_i are used for removing rows from the table
after a preset timeout period, to keep the MID store small in size and
enable these MIDs to be safely re-used in future communications.
(Note that the table only stores one time value per row, which
therefore needs to be updated on receipt of another MID that is stored
as a single bit in this row.  As a consequence of only storing one
time value per row, older MID entries typically time out later than
with a simple per-MID time value storage scheme.  The end-point
therefore needs to ensure that this additional delay before MID
entries are removed from the table is much smaller than the time
period after which a peer starts to re-use MID values due to
wrap-around of a peer’s MID variable. One solution is to check that a
value t_i in a table row is still recent enough, before using the row
and updating the
value t_i to current time. If not recent enough, e.g. older than N
seconds, a new row with an empty bitfield is
created.)
[Clearly, these optimizations would benefit if the peer were much more conservative about re-using MIDs than currently required in the protocol specification.]</t>

<t>The optimization described is less efficient for storing randomized
MIDs that a CoAP end-point may encounter from certain peers.  To solve
this, a storage algorithm may start in a simple MID storage mode,
first assuming that the peer produces non-sequential MIDs. While
storing MIDs, a heuristic is then applied based on monitoring some
“hit rate”, for example, the number of MIDs received that have a Most
Significant Byte equal to that of the previous MID divided by the
total number of MIDs received.  If the hit rate tends towards 1 over a
period of time, the MID store may decide that this particular CoAP
end-point uses sequential MIDs and in response improve efficiency by
switching its mode to the bitfield based storage.</t>

<!--
  <t>
    TBD: multicast messages
  </t>
-->

</section>
<section anchor="resource-specific-deduplication" title="Resource-specific Deduplication">

<t>Deduplication is heavy for Class 1 devices, as the number of peer
addresses can be vast.  Servers should be kept stateless, i.e., the
REST API should be designed idempotent whenever possible.  When this
is not the case, the resource handler could perform an optimized
deduplication by exploiting knowledge about the application.
Another, server-wide strategy is to only keep track of non-idempotent
requests.</t>

</section>
</section>
</section>
<section anchor="transmission-state-management" title="Transmission State Management">

<t>CoAP endpoints must keep transmission state to manage open requests, to handle
the different response modes, and to implement reliable delivery at the message
layer. The following finite state machines (FSMs) model the transmissions of a
CoAP exchange at the request/response layer and the message layer. These layers
are linked through actions. The M_CMD() action triggers a corresponding
transition at the message layer and the FF_EVT() action triggers a transition
at the request/response layer. The FSMs also use guard conditions to
distinguish between information that is only available through the other layer
(e.g., whether a request was sent using a CON or NON message).</t>

<section anchor="requestresponse-layer" title="Request/Response Layer">

<t><xref target="fsm_rr_c"/> depicts the two states at the request/response layer of a
CoAP client. When a request is issued, a “reliable_send” or “unreliable_send”
is triggered at the message layer. The WAITING state can be left through three
transitions: Either the client cancels the request and triggers cancellation of
a CON transmission at the message layer, the client receives a failure event
from the message layer, or a receive event containing a response.</t>

<figure title="CoAP Client Request/Response Layer FSM" anchor="fsm_rr_c"><artwork><![CDATA[
    +------------CANCEL-------------------------------+
    |        / M_CMD(cancel)                          |
    |                                                 V
    |                                              +------+
+-------+ -------RR_EVT(fail)--------------------> |      |
|WAITING|                                          | IDLE |
+-------+ -------RR_EVT(rx)[is Response]---------> |      |
    ^                / M_CMD(accept)               +------+
    |                                                 |
    +--------------------REQUEST----------------------+
               / M_CMD((un)reliable_send)
]]></artwork></figure>

<t>A server resource can decide at the request/response layer whether to respond
with a piggy-backed or a separate response. Thus, there are two busy states in
<xref target="fsm_rr_s"/>, SERVING and SEPARATE. An incoming receive event with a NON
request directly triggers the transition to the SEPARATE state.</t>

<figure title="CoAP Server Request/Response Layer FSM" anchor="fsm_rr_s"><artwork><![CDATA[
+--------+ <----------RR_EVT(rx)[is NON]---------- +------+
|SEPARATE|                                         |      |
+--------+ ----------------RESPONSE--------------> | IDLE |
    ^            / M_CMD((un)reliable_send)        |      |
    |                                        +---> +------+
    |EMPTY_ACK                               |         |         
    |/M_CMD(accept)                          |         |
    |                                        |         |
    |                                        |         |
+--------+                                   |         |
|SERVING | --------------RESPONSE------------+         |
+--------+          / M_CMD(accept)                    |
    ^                                                  |
    +------------------------RR_EVT(rx)[is CON]--------+
]]></artwork></figure>

</section>
<section anchor="message-layer" title="Message Layer">

<t><xref target="fsm_m"/> shows the different states of a CoAP endpoint per message exchange.
Besides the linking action RR_EVT(), the message layer has a TX action to send
a message. For sending and receiving NONs, the endpoint remains in its CLOSED
state. When sending a CON, the endpoint remains in RELIABLE_TX and keeps
retransmitting until the transmission times out, it receives a matching RST,
the request/response layer cancels the transmission, or the endpoint receives
an implicit acknowledgement through a matching NON or CON. Whenever the
endpoint receives a CON, it transitions into the ACK_PENDING state, which can
be left by sending the corresponding ACK.</t>

<figure title="CoAP Message Layer FSM" anchor="fsm_m"><artwork><![CDATA[
+-----------+ <-------M_CMD(reliable_send)-----+
|           |            / TX(con)              \
|           |                                +--------------+
|           | ---TIMEOUT(RETX_WINDOW)------> |              |
|RELIABLE_TX|     / RR_EVT(fail)             |              |
|           | ---------------------RX_RST--> |              | <----+
|           |               / RR_EVT(fail)   |              |      |
+-----------+ ----M_CMD(cancel)------------> |    CLOSED    |      |
 ^  |  |  \  \                               |              | --+  |
 |  |  |   \  +-------------------RX_ACK---> |              |   |  |
 +*1+  |    \                / RR_EVT(rx)    |              |   |  |
       |     +----RX_NON-------------------> +--------------+   |  |
       |       / RR_EVT(rx)                  ^ ^ ^ ^  | | | |   |  |
       |                                     | | | |  | | | |   |  | 
       |                                     | | | +*2+ | | |   |  |
       |                                     | | +--*3--+ | |   |  |
       |                                     | +----*4----+ |   |  |
       |                                     +------*5------+   |  |
       |                +---------------+                       |  |
       |                |  ACK_PENDING  | <--RX_CON-------------+  |
       +----RX_CON----> |               |  / RR_EVT(rx)            |
         / RR_EVT(rx)   +---------------+ ---------M_CMD(accept)---+
                                                     / TX(ack)

*1: TIMEOUT(RETX_TIMEOUT) / TX(con)
*2: M_CMD(unreliable_send) / TX(non)
*3: RX_NON / RR_EVT(rx)
*4: RX_RST / REMOVE_OBSERVER
*5: RX_ACK 
]]></artwork></figure>

<t>T.B.D.: (i) Rejecting messages (can be triggered at message and request/response
layer). (ii) ACKs can also be triggered at both layers.</t>

<!--
## Taxonomy of Cases

MK:
This section was removed, as it is unclear whether it is needed.
Maybe single interesting cases can be picked for further explaination.
Restore the figures from the SVN (Rev. 12)

-->

</section>
</section>
<section anchor="observing" title="Observing">

<t>For each observer, the server needs to store at least address, port, token,
and the last outgoing message ID.  The latter is needed to match incoming
RST messages and cancel the observe relationship.</t>

<t>It is favorable to have one retransmission buffer per observable resource
that is shared among all observers.  Each notification is serialized once
into this buffer and only address, port, and token are changed when
iterating over the observer list (note that different token lengths
might require realignment).  The advantage becomes clear for
Confirmable notifications: Instead of one retransmission buffer per
observer, only one buffer and only individual retransmission counters
and timers in the list entry need to be stored.  When the
notifications can be sent fast enough, even a single timer would
suffice.  Furthermore, per-resource buffers simplify the update with
a new resource state during open deliveries.</t>

</section>
<section anchor="block-wise-transfers" title="Block-wise Transfers">

<t>Block-wise transfers have the main purpose of providing fragmentation
at the application layer, where partial information can be processed.
This is not possible at lower layers such as 6LoWPAN, as only
assembled packets can be passed up the stack.  While
<xref target="I-D.ietf-core-block"/> also anticipates atomic handling of blocks,
i.e., only fully received CoAP messages, this is not possible on
Class 1 devices.</t>

<t>When receiving a block-wise transfer, each blocks is usually passed to
a handler function that for instance performs stream processing or
writes the blocks to external memory such as flash.  Although there
are no restrictions in <xref target="I-D.ietf-core-block"/>, it is beneficial for
Class 1 devices to only allow ordered transmission of blocks.
Otherwise on-the-fly processing would not be possible.</t>

<t>When sending a block-wise transfer, Class 1 devices usually do not
have sufficient memory to print the full message into a buffer, and
slice and send it in a second step.  When transferring the CoRE Link
Format from /.well-known/core for instance, a generator function is
required that generates slices of a large string with a specific
offset length (a ‘sonprintf()’).  This functionality is required
recurrently and should be included in a library.</t>

</section>
<section anchor="application-developer-api" title="Application Developer API">

<t>Bringing a Web transfer protocol to constrained environments does not
only change the networking of the corresponding systems, but also the
way they should be programmed.  A CoAP implementation should provide
a developer API similar to REST frameworks in traditional computing.
A server should not be created around an event loop with several
function calls, but rather by implementing handlers following the
resource abstraction.</t>

<t>So far, the following types of RESTful resources were identified:</t>

<t><list style='hanging'>
  <t hangText='NORMAL'>
  A normal resource defined by a static Uri-Path that is
associated with a resource handler function.  Allowed methods
could already be filtered by the implementation based on flags.
This is the basis for all other resource types.</t>
  <t hangText='PARENT'>
  A parent resource manages several sub-resources by
programmatically evaluating the Uri-Path, which may be longer than
that of the parent resource.  Defining a URI templates (see
<xref target="RFC6570"/>) would be a convenient way to pre-parse arguments given
in the Uri-Path.</t>
  <t hangText='PERIODIC'>
  A resource that has an additional handler function that is
triggered periodically by the CoAP implementation with a resource-
defined interval.  It can be used to sample a sensor or perform
similar periodic updates.  Usually, a periodic resource is
observable and sends the notifications in the periodic handler
function.  These periodic tasks are quite common for sensor nodes,
thus it makes sense to provide this functionality in the CoAP
implementation and avoid redundant code in every resource.</t>
  <t hangText='EVENT'>
  An event resource is similar to an periodic resource, only
that the second handler is called by an irregular event such as a
button.</t>
</list></t>

<!--  LocalWords:  lossy CoAP LLNs KiB Contiki IETF LWIG scalability
 -->
<!--  LocalWords:  URIs retransmission multi retransmissions MMU MTU
 -->
<!--  LocalWords:  acknowledgement Acknowledgements multicast LoWPAN
 -->
<!--  LocalWords:  memmove CoAP's IP ACKs RST PDUs JSON UDP NoSec API
 -->
<!--  LocalWords:  datagram DTLS MIDs implementers sequentiality ACK
 -->
<!--  LocalWords:  bitfield optimizations decrement retransmits CoRE
 -->
<!--  LocalWords:  RESTful URI
 -->

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2616'>

<front>
<title abbrev='HTTP/1.1'>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='UC Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='J.' surname='Gettys' fullname='James Gettys'>
<organization abbrev='Compaq/W3C'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials='J.' surname='Mogul' fullname='Jeffrey C. Mogul'>
<organization abbrev='Compaq'>Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials='H.' surname='Frystyk' fullname='Henrik Frystyk Nielsen'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox'>Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials='P.' surname='Leach' fullname='Paul J. Leach'>
<organization abbrev='Microsoft'>Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='W3C/MIT'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year='1999' month='June' />
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name='RFC' value='2616' />
<format type='TXT' octets='422317' target='http://www.rfc-editor.org/rfc/rfc2616.txt' />
<format type='PS' octets='5529857' target='http://www.rfc-editor.org/rfc/rfc2616.ps' />
<format type='PDF' octets='550558' target='http://www.rfc-editor.org/rfc/rfc2616.pdf' />
<format type='HTML' octets='637302' target='http://xml.resource.org/public/rfc/html/rfc2616.html' />
<format type='XML' octets='493420' target='http://xml.resource.org/public/rfc/xml/rfc2616.xml' />
</reference>



<reference anchor='RFC6570'>

<front>
<title>URI Template</title>
<author initials='J.' surname='Gregorio' fullname='J. Gregorio'>
<organization /></author>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='M.' surname='Hadley' fullname='M. Hadley'>
<organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
<organization /></author>
<author initials='D.' surname='Orchard' fullname='D. Orchard'>
<organization /></author>
<date year='2012' month='March' />
<abstract>
<t>A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion.  This specification defines the URI Template syntax and the process for expanding a URI Template into a URI reference, along with guidelines for the use of URI Templates on the Internet. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6570' />
<format type='TXT' octets='79813' target='http://www.rfc-editor.org/rfc/rfc6570.txt' />
</reference>



<reference anchor='I-D.ietf-core-coap'>
<front>
<title>Constrained Application Protocol (CoAP)</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='June' day='28' year='2013' />

<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as 6LoWPAN often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine-to-machine (M2M) applications such as smart energy and building automation.  CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead and simplicity for constrained environments.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-coap-18' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-coap-18.txt' />
</reference>




    </references>

    <references title='Informative References'>





<reference anchor='I-D.ietf-core-block'>
<front>
<title>Blockwise transfers in CoAP</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<date month='June' day='27' year='2013' />

<abstract><t>CoAP is a RESTful transfer protocol for constrained nodes and networks.  Basic CoAP messages work well for the small payloads we expect from temperature sensors, light switches, and similar building-automation devices.  Occasionally, however, applications will need to transfer larger payloads -- for instance, for firmware updates.  With HTTP, TCP does the grunt work of slicing large payloads up into multiple packets and ensuring that they all arrive and are handled in the right order.  CoAP is based on datagram transports such as UDP or DTLS, which limits the maximum size of resource representations that can be transferred without too much fragmentation.  Although UDP supports larger payloads through IP fragmentation, it is limited to 64 KiB and, more importantly, doesn't really work well for constrained applications and networks.  Instead of relying on IP fragmentation, this specification extends basic CoAP with a pair of "Block" options, for transferring multiple blocks of information from a resource representation in multiple request-response pairs.  In many important cases, the Block options enable a server to be truly stateless: the server can handle each block transfer separately, with no need for a connection setup or other server-side memory of previous block transfers.  In summary, the Block options provide a minimal way to transfer larger representations in a block-wise fashion.  The present revision -11 fixes one example and adds the text and examples about the Block/Observe interaction, taken from -observe. It also adds a couple of formatting bugs from the new xml2rfc.  The "grand rewrite" is next.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-block-12' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-block-12.txt' />
</reference>



<reference anchor='I-D.ietf-core-observe'>
<front>
<title>Observing Resources in CoAP</title>

<author initials='K' surname='Hartke' fullname='Klaus Hartke'>
    <organization />
</author>

<date month='February' day='25' year='2013' />

<abstract><t>CoAP is a RESTful application protocol for constrained nodes and networks.  The state of a resource on a CoAP server can change over time.  This document specifies a simple protocol extension for CoAP that enables CoAP clients to "observe" resources, i.e., to retrieve a representation of a resource and keep this representation updated by the server over a period of time.  The protocol follows a best- effort approach for sending new representations to clients, and provides eventual consistency between the state observed by each client and the actual resource state at the server.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-observe-08' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-observe-08.txt' />
</reference>



<reference anchor='I-D.ietf-lwig-terminology'>
<front>
<title>Terminology for Constrained Node Networks</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='M' surname='Ersue' fullname='Mehmet Ersue'>
    <organization />
</author>

<author initials='A' surname='Keranen' fullname='Ari Keranen'>
    <organization />
</author>

<date month='July' day='9' year='2013' />

<abstract><t>The Internet Protocol Suite is increasingly used on small devices with severe constraints, creating constrained node networks.  This document provides a number of basic terms that have turned out to be useful in the standardization work for constrained environments.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-lwig-terminology-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-lwig-terminology-05.txt' />
</reference>



<reference anchor='I-D.arkko-core-sleepy-sensors'>
<front>
<title>Implementing Tiny COAP Sensors</title>

<author initials='J' surname='Arkko' fullname='Jari Arkko'>
    <organization />
</author>

<author initials='H' surname='Rissanen' fullname='Heidi-Maria Rissanen'>
    <organization />
</author>

<author initials='S' surname='Loreto' fullname='Salvatore Loreto'>
    <organization />
</author>

<author initials='Z' surname='Turanyi' fullname='Zoltan Turanyi'>
    <organization />
</author>

<author initials='O' surname='Novo' fullname='Oscar Novo'>
    <organization />
</author>

<date month='July' day='5' year='2011' />

<abstract><t>The authors are developing COAP and IPv6-based sensor networks for environments where lightweight implementations, long battery lifetimes, and minimal management burden are important.  The memo shows how different communication models supported by COAP affect implementation complexity and energy consumption, far more so than mere changes in message syntax.  Our prototype implements a multicast-based IPv6, UDP, COAP, and XML protocol stack in less than 50 assembler instructions.  While this extremely minimal implementation is suitable only for limited applications and makes a number of assumptions, the general conclusions point to need for further work in developing the COAP multicast and observation frameworks.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-arkko-core-sleepy-sensors-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-arkko-core-sleepy-sensors-01.txt' />
</reference>




    </references>



  </back>
</rfc>

