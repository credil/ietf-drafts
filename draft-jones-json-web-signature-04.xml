<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC1421 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1421.xml">
<!ENTITY RFC1738 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1738.xml">
<!ENTITY RFC2045 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY RFC2104 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml">
<!ENTITY RFC2818 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml">
<!ENTITY RFC3275 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3275.xml">
<!ENTITY RFC3339 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY RFC3447 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC3629 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC3986 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC5246 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC5280 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC6125 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-jones-json-web-signature-04"
     ipr="trust200902">
  <front>
    <title>JSON Web Signature (JWS)</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
      <organization>Google</organization>
      <address>
	<email>balfanz@google.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>independent</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
      <organization>Microsoft</organization>
      <address>
	<email>yarong@microsoft.com</email>
      </address>
    </author>

    <author fullname="John Panzer" initials="J." surname="Panzer">
      <organization>Google</organization>
      <address>
	<email>jpanzer@google.com</email>
      </address>
    </author>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>Nomura Research Institute</organization>
      <address>
	<email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
      <organization>Facebook</organization>
      <address>
	<email>pt@fb.com</email>
      </address>
    </author>

    <date day="13" month="December" year="2011" />

    <area>Security</area>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>Assertion</keyword>
    <keyword>Simple Web Token</keyword>
    <keyword>Security Token</keyword>
    <keyword>SWT</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>JSON Web Signature</keyword>
    <keyword>JWS</keyword>
    <keyword>JSON Web Encryption</keyword>
    <keyword>JWE</keyword>
    <keyword>JSON Web Key</keyword>
    <keyword>JWK</keyword>

    <abstract>
      <t>
	JSON Web Signature (JWS) is a means of representing signed
	content using JSON data structures.  Related encryption
	capabilities are described in the separate JSON Web Encryption
	(JWE) specification.
      </t>
    </abstract>

    <note title="Requirements Language">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	JSON Web Signature (JWS) is a compact signature format
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.  It represents
	signed content using JSON <xref target="RFC4627" /> data
	structures.  The JWS signature mechanisms are independent of
	the type of content being signed, allowing arbitrary content
	to be signed.  A related encryption capability is described in
	a separate JSON Web Encryption (JWE) <xref target="JWE" />
	specification.
      </t>
    </section>

    <section title="Terminology">
      <t>
	<list style="hanging">

          <t hangText="JSON Web Signature (JWS)">
	    A data structure cryptographically securing a JWS Header
	    and a JWS Payload with a JWS Signature.
	  </t>

          <t hangText="JWS Header">
	    A string representing a JSON object that describes the
	    signature applied to the JWS Header and the JWS Payload to
	    create the JWS Signature.
	  </t>
          <t hangText="JWS Payload">
	    The bytes to be signed - a.k.a., the message.
	  </t>
          <t hangText="JWS Signature">
	    A byte array containing the cryptographic
	    material that secures the contents of the JWS Header
	    and the JWS Payload.
	  </t>

          <t hangText="Encoded JWS Header">
	    Base64url encoding of the bytes of the
	    UTF-8 <xref target="RFC3629">RFC 3629</xref>
	    representation of the JWS Header.
	  </t>
          <t hangText="Encoded JWS Payload">
	    Base64url encoding of the JWS Payload.
	  </t>
          <t hangText="Encoded JWS Signature">
	    Base64url encoding of the JWS Signature.
	  </t>

	  <t hangText="JWS Signing Input">
	    The concatenation of the Encoded JWS Header, a period ('.')
	    character, and the Encoded JWS Payload.
	  </t>

	  <t hangText="Header Parameter Names">
	    The names of the members within the JSON object
	    represented in a JWS Header.
	  </t>
	  <t hangText="Header Parameter Values">
	    The values of the members within the JSON object
	    represented in a JWS Header.
	  </t>

	  <t hangText="Digital Signature">
	    For the purposes of this specification, we use this term
	    to encompass both Hash-based Message Authentication Codes
	    (HMACs), which can provide authenticity but not
	    non-repudiation, and digital signatures using public key
	    algorithms, which can provide both.  Readers should be
	    aware of this distinction, despite the decision to use a
	    single term for both concepts to improve readability of
	    the specification.
	  </t>
          <t hangText="Base64url Encoding">
	    For the purposes of this specification, this term always
	    refers to the URL- and filename-safe Base64 encoding
	    described in <xref target="RFC4648">RFC 4648</xref>,
	    Section 5, with the (non URL-safe) '=' padding characters
	    omitted, as permitted by Section 3.2.  (See <xref
	    target="base64urlnotes" /> for notes on implementing
	    base64url encoding without padding.)
	  </t>
        </list>
      </t>
    </section>

    <section title="JSON Web Signature (JWS) Overview">

      <t>
	JWS represents signed content using JSON data
	structures and base64url encoding. The representation
	consists of three parts: the JWS Header, the JWS Payload,
	and the JWS Signature.  The three parts are
	base64url-encoded for transmission, and typically represented
	as the concatenation of the encoded strings in that order,
	with the three strings being separated by period ('.')
	characters.
      </t>
      <t>
        The JWS Header describes the signature method and parameters employed.
	The JWS Payload is the message content to be secured.
	The JWS Signature ensures the integrity of
	both the JWS Header and the JWS Payload.
      </t>

      <section title="Example JWS" anchor="ExampleJWS">

	<t>
	  The following example JWS Header declares that the
	  encoded object is a JSON Web Token (JWT) <xref target="JWT" />
	  and the JWS Header and the JWS Payload are
	  signed using the HMAC SHA-256 algorithm:
	</t>

	<figure><artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWS Header yields this Encoded JWS Header value:
	</t>

	<figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork></figure>

	<t>
	  The following is an example of a JSON object that can be
	  used as a JWS Payload.  (Note that the payload can be any
	  content, and need not be a representation of a JSON object.)
	</t>

	<figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	<t>
	  Base64url encoding the bytes of the UTF-8 representation of the JSON
	  object yields the following Encoded JWS Payload
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	<t>
	  Signing the UTF-8 representation of the JWS Signing Input
	  (the concatenation of the Encoded JWS Header, a period ('.')
	  character, and the Encoded JWS Payload) with the HMAC
	  SHA-256 algorithm and base64url encoding the result, as per
	  <xref target="DefiningHMAC"></xref>, yields this
	  Encoded JWS Signature value:
	</t>

	<figure><artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	<t>
	  Concatenating these parts in the order
	  Header.Payload.Signature with period characters between the
	  parts yields this complete JWS representation
	  (with line breaks for display purposes only):
	</t>

	<figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	<t>
	  This computation is illustrated in more detail in <xref
	  target="HMACSHA256Example"></xref>.
	</t>

      </section>
    </section>

    <section title="JWS Header">

      <t>
	The members of the JSON object represented by the JWS Header describe the signature applied to the Encoded JWS Header and the Encoded JWS Payload and optionally
	additional properties of the JWS.
	The Header Parameter Names within this object MUST be unique.
	Implementations MUST
	understand the entire contents of the header; otherwise, the
	JWS MUST be rejected for processing.
      </t>
      <t>
	The JWS Header MUST contain an <spanx style="verb">alg</spanx>
	parameter, the value of
	which is a string that unambiguously identifies the algorithm
	used to sign the JWS Header and the JWS Payload to
	produce the JWS Signature.
      </t>

      <t>
        There are three classes of Header Parameter Names:
	Reserved Header Parameter Names, Public Header Parameter Names,
	and Private Header Parameter Names.
      </t>

      <section title="Reserved Header Parameter Names" anchor="ReservedHeaderParameterName">
	<t>
	  The following header parameter names are reserved.  All
	  the names are short because a core goal of JWSs is for the
	  representations to be compact.
	</t>

	<texttable title="Reserved Header Parameter Definitions" anchor="HeaderParameterTable">

	  <ttcol align="left">Header Parameter Name</ttcol>
	  <ttcol align="left">JSON Value Type</ttcol>
	  <ttcol align="left">Header Parameter Syntax</ttcol>
	  <ttcol align="left">Header Parameter Semantics</ttcol>

	  <c>alg</c>
	  <c>string</c>
	  <c>StringOrURI</c>
	  <c>
	    The <spanx style="verb">alg</spanx> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    secure the JWS.  A list of defined
	    <spanx style="verb">alg</spanx> values is presented in <xref
	    target="AlgTable"></xref>.  The processing of the <spanx
	    style="verb">alg</spanx> header parameter
	    requires that the value MUST be one that
	    is both supported and for which there exists a key for use
	    with that algorithm associated with the signer of the
	    content.
	    The <spanx style="verb">alg</spanx> parameter value is case sensitive.
	    This header parameter is REQUIRED.
	  </c>

	  <c>typ</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">typ</spanx> (type) header
	    parameter is used to declare the type of the signed
	    content.
	    The <spanx style="verb">typ</spanx> value is case sensitive.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>jku</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The <spanx style="verb">jku</spanx> (JSON Web Key URL)
	    header parameter is an absolute URL that refers to a
	    resource for a set of JSON-encoded public keys, one of
	    which corresponds to the key that was used to sign the
	    JWS.
	    The keys MUST be encoded as described in the JSON Web Key
	    (JWK) <xref target="JWK" /> specification.
	    The protocol used to acquire the resource MUST provide
	    integrity protection.  An HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818">RFC
	    2818</xref> <xref target="RFC5246">RFC 5246</xref> with
	    server authentication <xref target="RFC6125">RFC
	    6125</xref>.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>kid</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">kid</spanx> (key ID) header
	    parameter is a hint indicating which specific key owned by
	    the signer should be used to validate the signature.  This
	    allows signers to explicitly signal a change of key to
	    recipients.  The interpretation of the
	    contents of the <spanx style="verb">kid</spanx> parameter
	    is unspecified.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>x5u</c>
	  <c>string</c>
	  <c>URL</c>
	  <c>
	    The <spanx style="verb">x5u</spanx> (X.509 URL) header
	    parameter is an absolute URL that refers to a resource for
	    the X.509 public key certificate or certificate chain
	    corresponding to the key used to sign the JWS.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <xref target="RFC5280">RFC 5280</xref> in PEM encoded form
	    <xref target="RFC1421">RFC 1421</xref>.
	    The protocol used to acquire the resource MUST provide
	    integrity protection.  An HTTP GET request to retrieve the
	    certificate MUST use TLS <xref target="RFC2818">RFC
	    2818</xref> <xref target="RFC5246">RFC 5246</xref> with
	    server authentication <xref target="RFC6125">RFC
	    6125</xref>.
	    This header parameter is OPTIONAL.
	  </c>

	  <c>x5t</c>
	  <c>string</c>
	  <c>String</c>
	  <c>
	    The <spanx style="verb">x5t</spanx> (x.509 certificate
	    thumbprint) header parameter provides a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of an
	    X.509 certificate that can be used to match the certificate.
	    This header parameter is OPTIONAL.
	  </c>

	</texttable>

	<t>
	  Additional reserved header parameter names MAY be defined
	  via the IANA JSON Web Signature Header Parameters registry,
	  as per <xref target="IANA" />.  The syntax values used above
	  are defined as follows:
	</t>

	<texttable title="Header Parameter Syntax Definitions" anchor="SyntaxDefinitions">
	  <ttcol align="left">Syntax Name</ttcol>
	  <ttcol align="left">Syntax Definition</ttcol>

	  <c>IntDate</c>
	  <c>
	    The number of seconds from 1970-01-01T0:0:0Z as measured
	    in UTC until the desired date/time. See <xref
	    target="RFC3339">RFC 3339</xref> for details regarding
	    date/times in general and UTC in particular.
	  </c>

	  <c>String</c>
	  <c>
	    Any string value MAY be used.
	  </c>

	  <c>StringOrURI</c>
	  <c>
	    Any string value MAY be used but a value containing a ":"
	    character MUST be a URI as defined in <xref
	    target="RFC3986">RFC 3986</xref>.
	  </c>

	  <c>URL</c>
	  <c>
	    A URL as defined in <xref target="RFC1738">RFC 1738</xref>.
	  </c>
	</texttable>

      </section>

      <section title="Public Header Parameter Names" anchor="PublicHeaderParameterName">

        <t>
	  Additional header parameter names can be defined by those
	  using JWSs. However, in order to prevent collisions, any new
	  header parameter name or algorithm value SHOULD either be
	  defined in the IANA JSON Web Signature Header Parameters
	  registry or be defined as a URI that contains a collision
	  resistant namespace.  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the header parameter name.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>
      </section>

      <section title="Private Header Parameter Names" anchor="PrivateHeaderParameterName">

	<t>
	  A producer and consumer of a JWS may agree to any header
	  parameter name that is not a Reserved Name <xref
	  target="ReservedHeaderParameterName"></xref> or a Public
	  Name <xref
	  target="PublicHeaderParameterName"></xref>. Unlike Public
	  Names, these private names are subject to collision and
	  should be used with caution.
	</t>
	<t>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	</t>

      </section>
    </section>

    <section title="Rules for Creating and Validating a JWS">
      <t>
	To create a JWS, one MUST perform these steps:

        <list style="numbers">

	  <t>
	    Create the content to be used as the JWS Payload.
	  </t>
          <t>
	    Base64url encode the bytes of the JWS Payload.  This
	    encoding becomes the Encoded JWS Payload.
	  </t>
	  <t>
	    Create a JWS Header containing the desired set of header
	    parameters.  Note that white space is explicitly allowed
	    in the representation and no canonicalization is performed
	    before encoding.
	  </t>
	  <t>
	    Base64url encode the bytes of the UTF-8 representation of
	    the JWS Header to create the Encoded JWS Header.
	  </t>
          <t>
	    Compute the JWS Signature in the manner defined for
	    the particular algorithm being used.  The JWS Signing
	    Input is always the concatenation of the Encoded JWS Header,
	    a period ('.') character, and the Encoded JWS Payload.  The
	    <spanx style="verb">alg</spanx> header parameter MUST be
	    present in the JSON Header, with the algorithm value
	    accurately representing the algorithm used to construct
	    the JWS Signature.
	  </t>
	  <t>
	    Base64url encode the representation of the JWS Signature to create the Encoded JWS Signature.
	  </t>
        </list>
      </t>
      <t>
	When validating a JWS, the following steps MUST be taken. If
	any of the listed steps fails, then the signed content MUST be
	rejected.
      </t>
      <t>
	<list style="numbers">
          <t>
	    The Encoded JWS Header MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWS Header MUST be completely valid
	    JSON syntax conforming to <xref target="RFC4627">RFC
	    4627</xref>.
	  </t>
          <t>
	    The JWS Header MUST be validated to only include
	    parameters and values whose syntax and semantics are both
	    understood and supported.
	  </t>
          <t>
	    The Encoded JWS Payload MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The Encoded JWS Signature MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  </t>
          <t>
	    The JWS Signature MUST be successfully validated
	    against the JWS Header and JWS Payload
	    in the manner defined for the algorithm being used, which
	    MUST be accurately represented by the value of the <spanx style="verb">alg</spanx>
	    header parameter, which MUST be present.
	  </t>
        </list>
      </t>

      <t>
	Processing a JWS inevitably requires comparing known strings
	to values in the header. For example, in checking what the
	algorithm is, the Unicode string encoding <spanx style="verb">alg</spanx> will be
	checked against the member names in the JWS Header
	to see if there is a matching header parameter
	name. A similar process occurs when determining if the value
	of the <spanx style="verb">alg</spanx> header parameter represents a supported
	algorithm.
      </t>
      <t>
	Comparisons between JSON strings and other Unicode strings
	MUST be performed as specified below:

	<list style="numbers">

          <t>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  </t>
          <t>
	    <xref target="USA15">Unicode Normalization</xref> MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  </t>
          <t>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  </t>

        </list>
      </t>

    </section>

    <section title="Signing JWSs with Cryptographic Algorithms" anchor="Signing">

      <t>
	JWSs use specific cryptographic algorithms to sign the contents
	of the JWS Header and the JWS Payload.  The
	use of the following algorithms for producing JWSs is defined in
	this section.  The table below is the list of <spanx style="verb">alg</spanx> header
	parameter values defined by this specification, each of which
	is explained in more detail in the following sections:
      </t>

      <texttable title='JWS Defined "alg" Parameter Values' anchor="AlgTable">

	<ttcol align="left">Alg Parameter Value</ttcol>
	<ttcol align="left">Algorithm</ttcol>

	<c>HS256</c>
	<c>HMAC using SHA-256 hash algorithm</c>

	<c>HS384</c>
	<c>HMAC using SHA-384 hash algorithm</c>

	<c>HS512</c>
	<c>HMAC using SHA-512 hash algorithm</c>

	<c>RS256</c>
	<c>RSA using SHA-256 hash algorithm</c>

	<c>RS384</c>
	<c>RSA using SHA-384 hash algorithm</c>

	<c>RS512</c>
	<c>RSA using SHA-512 hash algorithm</c>

	<c>ES256</c>
	<c>ECDSA using P-256 curve and SHA-256 hash algorithm</c>

	<c>ES384</c>
	<c>ECDSA using P-384 curve and SHA-384 hash algorithm</c>

	<c>ES512</c>
	<c>ECDSA using P-521 curve and SHA-512 hash algorithm</c>

      </texttable>

      <t>
	See <xref target="algxref" /> for a table cross-referencing the <spanx
	style="verb">alg</spanx> values used in this specification
	with the equivalent identifiers used by other
	standards and software packages.
      </t>

      <t>
	Of these algorithms, only HMAC SHA-256 MUST be implemented by
	conforming implementations.  It is RECOMMENDED that
	implementations also support the RSA SHA-256 and ECDSA P-256
	SHA-256 algorithms.  Support for other algorithms and key
	sizes is OPTIONAL.
      </t>

      <t>
	The signed content for a JWS is the same for all algorithms:
	the concatenation of the Encoded JWS Header, a period ('.')
	character, and the Encoded JWS Payload.  This character sequence
	is referred to as the JWS Signing Input.  Note that if the JWS
	represents a JWT, this corresponds to the portion of the JWT
	representation preceding the second period character.  The
	UTF-8 representation of the JWS Signing Input is passed to the
	respective signing algorithms.
      </t>

      <section title="Creating a JWS with HMAC SHA-256, HMAC SHA-384, or HMAC SHA-512" anchor="DefiningHMAC">

	<t>
	  Hash based Message Authentication Codes (HMACs) enable one to
	  use a secret plus a cryptographic hash function to generate a
	  Message Authentication Code (MAC). This can be used to
	  demonstrate that the MAC matches the hashed content, in this
	  case the JWS Signing Input, which therefore demonstrates that
	  whoever generated the MAC was in possession of the secret.
	  The means of exchanging the shared key is outside the scope
	  of this specification.
	</t>
	<t>
	  The algorithm for implementing and validating HMACs is
	  provided in <xref target="RFC2104">RFC 2104</xref>.  This
	  section defines the use of the HMAC SHA-256, HMAC SHA-384,
	  and HMAC SHA-512 cryptographic hash functions as defined in
	  <xref target="FIPS.180-3">FIPS 180-3</xref>. The
	  <spanx style="verb">alg</spanx> header parameter values
	  <spanx style="verb">HS256</spanx>, <spanx
	  style="verb">HS384</spanx>, and <spanx
	  style="verb">HS512</spanx> are used in the JWS Header
	  to indicate that the Encoded JWS Signature contains a base64url
	  encoded HMAC value using the respective hash function.
	</t>
	<t>
	  The HMAC SHA-256 MAC is generated as follows:

	  <list style="numbers">
	    <t>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWS Signing Input using the shared
	      key to produce an HMAC value.
	    </t>
	    <t>
	      Base64url encode the resulting HMAC value.
	    </t>
	  </list>

	  The output is the Encoded JWS Signature for that JWS.
	</t>

	<t>
	  The HMAC SHA-256 MAC for a JWS is validated as follows:

	  <list style="numbers">

	    <t>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWS Signing Input of the JWS using
	      the shared key.
	    </t>
	    <t>
	      Base64url encode the resulting HMAC value.
	    </t>
	    <t>
	      If the JWS Signature and the base64url encoded HMAC
	      value exactly match, then one has confirmation that the
	      shared key was used to generate the HMAC on the JWS and that the
	      contents of the JWS have not be tampered with.
	    </t>
	    <t>
	      If the validation fails, the signed content MUST be rejected.
	    </t>

	  </list>
	</t>

	<t>
	  Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is
	  performed identically to the procedure for HMAC SHA-256 - just
	  with correspondingly longer key and result values.
	</t>

      </section>

      <section title="Creating a JWS with RSA SHA-256, RSA SHA-384, or RSA SHA-512" anchor="DefiningRSA">

	<t>
	  This section defines the use of the RSASSA-PKCS1-v1_5
	  signature algorithm as defined in <xref target="RFC3447">RFC
	  3447</xref>, Section 8.2 (commonly known as PKCS#1), using
	  SHA-256, SHA-384, or SHA-512 as the hash function.  The
	  RSASSA-PKCS1-v1_5 algorithm is described in <xref
	  target="FIPS.186-3">FIPS 186-3</xref>, Section 5.5, and the
	  SHA-256, SHA-384, and SHA-512 cryptographic hash functions
	  are defined in <xref target="FIPS.180-3">FIPS 180-3</xref>.
	  The <spanx style="verb">alg</spanx> header
	  parameter values <spanx style="verb">RS256</spanx>, <spanx
	  style="verb">RS384</spanx>, and <spanx
	  style="verb">RS512</spanx> are used in the JWS Header
	  to indicate that the Encoded JWS Signature contains a base64url
	  encoded RSA signature using the respective hash function.
	</t>
	<t>
	  The public keys employed can be identified using Header
	  Parameter methods described in <xref
	  target="ReservedHeaderParameterName" /> or can be
	  distributed using methods that are outside the scope of this
	  specification.
	</t>
	<t>
	  A 2048-bit or longer key length MUST be used with this
	  algorithm.
	</t>
	<t>
	  The RSA SHA-256 signature is generated as follows:

	  <list style="numbers">

	    <t>
	      Generate a digital signature of the UTF-8 representation
	      of the JWS Signing Input using RSASSA-PKCS1-V1_5-SIGN
	      and the SHA-256 hash function with the desired private
	      key. The output will be a byte array.
	    </t>
	    <t>
	      Base64url encode the resulting byte array.
	    </t>

	  </list>

	  The output is the Encoded JWS Signature for that JWS.
	</t>

	<t>
	  The RSA SHA-256 signature for a JWS is validated as follows:

	  <list style="numbers">

	    <t>
	      Take the Encoded JWS Signature and base64url decode it into
	      a byte array. If decoding fails, the signed content MUST
	      be rejected.
	    </t>
	    <t>
	      Submit the UTF-8 representation of the JWS Signing Input
	      and the public key corresponding to the private key used
	      by the signer to the RSASSA-PKCS1-V1_5-VERIFY algorithm
	      using SHA-256 as the hash function.
	    </t>
	    <t>
	      If the validation fails, the signed content MUST be rejected.
	    </t>

	  </list>
	</t>

	<t>
	  Signing with the RSA SHA-384 and RSA SHA-512 algorithms is
	  performed identically to the procedure for RSA SHA-256 - just
	  with correspondingly longer key and result values.
	</t>

      </section>

      <section title="Creating a JWS with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512" anchor="DefiningECDSA">
	<t>
	  The Elliptic Curve Digital Signature Algorithm (ECDSA) is
	  defined by <xref target="FIPS.186-3">FIPS 186-3</xref>. ECDSA
	  provides for the use of Elliptic Curve cryptography, which is
	  able to provide equivalent security to RSA cryptography but
	  using shorter key lengths and with greater processing
	  speed. This means that ECDSA signatures will be substantially
	  smaller in terms of length than equivalently strong RSA
	  Digital Signatures.
	</t>
	<t>
	  This specification defines the use of ECDSA with the P-256
	  curve and the SHA-256 cryptographic hash function, ECDSA
	  with the P-384 curve and the SHA-384 hash function, and
	  ECDSA with the P-521 curve and the SHA-512 hash
	  function. The P-256, P-384, and P-521 curves are also
	  defined in FIPS 186-3. The <spanx
	  style="verb">alg</spanx> header parameter values <spanx
	  style="verb">ES256</spanx>, <spanx
	  style="verb">ES384</spanx>, and <spanx
	  style="verb">ES512</spanx> are used in the JWS Header
	  to indicate that the Encoded JWS Signature contains a base64url
	  encoded ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA
	  P-521 SHA-512 signature, respectively.
	</t>
	<t>
	  The public keys employed can be identified using Header
	  Parameter methods described in <xref
	  target="ReservedHeaderParameterName" /> or can be
	  distributed using methods that are outside the scope of this
	  specification.
	</t>
	<t>
	  A JWS is signed with an ECDSA P-256 SHA-256 signature as
	  follows:

	  <list style="numbers">
	    <t>
	      Generate a digital signature of the UTF-8 representation
	      of the JWS Signing Input using ECDSA P-256 SHA-256 with
	      the desired private key. The output will be the EC point
	      (R, S), where R and S are unsigned integers.
	    </t>
	    <t>
	      Turn R and S into byte arrays in big endian order. Each
	      array will be 32 bytes long.
	    </t>
	    <t>
	      Concatenate the two byte arrays in the order R and then S.
	    </t>
	    <t>
	      Base64url encode the resulting 64 byte array.
	    </t>
	  </list>

	  The output is the Encoded JWS Signature for the JWS.
	</t>

	<t>
	  The ECDSA P-256 SHA-256 signature for a JWS is validated as follows:

	  <list style="numbers">
	    <t>
	      Take the Encoded JWS Signature and base64url decode it into
	      a byte array. If decoding fails, the signed content MUST
	      be rejected.
	    </t>
	    <t>
	      The output of the base64url decoding MUST be a 64 byte
	      array.
	    </t>
	    <t>
	      Split the 64 byte array into two 32 byte arrays. The first
	      array will be R and the second S. Remember that the byte
	      arrays are in big endian byte order; please check the
	      ECDSA validator in use to see what byte order it requires.
	    </t>
	    <t>
	      Submit the UTF-8 representation of the JWS Signing
	      Input, R, S and the public key (x, y) to the ECDSA P-256
	      SHA-256 validator.
	    </t>
	    <t>
	      If the validation fails, the signed content MUST be rejected.
	    </t>
	  </list>

	  The ECDSA validator will then determine if the digital
	  signature is valid, given the inputs.  Note that ECDSA digital
	  signature contains a value referred to as K, which is a random
	  number generated for each digital signature instance. This
	  means that two ECDSA digital signatures using exactly the same
	  input parameters will output different signatures because
	  their K values will be different. The consequence of this is
	  that one must validate an ECDSA signature by submitting the
	  previously specified inputs to an ECDSA validator.
	</t>
	<t>
	  Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512
	  algorithms is performed identically to the procedure for ECDSA
	  P-256 SHA-256 - just with correspondingly longer key and
	  result values.
	</t>

      </section>

      <section title="Additional Algorithms" anchor="MoreAlgs">

	<t>
	  Additional algorithms MAY be used to protect JWSs with
	  corresponding <spanx style="verb">alg</spanx> header parameter values being defined to
	  refer to them. New <spanx style="verb">alg</spanx> header parameter values SHOULD
	  either be defined in the IANA JSON Web Signature Algorithms
	  registry or be a URI that contains a collision resistant
	  namespace.  In particular, it is permissible to use the algorithm identifiers
	  defined in <xref target="RFC3275">XML DSIG</xref> and
	  related specifications as <spanx style="verb">alg</spanx> values.
	</t>

      </section>
    </section>

    <section title="IANA Considerations" anchor="IANA">
      <t>
	This specification calls for:

        <list style="symbols">

          <t>
	    A new IANA registry entitled "JSON Web Signature Header
	    Parameters" for reserved header parameter names is defined
	    in <xref target="ReservedHeaderParameterName"></xref>.
	    Inclusion in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense for reserved JWS
	    header parameter names that are intended to be
	    interoperable between implementations.  The registry will
	    just record the reserved header parameter name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the header parameter names defined in
	    <xref target="HeaderParameterTable"></xref>.
	  </t>
          <t>
	    A new IANA registry entitled "JSON Web Signature Algorithms"
	    for values of the <spanx style="verb">alg</spanx> header parameter
	    is defined in <xref target="MoreAlgs"></xref>. Inclusion
	    in the registry is RFC Required in the <xref
	    target="RFC5226">RFC 5226</xref> sense. The registry will
	    just record the <spanx style="verb">alg</spanx> value and a pointer to the RFC that
	    defines it.  This specification defines inclusion of the
	    algorithm values defined in <xref
	    target="AlgTable"></xref>.
	  </t>
        </list>
      </t>
    </section>

    <section title="Security Considerations" anchor="Security">
      <t>
	TBD: Lots of work to do here. We need to remember to look into
	any issues relating to security and JSON parsing. One wonders
	just how secure most JSON parsing libraries are. Were they
	ever hardened for security scenarios? If not, what kind of
	holes does that open up? Also, we need to walk through the
	JSON standard and see what kind of issues we have especially
	around comparison of names.  For instance, comparisons of
	header parameter names and other parameters must occur after
	they are unescaped. Need to also put in text about: Importance
	of keeping secrets secret. Rotating keys. Strengths and
	weaknesses of the different algorithms.
      </t>
      <t>
	TBD: Need to put in text about why strict JSON validation is
	necessary.  Basically, that if malformed JSON is received then
	the intent of the sender is impossible to reliably discern.
	One example of malformed JSON that MUST be rejected is
	an object in which the same member name occurs multiple times.
      </t>
      <t>
	TBD: Write security considerations about the implications of
	using a SHA-1 hash (for compatibility reasons) for the
	<spanx style="verb">x5t</spanx> (x.509 certificate
	thumbprint).
      </t>

      <t>
	When utilizing TLS to retrieve information, the authority
	providing the resource MUST be authenticated and the
	information retrieved MUST be free from modification.
      </t>

      <section title="Unicode Comparison Security Issues">

        <t>
	  Header parameter names in JWSs are Unicode strings.  For
	  security reasons, the representations of these names must be
	  compared verbatim after performing any escape processing (as
	  per <xref target="RFC4627">RFC 4627</xref>, Section 2.5).
	</t>
        <t>
	  This means, for instance, that these JSON strings must
	  compare as being equal ("sig", "\u0073ig"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("SIG", "Sig", "si\u0047").
	</t>
	<t>
	  JSON strings MAY contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	</t>

      </section>
    </section>

    <section title="Open Issues and Things To Be Done (TBD)" anchor="TBD">

      <t>
	The following items remain to be done in this draft:

	<list style="symbols">

	  <t>
	    Consider whether there is a better term than "Digital
	    Signature" for the concept that includes both HMACs and
	    digital signatures using public keys.
	  </t>
	  <t>
	    Clarify the optional ability to provide type information in
	    the JWS header.  Specifically, clarify the intended use of
	    the <spanx style="verb">typ</spanx> Header Parameter,
	    whether it conveys syntax or semantics, and indeed, whether
	    this is the right approach.  Also clarify the relationship
	    between these type values and <xref
	    target="RFC2045">MIME</xref> types.
	  </t>
	  <t>
	    Clarify the semantics of the <spanx style="verb">kid</spanx>
	    (key ID) header parameter.  Open issues include: What
	    happens if a <spanx style="verb">kid</spanx> header is
	    received with an unrecognized value? Is that an error?
	    Should it be treated as if it's empty? What happens if the
	    header has a recognized value but the value doesn't match
	    the key associated with that value, but it does match
	    another key that is associated with the issuer? Is that an
	    error?
	  </t>
	  <t>
	    Consider whether a key type parameter should also be introduced.
	  </t>
	  <t>
	    Since RFC 3447 Section 8 explicitly calls for people NOT to
	    adopt RSASSA-PKCS1 for new applications and instead requests
	    that people transition to RSASSA-PSS, we probably need some
	    Security Considerations text explaining why RSASSA-PKCS1 is
	    being used (it's what's commonly implemented) and what the
	    potential consequences are.
	  </t>
	  <t>
	    Add Security Considerations text on timing attacks.
	  </t>
	  <t>
	    It would be good to have a confirmation method element so
	    it could be used with holder-of-key.
	  </t>
	  <t>
	    Consider whether to add parameters for directly including
	    keys in the header, either as JWK Key Objects, or X.509
	    cert values, or both.
	  </t>
	  <t>
	    Consider whether to add version numbers.
	  </t>
	  <t>
	    Think about how to best describe the concept currently
	    described as "the bytes of the UTF-8 representation of".
	    Possible terms to use instead of "bytes of" include "byte
	    sequence", "octet series", and "octet sequence".  Also
	    consider whether we want to add an overall clarifying
	    statement somewhere in each spec something like "every
	    place we say 'the UTF-8 representation of X', we mean 'the
	    bytes of the UTF-8 representation of X'".  That would
	    potentially allow us to omit the "the bytes of" part
	    everywhere else.
	  </t>
	  <t>
	    Finish the Security Considerations section.
	  </t>
	  <t>
	    Add an example in which the payload is not a base64url
	    encoded JSON object.
	  </t>
	  <t>
	    Consider having an algorithm that is a MAC using SHA-256
	    that provides content integrity but for which there is no
	    associated secret.  This would be like the JWT
	    "alg":"none", in that no validation of the authenticity
	    content is performed but a checksum is provided.
	  </t>
	  <t>
	    Consider whether to define "alg":"none" here,
	    rather than in the JWT spec.
	  </t>

	</list>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC1421;
      &RFC1738;
      &RFC2045;
      &RFC2104;
      &RFC2119;
      &RFC2818;
      &RFC3339;
      &RFC3447;
      &RFC3629;
      &RFC3986;
      &RFC4627;
      &RFC4648;
      &RFC5226;
      &RFC5246;
      &RFC5280;
      &RFC6125;

      <reference anchor="FIPS.180-3">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="October" year="2008" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-3" />
        <format target="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf" type="PDF" />
      </reference>

      <reference anchor="FIPS.186-3">
        <front>
          <title>Digital Signature Standard (DSS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="June" year="2009" />
        </front>
        <seriesInfo name="FIPS" value="PUB 186-3" />
        <format target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf" type="PDF" />
      </reference>

      <reference anchor="USA15">
        <front>
          <title>Unicode Normalization Forms</title>

          <author fullname="Mark Davis" initials="M." surname="Davis">
            <address>
              <email>markdavis@google.com</email>
            </address>
          </author>

          <author fullname="Ken Whistler" initials="K." surname="Whistler">
            <address>
              <email>ken@unicode.org</email>
            </address>
          </author>

          <author fullname="Martin D&uuml;rst" initials="M."
                  surname="D&uuml;rst"></author>

          <date day="03" month="09" year="2009" />
        </front>

        <seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>

      <reference anchor="JWK">
        <front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <date day="13" month="December" year="2011" />
        </front>
        <format target="http://tools.ietf.org/html/draft-jones-json-web-key" type="HTML" />
      </reference>

    </references>

    <references title="Informative References">
      &RFC3275;

      <reference anchor="JWT">
        <front>
          <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
	    <organization>Google</organization>
	    <address>
	      <email>balfanz@google.com</email>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	    </address>
	  </author>

	  <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
	    <organization>Microsoft</organization>
	    <address>
	      <email>yarong@microsoft.com</email>
	    </address>
	  </author>

	  <author fullname="John Panzer" initials="J." surname="Panzer">
	    <organization>Google</organization>
	    <address>
	      <email>jpanzer@google.com</email>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization>Nomura Research Institute</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	    </address>
	  </author>

	  <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
	    <organization>Facebook</organization>
	    <address>
	      <email>pt@fb.com</email>
	    </address>
	  </author>

	  <date day="13" month="December" year="2011" />
        </front>
        <format target="http://tools.ietf.org/html/draft-jones-json-web-token" type="HTML" />
      </reference>

      <reference anchor="MagicSignatures">
        <front>
          <title>Magic Signatures</title>

          <author fullname="John Panzer (editor)" initials="J." surname="Panzer (editor)"></author>

          <author fullname="Ben Laurie" initials="B." surname="Laurie"></author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz"></author>

          <date month="August" year="2010" />
        </front>
        <format target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html" type="HTML" />
      </reference>

      <reference anchor="JSS">
        <front>
          <title>JSON Simple Sign</title>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization>independent</organization>
	  </author>

	  <author fullname="Nat Sakimura (editor)" initials="N. " surname="Sakimura (editor)">
	    <organization>Nomura Research Institute</organization>
	  </author>

          <date month="September" year="2010" />
        </front>
        <format target="http://jsonenc.info/jss/1.0/" type="HTML" />
      </reference>

      <reference anchor="CanvasApp">
        <front>
          <title>Canvas Applications</title>

          <author fullname="Facebook" surname="Facebook"></author>

          <date year="2010" />
        </front>
        <format target="http://developers.facebook.com/docs/authentication/canvas" type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
	    <organization>RTFM, Inc.</organization>
	    <address>
	      <email>ekr@rtfm.com</email>
	    </address>
	  </author>

	  <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
	    <organization>Cisco Systems, Inc.</organization>
	    <address>
	      <email>jhildebr@cisco.com</email>
	    </address>
	  </author>

	  <date day="13" month="December" year="2011" />
        </front>
        <format target="http://tools.ietf.org/html/draft-jones-json-web-encryption" type="HTML" />
      </reference>

      <reference anchor="JCA">
        <front>
          <title>Java Cryptography Architecture</title>

	  <author fullname="Oracle" surname="Oracle">
	  </author>

          <date year="2011" />
        </front>
        <format target="http://download.java.net/jdk7/docs/technotes/guides/security/SunProviders.html" type="HTML" />
      </reference>


    </references>

    <section title="JWS Examples" anchor="JWSExamples">

      <t>
	This section provides several examples of JWSs.  While these
	examples all represent JSON Web Tokens (JWTs) <xref
	target="JWT" />, the payload can be any base64url encoded
	content.
      </t>

      <section title="JWS using HMAC SHA-256" anchor="HMACSHA256Example">
	<section title="Encoding">
	  <t>
	    The following example JWS Header declares that the
	    data structure is a JSON Web Token (JWT) <xref target="JWT" />
	    and the JWS Signing Input is signed using
	    the HMAC SHA-256 algorithm.  Note that white space is
	    explicitly allowed in JWS Header strings and
	    no canonicalization is performed before encoding.
	  </t>

	  <figure><artwork><![CDATA[{"typ":"JWT",
 "alg":"HS256"}]]></artwork></figure>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example
	    follows.  (Note that the payload can be any base64url
	    encoded content, and need not be a base64url encoded JSON
	    object.)
	  </t>

	  <figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	  <t>
	     The following byte array contains the UTF-8 characters
	     for the JWS Payload:
	  </t>
	  <t>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  </t>
	  <t>
	    Base64url encoding the above yields the Encoded JWS Payload value
	    (with line breaks for display purposes only):
	  </t>

          <figure><artwork><![CDATA[eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    HMACs are generated using keys. This example uses the key
	    represented by the following byte array:
	  </t>
	  <t>

[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163]

	  </t>
	  <t>
	    Running the HMAC SHA-256 algorithm on the UTF-8
	    representation of the JWS Signing Input with this key
	    yields the following byte array:
	  </t>
	  <t>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  </t>
	  <t>
	    Base64url encoding the above HMAC output yields the
	    Encoded JWS Signature value:
	  </t>

	  <figure><artwork><![CDATA[dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk]]></artwork></figure>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS first requires removing the base64url
	    encoding from the Encoded JWS Header, the Encoded JWS Payload,
	    and the Encoded JWS Signature. We base64url decode
	    the inputs and
	    turn them into the corresponding byte arrays.  We
	    translate the header input byte array containing UTF-8
	    encoded characters into the JWS Header
	    string.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Next we validate the decoded results.  Since the <spanx style="verb">alg</spanx>
	    parameter in the header is "HS256", we validate the HMAC
	    SHA-256 signature contained in the JWS Signature.  If
	    any of the validation steps fail, the signed content MUST be
	    rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
          <t>
	    To validate the signature, we repeat the previous process
	    of using the correct key and the UTF-8 representation of
	    the JWS Signing Input as input to a SHA-256 HMAC function
	    and then taking the output and determining if it matches
	    the JWS Signature.  If it matches exactly,
	    the signature has been validated.
	  </t>
	</section>
      </section>

      <section title="JWS using RSA SHA-256" anchor="RSASHA256Example">

	<section title="Encoding">
	  <t>
	    The JWS Header in this example is different
	    from the previous example in two ways:  First, because a
	    different algorithm is being used, the <spanx style="verb">alg</spanx> value is
	    different.  Second, for illustration purposes only, the
	    optional "typ" parameter is not used.  (This difference is
	    not related to the signature algorithm employed.)  The
	    JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[{"alg":"RS256"}]]></artwork></figure>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous example.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The RSA key consists of a public part (n, e), and a
	    private exponent d.  The values of the RSA key used in
	    this example, presented as the byte arrays representing
	    big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>n</c>
	    <c>

[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161]

	    </c>

	    <c>e</c>
	    <c>

[1, 0, 1]

	    </c>

	    <c>d</c>
	    <c>

[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157]

	    </c>
	  </texttable>

	  <t>
	    The RSA private key (n, d) is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the UTF-8 representation of the JWS Signing Input as
	    inputs.  The result of the signature is a byte array S,
	    which represents a big endian integer.  In this example, S
	    is:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>S</c>
	    <c>

[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]

	    </c>
	  </texttable>

	  <t>
	    Base64url encoding the signature produces this value for
	    the Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
p0igcN_IoypGlUPQGe77Rw]]></artwork></figure>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS from this example requires processing the
	    Encoded JWS Header and Encoded JWS Payload exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "RS256", we
	    validate the RSA SHA-256 signature contained in the JWS Signature.  If any of the validation steps fail, the
	    signed content MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the previous example. First, we base64url decode the
	    Encoded JWS Signature to produce a signature S to check.  We
	    then pass (n, e), S and the UTF-8 representation of the
	    JWS Signing Input to an RSA signature verifier that has
	    been configured to use the SHA-256 hash function.
	  </t>

	</section>
      </section>

      <section title="JWS using ECDSA P-256 SHA-256" anchor="ECDSASHA256Example">
	<section title="Encoding">
	  <t>
	    The JWS Header for this example differs from
	    the previous example because a different algorithm is
	    being used.  The JWS Header used is:
	  </t>

	  <figure><artwork><![CDATA[{"alg":"ES256"}]]></artwork></figure>

	  <t>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  </t>
	  <t>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  </t>
	  <t>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9]]></artwork></figure>

	  <t>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous examples.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  </t>

	  <figure><artwork><![CDATA[{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}]]></artwork></figure>

	  <t>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ]]></artwork></figure>

	  <t>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  </t>
	  <t>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  </t>
	  <t>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the byte arrays
	    representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Parameter Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>x</c>
	    <c>

[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69]

	    </c>

	    <c>y</c>
	    <c>

[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]

	    </c>

	    <c>d</c>
	    <c>

[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]

	    </c>
	  </texttable>

	  <t>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and the UTF-8 representation of
	    the JWS Signing Input as inputs.  The result of the
	    signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as byte arrays representing big endian integers are:
	  </t>

	  <texttable>
	    <ttcol align="left">Result Name</ttcol>
	    <ttcol align="left">Value</ttcol>

	    <c>R</c>
	    <c>

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </c>

	    <c>S</c>
	    <c>

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </c>
	  </texttable>

	  <t>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    Encoded JWS Signature
	    (with line breaks for display purposes only):
	  </t>

	  <figure><artwork><![CDATA[DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
pmWQxfKTUJqPP3-Kg6NU1Q]]></artwork></figure>

	</section>
	<section title="Decoding">

	  <t>
	    Decoding the JWS from this example requires processing the
	    Encoded JWS Header and Encoded JWS Payload exactly as
	    done in the first example.
	  </t>

	</section>
	<section title="Validating">

	  <t>
	    Since the <spanx style="verb">alg</spanx> parameter in the header is "ES256", we
	    validate the ECDSA P-256 SHA-256 signature contained in
	    the JWS Signature.  If any of the validation steps
	    fail, the signed content MUST be rejected.
	  </t>
	  <t>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  </t>
	  <t>
	    Validating the JWS Signature is a little different
	    from the first example. First, we base64url decode the Encoded JWS Signature as in the previous examples but we then
	    need to split the 64 member byte array that must result
	    into two 32 byte arrays, the first R and the second S. We
	    then pass (x, y), (R, S) and the UTF-8 representation of
	    the JWS Signing Input to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  </t>
	  <t>
	    As explained in <xref target="DefiningECDSA"></xref>, the
	    use of the k value in ECDSA means that we cannot validate
	    the correctness of the signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the signature.
	  </t>

	</section>
      </section>

    </section>

    <section title="Algorithm Identifier Cross-Reference" anchor="algxref">
      <t>
	This appendix contains a table cross-referencing the <spanx
	style="verb">alg</spanx> values used in this specification
	with the equivalent identifiers used by other standards and
	software packages.  See <xref target="RFC3275">XML DSIG</xref>
	and <xref target="JCA">Java Cryptography Architecture</xref>
	for more information about the names defined by those
	documents.

      </t>
      <texttable title="Algorithm Identifier Cross-Reference" anchor="algxreftable">

	<ttcol align="left">Algorithm</ttcol>
	<ttcol align="left">JWS</ttcol>
	<ttcol align="left">XML DSIG</ttcol>
	<ttcol align="left">JCA</ttcol>
	<ttcol align="left">OID</ttcol>

	<c>HMAC using SHA-256 hash algorithm</c>
	<c>HS256</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#hmac-sha256</c>
	<c>HmacSHA256</c>
	<c>1.2.840.113549.2.9</c>

	<c>HMAC using SHA-384 hash algorithm</c>
	<c>HS384</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#hmac-sha384</c>
	<c>HmacSHA384</c>
	<c>1.2.840.113549.2.10</c>

	<c>HMAC using SHA-512 hash algorithm</c>
	<c>HS512</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#hmac-sha512</c>
	<c>HmacSHA512</c>
	<c>1.2.840.113549.2.11</c>

	<c>RSA using SHA-256 hash algorithm</c>
	<c>RS256</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</c>
	<c>SHA256withRSA</c>
	<c>1.2.840.113549.1.1.11</c>

	<c>RSA using SHA-384 hash algorithm</c>
	<c>RS384</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#rsa-sha384</c>
	<c>SHA384withRSA</c>
	<c>1.2.840.113549.1.1.12</c>

	<c>RSA using SHA-512 hash algorithm</c>
	<c>RS512</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#rsa-sha512</c>
	<c>SHA512withRSA</c>
	<c>1.2.840.113549.1.1.13</c>

	<c>ECDSA using P-256 curve and SHA-256 hash algorithm</c>
	<c>ES256</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256</c>
	<c>SHA256withECDSA</c>
	<c>1.2.840.10045.4.3.2</c>

	<c>ECDSA using P-384 curve and SHA-384 hash algorithm</c>
	<c>ES384</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384</c>
	<c>SHA384withECDSA</c>
	<c>1.2.840.10045.4.3.3</c>

	<c>ECDSA using P-521 curve and SHA-512 hash algorithm</c>
	<c>ES512</c>
	<c>http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512</c>
	<c>SHA512withECDSA</c>
	<c>1.2.840.10045.4.3.4</c>

      </texttable>
    </section>

    <section title="Notes on implementing base64url encoding without padding" anchor="base64urlnotes">

      <t>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      </t>
      <t>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      </t>

      <figure><artwork><![CDATA[static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}]]></artwork></figure>

      <t>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      </t>
      <t>
	An example correspondence between unencoded and encoded values
	follows.  The byte sequence below encodes into the string
	below, which when decoded, reproduces the byte sequence.
      </t>

      <figure><artwork>3 236 255 224 193</artwork></figure>

      <figure><artwork>A-z_4ME</artwork></figure>
    </section>

    <section title="Acknowledgements" anchor="Acknowledgements">

      <t>
	Solutions for signing JSON content were previously explored by
	<xref target="MagicSignatures">Magic Signatures</xref>, <xref
	target="JSS">JSON Simple Sign</xref>, and <xref
	target="CanvasApp">Canvas Applications</xref>, all of which
	influenced this draft.
      </t>

    </section>

    <section title='Document History'>
      <t>
        -04
        <list style='symbols'>
	  <t>
	    Removed "if present" clause from <spanx
	    style="verb">alg</spanx> description.
	  </t>
	  <t>
	    Moved "MUST" requirements from the Overview to later in
	    the spec.
	  </t>
	  <t>
	    Respect line length restrictions in examples.
	  </t>
	  <t>
	    Corrected OID numbers for ECDSA algorithms.
          </t>
	  <t>
	    Applied other editorial improvements.
	  </t>
        </list>
      </t>
      <t>
        -03
        <list style='symbols'>
	  <t>
	    Simplified terminology to better match JWE, where the
	    terms "JWS Header" and "Encoded JWS Header", are now used,
	    for instance, rather than the previous terms "Decoded JWS
	    Header Input" and "JWS Header Input".  Likewise the terms
	    "JWS Payload" and "JWS Signature" are now used, rather
	    than "JWS Payload Input" and "JWS Crypto Output".
	  </t>
	  <t>
	    The <spanx style="verb">jku</spanx> and <spanx
	    style="verb">x5u</spanx> URLs are now required to be
	    absolute URLs.
	  </t>
	  <t>
	    Removed this unnecessary language from the <spanx
	    style="verb">kid</spanx> description: "Omitting this
	    parameter is equivalent to setting it to an empty string".
	  </t>
	  <t>
	    Changed StringAndURI to StringOrURI.
	  </t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    Reference the JSON Web Key (JWK) specification from the
	    <spanx style="verb">jku</spanx> header parameter.
	  </t>
        </list>
      </t>
      <t>
        -01
        <list style='symbols'>
	  <t>
	    Changed RSA SHA-256 from MUST be supported to RECOMMENDED
	    that it be supported.  Rationale: Several people have
	    objected to the requirement for implementing RSA SHA-256,
	    some because they will only be using HMACs and symmetric
	    keys, and others because they only want to use ECDSA when
	    using asymmetric keys, either for security or key length
	    reasons, or both.
	  </t>
	  <t>
	    Clarified that <spanx style="verb">x5u</spanx> is an HTTPS
	    URL referencing a PEM-encoded certificate or certificate
	    chain.
	  </t>
	  <t>
	    Clarified that the <spanx style="verb">alg</spanx>
	    parameter value is case sensitive.
	  </t>
	  <t>
	    Changed <spanx style="verb">x5t</spanx> (x.509 certificate
	    thumbprint) to use a SHA-1 hash, rather than a SHA-256
	    hash, for compatibility reasons.
	  </t>
        </list>
      </t>
      <t>
        -00
        <list style='symbols'>
          <t>
            Created first signature draft using content split from
            draft-jones-json-web-token-01.  This split introduced no
            semantic changes.
          </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
