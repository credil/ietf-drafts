<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="no" ?>
<?rfc subcompact="no" ?>
<?rfc comments="yes" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1964 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1964.xml">
<!ENTITY RFC2138 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2138.xml">
<!ENTITY RFC2203 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2203.xml">
<!ENTITY RFC2743 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml">
<!ENTITY RFC2865 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2865.xml">
<!ENTITY RFC2903 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2903.xml">
<!ENTITY RFC2904 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2904.xml">
<!ENTITY RFC3579 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3579.xml">
<!ENTITY RFC3588 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3588.xml">
<!ENTITY RFC3645 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3645.xml">
<!ENTITY RFC3748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3748.xml">
<!ENTITY RFC4017 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4017.xml">
<!ENTITY RFC4072 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4072.xml">
<!ENTITY RFC4422 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml">
<!ENTITY RFC4462 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4462.xml">
<!ENTITY RFC5056 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml">
<!ENTITY RFC5080 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5080.xml">
<!ENTITY RFC5106 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5106.xml">
<!ENTITY RFC5705 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5705.xml">
<!ENTITY RFC5801 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5801.xml">
<!ENTITY RFC5849 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml">
<!ENTITY RFC6614 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6614.xml">
<!ENTITY RFC6677 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6677.xml">
<!ENTITY I-D.nir-tls-eap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nir-tls-eap.xml">
<!ENTITY I-D.ietf-oauth-v2 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2.xml">
<!ENTITY I-D.iab-privacy-considerations SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.iab-privacy-considerations.xml">
<!ENTITY I-D.ietf-abfab-gss-eap SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-abfab-gss-eap.xml">
<!ENTITY I-D.ietf-abfab-aaa-saml SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-abfab-aaa-saml.xml">
<!ENTITY I-D.ietf-emu-crypto-bind SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-emu-crypto-bind.xml">
<!ENTITY I-D.ietf-emu-chbind SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-emu-chbind.xml">
<!ENTITY I-D.ietf-emu-eap-tunnel-method SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-emu-eap-tunnel-method.xml">
<!ENTITY I-D.ietf-radext-dtls SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-radext-dtls.xml">
<!ENTITY I-D.perez-radext-radius-fragmentation SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.perez-radext-radius-fragmentation.xml">
<!ENTITY I-D.ietf-radext-dynamic-discovery SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-radext-dynamic-discovery.xml">
<!ENTITY I-D.ietf-radext-nai SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-radext-nai.xml">
<!ENTITY SAML20 SYSTEM "http://xml.resource.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml">
]>

<!-- Ticket #7 Fixed -->
<!-- Ticket #8 Open -->
<!-- Ticket #9 Fixed -->
<!-- Ticket #10 Fixed -->
<!-- Ticket #23 Fixed -->
<!-- Ticket #27 Closed -->
<!-- Ticket #29 Fixed -->

<!-- DONE = kill all remaining occurrences of the word Subject -->


<rfc category="info" docName="draft-ietf-abfab-arch-08.txt" ipr="trust200902">
  <front>
    <title abbrev="ABFAB Architecture">Application Bridging for Federated Access Beyond Web (ABFAB) Architecture</title>

    <author initials="J." surname="Howlett" fullname="Josh Howlett">
      <organization>JANET(UK)</organization>
      <address>
        <postal>
          <street>Lumen House, Library Avenue, Harwell</street>
          <city>Oxford</city>
          <code>OX11 0SG</code>
          <country>UK</country>
        </postal>
        <phone>+44 1235 822363</phone>
        <email>Josh.Howlett@ja.net</email>
      </address>
    </author>
    <author initials="S." surname="Hartman" fullname="Sam Hartman">
      <organization>Painless Security</organization>
      <address>
        <postal>
          <street> </street>
          <city> </city>
          <code> </code>
          <country> </country>
        </postal>
        <phone> </phone>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Nokia Siemens Networks</organization>
      <address>
        <postal>
          <street>Linnoitustie 6</street>
          <city>Espoo</city>
          <code>02600</code>
          <country>Finland</country>
        </postal>
        <phone>+358 (50) 4871445</phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>
    <author fullname="Eliot Lear" initials="E." surname="Lear">
      <organization>Cisco Systems GmbH</organization>
      <address>
        <postal>
          <street>Richtistrasse 7</street>
          <city>Wallisellen</city>
          <code>CH-8304</code>
          <region>ZH</region>
          <country>Switzerland</country>
        </postal>
        <phone>+41 44 878 9200</phone>
        <email>lear@cisco.com</email>
      </address>
    </author>
    <author fullname="Jim Schaad" initials="J." surname="Schaad">
      <organization>Soaring Hawk Consulting</organization>
      <address>
        <email>ietf@augustcellars.com</email>
      </address>
    </author>
    <date/>
    <area>Security</area>
    <workgroup>ABFAB</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>Federated Authentication</keyword>
    <keyword>AAA</keyword>
    <keyword>RADIUS</keyword>
    <keyword>Diameter</keyword>
    <keyword>GSS-API</keyword>
    <keyword>EAP</keyword>
    <keyword>SAML</keyword>
    <abstract>
      <t>
        Over the last decade a substantial amount of work has occurred in
        the space of federated access management.  Most of
        this effort has focused on two use cases: network access and
        web-based access. However, the solutions to these use cases that
        have been proposed and deployed tend to have few common building blocks in common.
      </t>
      <t>
        This memo describes an architecture that makes use of extensions to the commonly used security mechanisms for both federated and non-federated access management, including the Remote Authentication Dial In User Service (RADIUS)
        and the Diameter protocol, the Generic Security Service (GSS), the Extensible Authentication Protocol (EAP) and the Security Assertion Markup Language (SAML). The architecture addresses 
        the problem of federated access management to primarily non-web-based
        services, in a manner that will scale to large numbers of identity providers, relying parties, and 
        federations.
      </t>
    </abstract>
  </front>
  <middle>
    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
    <section anchor="introduction" title="Introduction">
      <t>
        The Internet uses numerous security mechanisms to manage
        access to various resources.  These mechanisms have been generalized
        and scaled over the last decade through mechanisms such as
        <xref target="RFC5801">Simple Authentication and Security Layer (SASL) with the Generic Security Server Application Program Interface (GSS-API) (known as the GS2 family)</xref>, <xref target="OASIS.saml-core-2.0-os">Security Assertion Markup Language (SAML)</xref>, and the Authentication, Authorization, and Accounting (AAA) architecture as embodied in <xref target="RFC2865">RADIUS</xref> and <xref target="RFC3588">Diameter</xref>.
      </t>
      <t>
        A Relying Party (RP) is the entity that manages access to some resource.
        The entity that is requesting access to that resource is often described as the Client.
        Many security mechanisms are manifested as an exchange of information between these entities.
        The RP is therefore able to decide whether the Client is authorized, or not.
      </t>

      <t>
        Some security mechanisms allow the RP to delegate aspects of the access management decision to an entity called the Identity Provider (IdP).
        This delegation requires technical signaling, trust and a common understanding of semantics between the RP and IdP.
        These aspects are generally managed within a relationship known as a 'federation'.
        This style of access management is accordingly described as 'federated access management'.
      </t>

      <t>
        Federated access management has evolved over
        the last decade through specifications like SAML <xref target="OASIS.saml-core-2.0-os"/>,
        <eref target="http://www.openid.net">OpenID</eref>, OAuth <xref target="RFC5849"/>, <xref target="I-D.ietf-oauth-v2"/> and WS-Trust <xref target="WS-TRUST"/>.
        The benefits of federated access management include:
        <list style="hanging">
          <t hangText="Single or Simplified sign-on:"> 
            <vspace blankLines="1"/>
            An Internet service can delegate access management, 
            and the associated responsibilities such as identity management and credentialing,
            to an organization that already has a long-term relationship with the Client.
            This is often attractive as Relying Parties frequently do not want these responsibilities.
            The Client also requires fewer credentials, which is also desirable.
          </t>
          <t hangText="   Data Minimization and User Participation:">

            <vspace blankLines="1"/> 
            Often a Relying Party does not need to know the identity of a Client to reach an access management decision.
            It is frequently only necessary for the Relying Party to know specific attributes about the client, for example, that the client is affiliated with a particular organization or has a certain role or entitlement.
            Sometimes the RP only needs to know a pseudonym of the client.

            <vspace blankLines="1"/>
            Prior to the release of attributes to the RP from the IdP, the IdP will check configuration and policy to determine if the attributes are to be released.
            There is currently no direct client participation in this decision.
            
          </t>

          <t hangText="Provisioning:">
            <vspace blankLines="1"/>
            Sometimes a Relying Party needs, or would like, to know more about a client than an affiliation or a pseudonym.
            For example, a Relying Party may want the Client's email address or name.
            Some federated access management technologies provide the ability for the IdP to supply this information, either on request by the RP or unsolicited.
          </t>
        </list>
      </t>

      <t>
        This memo describes the Application Bridging for Federated Access Beyond the Web (ABFAB) architecture.
        This architecture makes use of extensions to the commonly used security mechanisms for both federated and non-federated access management, including the RADIUS and the Diameter protocols, the Generic Security Service (GSS), the Extensible Authentication Protocol (EAP) and SAML.
        The architecture addresses the problem of federated access management primarily for non-web-based services.
        It does so in a manner that will scale to large numbers of identity providers, relying parties, and federations.
      </t>

      <!-- ////////////////////////////////////////////////////////////////////////////////// -->

      <section anchor="terminology" title="Terminology">

        <t>
          This document uses identity management and privacy terminology from <xref target="I-D.iab-privacy-considerations"/>. 
          In particular, this document uses the terms identity provider, relying party, identifier, pseudonymity, unlinkability, and anonymity.
        </t> 

        <t>
          In this architecture the IdP consists of the following components: an EAP server, a RADIUS or a Diameter server, and optionally a SAML Assertion service.  
        </t>
        
        <t>
          This document uses the term Network Access Identifier (NAI), as defined in <xref target="I-D.ietf-radext-nai"/>. 
          An NAI consists of a realm identifier, which is associated with an IdP and a username which is associated with a specific client of the IdP.
          
        </t> 

        <t>
          One of the problems people will find with reading this document is that the terminology sometimes appears to be inconsistent.
          This is due the fact that the terms used by the different standards we are referencing are not consistent.
          In general the document uses either the ABFAB term or the term associated with the standard under discussion as appropriate.
          For reference we include this table which maps the different terms into a single table.
        </t>

        <texttable>
          <ttcol align='left'>Protocol</ttcol>  <ttcol align='left'>Client</ttcol> <ttcol align='left'>Relying Party</ttcol> <ttcol align='left'>Identity Provider</ttcol>
          <c>ABFAB</c>                    <c>Client</c>                  <c>Relying Party (RP)</c>            <c>Identity Provider (IdP)</c>
          <c></c>                         <c>Initiator</c>                <c>Acceptor</c>                              <c></c>
	  <c></c>			<c></c>				<c>Server</c>				<c></c>
          <c>SAML</c>                     <c>Subject</c>                  <c>Service Provider</c>              <c>Issuer</c>
          <c>GSS-API</c>                  <c>Initiator</c>                  <c>Acceptor</c>            <c></c>
          <c>EAP</c>                      <c>EAP peer</c>                <c>EAP Authenticator</c>                                <c>EAP server</c>
          <c>AAA</c>                      <c></c>                         <c>AAA Client</c>                       <c>AAA server</c>
          <c>RADIUS</c>                   <c>user</c>                   <c>NAS</c>                              <c>RADIUS server</c>
          <c></c>                         <c></c>                   <c>RADIUS client</c>                   <c></c>
          <postamble>Table 1. Terminology</postamble>
        </texttable>

        <t>
          Note that in some cases a cell has been left empty; in these cases there is no name that represents the entity.
        </t>

	<section title="Channel Binding" anchor="channel_bind">
	  <t>
            This document uses the term channel binding with two different meanings.
          </t>
	  <t>
            EAP channel binding is used to provide GSS-API naming semantics.
            EAP channel binding sends a set of attributes from the peer to the EAP server either as part of the EAP conversation or as part of a secure association protocol.
            In addition, attributes are sent in the backend protocol from the EAP authenticator to the EAP server.
            The EAP server confirms the consistency of these attributes and provides the confirmation back to the peer.
            In this document, channel binding without qualification refers to EAP channel binding.
          </t>
	  <t>
            GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used for authentication inside of some tunnel;  it is similar to a facility called cryptographic binding in EAP.
            The binding works by each side deriving a cryptographic value from the tunnel itself and then using that cryptographic value to prove to the other side that it knows the value.
          </t>
	  <t>
            See <xref target="RFC5056"/> for a discussion of the differences between these two facilities.
            However, the difference can be summarized as GSS-API channel binding says that there is nobody between the client and the EAP authenticator while EAP channel binding allows the client to have knowledge about attributes of the EAP authenticator (such as its name).
          </t>

          <t>
            Typically when considering both EAP and GSS-API channel binding, people think of channel binding in combination with mutual authentication.
            This is sufficiently common that without additional qualification channel binding should be assumed to imply mutual authentication.
            In GSS-API, without mutualtion only the acceptor has authenticated the initator.
            Similarly in EAP, only the EAP server has authenticated the peer.
            That's sometimes useful.

            Consider for example a user who wishes to access a protected resource for a shared whiteboard in a conference room.
            The whiteboard is the acceptor; it knows that the initiator is authorized to give it a presentation and the user can validate the whitebord got the correct presentation by visual means.
            (The presention should not be confiduatal in this case.)
            If channel binding is used without mutual authentication, it is effectively a request to disclose the resource in the context of a particular channel.
            Such an authentication would be similar in concept to a holder-of-key SAML assertion.
            However, also note that while it is not happening in the protocol, mutual authentication is happening in the overall system: the user is able to visually authenticate the content.
            This is consistent with all uses of channel binding without protocol level mutual authentication found so far.
          </t>
          
          <!-- Paul - It isn't clear why this is here - how it relates to the purposes of the ABFAB protocol. - DONE -->

          <!-- Paul - In what way is it conceptionally different?  (Of course it is different at a detailed level). - DONE -->
	</section>

      </section>

      <section title="An Overview of Federation">
        <t>
          In the previous section we introduced the following entities:
          <list style="symbols">
            <t>the Client,</t>
            <t>the Identity Provider, and </t>
            <t>the Relying Party.</t>
          </list>

          The final entity that needs to be introduced is the Individual.
          An Individual is a human being that is using the Client.
          In any given situation, an Individual may or may not exist.
          Clients can act either as front ends for Individuals or they may be independent entities that are setup and allowed to run autonomously.
          An example of such an entity can be found in the trust routing protocol where the routers use ABFAB to authenticate to each other.
        </t>

        <t>
          These entities and their relationships are illustrated graphically in <xref target="framework"/>.
        </t>
        <t>
          <figure title="Entities and their Relationships" anchor="framework">
            <artwork><![CDATA[

 ,----------\                        ,---------\
 | Identity |       Federation       | Relying |
 | Provider +  <-------------------> + Party   |
 `----------'                        '---------'
        <
         \                              
          \ Authentication                   
           \                 
            \                         
             \                      
              \                    
               \  +---------+  
                \ |         |  O    
                 v| Client  | \|/ Individual
                  |         |  |
                  +---------+ / \
            ]]></artwork>
          </figure>
        </t>

        <t>
          The relationships between the entities in <xref target="framework"/> are:
          <list style="hanging">
            <t hangText="Federation">
              <vspace blankLines="1"/>
              The Identity Provider and the Relying Parties are part of a Federation.
              The relationship may be direct (they have an explicit trust relationship) or transitive (the trust relationship is mediated by one or more entities).
              The federation relationship is governed by a federation agreement.
              Within a single federation, there may be multiple Identity Providers as well as multiple Relying Parties.
            </t>

            <t hangText="Authentication">
              <vspace blankLines="1"/>
              There is a direct relationship between the Client and the Identity Provider by which the entities trust and can securely authenticate each other.
            </t>
          </list>
        </t>
        
        <t>
          A federation agreement typically encompasses operational specifications and legal rules:
        </t>
        
        <t>
          <list style="hanging">
            <t hangText="Operational Specifications:">
              <vspace blankLines="1"/>
              These include the technical specifications (e.g. protocols used to communicate between the three parties), 
              process standards, policies, identity proofing, credential and authentication algorithm requirements, performance requirements, assessment and audit criteria, etc.
              The goal of operational specifications is to provide enough definition that the system works and interoperability is possible.
            </t>

            <t hangText="Legal Rules:">
              <vspace blankLines="1"/>
              The legal rules take the legal framework into consideration and provide contractual obligations for each entity.  The rules define the responsibilities of each party and provide further clarification of the operational specifications.
              These legal rules regulate the operational specifications, make operational specifications legally binding to the participants, define and govern the rights and responsibilities of the participants. 
              The legal rules may, for example, describe liability for losses, termination rights, enforcement mechanisms, measures of damage, dispute resolution, warranties, etc.
            </t>
          </list>
        </t>
        
        <!-- Talk about operational implications -->
        <t>
          <!-- This feels out of context at this point in the text - Paul Leach -->
          <!-- Hannes - 
               Some deployments demand the usage of sophisticated technical
               infrastructure, including message routing intermediaries, to offer
               the required technical functionality.  In other deployments fewer
               technical components are needed.
               - DONE
          -->
          The Operational Specifications can demand the usage of a sophisticated technical infrastructure, including requirements on the message routing intermediaries, to offer the required technical functionality.
          In other environments, the Operational Specifications require  fewer technical components in order to meet the required technical functionality.
        </t>

        <!--  Talk about Legal Rules -->
        <t>
          <!-- This is an awkward sentence and needs to be fixed - Paul Leach - DONE -->
          The Legal Rules include many non-technical aspects of federation, such as business practices and legal arrangements, which are  outside the scope of the IETF.  The Legal Rules can still have an impact on the architectural setup or on how to ensure the dynamic establishment of trust.
        </t>

        <!-- General Federation -->
        <t>
          While a federation agreement is often discussed within the context of formal relationships, such as between an enterprise and an employee or a government and a citizen, a federation agreement does not have to require any particular level of formality.
          For an IdP and a Client, it is sufficient for a relationship to be established by something as simple as using a web form and confirmation email.
          For an IdP and an RP, it is sufficient for the IdP to publish contact information along with a public key and for the RP to use that data.
          Within the framework of ABFAB, it will generally be required that a mechanism exists for the IdP to be able to trust the identity of the RP, if this is not present then the IdP cannot provide the assurances to the client that the identity of the RP has been established.
          <!-- Paul says I don't understand this. - DONE -->
        </t>

        <!-- IdP TO RP -->
        
        <t>
          The nature of federation dictates that there is some form of relationship between the identity provider and the relying party.
          This is particularly important when the relying party wants to use information obtained from the identity provider for access management decisions and when the identity provider does not want to release information to every relying party (or only under certain conditions).
        </t>
        
        <t>
          While it is possible to have a bilateral agreement between every IdP and every RP; on an Internet scale this setup requires the introduction of the multi-lateral federation concept, as the management of such pair-wise relationships would otherwise prove burdensome.
        </t>
        
        <!-- IdP To Client -->
        
        <t>
          The IdP will typically have a long-term relationship with the Client.
          This relationship typically involves the IdP positively identifying and credentialing the Client (for example, at time of employment within an organization).
          When dealing with individuals, this process is called identity proofing <xref target="NIST-SP.800-63"/>.
          <!-- s/often be instantiated within/also involve/ - Paul Leech - OPEN -->
          The relationship will often be instantiated within an agreement between the IdP and the Client (for example, within an employment contract or terms of use that stipulates the appropriate use of credentials and so forth).
        </t>
        
        
        <t>
          The nature and quality of the relationship between the Client and the IdP is an important contributor to the level of trust that an RP may attribute to an assertion describing a Client made by an IdP.
          This is sometimes described as the Level of Assurance <xref target="NIST-SP.800-63"/>.
        </t>
        
        <t>
          <!-- Paul - s/imposes requirement of/require/ - DONE -->
          Federation does not require an a priori relationship or a long-term relationship between the RP and the Client; it is this property of federation that yields many of its benefits. 
          However, federation does not preclude the possibility of a pre-existing relationship between the RP and the Client, nor that they may use the introduction to create a new long-term relationship independent of the federation.
        </t>

        <t>
          Finally, it is important to reiterate that in some scenarios there might indeed be an Individual behind the Client and in other cases the Client may be autonomous.
          <!-- Paul - Please provide an example - DONE -->
          <!-- JLS - An example is provided above -->
        </t>
      </section>


      
      <section title="Challenges for Contemporary Federation">
        <t>
          As the number of federated services has proliferated, the role of the individual can become ambiguous in certain circumstances. 
          
          
          For example, a school might provide online access for a student's grades to their parents for review, and to the student's teacher for modification.
          A teacher who is also a parent must clearly distinguish her role upon access.
        </t>
        
        <t>
          Similarly, as the number of federations proliferates, it becomes increasingly difficult to discover which identity provider(s) a user is associated with.
          This is true for both the web and non-web case, but is particularly acute for the latter as many non-web authentication systems are not semantically rich enough on their own to allow for such ambiguities.
          For instance, in the case of an email provider, the use of SMTP and IMAP protocols do not have the ability for the server to get additional information, beyond the clients NAI, in order to provide additional input to decide between multiple federations it may be associated with.
          However, the building blocks do exist to add this functionality.
          
          <!-- Paul - What does this mean ("select a federation")?  I can see what selecting an IdP means, but what does it mean to select a federation? - DONE -->
        </t>
      </section>

      <section title="An Overview of ABFAB-based Federation">
        <t>
          The previous section described the general model of federation, and the application of access management within the federation.
          This section provides a brief overview of ABFAB in the context of this model.
          <!-- Paul - Something wrong here.  Also, wasn't anything called "federated access management".  Also suggest running through the steps in an auth exchange w/o mentioning particular mechanism - DONE -->
        </t>
        
        <t>
          In this example, a client is attempting to connect to a server in order to either get access to some data or perform some type of transaction.
          In order for the client to mutually authenticate with the server, the following steps are taken in an ABFAB architecture:
        </t>
        
        <t>
          <list style="numbers">
            <!-- Paul - Before this step, I'd introduce that Principals have NAIs, and that an IdP owns all NAIs in some set of realms. - DONE -->
            <t>
              Client Configuration:
              <!-- Paul- In addition to the principal's NAI? - DONE -->
              The Client Application is configured with an NAI assigned by the IdP.  It is also configured with any keys, certificates, passwords or other secret and public information needed to run the EAP protocols between it and the IdP.
            </t>
            
            <t>
              Authentication mechanism selection:
              The GSS-EAP GSS-API mechanism is selected for authentication/authorization.
            </t>
            
            <t>
              Client provides an NAI to RP:
              
              The client application sets up a transport to the RP and begins the GSS-EAP authentication.
              In response, the RP sends an  EAP request message (nested in the GSS-EAP protocol) asking for the Client's name.
              The Client sends an EAP response with an NAI name form that, at a minimum, contains the realm portion of its full NAI.
            </t>
            
            <t>
              Discovery of federated IdP:

              The RP uses pre-configured information or a federation proxy to determine what IdP to use based on policy and the realm portion of the provided Client NAI.
              This is discussed in detail below (<xref target="discovery"/>).
            </t>
            
            <t>
              Request from Relying Party to IdP:

              Once the RP knows who the IdP is, it (or its agent) will send a RADIUS/Diameter request to the IdP.
              The RADIUS/Diameter access request encapsulates the EAP response.
              At this stage, the RP will likely  have no idea who the client is.
              The RP sends its identity to the IdP in AAA attributes, and
              <!-- Paul - What does claims mean here?  Unless it is anything more than "sends", then "sends" would be clearer - DONE -->
              it may send a SAML Attribute Request in a AAA attribute.
              <!-- Paul - s/contain/send/ - DONE -->
              The AAA network checks that the identity claimed by the RP is valid.
            </t>
            
            <t>
              IdP begins EAP with the client:

              The IdP sends an EAP message to the client with an EAP method to be used.
              <!-- Klaas - unexpected - it breaks or it is not normal? - DONE -->
              The IdP SHOULD NOT re-request the clients name in this message, but clients need to be able to handle it.
              In this case the IdP MUST accept a realm only in order to protect the client's name from the RP.
              
              The available and appropriate methods are discussed below in this memo (<xref target="Client_Eap"/>).
            </t>

            <t>
              <!-- Paul - didn't the EAP protocol get run in step 3 - need to clean that up - DONE -->
              The EAP protocol is run:

              A bunch of EAP messages are passed between the client (EAP peer) and the IdP (EAP server), until the result of the authentication protocol is determined.
              The number and content of those messages depends on the EAP method selected.
              If the IdP is unable to authenticate the client, the IdP sends an EAP failure message to the RP.

              As part of the EAP protocol, the client sends a channel bindings EAP message to the IdP (<xref target="client_channel_binding"/>).
              In the channel binding message the client identifies, among other things, the RP to which it is attempting to authenticate.

              <!-- Paul - How are RPs identified? - OPEN -->

              The IdP checks the channel binding data from the client with that provided by the RP via the AAA protocol.
              
              If the bindings do not match the IdP sends an EAP failure message to the RP.

              <!-- Paul - He has a confusion between the different things that are called channel bindings - may need to move that discussion higher in the text - DONE-->
            </t>
            
            <t>
              Successful EAP Authentication:
              
              At this point, the IdP (EAP server) and client (EAP peer) have mutually authenticated each other.
              As a result, the client and the IdP hold two cryptographic keys: a Master Session Key (MSK), and an Extended MSK (EMSK).

              At this point the client has a level of assurance about the identity of the RP based on the name checking the IdP has done using the RP naming information from the AAA framework and from the client (by the channel binding data).
              
              <!-- Paul - I can't follow this argument - - last two sentences - DONE -->
            </t>
            
            <t> 
              Local IdP Policy Check:
              
              At this stage, the IdP checks local policy to determine whether the RP and client are authorized for a given transaction/service, and if so, what if any,
              <!-- Paul - Which transaction/service? Nothing has been said about the client app specifying one. - DONE -->
              attributes will be released to the RP.
              If the IdP gets a policy failure, it sends an EAP failure message to the RP.<cref source="JLS">Should this be an EAP failure to the client as well?</cref>
              
              (The RP will have done its policy checks during the discovery process.)
            </t>

            <t>
              IdP provides the RP with the MSK:

              The IdP sends a positive result EAP to the RP, along with an optional set of AAA attributes associated with the client (usually as one or more SAML assertions).
              In addition, the EAP MSK is returned to the RP.
              <!-- Paul - How did the RP prove it's identity?  What prevent an attacker pretending to be an RP or being a man-in-the-middle? - DONE -->
            </t>

            <t>
              RP Processes Results:
              When the RP receives the result from the IdP, it should have enough information to either grant or refuse a resource access request.
              It may have information that associates the client with specific authorization identities.
              If additional attributes are needed from the IdP the RP may make a new SAML Request to the IdP.
              It will apply these results in an application-specific way.
            </t>
            
            <t>
              RP returns results to client:
              Once the RP has a response it must inform the client application of the result.
              If all has gone well, all are authenticated, and the application proceeds with appropriate authorization levels.
              The client can now complete the authentication of the RP by the use of the EAP MSK value.
            </t>
            
          </list>
        </t>
        <t>
          An example communication flow is given below:
        </t>
        <t>
          <figure>
            <artwork><![CDATA[
    Relying           Client        Identity
    Party            App          Provider
    
    |              (1)             | Client Configuration
    |               |              |
    |<-----(2)----->|              | Mechanism Selection
    |               |              |
    |<-----(3)-----<|              | NAI transmitted to RP
    |               |              |
    |<=====(4)====================>| Discovery
    |               |              |
    |>=====(5)====================>| Access request from RP to IdP
    |               |              |
    |               |< - - (6) - -<| EAP method to Client
    |               |              |
    |               |< - - (7) - ->| EAP Exchange to authenticate
    |               |              | Client
    |               |              |
    |               |           (8 & 9) Local Policy Check
    |               |              |
    |<====(10)====================<| IdP Assertion to RP
    |               |              |
    (11)              |              | RP processes results
    |               |              |
    |>----(12)----->|              | Results to client app.



    ----- = Between Client App and RP
    ===== = Between RP and IdP
    - - - = Between Client App and IdP
    ]]>

   </artwork>
          </figure>
        </t>
      </section>
      <section title="Design Goals">
        <!-- Klaas - this comes after a large amount of text - move it up? - OPEN -->
        <t>Our key design goals are as follows:</t>
        <t>
          <list style="symbols">
            <t>
              Each party of a transaction will be authenticated, although perhaps not identified, and the client will be authorized for access to a specific resource.
            </t>

            <!-- Hannes - I believe we have mutual authentication between the EAP peer and the EAP server; we may have mutual authentication between the AAA server and the AAA client.
                 We don't really have the authentication of the Subject to the RP (since the Subject may be anonymous towards the RP).
                 We also do not have a classical authentication of the RP to the Subject/App since the only guarantee we get is the channel binding mechanism (which may not be present, right?)
                 - OPEN 

                JimSch - I think that the goal is still the same, the question would be what is required to meet the goal - this is not a change that goes here
                - OPEN
            -->

            <t>
              Means of authentication is decoupled so as to allow for multiple authentication methods.
            </t>

            <t>
              The architecture requires no sharing of long term private keys between clients and servers.
              <!-- Paul - User and IDP share keys, don't they?  If RP is authenticated, then it will need to share key with IdP ... so I don't understand this statement. - DONE -->
            </t>
            <t>
	      The system will scale to large numbers of identity providers, relying parties, and users.
	    </t>
            <t>
	      The system will be designed primarily for non-Web-based authentication.
	    </t>
            <t>
	      The system will build upon existing standards, components, and operational practices.
            </t>
          </list>
        </t>
	
        <t>
	  Designing new three party authentication and authorization protocols is hard and fraught with risk of cryptographic flaws.
	  Achieving widespread deployment is even more difficult.
	  A lot of attention on federated access has been devoted to the Web.
	  This document instead focuses on a non-Web-based environment and focuses on those protocols where HTTP is not used.
	  Despite the increased excitement for layering every protocol on top of HTTP there are still a number of protocols available that do not use HTTP-based transports.
	  Many of these protocols are lacking a native authentication and authorization framework of the style shown in <xref target="framework"/>.
        </t>
      </section>


      <!-- ////////////////////////////////////////////////////////////////////////////////// -->
    </section>
    <section title="Architecture">
      <t>
        We have already introduced the federated access architecture, with the illustration of the different actors that need to interact, but did not expand on the specifics of providing support for non-Web based applications.
        This section details this aspect and motivates design decisions.
        The main theme of the work described in this document is focused on re-using existing building blocks that have been deployed already and to re-arrange them in a novel way.
      </t>

      <t>
        Although this architecture assumes updates to the relying party, the client application, and the Identity Provider, those changes are kept at a minimum.
        A mechanism that can demonstrate deployment benefits (based on ease of update of existing software, low implementation effort, etc.) is preferred and there may be a need to specify multiple mechanisms to support the range of different deployment scenarios.
      </t>

      <t>
        There are a number of ways for encapsulating EAP into an application protocol.
        For ease of integration with a wide range of non-Web based application protocols the usage of the GSS-API was chosen.
        A description of the technical specification can be found in <xref target="I-D.ietf-abfab-gss-eap"/>.
      </t>
      
      <t>
        The architecture consists of several building blocks, which is shown graphically in <xref target="abfab-arch"/>. 
        In the following sections, we discuss the data flow between each of the entities, the protocols used for that data flow and some of the trade-offs made in choosing the protocols.
      </t>

      <t><figure title="ABFAB Protocol Instantiation" anchor="abfab-arch">
        <artwork><![CDATA[
                                 +--------------+
                                 |   Identity   |
                                 |   Provider   |
                                 |    (IdP)     |
                                 +-^----------^-+
                                   * EAP      o RADIUS/
                                   *          o Diameter
                                 --v----------v--
                              ///                \\\
                            //                      \\     
                           |        Federation        | 
                           |        Substrate         | 
                            \\                      //  
                              \\\                ///
                                 --^----------^--
                                   * EAP      o RADIUS/
                                   *          o Diameter
+-------------+                  +-v----------v--+
|             |                  |               |
| Client      |  EAP/EAP Method  | Relying Party |
| Application |<****************>|     (RP)      |
|             |  GSS-API         |               |
|             |<---------------->|               |
|             |  Application     |               |
|             |  Protocol        |               |
|             |<================>|               |
+-------------+                  +---------------+

Legend:

 <****>: Client-to-IdP Exchange
 <---->: Client-to-RP Exchange
 <oooo>: RP-to-IdP Exchange 
 <====>: Protocol through which GSS-API/GS2 exchanges are tunneled
 ]]></artwork>
      </figure>
      </t>
      
      <section title="Relying Party to Identity Provider">
        <t>
          Communications between the Relying Party and the Identity Provider is done by the federation substrate.
          This communication channel is responsible for:
          <list style="symbols">
            <t>Establishing the trust relationship between the RP and the IdP.</t>
            <t>Determining the rules governing the relationship.</t>
            <t>Conveying authentication packets from the client to the IdP and back.</t>
            <t>Providing the means of establishing a trust relationship between the RP and the client.</t>
            <t>Providing a means for the RP to obtain attributes about the client from the IdP.</t>
          </list>
        </t>

        <t>
          
          The ABFAB working group has chosen the AAA framework for the messages transported between the RP and IdP.
          The AAA framework supports the requirements stated above as follows:

          <list style="symbols">
            <t>The AAA backbone supplies the trust relationship between the RP and the IdP.</t>
            <t>The agreements governing a specific AAA backbone contains the rules governing the relationships within the AAA federation.</t>
            <t>A method exists for carrying EAP packets within RADIUS <xref target="RFC3579"/> and Diameter <xref target="RFC4072"/>.</t>
            <t>The use of EAP channel binding <xref target="RFC6677"/> along with the core ABFAB protocol provide the pieces necessary to establish the identities of the RP and the client, while EAP provides the cryptographic methods for the RP and the client to validate they are talking to each other.</t>
            <t>A method exists for carrying SAML packets within RADIUS <xref target="I-D.ietf-abfab-aaa-saml"/> and Diameter (work in progress) which allows the RP to query attributes about the client from the IdP.</t>
          </list>
        </t>

        <t>
          Future protocols that support the same framework but do different routing may be used in the future. 
          One such effort is to setup a framework that creates a trusted point-to-point channel on the fly.
        </t>

        <section title="AAA, RADIUS and Diameter">
          <!-- ******************************* -->
          <t>
            Interestingly, for network access authentication the usage of the AAA framework with RADIUS <xref target="RFC2865"/> and Diameter <xref target="RFC3588"/> was quite successful from a deployment point of view.
            To map to the terminology used in <xref target="framework"/> to the AAA framework the IdP corresponds to the AAA server, the RP corresponds to the AAA client, and the technical building blocks of a federation are AAA proxies, relays and redirect agents (particularly if they are operated by third parties, such as AAA brokers and clearing houses).
            The front-end, i.e. the end host to AAA client communication, is in case of network access authentication offered by link layer protocols that forward authentication protocol exchanges back-and-forth.
            <!-- Klaas - Perhaps point to draft-wierenga-eduroam - WON'T FIX -->
            <!-- JLS - How fast is this document going to progress? -->
            <!-- JLS - 7/7/2013 - draft is no longer alive -->
            An example of a large scale RADIUS-based federation is <eref target="http://www.eduroam.org">EDUROAM</eref>.
          </t>

          <t>
            By using the AAA framework, ABFAB gets a lot of mileage as many of the federation agreements already exist and merely need to be expanded to cover the ABFAB additions.
            The AAA framework has already addressed some of the problems outlined above.  For example,
            <list style="symbols">
              <t>It already has a method for routing requests based on a domain.</t>
              <t>It already has an extensible architecture allowing for new attributes to be defined and transported.</t>
              <t>Pre-existing relationships can be re-used.</t>
            </list>
          </t>

          <t>
            The astute reader will notice that RADIUS and Diameter have substantially similar characteristics.
            Why not pick one?
            RADIUS and Diameter are deployed in different environments.
            RADIUS can often be found in enterprise and university networks, and is also in use by fixed network operators.
            Diameter, on the other hand, is deployed by mobile operators. 
            Another key difference is that today RADIUS is largely transported upon UDP.

            We leave as a deployment decision, which protocol will be appropriate.
            The protocol defines all the necessary new AAA attributes as RADIUS attributes.
            A future document would define the same AAA attributes for a Diameter environment.
            We also note that there exist proxies which convert from RADIUS to Diameter and back.
            This makes it possible for both to be deployed in a single federation substrate.
          </t>
          
          <t>
            Through the integrity protection mechanisms in the AAA framework, the identity provider can establish technical trust that messages are being sent by the appropriate relying party.
            Any given interaction will be associated with one federation at the policy level.
            The legal or business relationship defines what statements the identity provider is trusted to make and how these statements are interpreted by the relying party.
            The AAA framework also permits the relying party or elements between the relying party and identity provider to make statements about the relying party.
          </t>

          <t>
            The AAA framework provides transport for attributes.
            Statements made about the client by the identity provider, statements made about the relying party and other information are transported as attributes.
          </t>

          <t>
            One demand that the AAA substrate makes of the upper layers is that they must properly identify the end points of the communication.
            It must be possible for the AAA client at the RP to determine where to send each RADIUS or Diameter message.
            Without this requirement, it would be  the RP's responsibility to determine the identity of the client on its own, without the assistance of an IdP.
            This architecture makes use of the Network Access Identifier (NAI), where the IdP is indicated by the realm component <xref target="I-D.ietf-radext-nai"/>.
            The NAI is represented and consumed by the GSS-API layer as GSS_C_NT_USER_NAME as specified in <xref target="RFC2743"/>.
            The GSS-API EAP mechanism includes the NAI in the EAP Response/Identity message.
          </t>
          
        </section>

        <section title="Discovery and Rules Determination" anchor="discovery">

          <t>
            While we are using the AAA protocols to communicate with the IdP, the RP may have multiple federation substrates to select from.
            The RP has a number of criteria that it will use in selecting which of the different federations to use:
            <list style="symbols">
              <t>The federation selected must be able to communicate with the IdP.</t>
              <t>The federation selected must match the business rules and technical policies required for the RP security requirements.</t>
            </list>
          </t>

          <t>
            The RP needs to discover which federation will be used to contact the IdP.
            The first selection criteria used during discovery is going to be the name of the IdP to be contacted.
            The second selection criteria used during discovery is going to be the set of business rules and technical policies governing the relationship; this is called rules determination.
            The RP also needs to establish technical trust in the communications with the IdP.
          </t>
          
          <t>
            Rules determination covers  a broad range of decisions about the exchange.
            One of these is whether the given RP is permitted to talk to the IdP using a given federation at all, so rules determination encompasses the basic authorization decision.
            Other factors are included, such as what policies govern release of information about the client to the RP and what policies govern the RP's use of this information.
            While rules determination is ultimately a business function, it has significant impact on the technical exchanges.
            The protocols need to communicate the result of authorization.
            When multiple sets of rules are possible, the protocol must disambiguate which set of rules are in play.
            Some rules have technical enforcement mechanisms; for example in some federations intermediaries validate information that is being communicated within the federation.
          </t>

          <t>
            At the time of writing no protocol mechanism has been specified to allow a AAA client to determine whether a AAA proxy will indeed be able to route AAA requests to a specific IdP.
            The AAA routing is impacted by business rules and technical policies that may be quite complex and at the present time, the route selection is based on manual configuration.

          </t>

        </section>

        <section title="Routing and Technical Trust">
          <t>
            Several approaches to having messages routed through the federation substrate are possible.
            These routing methods can most easily be classified based on the mechanism for technical trust that is used.
            The choice of technical trust mechanism constrains how rules determination is implemented.

            <!-- Klaas - "names" or "identities"? - DONE -->
            Regardless of what deployment strategy is chosen, it is important that the technical trust mechanism be able to validate the identities of both parties to the exchange.
            <!-- Paul - In what way? - DONE -->

            The trust mechanism must ensure that the entity acting as IdP for a given NAI is permitted to be the IdP for that realm, and that any service name claimed by the RP is permitted to be claimed by that entity.

            Here are the categories of technical trust determination:

            <list style="hanging">
              <t hangText="AAA Proxy:"><vspace/>
              <!-- Klaas - "supports" or "forwards" - DONE -->
              The simplest model is that an RP is an AAA client and can send the request directly to an AAA proxy.
              The hop-by-hop integrity protection of the AAA fabric provides technical trust.
              An RP can submit a request directly to the correct federation.
              Alternatively, a federation disambiguation fabric can be used.
              Such a fabric takes information about what federations the RP is part of and what federations the IdP is part of and routes a message to the appropriate federation.
              The routing of messages across the fabric plus attributes added to requests and responses provides rules determination.
              For example, when a disambiguation fabric routes a message to a given federation, that federation's rules are chosen.
              Name validation is enforced as messages travel across the fabric.
              <!-- Paul - Naming constraints? - DONE -->
              The entities near the RP confirm its identity and validate names it claims.
              The fabric routes the message towards the appropriate IdP, validating the name of the IdP in the process.
              The routing can be statically configured.
              Alternatively a routing protocol could be developed to exchange reachability information about a given IdP and to apply policy across the AAA fabric.
              Such a routing protocol could flood naming constraints to the appropriate points in the fabric.
              </t>
              <t hangText="Trust Broker:"><vspace/>
              Instead of routing messages through AAA proxies, some trust broker could establish keys between entities near the RP and entities near the IdP.
              The advantage of this approach is efficiency of message handling.
              Fewer entities are needed to be involved for each message.
              Security may be improved by sending individual messages over fewer hops.
              Rules determination involves decisions made by trust brokers about what keys to grant.
              Also, associated with each credential is context about rules and about other aspects of technical trust including names that may be claimed.
              A routing protocol similar to the one for AAA proxies is likely to be useful to trust brokers in flooding rules and naming constraints.
              </t>
              <t hangText="Global Credential:"><vspace/>
              <!-- Does it have to be global? Agreed upon within the federation seems sufficient? -->
              A global credential such as a public key and certificate in a public key infrastructure can be used to establish technical trust.
              A directory or distributed database such as the Domain Name System is used by the RP to discover the endpoint to contact for a given NAI.
              Either the database or certificates can provide a place to store information about rules determination and naming constraints.
              Provided that no intermediates are required (or appear to be required) and that the RP and IdP are sufficient to enforce and determine rules, rules determination is reasonably simple.
              However applying certain rules is likely to be quite complex.
              For example if multiple sets of rules are possible between an IdP and RP, confirming the correct set is used may be difficult.
              This is particularly true if intermediates are involved in making the decision.
              Also, to the extent that directory information needs to be trusted, rules determination may be more complex.
              </t>
            </list>
          </t>
          <t>
            Real-world deployments are likely to be mixtures of these basic approaches.
            For example, it will be quite common for an RP to route traffic to a AAA proxy within an organization.
            That proxy could then use any of the three methods to get closer to the IdP.
            It is also likely that rather than being directly reachable, the IdP may have a proxy on the edge of its organization.
            Federations will likely provide a traditional AAA proxy interface even if they also provide another mechanism for increased efficiency or security.
          </t>
        </section>

        <section title="AAA Security">
          <t>
            For the AAA framework there are two different places where security needs to be examined.
            The first is the security that is in place for the links in the AAA backbone being used.
            The second is the nodes that the backbone consists of.
          </t>

          <t>
            <!-- Klaas - All true but worth noting that the use of EAP does provide quite a bit of protection of credentials - DONE -->

            The default link security for RADIUS is showing its age as it uses MD5 and a shared secret to both obfuscate passwords and to provide integrity on the RADIUS messages.
            While some EAP methods have designed in the ability to protect the client authentication credentials, the MSK returned from the IDP to the RP is protected only by the RADIUS security.
            In many environments this is considered to be insufficient, especially as not all attributes are obfuscated and can thus leak information to a passive eavesdropper.
            The use of RADIUS with TLS <xref target="RFC6614"/> and/or DTLS <xref target="I-D.ietf-radext-dtls"/> addresses these attacks.
            The same level of security is included in the base Diameter specifications.
          </t>
            
          <!--
          <t>
            If one uses a model such as the Trust Broker in the previous section, one could in theory link directly from the AAA client to the AAA server without any intervening nodes in the middle.
            However, proxy nodes may be necessary in the backbone in order to filter or alter the attributes being sent between the RP and the IDP.
            These proxy nodes can also be used as part of the operational specifications used to implement the federation agreement.
            
            
            TBD - Put in text - 
            Not all nodes can be eliminated - proxy nodes may be required
            Trust router looks for a way to shorten the list of inner nodes.
            Reference DYNAMIC and say that it does or does not help and why.
            Talk about Diameter in the same context - does it have the same set of issues or not?
          </t>
          -->
        </section>

        <section title="SAML Assertions">
          <t>
            For the traditional use of AAA frameworks, network access, the only requirement that was necessary to grant access was an affirmative response from the IdP.
            In the ABFAB world, the RP may need to get additional information about the client before granting access.
            ABFAB therefore has a requirement that it can transport an arbitrary set of attributes about the client from the IdP to the RP.
          </t>
          
          <t>
            Security Assertions Markup Language (SAML) <xref target="OASIS.saml-core-2.0-os"/> was designed in order to carry an extensible set of attributes about a subject.
            Since SAML is extensible in the attribute space, ABFAB has no immediate needs to update the core SAML specifications for our work.
            It will be necessary to update IdPs that need to return SAML assertions to RPs and for both the IdP and the RP to implement a new SAML profile designed to carry SAML assertions in AAA.
            The new profile can be found in RFCXXXX <xref target="I-D.ietf-abfab-aaa-saml"/>.
            As SAML statements will frequently be large, RADIUS servers and clients that deal with SAML statements will need to implement RFC XXXX <xref target="I-D.perez-radext-radius-fragmentation"/>
          </t>

          <!-- Hannes - Reference the Diameter document as well - JLS - No Diameter document to reference - WON'T FIX -->

          <t>
            There are several issues that need to be highlighted:  

            <list style="symbols">
              <t>The security of SAML assertions.</t>
              <t>Namespaces and mapping of SAML attributes.</t>
              <t>Subject naming of entities.</t>
              <t>Making multiple queries about the subject(s).</t>
              <t>Level of Assurance for authentication.</t>
            </list>
          </t>
          
          <t>
            SAML assertions have an optional signature that can be used to protect and provide origination of the assertion.
            These signatures are normally based on asymmetric key operations and require that the verifier be able to check not only the cryptographic operation, but also the binding of the originators name and the public key.
            In a federated environment it will not always be possible for the RP to validate the binding, for this reason the technical trust established in the federation is used as an alternate method of validating the origination and integrity of the SAML Assertion.
          </t>
          
          <t>
            Attributes placed in SAML assertions can have different namespaces assigned to the same name.
            In many, but not all, cases the federation agreements will determine what attributes can be used in a SAML statement.
            This means that the RP needs to map from the federation names, types and semantics into the ones that the policies of the RP are written in.
            In other cases the federation substrate may modify the SAML assertions in transit to do the necessary namespace, naming and semantic mappings as the assertion crosses the different boundaries in the federation.
            If the proxies are modifying the SAML Assertion, then they will obviously remove any signatures as they would no longer validate.
            In this case the technical trust is the required mechanism for validating the integrity of the assertion.  
            Finally, the attributes may still be in the namespace of the originating IdP.
            When this occurs the RP will need to get the required mapping operations from the federation agreements and do the appropriate mappings itself.
            <!-- Paul - s/In the last case/finally/ - DONE-->
          </t>

          <t>
            <!-- Klaas - Would this make life easier? - DONE -->
            <!-- JLS - No longer a true statement - see SAML document -->
            The RADIUS SAML RFC <xref target="I-D.ietf-abfab-aaa-saml"/> has defined a new SAML name format that corresponds to the NAI name form defined by RFC XXXX <xref target="I-D.ietf-radext-nai"/>.
            This allows for easy name matching in many cases as the name form in the SAML statement and the name form used in RADIUS or Diameter will be the same.
            In addition to the NAI name form, the document also defines a pair of implicit name forms corresponding to the Client and the Client's machine.
            These implicit name forms are based on the Identity-Type enumeration defined in TEAP <xref target="I-D.ietf-emu-eap-tunnel-method"/>.
            If the name form returned in a SAML statement is not based on the NAI, then it is a requirement on the EAP server that it validate that the subject of the SAML assertion, if any, is equivalent to the subject identified by the NAI used in the RADIUS or Diameter session.
          </t>

          <t>
            RADIUS has the ability to deal with multiple SAML queries for those EAP Servers which follow RFC 5080 <xref target="RFC5080"/>.
            In this case a State attribute will always be returned with the Access-Accept.
            The EAP client can then send a new Access-Request with the State attribute and the new SAML Request
            Multiple SAML queries can then be done by making a new Access-Request using the State attribute returned in the last Access-Accept to link together the different RADIUS sessions.
          </t>

          <t>
            Some RPs need to ensure that specific criteria are met during the authentication process.
            This need is met by using Levels of Assurance.
            The way a Level of Assurance is communicated to the RP from the EAP server is by the use of a SAML Authentication Request using the Authentication Profile from RFC XXX <xref target="I-D.ietf-abfab-aaa-saml"/> 
            When crossing boundaries between different federations, either the policy specified will need to be shared between the two federations, the policy will need to be mapped by the proxy server on the boundary or the proxy server on the boundary will need to supply information the EAP server so that it can do the required mapping.
            If this mapping is not done, then the EAP server will not be able to enforce the desired Level of Assurance as it will not understand the policy requirements.
          </t>
        </section>

      </section>

      
      <section title="Client To Identity Provider">
        <t>
          Looking at the communications between the client and the IdP, the following items need to be dealt with:
          <list style="symbols">
            <t>The client and the IdP need to mutually authenticate each other.</t>
            <!-- Klaas - Always - even if the RP learns nothing about the client? - WON'T FIX -->
            <!-- JLS - The RP always learns someting about the client - even if it is just that they are a member of a domain.  There is a difference between authenticate and identify. -->

            <t>The client and the IdP need to mutually agree on the identity of the RP.</t>
          </list>
        </t>

        <t>
          ABFAB selected EAP for the purposes of mutual authentication and assisted in creating some new EAP channel binding documents for dealing with determining the identity of the RP.
          A framework for the channel binding mechanism has been defined in RFC 6677 <xref target="RFC6677"/> that allows the IdP to check the identity of the RP provided by the AAA framework with that provided by the client.
        </t>

        <section title="Extensible Authentication Protocol (EAP)" anchor="Client_Eap">
          <t>
            Traditional web federation does not describe how a client interacts with an identity provider for authentication.
            As a result, this communication is not standardized.
            There are several disadvantages to this approach.
            Since the communication is not standardized, it is difficult for machines to correctly enter their credentials with different authentications, where Individuals can correctly identify the entire mechanism on the fly.
            <!-- Paul - Not clear who has the programatic credential - DONE -->
            The use of browsers for authentication restricts the deployment of more secure forms of authentication beyond plaintext username and password known by the server.
            In a number of cases the authentication interface may be presented before the client has adequately validated they are talking to the intended server.
            By giving control of the authentication interface to a potential attacker, the security of the system may be reduced and phishing opportunities introduced.
          </t>

          <t>
            As a result, it is desirable to choose some standardized approach for communication between the client's end-host and the identity provider.
            There are a number of requirements this approach must meet.
          </t>

          <t>
            Experience has taught us one key security and scalability requirement: it is important that the relying party not get possession of the long-term secret of the client.
            Aside from a valuable secret being exposed, a synchronization problem can develop when the client changes keys with the IdP.
          </t>

          <t>
            Since there is no single authentication mechanism that will be used everywhere there is another associated requirement:
            The authentication framework must allow for the flexible integration of authentication mechanisms.
            For instance, some IdPs require hardware tokens while others use passwords.
            A service provider wants to provide support for both authentication methods, and other methods from IdPs not yet seen.
          </t>

          <t>
            <!-- Klaas, Not as much of a surprise as this text suggests after all the prior text on EAP channel brining etc - DONE -->
            These requirements can be met by utilizing standardized and successfully deployed technology, namely by the Extensible Authentication Protocol (EAP) framework <xref target="RFC3748"/>.
            <xref target="abfab-arch"/> illustrates the integration graphically.
          </t>

          <t>
            EAP is an end-to-end framework; it provides for two-way communication between a peer (i.e. client or individual) through the EAP authenticator (i.e., relying party) to the back-end (i.e., identity provider).
            Conveniently, this is precisely the communication path that is needed for federated identity.
            Although EAP support is already integrated in AAA systems (see <xref target="RFC3579"/> and <xref target="RFC4072"/>) several challenges remain:
            <list style="symbols">
              <t>The first is how to carry EAP payloads from the end host to the relying party.</t>
              <t>Another is to verify statements the relying party has made to the client, confirm these statements are consistent with statements made to the identity provider and confirm all of the above are consistent with the federation and any federation-specific policy or configuration.</t>
              <t>Another challenge is choosing which identity provider to use for which service.</t>
            </list>
          </t>

          <t>
            The EAP method used for ABFAB needs to meet the following requirements:
            <list style="symbols">
              <t>It needs to provide mutual authentication of the client and IdP.</t>
              <t>It needs to support channel binding.</t>
            </list>
            As of this writing, the only EAP method that meets these criteria is TEAP <xref target="I-D.ietf-emu-eap-tunnel-method"/> either alone (if client certificates are used) or with an inner EAP method that does mutual authentication.
          </t>
        </section>

        <section title="EAP Channel Binding" anchor="client_channel_binding">
          <t>
            <!-- Repeat of earlier text on channel binding -->
            EAP channel binding is easily confused with a facility in GSS-API also called channel binding.
            GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used as authentication inside some tunnel; it is similar to a facility called cryptographic binding in EAP.
            See <xref target="RFC5056"/> for a discussion of the differences between these two facilities.
          </t>

          <t>
            The client knows, in theory, the name of the RP that it attempted to connect to, however in the event that an attacker has intercepted the protocol, the client and the IdP need to be able to detect this situation.  A general overview of the problem along with a recommended way to deal with the channel binding issues can be found in RFC 6677 <xref target="RFC6677"/>.
          </t>

          <t>
            Since that document was published, a number of possible attacks were found and methods to address these attacks have been outlined in <xref target="I-D.ietf-emu-crypto-bind"/>.
          </t>

        </section>

      </section>

      <section title="Client to Relying Party">
        <t>
          The final set of interactions between the parties to consider are those between the client and the RP.
          In some ways this is the most complex set since at least part of it is outside the scope of the ABFAB work.  The interactions between these parties include:
          <list style="symbols">
            <t>Running the protocol that implements the service that is provided by the RP and desired by the client.</t>
            <!-- Paul - non-web service? - That's what the first paragraph of section 2 said this is about - DONE -->
            <t>Authenticating the client to the RP and the RP to the client.</t>
            <t>Providing the necessary security services to the service protocol that it needs beyond authentication.</t>
            <!-- Paul - ditto s/web/non-web/ - DONE -->
            <t>Deal with client re-authentication where desired.</t>
          </list>
        </t>

        <section title="GSS-API">
          <t>
            One of the remaining layers is responsible for integration of federated authentication into the application.
            There are a number of approaches that applications have adopted for security.
            So, there may need to be multiple strategies for integration of federated authentication into applications.
            However, we have started with a strategy that provides integration to a large number of application protocols.
          </t>
          <t>
            Many applications such as SSH <xref target="RFC4462"/>, NFS <xref target="RFC2203"/>, DNS <xref target="RFC3645"/> and several non-IETF applications support the Generic Security Services Application Programming Interface <xref target="RFC2743"/>.
            Many applications such as IMAP, SMTP, XMPP and LDAP support the Simple Authentication and Security Layer (SASL) <xref target="RFC4422"/> framework.
            These two approaches work together nicely: by creating a GSS-API mechanism, SASL integration is also addressed.
            In effect, using a GSS-API mechanism with SASL simply requires placing some headers on the front of the mechanism and constraining certain GSS-API options.
          </t>
          <t>
            GSS-API is specified in terms of an abstract set of operations which can be mapped into a programming language to form an API.
            When people are first introduced to GSS-API, they focus on it as an API.
            However, from the prospective of authentication for non-web applications, GSS-API should be thought of as a protocol as well as an API.
            When looked at as a protocol, it consists of abstract operations such as the initial context exchange, which includes two sub-operations (gss_init_sec_context and gss_accept_sec_context).
            An application defines which abstract operations it is going to use and where messages produced by these operations fit into the application architecture.
            A GSS-API mechanism will define what actual protocol messages	result from that abstract message for a given abstract operation.
            So, since this work is focusing on a particular GSS-API mechanism, we generally focus on protocol elements rather than the API view of GSS-API.
          </t>
          <t>
            <!-- Klaas - - Ehm, you just told me you were not focusing on the API view - FIXED -->
            The API view of GSS-API does have significant value as well, since the abstract operations are well defined, the set of information that a mechanism gets from the application is well defined.
            Also, the set of assumptions the application is permitted to make is generally well defined.
            As a result, an application protocol that supports GSS-API or SASL is very likely to be usable with a new approach to authentication including this one with no required modifications.
            In some cases, support for a new authentication mechanism has been added using plugin interfaces to applications without the application being modified at all.
            Even when modifications are required, they can often be limited to supporting a new naming and authorization model.
            For example, this work focuses on privacy; an application that assumes it will always obtain an identifier for the client will need to be modified to support anonymity, unlinkability or pseudonymity.
          </t>
          <t>
            So, we use GSS-API and SASL because a number of the application protocols we wish to federate support these strategies for security integration.
            What does this mean from a protocol standpoint and how does this relate to other layers?
            This means we need to design a concrete GSS-API mechanism.
            We have chosen to use a GSS-API mechanism that encapsulates EAP authentication.
            So, GSS-API (and SASL) encapsulates EAP between the end-host and the service.
            The AAA framework encapsulates EAP between the relying party and the identity provider.
            The GSS-API mechanism includes rules about how initiators and services are named as well as per-message security and other facilities required by the applications we wish to support.
          </t>
        </section>

        <section title="Protocol Transport">
          <t>The transport of data between the client and the relying party is not provided by GSS-API.  GSS-API creates and consumes messages, but it does not provide the transport itself, instead the protocol using GSS-API needs to provide the transport.  In many cases HTTP or HTTPS is used for this transport, but other transports are perfectly acceptable.  The core GSS-API document <xref target="RFC2743"/> provides some details on what requirements exist.</t>
          <t>
            In addition we highlight the following:
            <list style="symbols">
              <t>
                The transport does not need to provide either privacy or integrity.
                After GSS-EAP has finished negotiation, GSS-API can be used to provide both services.
                If the negotiation process itself needs protection from eavesdroppers then the transport would need to provide the necessary services.
              </t>
              <!-- Klaas - Does this follow from anything? - OPEN -->
              <t>The transport needs to provide reliable transport of the messages.</t>
              <t>The transport needs to ensure that tokens are delivered in order during the negotiation process.</t>
              <t>GSS-API messages need to be delivered atomically.  If the transport breaks up a message it must also reassemble the message before delivery.</t>
            </list>
          </t>
        </section>

        <section title="Reauthentication">
          <t>
            There are circumstances where the server will want to have the client reauthenticate itself.
            These include very long sessions, where the original authentication is time limited or cases where in order to complete an operation a different authentication is required.
            GSS-EAP does not have any mechanism for the server to initiate a reauthentication as all authentication operations start from the client.
            If a protocol using GSS-EAP needs to support reauthentication that is initiated by the server, then a request from the server to the client for the reauthentiction to start needs to be placed in the protocol.
          </t>
          <t>
            Clients can re-use the existing secure connection established by GSS-API to run the new authentication in by calling GSS_Init_sec_context.
            At this point a full reauthentication will be done.
          </t>
        </section>
      </section>
             
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Application Security Services">
      <t>
        One of the key goals is to integrate federated authentication into existing application protocols and where possible, existing implementations of these protocols.
        Another goal is to perform this integration while meeting the best security practices of the technologies used to perform the integration.
        This section describes security services and properties required by the EAP GSS-API mechanism in order to meet these goals.
        This information could be viewed as specific to that mechanism.
        However, other future application integration strategies are very likely to need similar services.
        So, it is likely that these services will be expanded across application integration strategies if new application integration strategies are adopted.
      </t>
      
      <section title="Authentication">
        <!-- Hannes - 
             The authentication section is indeed interesting and I understand that there is a challenge to describe it properly. However, may the way how the story was phrased for earlier EAP-related publications may help. I believe that the situation is similar to the Secure Association Protocol, as http://tools.ietf.org/html/rfc4962 calls it. Here is the short description: 

A protocol for managing security associations derived from EAP
and/or AAA exchanges.  The protocol establishes a security
association, which includes symmetric keys and a context for
the use of the keys.  An example of a Secure Association
Protocol is the 4-way handshake defined within [802.11i].

The properties of the exchange between the GSS initiator and the GSS acceptor can similar to the IEEE 802.11i 4-way handshake protocol, i.e., where the Supplient and the Access Point do not authenticate each other directly but they both independently derive keying material obtained via the EAP MSK to confirm through this protocol exchange that they indeed know the same keying material. 

A possible variation (which is also supported with the ABFAB work) is that there is indeed direct authentication of the acceptor to the initiator (when TLS with server-side authentication is used in GSS). Here the appropriate comparison would be the IKEv2-EAP integration. 

The details matter here and since I am not the GSS-API expert I am wondering how the exchange looks in detail. Maybe a diagram would help to illustrate how the keying material is derived.
- M00TODO - OPEN
        -->

        <t>
          GSS-API provides an optional security service called mutual authentication.
          This service means that in addition to the initiator providing (potentially anonymous or pseudonymous) identity to the acceptor, the acceptor confirms its identity to the initiator.
          Especially for the ABFAB context, this service is confusingly named.
          We still say that mutual authentication is provided when the identity of an acceptor is strongly authenticated to an anonymous initiator.
        </t>

        <t>
          RFC 2743, unfortunately, does not explicitly talk about what mutual authentication means.
          Within this document we therefore define it as:
          <list style="symbols">
            <t>
              If a target name is configured for the initiator, then the initiator trusts that the supplied target name describes the acceptor.
              This implies both that appropriate cryptographic exchanges took place for the initiator to make such a trust decision, and that after evaluating the results of these exchanges, the initiator's policy trusts that the target name is accurate.
              <!-- Paul - It isn't always necessary to do crypto exchange to believe that the supplied target name describes the supplied target name describes the acceptor.  E.g. the taret name is the DNS name of the server, which was entered by the user - in which case it is assumed to be what the user wanted. - DONE -->
              <!-- JLS - however this does not mean that the server you are talking to is actually what the user typed in.
              We are checking what the user typed in againist who the acceptor claims to be.
              -->
            </t>
            <t>
              If no target name is configured for the initiator, then the initiator trusts that the acceptor name, supplied by the acceptor, correctly names the entity it is communicating with.
              <!-- Paul - Don't get this.  If no target name is suppled, where did the initiator get the "idea" - DONE -->
            </t>
            <t>
              Both the initiator and acceptor have the same key material for per-message keys and both parties have confirmed they actually have the key material.
              In EAP terms, there is a protected indication of success.
            </t>
          </list>
        </t>
        
        <t>
          Mutual authentication is an important defense against certain aspects of phishing.
          Intuitively, clients would like to assume that if some party asks for their credentials as part of authentication, successfully gaining access to the resource means that they are talking to the expected party.
          Without mutual authentication, the server could "grant access" regardless of what credentials are supplied.
          Mutual authentication better matches this user intuition.
        </t>
        
        <t>
          It is important, therefore, that the GSS-EAP mechanism implement mutual authentication.
          That is, an initiator needs to be able to request mutual authentication.
          
          <!-- Paul,  Shouldn't it always request mutual authenticaiton in this day and age? - DONE -->
          <!-- JLS - There may be other ways to get the required authentication or it may not be a required property -->
          
          When mutual authentication is requested, only EAP methods capable of providing the necessary service can be used, and appropriate steps need to be taken to provide mutual authentication.
          While a broader set of EAP methods could be supported by not requiring mutual authentication, it was decided that the client needs to always have the ability to request it.
          In some cases the IdP and the RP will not support mutual authentication, however the client will always be able to detect this and make an appropriate security decision.
        </t>
        
        <t>
          <!-- May want to move this paragraph to a different section - OPEN -->
          The AAA infrastructure MAY hide the initiator's identity from the GSS-API acceptor, providing anonymity between the initiator and the acceptor.
          At this time, whether the identity is disclosed is determined by EAP server policy rather than by an indication from the initiator.
          Also, initiators are unlikely to be able to determine whether anonymous communication will be provided.
          For this reason, initiators are unlikely to set the anonymous return flag from GSS_Init_Sec_context.
        </t>
      </section>

                      
      <section title="GSS-API Channel Binding">
        <t>
          <xref target="RFC5056"/> defines a concept of channel binding which is used prevent man-in-the-middle attacks.
          The channel binding works by taking a cryptographic value from the transport security and checks that both sides of the GSS-API conversation know this value.
          Transport Layer Security (TLS) is the most common transport security layer used for this purpose.
        </t>

        <t>
          It needs to be stressed that RFC 5056 channel binding (also called GSS-API channel binding when GSS-API is involved) is not the same thing as EAP channel binding.
          GSS-API channel binding is used for detecting Man-In-The-Middle attacks.
          <!-- Klaas - Introduce term "lying NAS"? - WON'T FIX -->
          <!-- JLS - lying NAS is part of the EAP channel binding problem and not the GSS-API channel binding problem.  THerefore it does not belong here. -->
          EAP channel binding is used for mutual authentication and acceptor naming checks.
          Details are discussed in the mechanisms specification <xref target="I-D.ietf-abfab-gss-eap"/>.
          A fuller description of the differences between the facilities can be found in RFC 5056 <xref target="RFC5056"/>.
        </t>

        <t>
          The use of TLS can provide both encryption and integrity on the channel.
          It is common to provide SASL and GSS-API with these other security services.
        </t>

        <t>
          One of the benefits that the use of TLS provides, is that client has the ability to validate the name of the server.
          However this validation is predicated on a couple of things.
          The TLS sessions needs to be using certificates and not be an anonymous session.
          The client and the TLS server need to share a common trust point for the certificate used in validating the server.
          

          TLS provides its own server authentication.
          However there are a variety of situations where this authentication is not checked for policy or usability reasons.

          When the TLS authentication is checked, if the trust infrastructure behind the TLS authentication is different from the trust infrastructure behind the GSS-API mutual authentication then confirming the end-points using both trust infrastructures is likely to enhance security.
          If the endpoints of the GSS-API authentication are different than the endpoints of the lower layer, this is a strong indication of a problem such as a man-in-the-middle attack.
          Channel binding provides a facility to determine whether these endpoints are the same.
        </t>
        
        <t>
          The GSS-EAP mechanism needs to support channel binding.
          When an application provides channel binding data, the mechanism needs to confirm this is the same on both sides consistent with the GSS-API specification. 
        </t>
        
        
        
      </section>


      <section title="Host-Based Service Names">
        <t>
          IETF security mechanisms typically take a host name and perhaps a service, entered by a user, and make some trust decision about whether the remote party in the interaction is the intended party.
          This decision can be made by the use of certificates, pre-configured key information or a previous leap of trust.
          
          GSS-API has defined a relatively flexible name convention, however most of the IETF applications that use GSS-API (including SSH, NFS, IMAP, LDAP and XMPP) have chosen to use a more restricted naming convention based on the host name.
          The GSS-EAP mechanism needs to support host-based service names in order to work with existing IETF protocols.

        </t>
        
        <t>
          The use of host-based service names leads to a challenging trust delegation problem.
          Who is allowed to decide whether a particular host name maps to a specific entity?
          Possible solutions to this problem have been looked at.
          <list style="symbols">
            <t>
              The public-key infrastructure (PKI) used by the web has chosen to have a number of trust anchors (root certificate authorities) each of which can map any host name to a public key.
            </t>
            <t>
              A number of GSS-API mechanisms, such as Kerberos <xref target="RFC1964"/>, have split the problem into two parts.
              A new concept called a realm is introduced, the realm is responsible for host mapping within that realm.
              The mechanism then decides what realm is responsible for a given name.
              This is the approach adopted by ABFAB.
            </t>
          </list>
        </t>

        <t>
          GSS-EAP defines a host naming convention that takes into account the host name, the realm, the service and the service parameters.
          An example of GSS-API service name is "xmpp/foo@example.com".
          This identifies the XMPP service on the host foo in the realm example.com.
          Any of the components, except for the service name may be omitted from a name.
          When omitted, then a local default would be used for that component of the name.
        </t>


        <t>
          While there is no requirement that realm names map to Fully Qualified Domain Names (FQDN) within DNS, in practice this is normally true.
          Doing so allows for the realm portion of service names and the portion of NAIs to be the same.
          It also allows for the use of DNS in locating the host of a service while establishing the transport channel between the client and the relying party.
          

        </t>

        <!-- Paul - This is an architecture doucment not a requierments document - remove last sentence - DONE -->

        <t>
          It is the responsibility of the application to determine the server that it is going to communicate with; GSS-API has the ability to help confirm that the server is the desired server but not to determine the name of the server to use.
          It is also the responsibility of the application to determine how much of the information identifying the service needs to be validated by the ABFAB system.
          The information that needs to be validated is used to build up the service name passed into the GSS-EAP mechanism.
          What information is to be validated will depend on both what information was provided by the client, and what information is considered significant.
          If the client only cares about getting a specific service, then the host and realm that provides the service does not need to be validated.
        </t>

        <!--
        <t>
          In many cases applications may retrieve information about providers of services from DNS.
          When Service Records (SRV) and Naming Authority Pointer (NAPTR) records are used to help find a host that provides a service, the security requirements on the referrals are going to interact with the information used in the service name.
          If a host name is returned from the DNS referrals, and the host name is to be validated by GS-EAP, then it makes sense that the referrals themselves should be secure.
          On the other hand, if the host name returned is not validated, i.e. only the service is passed in, then it is less important that the host name be obtained in a secure manner.
        </t>
        -->

        <t>
          Applications may retrieve information about providers of services from DNS.
          Service Records (SRV) and Naming Authority Pointer (NAPTR) records are used to help find a host that provides a service; however the necessity of having DNSSEC on the queries depends on how the information is going to be used.
          If the host name returned is not going to be validated by EAP channel binding, because only the service is being validated, then DNSSEC is not required.
          However, if the host name is going to be validated by EAP channel binding then DNSSEC needs to be use to ensure that the correct host name is validated.
          In general, if the information that is returned from the DNS query is to be validated, then it needs to be obtained in a secure manner.
        </t>

        <!-- Paul - And what is being done about this problem?  MS target names include port numbers - DONE -->

        <t>
          Another issue that needs to be addressed for host-based service names is that they do not work ideally when different instances of a service are running on different ports.
          If the services are equivalent, then it does not matter.
          However if there are substantial differences in the quality of the service that information needs to be part of the validation process.
          If one has just a host name and not a port in the information being validated, then this is not going to be a successful strategy.
        </t>
      </section>

      <section title="Additional GSS-API Services">
        <t>
          GSS-API provides per-message security services that can provide confidentiality and/or integrity.
          Some IETF protocols such as NFS and SSH take advantage of these services.
          As a result GSS-EAP needs to support these services.

          As with mutual authentication, per-message services will limit the set of EAP methods that can be used to those that generate a Master Session Key (MSK).

          Any EAP method that produces an MSK is able to support per-message security services described in <xref target="RFC2743"/>.


        </t>
        
        <t>
          GSS-API provides a pseudo-random function.
          This function generates a pseudo-random sequence using the shared session key as the seed for the bytes generated.
          This provides an algorithm that both the initiator and acceptor can run in order to arrive at the same key value.
          The use of this feature allows for an application to generate keys or other shared secrets for use in other places in the protocol.
          In this regards, it is similar in concept to the TLS extractor (RFC 5705 <xref target="RFC5705"/>.).
          While no current IETF protocols require this, non-IETF protocols are expected to take advantage of this in the near future.
          Additionally, a number of protocols have found the TLS extractor to be useful in this regards so it is highly probable that IETF protocols may also start using this feature.
        </t>

      </section>
    </section>


    <section title="Privacy Considerations">
      <t>
        ABFAB, as an architecture designed to enable federated authentication and allow for the secure transmission of identity information between entities, obviously requires careful consideration around privacy and the potential for privacy violations.
      </t>

      <t>
        This section examines the privacy related information presented in this document, summarizing the entities that are involved in ABFAB communications and what exposure they have to identity information. In discussing these privacy considerations in this section, we use terminology and ideas from <xref target="I-D.iab-privacy-considerations"/>.
      </t>

      <t>
        Note that the ABFAB architecture uses at its core several existing technologies and protocols; detailed privacy discussion around these is not examined.
        This section instead focuses on privacy considerations specifically related to overall architecture and usage of ABFAB.
      </t>

      <t>
        <figure title="Entities and Data Flow" anchor="dataflow">
          <artwork><![CDATA[

+--------+       +---------------+       +--------------+
| Client | <---> |      RP       | <---> | AAA Client   |
+--------+       +---------------+       +--------------+
                                               ^
                                               |
                                               v
                 +---------------+       +--------------+
                 | SAML Server   |       | AAA Proxy(s) |
                 +---------------+       +--------------+
                          ^                       ^
                          |                       |
                          v                       v
+------------+       +---------------+       +--------------+
| EAP Server | <---> |   IdP         | <---> | AAA Server   |
+------------+       +---------------+       +--------------+
            ]]></artwork>
          </figure>
        </t>

      <section title="Entities and their roles">
        <!-- TODO reclassify -->
          <t>
            Categorizing the ABFAB entities shown in the <xref target="dataflow"/> according to the taxonomy of terms from <xref target="I-D.iab-privacy-considerations"/> the entities shown in <xref target="dataflow"/> is somewhat complicated as during the various phases of ABFAB communications the roles of each entity changes.
            The three main phases of relevance are the Client to RP communication phase,  the Client to IdP (via the Federation Substrate) phase, and the IdP to RP (via the Federation Substrate) phase.
          </t>
          <!-- 
               <t>
               Using the taxonomy of privacy terms from <xref target="I-D.iab-privacy-considerations"/> the entities show in <xref target="dataflow"/> are categorized as follows:
               <list style="hanging">
               <t hangText="Enablers:"> AAA Client, AAA Server, IdP, EAP Server, SAML Server.</t>
               <t hangText="Initiator:"> Client.</t>
               <t hangText="Intermediary:"> AAA Proxy(s).</t>
               <t hangText="Observers:">Relying Party, AAA Client, AAA Proxy(s), AAA Server, IdP, EAP Server, SAML Server.</t>
               <t hangText="Recipient:"> Relying Party.</t>
               </list>
               </t>
          -->

          <t>
              In the Client to RP communication phase, we have:
              <list style="hanging">
                <t hangText="Initiator:">Client.</t>
                <t hangText="Observers:">Client, RP.</t>
                <t hangText="Recipient:">RP.</t>
              </list>
          </t>
          <t>
              In the Client to IdP (via the Federation Substrate) communication phase, we have:
              <list style="hanging">
                  <t hangText="Initiator:">Client.</t>
                  <t hangText="Observers:">Client, RP, AAA Client, AAA Proxy(s), AAA Server, IdP.</t>
                  <t hangText="Recipient:">IdP</t>
              </list>
          </t>
          <t>
              In the IdP to Relying party (via the Federation Substrate) communication phase, we have:
              <list style="hanging">
                  <t hangText="Initiator:">RP.</t>
                  <t hangText="Observers:">IdP, AAA Server, AAA Proxy(s), AAA Client, RP.</t>
                  <t hangText="Recipient:">IdP</t>
              </list>
          </t>
        <t>
          Eavesdroppers and Attackers can reside on any communication link between entities in <xref target="dataflow"/>.
        </t>

        <t>
          The Federation Substrate consists of all of the AAA entities.
          In some cases the AAA Proxies entities may not exist as the AAA Client can talk directly to the AAA Server.
          Specifications such as the Trust Router Protocol and RADIUS dynamic discovery <xref target="I-D.ietf-radext-dynamic-discovery"/> can be used to shorten the path between the AAA client and the AAA server (and thus stop these AAA Proxies from being Observers); however even in these circumstances there may be AAA Proxies in the path.
        </t>

        <t>
          In <xref target="dataflow"/> the IdP has been divided into multiple logical pieces, in actual implementations these pieces will frequently be tightly coupled.
          The links between these pieces provide the greatest opportunity for attackers and eavesdroppers to acquire information, however, as they are all under the control of a single entity they are also the easiest to have tightly secured.
        </t>
          

        <!---
        <t>
          As described in detail earlier in this document, when a user wishes to access a Relying Party, a secure tunnel is set up between their client application and their Identity Provider (via the Relying Party and the federation substrate) through which credentials are exchanged.
          An indication of success or failure, alongside a set of AAA attributes about a principal is then passed from the Identity Provider to the Relying Party (usually in the form of a SAML assertion).
        </t>
        -->
      </section>

        
        <section title="Privacy Aspects of ABFAB Communication Flows">
            
            <t>
              In the ABFAB architecture, there are a few different types of data and identifiers in use. The best way to understand them, and the potential privacy impacts of them, is to look at each phase of communication in ABFAB.
            </t>
            
            <section title="Client to RP">
                <t>
                  The flow of data between the client and the RP is divided into two parts.
                  The first part consists of all of the data exchanged as part of the ABFAB authentication process.
                  The second part consists of all of the data exchanged after the authentication process has been finished.
                </t>
                
                <t>
                  During the initial communications phase, the client sends an NAI (see <xref target="I-D.ietf-radext-nai"/>) to the RP.
                  Many EAP methods (but not all) allow for the client to disclose an NAI to RP the in a form that includes only a realm component during this communications phase.
                  This is the minimum amount of identity information necessary for ABFAB to work - it indicates an IdP that the principal has a relationship with.
                  EAP methods that do not allow this will necessarily also reveal an identifier for the principal in the IdP realm (e.g. a username).
                </t>

                <t>
                  The data shared during the initial communication phase may be protected by a channel protocol such as TLS.
                  This will prevent the leak of information to passive eavesdroppers, however an active attacker may still be able to setup as a man-in-the-middle.
                  The client may not be able to validate the certificates (if any) provided by the service, deferring the check of the identity of the RP until the completion of the ABFAB authentication protocol (i.e., using EAP channel binding).
                </t>

                <t>
                  The data exchanged after the authentication process can have privacy and authentication using the GSS-API services.
                  If the overall application protocol allows for the process of re-authentication, then the same privacy implications as discussed in previous paragraphs apply.
                </t>
            </section>
            
            <section title="Client to IdP (via Federation Substrate)">
                <t>
                  This phase sees a secure TLS tunnel initiated between the Client and the IdP via the RP and federation substrate.
                  The process is initiated by the RP using the realm information given to it by the client.
                  Once set up, the tunnel is used to send credentials to IdP to authenticate.
                </t>
                <t>
                    Various operational information is transported between RP and IdP, over the AAA infrastructure, for example using RADIUS headers.
                    As no end-to-end security is provided by AAA, all AAA entities on the path between the RP and IdP have the ability to eavesdrop on this information unless additional security measures are taken (such as the use of TLS for RADIUS <xref target="I-D.ietf-radext-dtls"/>).
                    Some of this information may form identifiers or explicit identity information:
                    <list style="symbols">
                        <t>
                            The Relying Party knows the IP address of the Client.
                            It is possible that the Relying Party could choose to expose this IP address by including it in a RADIUS header such as Calling Station ID.
                            This is a privacy consideration to take into account of the application protocol.
                        </t>
                        <t>
                            The EAP MSK is transported between the IdP and the RP over the AAA infrastructure, for example through RADIUS headers.
                            This is a particularly important privacy consideration, as any AAA Proxy that has access to the EAP MSK is able to decrypt and eavesdrop on any traffic encrypted using that EAP MSK (i.e. all communications between the Client and IdP).
                        </t>
                        <t>
                            Related to the above, the AAA server has access to the material necessary to derive the session key, thus the AAA server can observe any traffic encrypted between the Client and RP.
                            This "feature" was" chosen as a simplification and to make performance faster; if it was decided that this trade-off was not desirable for privacy and security reasons,  then extensions to ABFAB that make use of techniques such as Diffie-Helman key exchange would mitigate against this.
                        </t>

                    </list>
                </t>
                <t>
                    The choice of EAP method used has other potential privacy implications.
                    For example, if the EAP method in use does not support trust anchors to enable mutual authentication, then there are no guarantees that the IdP is who it claims to be, and thus the full NAI including a username and a realm might be sent to any entity masquerading as a particular IdP.
                </t>
                <t>
                    Note that ABFAB has not specified any AAA accounting requirements.
                    Implementations that use the accounting portion of AAA should consider privacy appropriately when designing this aspect.
                </t>
            </section>
            
            <section title="IdP to RP (via Federation Substrate)">
                <t>
                    In this phase, the IdP communicates with the RP informing it as to the success or failure of authentication of the user, and optionally, the sending of identity information about the principal.
                </t>
                <t>
                    As in the previous flow (Client to IdP), various operation information is transported between IdP and RP over the AAA infrastructure, and the same privacy considerations apply.
                    However, in this flow, explicit identity information about the authenticated principal can be sent from the IdP to the RP.
                    This information can be sent through RADIUS headers, or using SAML <xref target="I-D.ietf-abfab-aaa-saml"/>.
                    This can include protocol specific identifiers, such as SAML NameIDs, as well as arbitrary attribute information about the principal.
                    What information will be released is controlled by policy on the Identity Provider.
                    As before, when sending this through RADIUS headers, all AAA entities on the path between the RP and IdP have the ability to eavesdrop unless additional security measures are taken (such as the use of TLS for RADIUS <xref target="I-D.ietf-radext-dtls"/>).
                    When sending this using SAML, as specified in <xref target="I-D.ietf-abfab-aaa-saml"/>, confidentiality of the information should however be guaranteed as <xref target="I-D.ietf-abfab-aaa-saml"/> requires the use of TLS for RADIUS.
                </t>
            </section>
            
        </section>

        <section title="Relationship between User and Entities">
            <t>
                <list style="symbols">
                    <t>
                        Between User and IdP - the IdP is an entity the user will have a direct relationship with, created when the organization that operates the entity provisioned and exchanged the user's credentials.
                        Privacy and data protection guarantees may form a part of this relationship.
                    </t>
                    <t>
                        Between User and RP - the RP is an entity the user may or may not have a direct relationship with, depending on the service in question.
                        Some services may only be offered to those users where such a direct relationship exists (for particularly sensitive services, for example), while some may not require this and would instead be satisfied with basic federation trust guarantees between themselves and the IdP).
                        This may well include the option that the user stays anonymous with respect to the RP (though obviously never to the IdP).
                        If attempting to preserve privacy through the mitigation of data minimization, then the only attribute information about individuals exposed to the RP should be that which is strictly necessary for the operation of the service.
                    </t>
                    <t>
                        Between User and Federation substrate - the user is highly likely to have no knowledge of, or relationship with, any entities involved with the federation substrate (not that the IdP and/or RP may, however).
                        Knowledge of attribute information about individuals for these entities is not necessary, and thus such information should be protected in such a way as to prevent access to this information from being possible.
                    </t>
                </list>
            </t>
        </section>
        
        <section title="Accounting Information">
          <t>
            Alongside the core authentication and authorization that occurs in AAA communications, accounting information about resource consumption may be delivered as part of the accounting exchange during the lifetime of the granted application session.
          </t>
        </section>

        <section title="Collection and retention of data and identifiers">
          <t>
            In cases where Relying Parties are not required to identify a particular individual when an individual wishes to make use of their service, the ABFAB architecture enables anonymous or pseudonymous access. Thus data and identifiers other than pseudonyms and unlinkable attribute information need not be stored and retained.
          </t>
          <t>
            However, in cases where Relying Parties require the ability to identify a particular individual (e.g. so they can link this identity information to a particular account in their service, or where identity information is required for audit purposes), the service will need to collect and store such information, and to retain it for as long as they require. Deprovisioning of such accounts and information is out of scope for ABFAB, but obviously for privacy protection any identifiers collected should be deleted when they are no longer needed.
          </t>
        </section>

        <section title="User Participation">
            <t>
                In the ABFAB architecture, by its very nature users are active participants in the sharing of their identifiers as they initiate the communications exchange every time they wish to access a server.
                They are, however, not involved in control of the set of information related to them that transmitted from the IdP to RP for authorization purposes; rather, this is under the control of policy on the IdP.
                Due to the nature of the AAA communication flows, with the current ABFAB architecture there is no place for a process of gaining user consent for the information to be released from IdP to RP.
            </t>
        </section>

        <!--
      <section title="Data Disclosure">
          
        <t>
          In the ABFAB architecture, there are a few different types of data and identifiers in use.
        </t>
        <section title="NAI">
          <t>
            In order for the Relying Party to be able to route messages to enable an EAP transaction to occur between client application and the correct identity Provider, it is necessary for the client application to provide enough information to the Relying Party to enable the identification of the correct Identity Provider. This takes the form of an Network Access Identifier (NAI) (as specified in
            <xref target="I-D.ietf-radext-nai"/>). Note that an NAI can have inner and outer forms in a AAA architecture.
            <list style="symbols">
              <t>
                The outer part of NAI is exposed to the Relying Party; this can simply contain realm information. Doing so (i.e. not including user identification details such as a username) minimises the data given to the Relying Part to that which is purely necessary to support the necessary routing decision.
              </t>
              <t>
                The inner part of NAI is sent through the secure tunnel as established by the EAP protocol; this form of the NAI will contain credentials for the user suitable for authenticating them successfully (e.g. a username and password). Since the entire purpose of the secure tunnel is to protect communications between client application (EAP client) and Identity Provider (EAP server), then it is considered secure from eavesdroppers or malicious intermediaries and no further privacy discussion is necessary.
              </t>
            </list>
          </t>
        </section>
        <section title="Identity Information">
          <t>
            As a part of the ABFAB process, after a successful authentication has occurred between client application and Identity Provider, an indication of this success is sent to the Relying Party. Alongside this message, information about the user may be returned through AAA attributes, usually in form of a SAML assertion. This information is arbitrary and may include either only attributes that prevent an individual from being identified by the Relying Party (thus enabling anonymous or pseudonymous access) or attributes that contain personally identifiable information.
          </t>
          <t>
            Depending on the method used, this information carried through AAA attributes may or may not be accessible to intermediaries involved in communications - e.g. in the case of RADIUS and unencrypted SAML, these headers are plain text and could be seen by any observer, whereas if using RADSEC or encrypted SAML, these headers are protected from observers. Obviously, where the protection of the privacy of an individual is required then this information needs to be protected by some appropriate means.
          </t>
        </section>
      </section>
      <section title="User Participation">
        <t>
          In the ABFAB architecture, by its very nature users are active participants in the sharing of their identifiers as they initiate the communications exchange every time they wish to access a server. They are, however, not involved in control of the set of information related to them that transmitted from Identity Provider to Relying Party for authorisation purposes.
        </t>
      </section>
-->
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
<!--



      <section title="Data Disclosure">
          
        <t>
          In the ABFAB architecture, there are a few different types of data and identifiers in use.
        </t>
        <section title="NAI">
          <t>
            In order for the Relying Party to be able to route messages to enable an EAP transaction to occur between client application and the correct identity Provider, it is necessary for the client application to provide enough information to the Relying Party to enable the identification of the correct Identity Provider. This takes the form of an Network Access Identifier (NAI) (as specified in
            <xref target="I-D.ietf-radext-nai"/>). Note that an NAI can have inner and outer forms in a AAA architecture.
            <list style="symbols">
              <t>
                The outer part of NAI is exposed to the Relying Party; this can simply contain realm information. Doing so (i.e. not including user identification details such as a username) minimizes the data given to the Relying Part to that which is purely necessary to support the necessary routing decision.
              </t>
              <t>
                The inner part of NAI is sent through the secure tunnel as established by the EAP protocol; this form of the NAI will contain credentials for the user suitable for authenticating them successfully (e.g. a username and password). Since the entire purpose of the secure tunnel is to protect communications between client application (EAP client) and Identity Provider (EAP server), then it is considered secure from eavesdroppers or malicious intermediaries and no further privacy discussion is necessary.
              </t>
            </list>
          </t>
        </section>
        
        <section title="Identity Information">
          <t>
            As a part of the ABFAB process, after a successful authentication has occurred between client application and Identity Provider, an indication of this success is sent to the Relying Party. Alongside this message, information about the user may be returned through AAA attributes, usually in form of a SAML assertion. This information is arbitrary and may include either only attributes that prevent an individual from being identified by the Relying Party (thus enabling anonymous or pseudonymous access) or attributes that contain personally identifiable information.
          </t>
          <t>
            Depending on the method used, this information carried through AAA attributes may or may not be accessible to intermediaries involved in communications - e.g. in the case of RADIUS and unencrypted SAML, these headers are plain text and could be seen by any observer, whereas if using RADSEC or encrypted SAML, these headers are protected from observers. Obviously, where the protection of the privacy of an individual is required then this information needs to be protected by some appropriate means.
          </t>
        </section>
        <section title="Accounting Information">
          <t>
            Alongside the core authentication and authorization that occurs in AAA communications, accounting information about resource consumption may be delivered as part of the accounting exchange during the lifetime of the granted application session.
          </t>
        </section>
        <section title="Collection and retention of data and identifiers">
          <t>
            In cases where Relying Parties do not require to identify a particular individual when an individual wishes to make use of their service, the ABFAB architecture enable anonymous or pseudonymous access. Thus data and identifiers other than pseudonyms and unlinkable attribute information need not be stored and retained.
          </t>
          <t>
            However, in cases where Relying Parties require the ability to identify a particular individual (e.g. so they can link this identity information to a particular account in their service, or where identity information is required for audit purposes), the service will need to collect and store such information, and to retain it for as long as they require. Deprovisioning of such accounts and information is out of scope for ABFAB, but obviously for privacy protection any identifiers collected should be deleted when they are no longer needed.
          </t>
        </section>
      </section>
      -->

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

<!--  JLS - No longer doing this section
    <section title="Deployment Considerations">
      <section title="EAP Channel Binding">
        <t>Discuss the implications of needing EAP channel
        binding.</t>

      </section>
      <section title="AAA Proxy Behavior">
        <t>Discuss deployment implications of our proxy requirements.</t>
      </section>
    </section>
-->

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="sec-cons" title="Security Considerations">

      <t>This document describes the architecture for Application Bridging for Federated Access Beyond Web (ABFAB) and security is therefore the main focus. This section highlights the main communication channels and their security properties: 
      
      <list style="hanging"> 
        <t hangText="Client-to-RP Channel:">
          <vspace blankLines="1"/>
          The channel binding material is provided by any certificates and the final message (i.e., a cryptographic token for the channel).
          Authentication may be provided by the RP to the client but a deployment without authentication at the TLS layer is possible as well.
          In addition, there is a channel between the GSS requestor and the GSS  acceptor, but the keying material is provided by a "third party" to both entities.
          The client can derive keying material locally, but the RP gets the material from the IdP.

          In the absence of a transport that provides encryption and/or integrity, the channel between the client and the RP has no ability to have any cryptographic protection until the EAP authentication has been completed and the MSK is transferred from the IdP to the RP.
        </t> 

        <t hangText="RP-to-IdP Channel:">
          <vspace blankLines="1"/>
          The security of this communication channel is mainly provided by the functionality offered via RADIUS and Diameter.
          At the time of writing there are no end-to-end security mechanisms standardized and thereby the architecture has to rely on hop-by-hop security with trusted AAA entities or, as an alternative but possible deployment variant, direct communication between the AAA client to the AAA server.
          Note that the authorization result the IdP provides to the RP in the form of a SAML assertion may; however, be protected such that the SAML related components are secured end-to-end.
          <vspace blankLines="1"/>
          The MSK is transported from the IdP to the RP over this channel.  As no end-to-end security is provided by AAA, all AAA entities on the path between the RP and IdP have the ability to eavesdrop if no additional security measures are taken.  One such measure is to use a transport between the client and the IdP that provides confidentiality.
        </t>

        <t hangText="Client-to-IdP Channel:"><vspace blankLines="1"/>This communication interaction is accomplished with the help of EAP and EAP methods. The offered security protection will depend on the EAP method that is chosen but a minimum requirement is to offer mutual authentication, and key derivation. The IdP is responsible during this process to determine that the RP that is communication to the client over the RP-to-IdP channel is the same one talking to the IdP. This is accomplished via the EAP channel binding.</t>
        
      </list> 
      </t> 

      <t>Partial list of issues to be addressed in this section:  Privacy, SAML, Trust Anchors, EAP Algorithm Selection, Diameter/RADIUS/AAA Issues, Naming of Entities, Protection of passwords, Channel Binding, End-point-connections (TLS), Proxy problems</t>

      <t>When a pseudonym is generated as a unique long term identifier for a client by an IdP, care MUST be taken in the algorithm that it cannot easily be reverse engineered by the service provider.  If it can be reversed then the service provider can consult an oracle to determine if a given unique long term identifier is associated with a different known identifier.</t>

      
    </section>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="iana" title="IANA Considerations">
      <t>This document does not require actions by IANA.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Acknowledgments">
      <t>We would like to thank Mayutan Arumaithurai, Klaas Wierenga and Rhys Smith for their feedback. Additionally, we would like to
      thank Eve Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, Paul Leach, and Luke Howard for their feedback on the
      federation terminology question.</t>
      <t>Furthermore, we would like to thank Klaas Wierenga for his review of the pre-00 draft version.</t>
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->
  </middle>

  <!-- ////////////////////////////////////////////////////////////////////////////////// -->

  <back>
    <references title="Normative References">
      &RFC2743;
      &RFC2865; &RFC3588;
      &RFC3748;  &RFC3579; &RFC4072;
      &I-D.ietf-abfab-gss-eap;
      &I-D.ietf-abfab-aaa-saml;
      &I-D.ietf-radext-nai;
      &RFC6677;
    </references>

    <references title="Informative References">
      &RFC2903;
      &I-D.nir-tls-eap;
      &I-D.ietf-oauth-v2;
      &I-D.iab-privacy-considerations;
      &I-D.perez-radext-radius-fragmentation;
      &RFC4017;
      &RFC5106;
      &RFC1964;
      &RFC2203;
      &RFC3645;
      &RFC2138;
      &RFC4462;
      &RFC4422;
      &RFC5056;
      &RFC5080;
      &RFC5705;
      &RFC5801; 
      &RFC5849;
      &RFC6614;
      &SAML20;
      &RFC2904;
      &I-D.ietf-emu-crypto-bind;
      &I-D.ietf-emu-eap-tunnel-method;
      &I-D.ietf-radext-dtls;
      &I-D.ietf-radext-dynamic-discovery;
      <reference anchor="WS-TRUST" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">
        <front>
          <title>WS-Trust 1.4</title>
          <author initials="K" surname="Lawrence"/>
          <author initials="C" surname="Kaler"/>
          <author initials="A" surname="Nadalin"/>
          <author initials="M" surname="Goodner"/>
          <author initials="M" surname="Gudgin"/>
          <author initials="A" surname="Barbir"/>
          <author initials="H" surname="Granqvist"/>
          <date month="February" day='2' year='2009'/>
        </front>
        <seriesInfo name="OASIS Standard" value="ws-trust-200902"/>
        <format type="HTML" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html"/>
      </reference>
      <reference anchor="NIST-SP.800-63">
        <front>
          <title>Electronic Authentication Guideline</title>
          <author initials="W" surname="Burr"/>
          <author initials="D" surname="Dodson"/>
          <author initials="W" surname="Polk"/>
          <date month="April" year="2006"/>
        </front>
        <seriesInfo name="NIST Special Publication" value="800-63"/>
        <format type="PDF" target="http://csrc.nist.gov/publications/nistpubs/800-63/SP800-63V1_0_2.pdf"/>
      </reference>
    </references>
  </back>
</rfc>
