<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY routing SYSTEM "ietf-routing.yangx">
<!ENTITY ipv4-unicast SYSTEM "ietf-ipv4-unicast-routing.yangx">
<!ENTITY ipv6-unicast SYSTEM "ietf-ipv6-unicast-routing.yangx">
<!ENTITY rip SYSTEM "example-rip.yang.aw">
<!ENTITY get-reply SYSTEM "sample-get-reply.xml.aw">
<!ENTITY routing-tree SYSTEM "routing-tree.txt.aw">
<!ENTITY routing-coll-tree SYSTEM "routing-coll-tree.txt.aw">
<!ENTITY static-routes-tree SYSTEM "static-routes-tree.txt.aw">
<!ENTITY diagram SYSTEM "diagram.txt.aw">
<!ENTITY example-net SYSTEM "example-net.txt.aw">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<rfc ipr="trust200902" category="std" docName="draft-ietf-netmod-routing-cfg-06">

<front>
  <title abbrev="YANG Routing Management">A YANG Data Model for
  Routing Management</title>

  <author initials="L." surname="Lhotka" fullname="Ladislav Lhotka">
    <organization>CZ.NIC</organization>
    <address>
      <email>lhotka@nic.cz</email>
    </address>
  </author>
  <date day="15" month="November" year="2012"/>
  <area>Operations and Management</area>
   <workgroup>NETMOD</workgroup>
  <abstract>
    <t>This document contains a specification of three YANG modules.
    Together they form the core routing data model which serves as a
    framework for configuring and managing a routing subsystem. It
    is expected that these modules will be augmented by additional
    YANG modules defining data models for individual routing protocols
    and other related functions. The core routing data model provides
    common building blocks for such extensions - router instances,
    routes, routing tables, routing protocols and route filters.</t>
  </abstract>
</front>
<middle>

  <section anchor="sec.introduction" title="Introduction">

    <t>This document contains a specification of the following YANG
    modules:
    <list style="symbols">
      <t>Module "ietf-routing" provides generic components of a
      routing data model.</t>
      <t>Module "ietf-ipv4-unicast-routing" augments the
      "ietf-routing" module with additional data specific to IPv4
      unicast.</t>
      <t>Module "ietf-ipv6-unicast-routing" augments the
      "ietf-routing" module with additional data specific to IPv6
      unicast, including the router configuration variables required
      by <xref target="RFC4861"/>.</t>
    </list></t>

    <t>These modules together define the so-called core routing data
    model, which is proposed as a basis for the development of data
    models for configuration and management of more sophisticated
    routing systems. While these three modules can be directly used
    for simple IP devices with static routing, their main purpose is
    to provide essential building blocks for more complicated setups
    involving multiple routing protocols, multicast routing,
    additional address families, and advanced functions such as route
    filtering or policy routing. To this end, it is expected that the
    core routing data model will be augmented by numerous modules
    developed by other IETF working groups.</t>

  </section>

  <section anchor="sec.term-not" title="Terminology and Notation">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
    in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

    <t>The following terms are defined in <xref target="RFC6241"/>:
    <list style="symbols">
      <t>client</t>
      <t>message</t>
      <t>protocol operation</t>
      <t>server</t>
    </list></t>

    <t>The following terms are defined in <xref target="RFC6020"/>:
    <list style="symbols">
      <t>augment</t>
      <t>configuration data</t>
      <t>data model</t>
      <t>data node</t>
      <t>mandatory node</t>
      <t>module</t>
      <t>state data</t>
      <t>RPC operation</t>
    </list></t>

    <section anchor="sec.new-terms" title="Glossary of New Terms">
      <t><list style="hanging">
        <t hangText="active route:">a route which is actually used for
        sending packets. If there are multiple candidate routes with a
        matching destination prefix, then it is up to the routing
        algorithm to select the active route (or several active routes
        in the case of multi-path routing).</t>
        <t hangText="core routing data model:"> YANG data model
        resulting from the combination of "ietf-routing",
        "ietf-ipv4-unicast-routing" and
        "ietf-ipv6-unicast-routing" modules.</t>
        <t hangText="direct route:">a route to a directly connected
        network.</t>
      </list></t>
    </section>

    <section anchor="sec.tree-symbols" title="Tree Diagrams">
      <t>A simplified graphical representation of the complete data
      tree is presented in <xref target="app.data-tree"/>, and similar
      diagrams of its various subtrees appear in the main text. The
      meaning of the symbols in these diagrams is as follows:
      <list style="symbols">
        <t>Brackets "[" and "]" enclose list keys.</t>
        <t>Abbreviations before data node names: "rw" means
        configuration (read-write) and "ro" state data
        (read-only).</t>
        <t>Symbols after data node names: "?" means an optional node and "*"
        denotes a "leaf-list".</t>
        <t>Parentheses enclose choice and case nodes, and case nodes
        are also marked with a colon (":").</t>
        <t>Ellipsis ("...") stands for contents of subtrees that are
        not shown.</t>
      </list></t>
    </section>

    <section anchor="sec.prefixes" title="Prefixes in Data Node Names">
      <t>In this document, names of data nodes, RPC methods and other
      data model objects are used mostly without a prefix, as long as
      it is clear from the context in which YANG module each name is
      defined. Otherwise, names are prefixed using the standard prefix
      associated with the corresponding YANG module, as shown in <xref target="tab.prefixes"/>.</t>

      <texttable anchor="tab.prefixes" title="Prefixes and corresponding YANG modules">
        <ttcol>Prefix</ttcol>
        <ttcol>YANG module</ttcol>
        <ttcol>Reference</ttcol>
        <c>ianaaf</c><c>iana-afn-safi</c><c><xref target="IANA-IF-AF"/></c>
        <c>if</c><c>ietf-interfaces</c><c><xref target="YANG-IF"/></c>
        <c>ip</c><c>ietf-ip</c><c><xref target="YANG-IP"/></c>
        <c>rip</c><c>example-rip</c><c><xref target="app.rip"/></c>
        <c>rt</c><c>ietf-routing</c><c><xref target="sec.mod-rt"/></c>
        <c>v4ur</c><c>ietf-ipv4-unicast-routing</c>
        <c><xref target="sec.mod-v4ur"/></c>
        <c>v6ur</c><c>ietf-ipv6-unicast-routing</c>
        <c><xref target="sec.mod-v6ur"/></c>
        <c>yang</c><c>ietf-yang-types</c><c><xref target="RFC6021"/></c>
        <c>inet</c><c>ietf-inet-types</c><c><xref target="RFC6021"/></c>
      </texttable>
    </section>

  </section>

  <section anchor="sec.objectives" title="Objectives">
    <t>The initial design of the core routing data model was driven by
    the following objectives:
    <list style="symbols">
      <t>The data model should be suitable for the common address
      families, in particular IPv4 and IPv6, and for unicast and
      multicast routing, as well as Multiprotocol Label Switching
      (MPLS).</t>
      <t>Simple routing setups, such as static routing, should be
      configurable in a simple way, ideally without any need to develop
      additional YANG modules.</t>
      <t>On the other hand, the core routing framework must
      allow for complicated setups involving multiple routing tables
      and multiple routing protocols, as well as controlled
      redistributions of routing information.</t>
      <t>Device vendors will want to map the data models built on this
      generic framework to their proprietary data models and
      configuration interfaces. Therefore, the framework should be
      flexible enough to facilitate such a mapping and accommodate
      data models with different logic.</t>
    </list>
    </t>
  </section>

  <section anchor="sec.design" title="The Design of the Core Routing Data Model">

    <t>The core routing data model consists of three YANG modules. The
    first module, "ietf-routing", defines the generic components of a
    routing system. The other two modules, "ietf-ipv4-unicast-routing"
    and "ietf-ipv6-unicast-routing", augment the "ietf-routing" module
    with additional data nodes that are needed for IPv4 and IPv6
    unicast routing, respectively. An abridged view of the data
    hierarchy is given in <xref target="fig.yangdata"/>. See <xref target="app.data-tree"/> for the complete data tree.</t>

    <figure anchor="fig.yangdata" title="Data hierarchy of the core routing data model.">
      <artwork><![CDATA[
+--rw routing
   +--rw router [name]
   |  +--rw name
   |  +--rw type?
   |  +--rw enabled?
   |  +--rw router-id?
   |  +--rw description?
   |  +--rw main-routing-tables
   |  |  +--rw main-routing-table [address-family safi]
   |  |     +--rw address-family
   |  |     +--rw safi
   |  |     +--rw name?
   |  +--rw interfaces
   |  |  +--rw interface [name]
   |  |     +--rw name
   |  |     +--rw v6ur:ipv6-router-advertisements
   |  |           ...
   |  +--rw routing-protocols
   |     +--rw routing-protocol [name]
   |        +--rw name
   |        +--rw description?
   |        +--rw enabled?
   |        +--rw type
   |        +--rw connected-routing-tables
   |        |     ...
   |        +--rw static-routes
   |              ...
   +--rw routing-tables
   |  +--rw routing-table [name]
   |     +--rw name
   |     +--rw address-family
   |     +--rw safi
   |     +--rw description?
   |     +--ro routes
   |     |  +--ro route
   |     |        ...
   |     +--rw recipient-routing-tables
   |        +--rw recipient-routing-table [name]
   |              ...
   +--rw route-filters
      +--rw route-filter [name]
         +--rw name
         +--rw description?
         +--rw type
]]></artwork>

    </figure>

    <t>As can be seen from <xref target="fig.yangdata"/>, the core
    routing data model introduces several generic components of a
    routing framework: routers, routing tables containing lists of
    routes, routing protocols and route filters. The following
    subsections describe these components in more detail.</t>
    <t>By combining the components in various ways, and possibly
    augmenting them with appropriate contents defined in other
    modules, various routing setups can be realized.</t>

    <figure anchor="fig.exsetup" title="Example setup of a routing system">
      <artwork><![CDATA[
+--------+
| direct |    +---+    +--------------+    +---+    +--------------+
| routes |--->| F |--->|              |<---| F |<---|              |
+--------+    +---+    |    main      |    +---+    |  additional  |
                       |   routing    |             |   routing    |
+--------+    +---+    |    table     |    +---+    |    table     |
| static |--->| F |--->|              |--->| F |--->|              |
| routes |    +---+    +--------------+    +---+    +--------------+
+--------+                 ^      |                     ^      |
                           |      v                     |      v
                         +---+  +---+                 +---+  +---+
                         | F |  | F |                 | F |  | F |
                         +---+  +---+                 +---+  +---+
                           ^      |                     ^      |
                           |      v                     |      v
                         +----------+                 +----------+
                         | routing  |                 | routing  |
                         | protocol |                 | protocol |
                         +----------+                 +----------+
]]></artwork>

    </figure>

    <t>The example in <xref target="fig.exsetup"/> shows a typical
    (though certainly not the only possible) organization of a more
    complex routing subsystem for a single address family. Several of
    its features are worth mentioning:
    <list style="symbols">
      <t>Along with the main routing table, which must always be
      present, an additional routing table is configured.</t>
      <t>Each routing protocol instance, including the "static" and
      "direct" pseudo-protocols, is connected to one routing
      table with which it can exchange routes (in both directions,
      except for the "static" and "direct" pseudo-protocols).</t>
      <t>Routing tables may also be connected to each other and
      exchange routes in either direction (or both).</t>
      <t>Route exchanges along all connections may be controlled by
      means of route filters, denoted by "F" in <xref target="fig.exsetup"/>.</t>
    </list></t>

    <section anchor="sec.router" title="Router">

      <t>Each router instance in the core routing data model
      represents a logical router. The exact semantics of this term is left
      to implementations. For example, router instances may be
      completely isolated virtual routers or, alternatively, they may
      internally share certain information.</t>
      <t>An implementation MAY support multiple types of logical
      routers simultaneously. Instances of all router types are
      organized as entries of the same flat "router" list. In order to
      discriminate router instances belonging to different types, the
      "type" leaf is defined as a child of the "router" node.</t>
      <t>An implementation MAY pose restrictions on allowed router
      types and on the number of supported instances for each
      type. For example, a simple router implementation may support
      only one router instance of the default type "standard-router".</t>
      <t>Each network layer interface has to be assigned to one or
      more router instances in order to be able to participate in
      packet forwarding, routing protocols and other operations of
      those router instances. The assignment is accomplished by
      creating a corresponding entry in the list of router interfaces
      ("rt:interface"). The key of the list entry MUST be the name of
      a configured network layer interface, i.e., the value of a node
      /if:interfaces/if:interface/if:name defined in the
      "ietf-interfaces" module&#xA0;<xref target="YANG-IF"/>.</t>
      <t>In YANG terms, the list of router interfaces is modeled as
      the "list" node rather than "leaf-list" in order to allow for
      adding, via augmentation, other configuration or state data
      related to the corresponding router interface.</t>
      <t>Implementations MAY specify additional rules for the
      assignment of interfaces to logical routers. For example, it may
      be required that the sets of interfaces assigned to different
      logical routers be disjoint.</t>

      <section anchor="sec.4861" title="Configuration of IPv6 Router Interfaces">

        <t>The module "ietf-ipv6-unicast-routing" augments the
        definition of the data node "rt:interface"
        with definitions of the following configuration variables as
        required by <xref target="RFC4861"/>, sec. 6.2.1:
        <list style="symbols">
          <t>send-advertisements,</t>
          <t>max-rtr-adv-interval,</t>
          <t>min-rtr-adv-interval,</t>
          <t>managed-flag,</t>
          <t>other-config-flag,</t>
          <t>link-mtu,</t>
          <t>reachable-time,</t>
          <t>retrans-timer,</t>
          <t>cur-hop-limit,</t>
          <t>default-lifetime,</t>
          <t>prefix-list: a list of prefixes to be advertised.<vspace blankLines="1"/>The
          following parameters are associated with each prefix in the
          list:
          <list style="symbols">
            <t>valid-lifetime,</t>
            <t>on-link-flag,</t>
            <t>preferred-lifetime,</t>
            <t>autonomous-flag.</t>
          </list></t>
        </list>
        The definitions and descriptions of the above parameters can be
        found in the text of the module "ietf-ipv6-unicast-routing"
        (<xref target="sec.mod-v6ur"/>).</t>
        <t>NOTES:</t>
        <t><list style="numbers">
          <t>The "IsRouter" flag, which is also required by <xref target="RFC4861"/>, is implemented in the "ietf-ip" module
          <xref target="YANG-IP"/> (leaf "ip:forwarding").</t>
          <t>The original specification <xref target="RFC4861"/>
          allows the implementations to decide whether the
          "valid-lifetime" and "preferred-lifetime" parameters remain
          the same in consecutive advertisements, or decrement in real
          time. However, the latter behavior seems problematic because
          the values might be reset again to the (higher) configured
          values after a configuration is reloaded. Moreover, no
          implementation is known to use the decrementing
          behavior. The "ietf-ipv6-unicast-routing" module therefore
          assumes the former behavior with constant values.</t>
        </list></t>
        
      </section>
    </section> 

    <section anchor="sec.routes" title="Routes">
      <t>Routes are basic elements of information in a routing
      system. The core routing data model defines only the following
      minimal set of route attributes:
      <list style="symbols">
        <t>"destination-prefix": IP prefix specifying the set of
        destination addresses for which the route may be used. This
        attribute is mandatory.</t>
        <t>"next-hop": IP address of an adjacent router or host to
        which packets with destination addresses belonging to
        "destination-prefix" should be sent.</t>
        <t>"outgoing-interface": network interface that should be used
        for sending packets with destination addresses belonging to
        "destination-prefix".</t>
      </list>
      </t>
      <t>The above list of route attributes suffices for a simple
      static routing configuration. It is expected that future modules
      defining routing protocols will add other route attributes such
      as metrics or preferences.</t>
      <t>Routes and their attributes are used both in configuration
      data, for example as manually configured static routes, and in
      state data, for example as entries in routing tables.</t>
    </section>

    <section anchor="sec.rtables" title="Routing Tables">
      <t>Routing tables are lists of routes complemented with
      administrative data, namely:
      <list style="symbols">
        <t>"source-protocol": name of the routing protocol from which
        the route was originally obtained.</t>
        <t>"last-updated": the date and time when the route was last
        updated, or inserted into the routing table.</t>
      </list>
      Each routing table must contain only routes of the same address
      family. Address family information consists of two parameters -
      "address-family" and "safi" (Subsequent Address Family
      Identifier, SAFI). The permitted values for these two parameters
      are defined by IANA and represented using YANG enumeration types
      "ianaaf:address-family" and "ianaaf:subsequent-address-family"
      <xref target="IANA-IF-AF"/>.</t>
      <t>In the core routing data model, the "routing-table" node
      represents configuration while the descendant list of routes is
      defined as state data. The contents of route lists
      are controlled and manipulated by routing protocol operations
      which may result in route additions, removals and
      modifications. This also includes manipulations via the "static"
      and/or "direct" pseudo-protocols, see <xref target="sec.pseudoproto"/>.</t>
      <t>In order to activate an address family for use within a
      router instance, a client configures an entry of the list
      /routing/router/main-routing-tables/main-routing-table. This
      entry contains a reference to a routing table which henceforth
      serves as the so-called main routing table for the router
      instance and address family. <xref target="sec.proto"/> explains
      the role of main routing tables.</t>
      <t>Routing tables are global, which means that a configured
      routing table may be used by any or all router instances.</t>
      <t>Server implementations MAY pose restrictions regarding the
      number of supported routing tables, and rules for configuration
      and use of routing tables. For example:
      <list style="symbols">
        <t>A server may support no more than one routing table per
        address family.</t>
        <t>Router instances (of a certain type) may not be allowed to
        share routing tables, i.e., each routing table is used by no
        more than one router instance.</t>
      </list>
      For servers supporting multiple routing tables per address
      family, additional tables can be configured by creating new
      entries in the "routing-table" list, either as a part of
      factory-default configuration, or by a client's action.</t>
      <t>The way how a routing system uses information from routing
      tables for actual packet forwarding is outside the scope of this
      document.</t>
      <t>Every routing table can serve as a source of routes for other
      routing tables. To achieve this, one or more recipient routing
      tables may be specified in the configuration of the source
      routing table. Optionally, a route filter may be configured for
      any or all recipient routing tables. Such a route filter then
      selects and/or manipulates the routes that are passed between
      the source and recipient routing table.</t>
      <t>A routing table MUST NOT appear among its own recipient
      routing tables. A recipient routing table also MUST be of the
      same address family as its source routing table. Consequently,
      configuration of recipient routing tables makes sense only for
      servers supporting multiple routing tables per address
      family. Servers supporting only one routing table per address
      family MAY therefore decide to remove the container
      "recipient-routing-tables", together with its contents, from the
      data model.</t>
      <t/>
    </section>

    <section anchor="sec.proto" title="Routing Protocols">

      <t>The core routing data model provides an open-ended framework
      for defining multiple routing protocol instances within each
      router instance. Each routing protocol instance MUST be assigned
      a type, which is an identity derived from the
      "rt:routing-protocol" base identity. The core routing data model
      defines two identities for the direct and static
      pseudo-protocols (<xref target="sec.pseudoproto"/>).</t>
      <t>Each routing protocol instance is connected to exactly one
      routing table for each address family that the routing protocol
      instance supports. Routes learned from the network by a routing
      protocol are normally installed into the connected routing
      table(s) and, conversely, routes from the connected routing
      table(s) are normally injected into the routing
      protocol. However, routing protocol implementations MAY specify
      rules that restrict this exchange of routes in either direction
      (or both directions).</t>
      <t>A routing table is connected to a routing protocol instance
      by creating a corresponding entry in the
      "connected-routing-table" list. If such an entry is not
      configured for an address family, then the main routing table
      MUST be used as the connected routing table for this address
      family.</t>
      <t>In addition, two independent route filters (see <xref target="sec.filters"/>) may be configured for each connected
      routing table to apply client-defined policies controlling the
      exchange of routes in both directions between the routing
      protocol instance and the connected routing table:
      <list style="symbols">
        <t>import filter controls which routes are passed from the
        routing protocol instance to the connected routing table,</t>
        <t>export filter controls which routes the routing protocol
        instance receives from the connected routing table.</t>
      </list></t>
      <t>Note that the terms import and export are used from the
      viewpoint of a routing table.</t>

      <section anchor="sec.pseudoproto" title="Routing Pseudo-Protocols">

      <t>The core routing data model defines two special routing
      protocol types - "direct" and "static". Both are in fact
      pseudo-protocols, which means that they are confined to the
      local device and do not exchange any routing information with
      neighboring routers. Routes from both "direct" and "static"
      protocol instances are passed to the connected routing table
      (subject to route filters, if any), but an exchange in the
      opposite direction is not allowed.</t>
      <t>Every router instance MUST implement exactly one instance of
      the "direct" pseudo-protocol type. The name of this instance
      MUST also be "direct". It is the source of direct routes for all
      configured address families. Direct routes are normally supplied
      by the operating system kernel, based on the configuration of
      network interface addresses, see <xref target="sec.ietf-ip"/>. The "direct" pseudo-protocol MUST always
      be connected to the main routing tables of all supported address
      families. Unlike other routing protocol types, this connection
      cannot be changed in the configuration. Direct routes MAY be
      filtered before they appear in the main routing table.</t>
      <t>A pseudo-protocol of the type "static" allows for specifying
      routes manually. It MAY be configured in zero or multiple
      instances, although a typical configuration will have exactly
      one instance per logical router.</t>
      <t>Static routes are configured within the "static-routes"
      container, see <xref target="fig.static-routes"/>.</t>

    <figure anchor="fig.static-routes" title="Structure of &quot;static-routes&quot; subtree.">
      <artwork><![CDATA[
+--rw static-routes
   +--rw v4ur:ipv4
   |  +--rw v4ur:route [id]
   |     +--rw v4ur:id
   |     +--rw v4ur:description?
   |     +--rw v4ur:outgoing-interface?
   |     +--rw v4ur:dest-prefix
   |     +--rw v4ur:next-hop?
   +--rw v6ur:ipv6
      +--rw v6ur:route [id]
         +--rw v6ur:id
         +--rw v6ur:description?
         +--rw v6ur:outgoing-interface?
         +--rw v6ur:dest-prefix
         +--rw v6ur:next-hop?
]]></artwork>

    </figure>

      </section>

      <section anchor="sec.newproto" title="Defining New Routing Protocols">
        <t>It is expected that future YANG modules will create data
        models for additional routing protocol types. Such a new
        module has to define the protocol-specific configuration and
        state data, and it has to fit it into the core routing
        framework in the following way:
        <list style="symbols">
          <t>A new identity MUST be defined for the routing protocol
          and its base identity MUST be set to "rt:routing-protocol",
          or to an identity derived from "rt:routing-protocol".</t>
          <t>Additional route attributes MAY be defined, preferably in
          one place by means of defining a YANG grouping. The new
          attributes have to be inserted as state data by augmenting
          the definition of the node
                  <figure>
          <artwork><![CDATA[
          /rt:routing-tables/rt:routing-table/rt:route,
]]></artwork>
                  </figure>
          and possibly to other places in the configuration, state
          data and RPC input or output.</t>
          <t>Per-interface configuration parameters can be added by
          augmenting the data node "rt:interface" (the list of router
          interfaces).</t>
          <t>Other configuration parameters and state data can be
          defined by augmenting the "routing-protocol" data node.</t>
        </list></t>
        <t>By using the "when" statement, the augmented per-interface
        and other configuration parameters specific to the new
        protocol SHOULD be made conditional and valid only if the
        value of "rt:type" is equal to the new protocol's identity. It
        is also RECOMMENDED that the protocol-specific data be
        encapsulated in appropriately named containers.</t>
        <t>The above steps are implemented by the example YANG module
        for the RIP routing protocol in <xref target="app.rip"/>.</t>
      </section>
    </section>

    <section anchor="sec.filters" title="Route Filters">
      <t>The core routing data model provides a skeleton for defining
      route filters that can be used to restrict the set of routes
      being exchanged between a routing protocol instance and a
      connected routing table, or between a source and a recipient
      routing table. Route filters may also manipulate routes, i.e.,
      add, delete, or modify their attributes.</t>
      <t>Route filters are global, which means that a configured route
      filter may be used by any or all router instances.</t>
      <t>By itself, the route filtering framework defined in this
      document allows for applying only two extreme routing
      policies which are represented by the following pre-defined
      route filter types:
      <list style="symbols">
        <t>"deny-all-route-filter": all routes are blocked,</t>
        <t>"allow-all-route-filter": all routes are permitted.</t>
      </list>
      Note that the latter type is equivalent to no route filter.</t>
      <t>It is expected that more comprehensive route filtering
      frameworks will be developed separately.</t>
      <t>Each route filter is identified by a name which MUST be
      unique within the entire configuration. Its type MUST be
      specified by the "type" identity reference - this opens the
      space for multiple route filtering framework
      implementations. The default value for the route filter type is
      the identity "deny-all-route-filter".</t>
    </section>

    <section anchor="sec.rpcs" title="RPC Operations">

      <t>The "ietf-routing" module defines two RPC operations:
      <list style="symbols">
        <t>active-route: query the routing system for the active
        route(s) that are currently used for sending datagrams to a
        destination host whose address is passed as an input parameter.</t>
        <t>route-count: retrieve the total number of entries in a
        routing table.</t>
      </list></t>

    </section>

  </section>

  <section anchor="sec.interactions" title="Interactions with Other YANG Modules">
    <t>The semantics of the core routing data model also depend on
    several configuration parameters that are defined in other YANG
    modules.</t>

    <section anchor="sec.ietf-if" title="Module &quot;ietf-interfaces&quot;">
      <t>The following boolean switch is defined in the
      "ietf-interfaces" YANG module <xref target="YANG-IF"/>:
      <list style="hanging">
        <t hangText="/if:interfaces/if:interface/if:enabled">
          <vspace blankLines="1"/>
          If this switch is set to "false" for a given network layer
          interface, the device MUST behave exactly as if that
          interface was not assigned to any logical router at all.
        </t>
      </list>
      </t>
    </section>

    <section anchor="sec.ietf-ip" title="Module &quot;ietf-ip&quot;">
      <t>The following boolean switches are defined in the "ietf-ip"
      YANG module <xref target="YANG-IP"/>:
      <list style="hanging">
        <t hangText="/if:interfaces/if:interface/ip:ipv4/ip:enabled">
          <vspace blankLines="1"/>
          If this switch is set to "false" for a given interface, then
          all IPv4 routing functions related to that interface MUST be
          disabled.
        </t>
        <t hangText="/if:interfaces/if:interface/ip:ipv4/ip:forwarding">
          <vspace blankLines="1"/>
          If this switch is set to "false" for a given interface, then
          the forwarding of IPv4 datagrams to and from this interface
          MUST be disabled. However, the interface may participate in
          other routing functions, such as routing protocols.
        </t>
        <t hangText="/if:interfaces/if:interface/ip:ipv6/ip:enabled">
          <vspace blankLines="1"/>
          If this switch is set to "false" for a given interface, then
          all IPv6 routing functions related to that interface MUST be
          disabled.
        </t>
        <t hangText="/if:interfaces/if:interface/ip:ipv6/ip:forwarding">
          <vspace blankLines="1"/>
          If this switch is set to "false" for a given interface, then
          the forwarding of IPv6 datagrams to and from this interface
          MUST be disabled. However, the interface may participate in
          other routing functions, such as routing protocols.
        </t>
      </list>
      </t>
      <t>In addition, the "ietf-ip" module allows for configuring IPv4
      and IPv6 addresses and subnet masks on network layer
      interfaces. Configuration of these parameters on an enabled
      interface MUST result in an immediate creation of the
      corresponding direct route. The destination prefix of this route
      is set according to the configured IP address and subnet mask,
      and the interface is set as the outgoing interface for that
      route.</t>
    </section>

  </section> 

  <section anchor="sec.mod-rt" title="Routing YANG Module">

    <t>RFC Ed.: In this section, replace all occurrences of 'XXXX' with
    the actual RFC number and all occurrences of the revision date
    below with the date of RFC publication (and remove this note).</t>

    <figure>
      <artwork>
<![CDATA[<CODE BEGINS> file "ietf-routing@2012-11-15.yang"

module ietf-routing {

  namespace "urn:ietf:params:xml:ns:yang:ietf-routing";

  prefix "rt";

  import ietf-yang-types {
    prefix "yang";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-interfaces {
    prefix "if";
  }

  import iana-afn-safi {
    prefix "ianaaf";
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web: <http://tools.ietf.org/wg/netmod/>
     WG List: <mailto:netmod@ietf.org>

     WG Chair: David Kessens
     <mailto:david.kessens@nsn.com>

     WG Chair: Juergen Schoenwaelder
     <mailto:j.schoenwaelder@jacobs-university.de>

     Editor: Ladislav Lhotka
     <mailto:lhotka@nic.cz>
    ";

  description
    "This YANG module defines essential components that may be used
     for configuring a routing subsystem.

     Copyright (c) 2012 IETF Trust and the persons identified as
     authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see the
     RFC itself for full legal notices.
    ";

  revision 2012-11-15 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: A YANG Data Model for Routing Management";
  }

  /* Identities */

  identity router-type {
    description
      "Base identity from which router type identities are derived.

       It is primarily intended for discriminating among different
       types of logical routers or router virtualization.
      ";
  }

  identity standard-router {
    base router-type;
    description
      "This identity represents a standard router.";
  }

  identity routing-protocol {
    description
      "Base identity from which routing protocol identities are
       derived.";
  }

  identity direct {
    base routing-protocol;
    description
      "Routing pseudo-protocol which provides routes to directly
       connected networks.";
  }

  identity static {
    base routing-protocol;
    description
      "Static routing pseudo-protocol.";
  }

  identity route-filter {
    description
      "Base identity from which all route filters are derived.";
  }

  identity deny-all-route-filter {
    base route-filter;
    description
      "Route filter that blocks all routes.";
  }

  identity allow-all-route-filter {
    base route-filter;
    description
      "Route filter that permits all routes.";
  }

  /* Type Definitions */

  typedef router-ref {
    type leafref {
      path "/rt:routing/rt:router/rt:name";
    }
    description
      "This type is used for leafs that reference a router
       instance.";
  }

  typedef routing-table-ref {
    type leafref {
      path "/rt:routing/rt:routing-tables/rt:routing-table/rt:name";
    }
    description
      "This type is used for leafs that reference a routing table.";
  }

  typedef route-filter-ref {
    type leafref {
      path "/rt:routing/rt:route-filters/rt:route-filter/rt:name";
    }
    description
      "This type is used for leafs that reference a route filter.";
  }

  /* Groupings */

  grouping afn-safi {
    leaf address-family {
      type ianaaf:address-family;
      mandatory "true";
      description
        "Address family.";
    }
    leaf safi {
      type ianaaf:subsequent-address-family;
      mandatory "true";
      description
        "Subsequent address family.";
    }
    description
      "This grouping provides two parameters specifying address
       family and subsequent address family.";
  }

  grouping route-content {
    description
      "Generic parameters of routes.";
    leaf outgoing-interface {
      type if:interface-ref;
      description
        "Outgoing interface.";
    }
  }

  /* RPC Methods */

  rpc active-route {
    description
      "Return the active route (or multiple routes, in the case of
       multi-path routing) to a destination address.

       Parameters

       1. 'router-name',

       2. 'destination-address'.

       If the router instance with 'router-name' doesn't exist, then
       this operation SHALL fail with error-tag 'data-missing' and
       error-app-tag 'router-not-found'.

       If no active route for 'destination-address' exists, no output
       is returned - the server SHALL send an <rpc-reply> containing
       a single element <ok>.
      ";
    input {
      leaf router-name {
        type router-ref;
        mandatory "true";
        description
          "Name of the router instance whose forwarding information
           base is being queried.";
      }
      container destination-address {
        uses afn-safi;
        description
          "Network layer destination address.

           Address family specific modules MUST augment this
           container with a leaf named 'address'.
          ";
      }
    }
    output {
      list route {
        uses afn-safi;
        uses route-content;
        description
          "List of active routes.

           Route contents specific for each address family is
           expected be defined through augmenting.
          ";
      }
    }
  }

  rpc route-count {
    description
      "Return the current number of routes in a routing table.

       Parameters:

       1. 'routing-table-name'.

       If the routing table with the name specified in
       'routing-table-name' doesn't exist, then this operation SHALL
       fail with error-tag 'data-missing' and error-app-tag
       'routing-table-not-found'.
      ";
    input {
      leaf routing-table {
        type routing-table-ref;
        mandatory "true";
        description
          "Name of the routing table.";
      }
    }
    output {
      leaf number-of-routes {
        type uint32;
        mandatory "true";
        description
          "Number of routes in the routing table.";
      }
    }
  }

  /* Data Nodes */

  container routing {
    description
      "Routing parameters.";
    list router {
      key "name";
      description
        "Each list entry is a container for configuration and state
         data of a single (logical) router instance.
        ";
      leaf name {
        type string;
        description
          "An arbitrary name of the router instance.";
      }
      leaf type {
        type identityref {
          base router-type;
        }
        default "rt:standard-router";
        description
          "This leaf specifies the router type.

           It is primarily intended as a means for discriminating
           among different types of logical routers, route
           virtualization, master-slave arrangements etc., while
           keeping all such router instances in the same flat list.
          ";
      }
      leaf enabled {
        type boolean;
        default "true";
        description
          "Enable/disable the router instance.

           If this parameter is false, the parent router instance is
           disabled, despite any other configuration that might be
           present.
          ";
      }
      leaf router-id {
        type inet:ipv4-address;
        description
          "Global router ID in the form of an IPv4 address.

           An implementation MAY select a value if this parameter is
           not configured.

           Routing protocols MAY override this global parameter
           inside their configuration.
          ";
      }
      leaf description {
        type string;
        description
          "Textual description of the router.";
      }
      container main-routing-tables {
        description
          "Main routing tables used by the router instance.";
        list main-routing-table {
          must "address-family=/routing/routing-tables/"
             + "routing-table[name=current()/name]/"
             + "address-family and safi=/routing/routing-tables/"
             + "routing-table[name=current()/name]/safi" {
            error-message "Address family mismatch.";
            description
              "The entry's address family MUST match that of the
               referenced routing table.";
          }
          key "address-family safi";
          description
            "Each list entry specifies the main routing table for one
             address family.

             The main routing table is operationally connected to all
             routing protocols for which a connected routing table
             has not been explicitly configured.

             The 'direct' pseudo-protocol is always connected to the
             main routing table.

             Address families that don't have their entry in this
             list MUST NOT be used in the rest of the router instance
             configuration.
            ";
          uses afn-safi;
          leaf name {
            type routing-table-ref;
            description
              "Name of an existing routing table to be used as the
               main routing table for the given router instance and
               address family.";
          }
        }
      }
      container interfaces {
        description
          "Router interface parameters.";
        list interface {
          key "name";
          description
            "List of network layer interfaces assigned to the router
             instance.";
          leaf name {
            type if:interface-ref;
            description
              "A reference to the name of a configured network layer
               interface.";
          }
        }
      }
      container routing-protocols {
        description
          "Container for the list of configured routing protocol
           instances.";
        list routing-protocol {
          key "name";
          description
            "An instance of a routing protocol.";
          leaf name {
            type string;
            description
              "An arbitrary name of the routing protocol instance.";
          }
          leaf description {
            type string;
            description
              "Textual description of the routing protocol
               instance.";
          }
          leaf enabled {
            type boolean;
            default "true";
            description
              "Enable/disable the routing protocol instance.

               If this parameter is false, the parent routing
               protocol instance is disabled, despite any other
               configuration that might be present.
              ";
          }
          leaf type {
            type identityref {
              base routing-protocol;
            }
            mandatory "true";
            description
              "Type of the routing protocol - an identity derived
               from the 'routing-protocol' base identity.";
          }
          container connected-routing-tables {
            description
              "Container for connected routing tables.";
            list connected-routing-table {
              must "not(/routing/routing-tables/"
                 + "routing-table[name=current()/"
                 + "preceding-sibling::connected-routing-table/"
                 + "name]/address-family=/routing/routing-tables/"
                 + "routing-table[name=current()/name]/"
                 + "address-family and /routing/routing-tables/"
                 + "routing-table[name=current()/"
                 + "preceding-sibling::connected-routing-table/"
                 + "name]/safi=/routing/routing-tables/"
                 + "routing-table[name=current()/name]/safi)" {
                error-message "Duplicate address family for "
                            + "connected routing tables.";
                description
                  "For each AFN/SAFI pair there MUST NOT be more than
                   one connected routing table.";
              }
              key "name";
              description
                "List of routing tables to which the routing protocol
                 instance is connected (at most one routing table per
                 address family).

                 If no connected routing table is configured for an
                 address family, the routing protocol MUST be
                 operationally connected to the main routing table
                 for that address family.
                ";
              leaf name {
                must "../../../type != 'rt:direct' or "
                   + "../../../../../main-routing-tables/ "
                   + "main-routing-table/name=." {
                  error-message "The 'direct' protocol can be "
                              + "connected only to a main routing "
                              + "table.";
                  description
                    "For the 'direct' pseudo-protocol, the connected
                     routing table must always be a main routing
                     table.";
                }
                type routing-table-ref;
                description
                  "Name of an existing routing table.";
              }
              leaf import-filter {
                type route-filter-ref;
                description
                  "Reference to a route filter that is used for
                   filtering routes passed from this routing protocol
                   instance to the routing table specified by the
                   'name' sibling node.

                   If this leaf is not present, the behavior is
                   protocol-specific, but typically it means that all
                   routes are accepted.
                  ";
              }
              leaf export-filter {
                type route-filter-ref;
                description
                  "Reference to a route filter that is used for
                   filtering routes passed from the routing table
                   specified by the 'name' sibling node to this
                   routing protocol instance.

                   If this leaf is not present, the behavior is
                   protocol-specific - typically it means that all
                   routes are accepted.

                   The 'direct' and 'static' pseudo-protocols accept
                   no routes from any routing table.
                  ";
              }
            }
          }
          container static-routes {
            when "../type='rt:static'" {
              description
                "This container is only valid for the 'static'
                 routing protocol.";
            }
            description
              "Configuration of 'static' pseudo-protocol.

               Address family specific modules augment this node with
               their lists of routes.
              ";
          }
        }
      }
    }
    container routing-tables {
      description
        "Container for configured routing tables.";
      list routing-table {
        key "name";
        description
          "Each entry represents a routing table identified by the
           'name' key. All routes in a routing table MUST belong to
           the same address family.";
        leaf name {
          type string;
          description
            "An arbitrary name of the routing table.";
        }
        uses afn-safi;
        leaf description {
          type string;
          description
            "Textual description of the routing table.";
        }
        container routes {
          config "false";
          description
            "Current contents of the routing table (state data).";
          list route {
            description
              "A routing table entry. This data node MUST be
               augmented with information specific for routes of each
               address family.";
            uses route-content;
            leaf source-protocol {
              type string;
              mandatory "true";
              description
                'Routing protocol instance from which the route
                 originated.

                 It must be either "direct" or the name of a
                 configured routing protocol instance.
                ';
            }
            leaf last-updated {
              type yang:date-and-time;
              description
                "Time stamp of the last modification of the route. If
                 the route was never modified, it is the time when
                 the route was inserted into the routing table.";
            }
          }
        }
        container recipient-routing-tables {
          description
            "Container for recipient routing tables.";
          list recipient-routing-table {
            must "name != ../../name" {
              error-message "Source and recipient routing tables "
                          + "are identical.";
              description
                "A routing table MUST NOT appear among its recipient
                 routing tables.";
            }
            must "/routing/routing-tables/"
               + "routing-table[name=current()/name]/"
               + "address-family=../../address-family and /routing/"
               + "routing-tables/routing-table[name=current()/name]/"
               + "safi=../../safi" {
              error-message "Address family mismatch.";
              description
                "Address family of the recipient routing table MUST
                 match the source table.";
            }
            key "name";
            description
              "List of routing tables that receive routes from this
               routing table.";
            leaf name {
              type routing-table-ref;
              description
                "The name of the recipient routing table.";
            }
            leaf filter {
              type route-filter-ref;
              description
                "A route filter which is applied to the routes passed
                 to the recipient routing table.";
            }
          }
        }
      }
    }
    container route-filters {
      description
        "Container for configured route filters.";
      list route-filter {
        key "name";
        description
          "Route filters are used for filtering and/or manipulating
           routes that are passed between a routing protocol and a
           routing table or vice versa, or between two routing
           tables.

           It is expected that other modules augment this list with
           contents specific for a particular route filter type.
          ";
        leaf name {
          type string;
          description
            "An arbitrary name of the route filter.";
        }
        leaf description {
          type string;
          description
            "Textual description of the route filter.";
        }
        leaf type {
          type identityref {
            base route-filter;
          }
          mandatory "true";
          description
            "Type of the route-filter - an identity derived from the
             'route-filter' base identity.";
        }
      }
    }
  }
}

<CODE ENDS>]]></artwork>

    </figure>

  </section>

  <section anchor="sec.mod-v4ur" title="IPv4 Unicast Routing YANG Module">

    <t>RFC Ed.: In this section, replace all occurrences of 'XXXX' with
    the actual RFC number and all occurrences of the revision date
    below with the date of RFC publication (and remove this note).</t>

    <figure>
      <artwork>
<![CDATA[<CODE BEGINS> file "ietf-ipv4-unicast-routing@2012-11-15.yang"

module ietf-ipv4-unicast-routing {

  namespace "urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing";

  prefix "v4ur";

  import ietf-routing {
    prefix "rt";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web: <http://tools.ietf.org/wg/netmod/>
     WG List: <mailto:netmod@ietf.org>

     WG Chair: David Kessens
     <mailto:david.kessens@nsn.com>

     WG Chair: Juergen Schoenwaelder
     <mailto:j.schoenwaelder@jacobs-university.de>

     Editor: Ladislav Lhotka
     <mailto:lhotka@nic.cz>
    ";

  description
    "This YANG module augments the 'ietf-routing' module with basic
     configuration and state data for IPv4 unicast routing.

     Copyright (c) 2012 IETF Trust and the persons identified as
     authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see the
     RFC itself for full legal notices.
    ";

  revision 2012-11-15 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: A YANG Data Model for Routing Management";
  }

  /* Groupings */

  grouping route-content {
    description
      "Parameters of IPv4 unicast routes.";
    leaf dest-prefix {
      type inet:ipv4-prefix;
      description
        "IPv4 destination prefix.";
    }
    leaf next-hop {
      type inet:ipv4-address;
      description
        "IPv4 address of the next hop.";
    }
  }

  /* RPC Methods */

  augment "/rt:active-route/rt:input/rt:destination-address" {
    when "address-family='ipv4' and safi='nlri-unicast'" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "The 'address' leaf augments the 'rt:destination-address'
       parameter of the 'rt:active-route' operation.";
    leaf address {
      type inet:ipv4-address;
      description
        "IPv4 destination address.";
    }
  }

  augment "/rt:active-route/rt:output/rt:route" {
    when "address-family='ipv4' and safi='nlri-unicast'" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "Contents of the reply to 'rt:active-route' operation.";
    uses route-content;
  }

  /* Data nodes */

  augment "/rt:routing/rt:router/rt:routing-protocols/"
        + "rt:routing-protocol/rt:static-routes" {
    description
      "This augment defines the configuration of the 'static'
       pseudo-protocol with data specific for IPv4 unicast.";
    container ipv4 {
      description
        "Configuration of a 'static' pseudo-protocol instance
         consists of a list of routes.";
      list route {
        key "id";
        ordered-by "user";
        description
          "A user-ordered list of static routes.";
        leaf id {
          type uint32 {
            range "1..max";
          }
          description
            "Numeric identifier of the route.

             It is not required that the routes be sorted by their
             'id'.
            ";
        }
        leaf description {
          type string;
          description
            "Textual description of the route.";
        }
        uses rt:route-content;
        uses route-content {
          refine "dest-prefix" {
            mandatory "true";
          }
        }
      }
    }
  }

  augment "/rt:routing/rt:routing-tables/rt:routing-table/rt:routes/"
        + "rt:route" {
    when "../../rt:address-family = 'ipv4' and ../../rt:safi = "
       + "'nlri-unicast'" {
      description
        "This augment is valid only for IPv4 unicast.";
    }
    description
      "This augment defines the content of IPv4 unicast routes.";
    uses route-content;
  }
}

<CODE ENDS>]]></artwork>

    </figure>

  </section>

  <section anchor="sec.mod-v6ur" title="IPv6 Unicast Routing YANG Module">

    <t>RFC Ed.: In this section, replace all occurrences of 'XXXX' with
    the actual RFC number and all occurrences of the revision date
    below with the date of RFC publication (and remove this note).</t>

    <figure>
      <artwork>
<![CDATA[<CODE BEGINS> file "ietf-ipv6-unicast-routing@2012-11-15.yang"

module ietf-ipv6-unicast-routing {

  namespace "urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing";

  prefix "v6ur";

  import ietf-routing {
    prefix "rt";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-interfaces {
    prefix "if";
  }

  import ietf-ip {
    prefix "ip";
  }

  organization
    "IETF NETMOD (NETCONF Data Modeling Language) Working Group";

  contact
    "WG Web: <http://tools.ietf.org/wg/netmod/>
     WG List: <mailto:netmod@ietf.org>

     WG Chair: David Kessens
     <mailto:david.kessens@nsn.com>

     WG Chair: Juergen Schoenwaelder
     <mailto:j.schoenwaelder@jacobs-university.de>

     Editor: Ladislav Lhotka
     <mailto:lhotka@nic.cz>
    ";

  description
    "This YANG module augments the 'ietf-routing' module with basic
     configuration and state data for IPv6 unicast routing.

     Copyright (c) 2012 IETF Trust and the persons identified as
     authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see the
     RFC itself for full legal notices.
    ";

  revision 2012-11-15 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: A YANG Data Model for Routing Management";
  }

  /* Groupings */

  grouping route-content {
    description
      "Specific parameters of IPv6 unicast routes.";
    leaf dest-prefix {
      type inet:ipv6-prefix;
      description
        "IPv6 destination prefix.";
    }
    leaf next-hop {
      type inet:ipv6-address;
      description
        "IPv6 address of the next hop.";
    }
  }

  /* RPC Methods */

  augment "/rt:active-route/rt:input/rt:destination-address" {
    when "address-family='ipv6' and safi='nlri-unicast'" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "The 'address' leaf augments the 'rt:destination-address'
       parameter of the 'rt:active-route' operation.";
    leaf address {
      type inet:ipv6-address;
      description
        "IPv6 destination address.";
    }
  }

  augment "/rt:active-route/rt:output/rt:route" {
    when "address-family='ipv6' and safi='nlri-unicast'" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "Contents of the reply to 'rt:active-route' operation.";
    uses route-content;
  }

  /* Data nodes */

  augment "/rt:routing/rt:router/rt:interfaces/rt:interface" {
    when "/if:interfaces/if:interface[name=current()/name]/ip:ipv6/"
       + "ip:enabled='true'" {
      description
        "This augment is only valid for router interfaces with
         enabled IPv6.";
    }
    description
      "IPv6-specific parameters of router interfaces.";
    container ipv6-router-advertisements {
      description
        "Parameters of IPv6 Router Advertisements.";
      leaf send-advertisements {
        type boolean;
        default "false";
        description
          "A flag indicating whether or not the router sends periodic
           Router Advertisements and responds to Router
           Solicitations.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvSendAdvertisements.";
      }
      leaf max-rtr-adv-interval {
        type uint16 {
          range "4..1800";
        }
        units "seconds";
        default "600";
        description
          "The maximum time allowed between sending unsolicited
           multicast Router Advertisements from the interface.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           MaxRtrAdvInterval.";
      }
      leaf min-rtr-adv-interval {
        type uint16 {
          range "3..1350";
        }
        must ". <= 0.75 * ../max-rtr-adv-interval" {
          description
            "The value MUST NOT be greater than 75 % of
             'max-rtr-adv-interval'.";
        }
        units "seconds";
        description
          "The minimum time allowed between sending unsolicited
           multicast Router Advertisements from the interface.

           The default value to be used operationally if this leaf is
           not configured is determined as follows:

           - if max-rtr-adv-interval >= 9 seconds, the default value
             is 0.33 * max-rtr-adv-interval;

           - otherwise it is 0.75 * max-rtr-adv-interval.
          ";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           MinRtrAdvInterval.";
      }
      leaf managed-flag {
        type boolean;
        default "false";
        description
          "The boolean value to be placed in the 'Managed address
           configuration' flag field in the Router Advertisement.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvManagedFlag.";
      }
      leaf other-config-flag {
        type boolean;
        default "false";
        description
          "The boolean value to be placed in the 'Other
           configuration' flag field in the Router Advertisement.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvOtherConfigFlag.";
      }
      leaf link-mtu {
        type uint32;
        default "0";
        description
          "The value to be placed in MTU options sent by the router.
           A value of zero indicates that no MTU options are sent.";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvLinkMTU.";
      }
      leaf reachable-time {
        type uint32 {
          range "0..3600000";
        }
        units "milliseconds";
        default "0";
        description
          "The value to be placed in the Reachable Time field in the
           Router Advertisement messages sent by the router. The
           value zero means unspecified (by this router).";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvReachableTime.";
      }
      leaf retrans-timer {
        type uint32;
        units "milliseconds";
        default "0";
        description
          "The value to be placed in the Retrans Timer field in the
           Router Advertisement messages sent by the router. The
           value zero means unspecified (by this router).";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvRetransTimer.";
      }
      leaf cur-hop-limit {
        type uint8;
        default "64";
        description
          "The default value to be placed in the Cur Hop Limit field
           in the Router Advertisement messages sent by the router.
           The value should be set to the current diameter of the
           Internet. The value zero means unspecified (by this
           router).

           The default SHOULD be set to the value specified in IANA
           Assigned Numbers that was in effect at the time of
           implementation.
          ";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvCurHopLimit.

           IANA: IP Parameters,
           http://www.iana.org/assignments/ip-parameters
          ";
      }
      leaf default-lifetime {
        type uint16 {
          range "0..9000";
        }
        units "seconds";
        description
          "The value to be placed in the Router Lifetime field of
           Router Advertisements sent from the interface, in seconds.
           MUST be either zero or between max-rtr-adv-interval and
           9000 seconds. A value of zero indicates that the router is
           not to be used as a default router. These limits may be
           overridden by specific documents that describe how IPv6
           operates over different link layers.

           The default value is dynamic and SHOULD be set to 3 *
           max-rtr-adv-interval.
          ";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvDefaultLifeTime.";
      }
      container prefix-list {
        description
          "A list of prefixes to be placed in Prefix Information
           options in Router Advertisement messages sent from the
           interface.

           By default, all prefixes that the router advertises via
           routing protocols as being on-link for the interface from
           which the advertisement is sent. The link-local prefix
           SHOULD NOT be included in the list of advertised prefixes.
          ";
        reference
          "RFC 4861: Neighbor Discovery for IP version 6 (IPv6) -
           AdvPrefixList.";
        list prefix {
          key "prefix-spec";
          description
            "Advertised prefix entry.";
          leaf prefix-spec {
            type inet:ipv6-prefix;
            description
              "IPv6 address prefix.";
          }
          choice control-adv-prefixes {
            default "advertise";
            description
              "The prefix either may be explicitly removed from the
               set of advertised prefixes, or parameters with which
               it is advertised may be specified (default case).";
            leaf no-advertise {
              type empty;
              description
                "The prefix will not be advertised.

                 This can be used for removing the prefix from the
                 default set of advertised prefixes.
                ";
            }
            case advertise {
              leaf valid-lifetime {
                type uint32;
                units "seconds";
                default "2592000";
                description
                  "The value to be placed in the Valid Lifetime in
                   the Prefix Information option, in seconds. The
                   designated value of all 1's (0xffffffff)
                   represents infinity.
                  ";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvValidLifetime.";
              }
              leaf on-link-flag {
                type boolean;
                default "true";
                description
                  "The value to be placed in the on-link flag
                   ('L-bit') field in the Prefix Information
                   option.";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvOnLinkFlag.";
              }
              leaf preferred-lifetime {
                type uint32;
                units "seconds";
                must ". <= ../valid-lifetime" {
                  description
                    "This value MUST NOT be greater than
                     valid-lifetime.";
                }
                default "604800";
                description
                  "The value to be placed in the Preferred Lifetime
                   in the Prefix Information option, in seconds. The
                   designated value of all 1's (0xffffffff)
                   represents infinity.
                  ";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvPreferredLifetime.";
              }
              leaf autonomous-flag {
                type boolean;
                default "true";
                description
                  "The value to be placed in the Autonomous Flag
                   field in the Prefix Information option.";
                reference
                  "RFC 4861: Neighbor Discovery for IP version 6
                   (IPv6) - AdvAutonomousFlag.";
              }
            }
          }
        }
      }
    }
  }

  augment "/rt:routing/rt:router/rt:routing-protocols/"
        + "rt:routing-protocol/rt:static-routes" {
    description
      "This augment defines the configuration of the 'static'
       pseudo-protocol with data specific for IPv6 unicast.";
    container ipv6 {
      description
        "Configuration of a 'static' pseudo-protocol instance
         consists of a list of routes.";
      list route {
        key "id";
        ordered-by "user";
        description
          "A user-ordered list of static routes.";
        leaf id {
          type uint32 {
            range "1..max";
          }
          description
            "Numeric identifier of the route.

             It is not required that the routes be sorted by their
             'id'.
            ";
        }
        leaf description {
          type string;
          description
            "Textual description of the route.";
        }
        uses rt:route-content;
        uses route-content {
          refine "dest-prefix" {
            mandatory "true";
          }
        }
      }
    }
  }

  augment "/rt:routing/rt:routing-tables/rt:routing-table/rt:routes/"
        + "rt:route" {
    when "../../rt:address-family = 'ipv6' and ../../rt:safi = "
       + "'nlri-unicast'" {
      description
        "This augment is valid only for IPv6 unicast.";
    }
    description
      "This augment defines the content of IPv6 unicast routes.";
    uses route-content;
  }
}

<CODE ENDS>]]></artwork>

    </figure>

  </section>

  <section anchor="sec.iana" title="IANA Considerations">

    <t>RFC Ed.: In this section, replace all occurrences of 'XXXX' with
    the actual RFC number (and remove this note).</t>

    <t>This document registers the following namespace URIs in the
    IETF XML registry <xref target="RFC3688"/>:</t>
    <figure>
      <artwork>
----------------------------------------------------------
URI: urn:ietf:params:xml:ns:yang:ietf-routing

Registrant Contact: The IESG.

XML: N/A, the requested URI is an XML namespace.
----------------------------------------------------------

----------------------------------------------------------
URI: urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing

Registrant Contact: The IESG.

XML: N/A, the requested URI is an XML namespace.
----------------------------------------------------------

----------------------------------------------------------
URI: urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing

Registrant Contact: The IESG.

XML: N/A, the requested URI is an XML namespace.
----------------------------------------------------------
      </artwork>
    </figure>

    <t>This document registers the following YANG modules in the YANG
    Module Names registry <xref target="RFC6020"/>:</t>

    <figure>
      <artwork>
-------------------------------------------------------------------
name:         ietf-routing
namespace:    urn:ietf:params:xml:ns:yang:ietf-routing
prefix:       rt
reference:    RFC XXXX
-------------------------------------------------------------------

-------------------------------------------------------------------
name:         ietf-ipv4-unicast-routing
namespace:    urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing
prefix:       v4ur
reference:    RFC XXXX
-------------------------------------------------------------------

-------------------------------------------------------------------
name:         ietf-ipv6-unicast-routing
namespace:    urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing
prefix:       v6ur
reference:    RFC XXXX
-------------------------------------------------------------------
      </artwork>
    </figure>

  </section>

  <section anchor="sec-cons" title="Security Considerations">

    <t>Configuration and state data conforming to the core routing
    data model (defined in this document) are designed to be accessed
    via the NETCONF protocol <xref target="RFC6241"/>.  The lowest
    NETCONF layer is the secure transport layer and the
    mandatory-to-implement secure transport is SSH <xref target="RFC6242"/>.</t>
    <t>A number of data nodes defined in the YANG modules belonging to
    the core routing data model are writable/creatable/deletable
    (i.e., "config true" in YANG terms, which is the default).  These
    data nodes may be considered sensitive or vulnerable in some
    network environments.  Write operations to these data nodes, such
    as "edit-config", can have negative effects on the network if the
    protocol operations are not properly protected.</t>
    <t>The vulnerable "config true" subtrees and data nodes are the
    following:
    <list style="hanging">
      <t hangText="/routing/router/interfaces/interface">This
      list assigns a network layer interface to a router instance and
      may also specify interface parameters related to routing.</t>

      <t hangText="/routing/router/routing-protocols/routing-protocol">This
      list specifies the routing protocols configured on a device.</t>

      <t hangText="/routing/route-filters/route-filter">This
      list specifies the configured route filters which represent
      administrative policies for redistributing and modifying routing
      information.</t>

      <t hangText="/routing/routing-tables/routing-table">This
      list specifies the configured routing tables used by the device.</t>
    </list>
    
      Unauthorized access to any of these lists can adversely affect the
      routing subsystem of both the local device and the network. This
      may lead to network malfunctions, delivery of packets to
      inappropriate destinations and other problems.</t>

  </section>

  <section anchor="acknowledgments" title="Acknowledgments">
    <t>The author wishes to thank Martin&#xA0;Bjorklund, Joel&#xA0;Halpern,
    Wes&#xA0;Hardaker, Andrew&#xA0;McGregor, Thomas&#xA0;Morin, Tom&#xA0;Petch,
    Bruno&#xA0;Rijsman, Juergen&#xA0;Schoenwaelder, Phil&#xA0;Shafer, Dave&#xA0;Thaler and
    Yi&#xA0;Yang for their helpful comments and suggestions.</t>
  </section>

</middle>

<back>

  <references title="Normative References">

    <reference anchor="IANA-IF-AF">
      <front>
        <title>IANA Interface Type and Address Family YANG Modules</title>
        <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
          <organization/>
        </author>
        <date month="June" day="5" year="2012"/>
      </front>
      <seriesInfo name="Internet-Draft" value="draft-ietf-netmod-iana-if-type-04"/>
      <format type="HTML" target="http://tools.ietf.org/html/draft-ietf-netmod-iana-if-type-04"/>
    </reference>

    <reference anchor="RFC2119">
      <front>
        <title abbrev="RFC Key Words">Key words for use in RFCs to
        Indicate Requirement Levels</title>
        <author initials="S." surname="Bradner" fullname="S. Bradner">
          <organization/>
        </author>
        <date year="1997" month="March"/>
      </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
    </reference>

    <reference anchor="RFC3688">
      <front>
        <title>The IETF XML Registry</title>
        <author initials="M." surname="Mealling" fullname="M. Mealling">
        <organization/></author>
        <date year="2004" month="January"/>
      </front>
      <seriesInfo name="BCP" value="81"/>
      <seriesInfo name="RFC" value="3688"/>
      <format type="TXT" octets="17325" target="ftp://ftp.isi.edu/in-notes/rfc3688.txt"/>
    </reference>

    <reference anchor="RFC4861">
      <front>
        <title>Neighbor Discovery for IP version 6 (IPv6)</title>
        <author initials="T" surname="Narten" fullname="T. Narten">
          <organization>IBM</organization>
        </author>
        <author initials="E." surname="Nordmark" fullname="E. Nordmark">
          <organization>Sun Microsystems</organization>
        </author>
        <author initials="W." surname="Simpson" fullname="W. Simpson">
          <organization>Daydreamer</organization>
        </author>
        <author initials="H." surname="Soliman" fullname="H. Soliman">
          <organization>Elevate Technologies</organization>
        </author>
        <date month="September" year="2007"/>
      </front>
      <seriesInfo name="RFC" value="4861"/>
      <format type="HTML" target="http://tools.ietf.org/html/rfc4861"/>
    </reference>

    <reference anchor="RFC6020">
      <front>
        <title>YANG - A Data Modeling Language for Network
        Configuration Protocol (NETCONF)</title>
        <author role="editor" initials="M" surname="Bjorklund" fullname="M. Bjorklund">
          <organization>Tail-f Systems</organization>
        </author>
        <date month="September" year="2010"/>
      </front>
      <seriesInfo name="RFC" value="6020"/>
      <format type="HTML" target="http://tools.ietf.org/html/rfc6020"/>
    </reference>

    <reference anchor="RFC6021">
      <front>
        <title>Common YANG Data Types</title>
        <author role="editor" initials="J." surname="Schoenwaelder" fullname="J. Schoenwaelder">
          <organization/>
        </author>
        <date month="September" year="2010"/>
      </front>
      <seriesInfo name="RFC" value="6021"/>
      <format type="HTML" target="http://tools.ietf.org/html/rfc6021"/>
    </reference>

    <reference anchor="RFC6241">
      <front>
        <title>NETCONF Configuration Protocol</title>
        <author initials="R." surname="Enns" fullname="R. Enns">
          <organization/>
        </author>
        <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
          <organization/>
        </author>
        <author initials="J." surname="Schoenwaelder" fullname="J. Schoenwaelder">
          <organization/>
        </author>
        <author initials="A." surname="Bierman" fullname="A. Bierman">
          <organization/>
        </author>
        <date year="2011" month="June"/>
      </front>
      <seriesInfo name="RFC" value="6241"/>
      <format type="TXT" octets="209465" target="http://www.ietf.org/rfc/rfc6241.txt"/>
    </reference>

    <reference anchor="YANG-IF">
      <front>
        <title>A YANG Data Model for Interface Configuration</title>
        <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
          <organization/>
        </author>
        <date month="November" day="15" year="2012"/>
      </front>
      <seriesInfo name="Internet-Draft" value="draft-ietf-netmod-interfaces-cfg-08"/>
      <format type="HTML" target="http://tools.ietf.org/html/draft-ietf-netmod-interfaces-cfg-08"/>
    </reference>

    <reference anchor="YANG-IP">
      <front>
        <title>A YANG Data Model for IP Configuration</title>
        <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
          <organization/>
        </author>
        <date month="November" day="15" year="2012"/>
      </front>
      <seriesInfo name="Internet-Draft" value="draft-ietf-netmod-ip-cfg-07"/>
      <format type="HTML" target="http://tools.ietf.org/html/draft-ietf-netmod-ip-cfg-07"/>
    </reference>

  </references>

  <references title="Informative References">

    <reference anchor="RFC6087">
      <front>
        <title>Guidelines for Authors and Reviewers of YANG Data Model
        Documents</title>
        <author initials="A." surname="Bierman" fullname="Andy Bierman">
          <organization/>
        </author>
        <date month="January" year="2011"/>
      </front>
      <seriesInfo name="RFC" value="6087"/>
      <format type="HTML" target="http://tools.ietf.org/html/rfc6087"/>
    </reference>

    <reference anchor="RFC6242">
      <front>
        <title>Using the NETCONF Protocol over Secure Shell (SSH)</title>
        <author initials="M." surname="Wasserman" fullname="M. Wasserman">
          <organization/>
        </author>
        <date year="2011" month="June"/>
      </front>
      <seriesInfo name="RFC" value="6242"/>
      <format type="TXT" octets="22704" target="http://www.ietf.org/rfc/rfc6242.txt"/>
    </reference>

  </references>

  <section anchor="app.data-tree" title="The Complete Data Tree">

    <t>This appendix presents the complete data tree of the
    core routing data model. See <xref target="sec.tree-symbols"/> for
    an explanation of symbols. Data type of every leaf node is shown
    near the right end of the corresponding line.</t>

    <figure>
      <artwork><![CDATA[
+--rw routing
   +--rw router [name]
   |  +--rw name                   string
   |  +--rw type?                  identityref
   |  +--rw enabled?               boolean
   |  +--rw router-id?             inet:ipv4-address
   |  +--rw description?           string
   |  +--rw main-routing-tables
   |  |  +--rw main-routing-table [address-family safi]
   |  |     +--rw address-family    ianaaf:address-family
   |  |     +--rw safi              ianaaf:subsequent-address-family
   |  |     +--rw name?             routing-table-ref
   |  +--rw interfaces
   |  |  +--rw interface [name]
   |  |     +--rw name                               if:interface-ref
   |  |     +--rw v6ur:ipv6-router-advertisements
   |  |        +--rw v6ur:send-advertisements?    boolean
   |  |        +--rw v6ur:max-rtr-adv-interval?   uint16
   |  |        +--rw v6ur:min-rtr-adv-interval?   uint16
   |  |        +--rw v6ur:managed-flag?           boolean
   |  |        +--rw v6ur:other-config-flag?      boolean
   |  |        +--rw v6ur:link-mtu?               uint32
   |  |        +--rw v6ur:reachable-time?         uint32
   |  |        +--rw v6ur:retrans-timer?          uint32
   |  |        +--rw v6ur:cur-hop-limit?          uint8
   |  |        +--rw v6ur:default-lifetime?       uint16
   |  |        +--rw v6ur:prefix-list
   |  |           +--rw v6ur:prefix [prefix-spec]
   |  |              +--rw v6ur:prefix-spec           inet:ipv6-prefix
   |  |              +--rw (control-adv-prefixes)?
   |  |                 +--:(no-advertise)
   |  |                 |  +--rw v6ur:no-advertise?         empty
   |  |                 +--:(advertise)
   |  |                    +--rw v6ur:valid-lifetime?       uint32
   |  |                    +--rw v6ur:on-link-flag?         boolean
   |  |                    +--rw v6ur:preferred-lifetime?   uint32
   |  |                    +--rw v6ur:autonomous-flag?      boolean
   |  +--rw routing-protocols
   |     +--rw routing-protocol [name]
   |        +--rw name                        string
   |        +--rw description?                string
   |        +--rw enabled?                    boolean
   |        +--rw type                        identityref
   |        +--rw connected-routing-tables
   |        |  +--rw connected-routing-table [name]
   |        |     +--rw name             routing-table-ref
   |        |     +--rw import-filter?   route-filter-ref
   |        |     +--rw export-filter?   route-filter-ref
   |        +--rw static-routes
   |           +--rw v4ur:ipv4
   |           |  +--rw v4ur:route [id]
   |           |     +--rw v4ur:id                    uint32
   |           |     +--rw v4ur:description?          string
   |           |     +--rw v4ur:outgoing-interface?   if:interface-ref
   |           |     +--rw v4ur:dest-prefix           inet:ipv4-prefix
   |           |     +--rw v4ur:next-hop?             inet:ipv4-address
   |           +--rw v6ur:ipv6
   |              +--rw v6ur:route [id]
   |                 +--rw v6ur:id                    uint32
   |                 +--rw v6ur:description?          string
   |                 +--rw v6ur:outgoing-interface?   if:interface-ref
   |                 +--rw v6ur:dest-prefix           inet:ipv6-prefix
   |                 +--rw v6ur:next-hop?             inet:ipv6-address
   +--rw routing-tables
   |  +--rw routing-table [name]
   |     +--rw name                    string
   |     +--rw address-family          ianaaf:address-family
   |     +--rw safi                    ianaaf:subsequent-address-family
   |     +--rw description?            string
   |     +--ro routes
   |     |  +--ro route
   |     |     +--ro outgoing-interface?   if:interface-ref
   |     |     +--ro source-protocol       string
   |     |     +--ro last-updated?         yang:date-and-time
   |     |     +--ro v4ur:dest-prefix?     inet:ipv4-prefix
   |     |     +--ro v4ur:next-hop?        inet:ipv4-address
   |     |     +--ro v6ur:dest-prefix?     inet:ipv6-prefix
   |     |     +--ro v6ur:next-hop?        inet:ipv6-address
   |     +--rw recipient-routing-tables
   |        +--rw recipient-routing-table [name]
   |           +--rw name      routing-table-ref
   |           +--rw filter?   route-filter-ref
   +--rw route-filters
      +--rw route-filter [name]
         +--rw name           string
         +--rw description?   string
         +--rw type           identityref
]]></artwork>

    </figure>
    
  </section>

  <section anchor="app.rip" title="Example: Adding a New Routing Protocol">

    <t>This appendix demonstrates how the core routing data model can
    be extended to support a new routing protocol. The YANG module
    "example-rip" shown below is intended only as an illustration
    rather than a real definition of a data model for the RIP routing
    protocol. For the sake of brevity, we do not follow all the
    guidelines specified in <xref target="RFC6087"/>. See also <xref target="sec.newproto"/>.</t>

      <figure>
        <artwork><![CDATA[
module example-rip {

  namespace "http://example.com/rip";

  prefix "rip";

  import ietf-routing {
    prefix "rt";
  }

  identity rip {
    base rt:routing-protocol;
    description
      "Identity for the RIP routing protocol.";
  }

  typedef rip-metric {
    type uint8 {
      range "0..16";
    }
  }

  grouping route-content {
    description
      "This grouping defines RIP-specific route attributes.";
    leaf metric {
      type rip-metric;
    }
    leaf tag {
      type uint16;
      default "0";
      description
        "This leaf may be used to carry additional info, e.g. AS
         number.";
    }
  }

  augment "/rt:routing/rt:routing-tables/rt:routing-table/rt:routes/"
        + "rt:route" {
    description
      "RIP-specific route attributes.";
    uses route-content;
  }

  augment "/rt:active-route/rt:output/rt:route" {
    description
      "RIP-specific route attributes.";
    uses route-content;
  }

  augment "/rt:routing/rt:router/rt:interfaces/rt:interface" {
    when "../../rt:routing-protocols/rt:routing-protocol/rt:type = "
       + "'rip:rip'" {
      description
        'This augment is only valid for a routing protocol instance
         of type "rip".';
    }
    container rip {
      description
        "Per-interface RIP configuration.";
      leaf enabled {
        type boolean;
        default "true";
      }
      leaf metric {
        type rip-metric;
        default "1";
      }
    }
  }

  augment "/rt:routing/rt:router/rt:routing-protocols/"
        + "rt:routing-protocol" {
    when "rt:type = 'rip:rip'" {
      description
        'This augment is only valid for a routing protocol instance
         of type "rip".';
    }
    container rip {
      description
        "Global RIP configuration.";
      leaf update-interval {
        type uint8 {
          range "10..60";
        }
        units "seconds";
        default "30";
        description
          "Time interval between periodic updates.";
      }
    }
  }
}
]]></artwork>

      </figure>

  </section>

  <section anchor="app.get-reply" title="Example: NETCONF &lt;get&gt; Reply">

    <t>This section contains a sample reply to the NETCONF &lt;get&gt;
    message, which could be sent by a server supporting (i.e.,
    advertising them in the NETCONF &lt;hello&gt; message) the
    following YANG modules:
    <list style="symbols">
      <t>ietf-interfaces <xref target="YANG-IF"/>,</t>
      <t>ietf-ip <xref target="YANG-IP"/>,</t>
      <t>ietf-routing (<xref target="sec.mod-rt"/>),</t>
      <t>ietf-ipv4-unicast-routing (<xref target="sec.mod-v4ur"/>),</t>
      <t>ietf-ipv6-unicast-routing (<xref target="sec.mod-v6ur"/>).</t>
    </list></t>

    <t>We assume a simple network setup as shown in <xref target="fig.exnet"/>: router "A" uses static default routes with
    the "ISP" router as the next hop. IPv6 router advertisements are
    configured only on the "eth1" interface and disabled on the
    upstream "eth0" interface.</t>

    <figure anchor="fig.exnet" title="Example network configuration">
      <artwork><![CDATA[
                +-----------------+
                |                 |
                |    Router ISP   |
                |                 |
                +--------+--------+
                         |2001:db8:0:1::2
                         |192.0.2.2
                         |
                         |
                         |2001:db8:0:1::1
                     eth0|192.0.2.1
                +--------+--------+
                |                 |
                |     Router A    |
                |                 |
                +--------+--------+
                     eth1|198.51.100.1
                         |2001:db8:0:2::1
                         |
]]></artwork>

    </figure>

    <t>A reply to the NETCONF &lt;get&gt; message sent by router "A"
    would then be as follows:</t>

    <figure>
      <artwork><![CDATA[
<?xml version="1.0"?>
<rpc-reply
    message-id="101"
    xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
    xmlns:v4ur="urn:ietf:params:xml:ns:yang:ietf-ipv4-unicast-routing"
    xmlns:v6ur="urn:ietf:params:xml:ns:yang:ietf-ipv6-unicast-routing"
    xmlns:if="urn:ietf:params:xml:ns:yang:ietf-interfaces"
    xmlns:ip="urn:ietf:params:xml:ns:yang:ietf-ip"
    xmlns:rt="urn:ietf:params:xml:ns:yang:ietf-routing">
 <data>
  <if:interfaces>
   <if:interface>
    <if:name>eth0</if:name>
    <if:type>ethernetCsmacd</if:type>
    <if:location>05:00.0</if:location>
    <ip:ipv4>
     <ip:address>
      <ip:ip>192.0.2.1</ip:ip>
      <ip:prefix-length>24</ip:prefix-length>
     </ip:address>
    </ip:ipv4>
    <ip:ipv6>
     <ip:address>
      <ip:ip>2001:0db8:0:1::1</ip:ip>
      <ip:prefix-length>64</ip:prefix-length>
     </ip:address>
     <ip:autoconf>
      <ip:create-global-addresses>false</ip:create-global-addresses>
     </ip:autoconf>
    </ip:ipv6>
   </if:interface>
   <if:interface>
    <if:name>eth1</if:name>
    <if:type>ethernetCsmacd</if:type>
    <if:location>05:00.1</if:location>
    <ip:ipv4>
     <ip:address>
      <ip:ip>198.51.100.1</ip:ip>
      <ip:prefix-length>24</ip:prefix-length>
     </ip:address>
    </ip:ipv4>
    <ip:ipv6>
     <ip:address>
      <ip:ip>2001:0db8:0:2::1</ip:ip>
      <ip:prefix-length>64</ip:prefix-length>
     </ip:address>
     <ip:autoconf>
      <ip:create-global-addresses>false</ip:create-global-addresses>
     </ip:autoconf>
    </ip:ipv6>
   </if:interface>
  </if:interfaces>
  <rt:routing>
   <rt:router>
    <rt:name>rtr0</rt:name>
    <rt:router-id>192.0.2.1</rt:router-id>
    <rt:description>Router A</rt:description>
    <rt:main-routing-tables>
     <rt:main-routing-table>
      <rt:address-family>ipv4</rt:address-family>
      <rt:safi>nlri-unicast</rt:safi>
      <rt:name>ipv4-unicast</rt:name>
     </rt:main-routing-table>
     <rt:main-routing-table>
      <rt:address-family>ipv6</rt:address-family>
      <rt:safi>nlri-unicast</rt:safi>
      <rt:name>ipv6-unicast</rt:name>
     </rt:main-routing-table>
    </rt:main-routing-tables>
    <rt:interfaces>
     <rt:interface>
      <rt:name>eth0</rt:name>
     </rt:interface>
     <rt:interface>
      <rt:name>eth1</rt:name>
      <v6ur:ipv6-router-advertisements>
       <v6ur:send-advertisements>true</v6ur:send-advertisements>
       <v6ur:prefix-list>
        <v6ur:prefix>
         <v6ur:prefix-spec>2001:db8:0:2::/64</v6ur:prefix-spec>
        </v6ur:prefix>
       </v6ur:prefix-list>
      </v6ur:ipv6-router-advertisements>
     </rt:interface>
    </rt:interfaces>
    <rt:routing-protocols>
     <rt:routing-protocol>
      <rt:name>st0</rt:name>
      <rt:description>
       Static routing is used for the internal network.
      </rt:description>
      <rt:type>rt:static</rt:type>
      <rt:static-routes>
       <v4ur:ipv4>
        <v4ur:route>
         <v4ur:id>1</v4ur:id>
         <v4ur:dest-prefix>0.0.0.0/0</v4ur:dest-prefix>
         <v4ur:next-hop>192.0.2.2</v4ur:next-hop>
        </v4ur:route>
       </v4ur:ipv4>
       <v6ur:ipv6>
        <v6ur:route>
         <v6ur:id>1</v6ur:id>
         <v6ur:dest-prefix>::/0</v6ur:dest-prefix>
         <v6ur:next-hop>2001:db8:0:1::2</v6ur:next-hop>
        </v6ur:route>
       </v6ur:ipv6>
      </rt:static-routes>
     </rt:routing-protocol>
    </rt:routing-protocols>
   </rt:router>
   <rt:routing-tables>
    <rt:routing-table>
     <rt:name>ipv4-unicast</rt:name>
     <rt:address-family>ipv4</rt:address-family>
     <rt:safi>nlri-unicast</rt:safi>
     <rt:routes>
      <rt:route>
       <v4ur:dest-prefix>192.0.2.1/24</v4ur:dest-prefix>
       <rt:outgoing-interface>eth0</rt:outgoing-interface>
       <rt:source-protocol>direct</rt:source-protocol>
       <rt:last-updated>2012-10-02T17:11:27+01:00</rt:last-updated>
      </rt:route>
      <rt:route>
       <v4ur:dest-prefix>198.51.100.0/24</v4ur:dest-prefix>
       <rt:outgoing-interface>eth1</rt:outgoing-interface>
       <rt:source-protocol>direct</rt:source-protocol>
       <rt:last-updated>2012-10-02T17:11:27+01:00</rt:last-updated>
      </rt:route>
      <rt:route>
       <v4ur:dest-prefix>0.0.0.0/0</v4ur:dest-prefix>
       <rt:source-protocol>st0</rt:source-protocol>
       <v4ur:next-hop>192.0.2.2</v4ur:next-hop>
       <rt:last-updated>2012-10-02T18:02:45+01:00</rt:last-updated>
      </rt:route>
     </rt:routes>
    </rt:routing-table>
    <rt:routing-table>
     <rt:name>ipv6-unicast</rt:name>
     <rt:address-family>ipv6</rt:address-family>
     <rt:safi>nlri-unicast</rt:safi>
     <rt:routes>
      <rt:route>
       <v6ur:dest-prefix>2001:db8:0:1::/64</v6ur:dest-prefix>
       <rt:outgoing-interface>eth0</rt:outgoing-interface>
       <rt:source-protocol>direct</rt:source-protocol>
       <rt:last-updated>2012-10-02T17:11:27+01:00</rt:last-updated>
      </rt:route>
      <rt:route>
       <v6ur:dest-prefix>2001:db8:0:2::/64</v6ur:dest-prefix>
       <rt:outgoing-interface>eth1</rt:outgoing-interface>
       <rt:source-protocol>direct</rt:source-protocol>
       <rt:last-updated>2012-10-02T17:11:27+01:00</rt:last-updated>
      </rt:route>
      <rt:route>
       <v6ur:dest-prefix>::/0</v6ur:dest-prefix>
       <v6ur:next-hop>2001:db8:0:1::2</v6ur:next-hop>
       <rt:source-protocol>st0</rt:source-protocol>
       <rt:last-updated>2012-10-02T18:02:45+01:00</rt:last-updated>
      </rt:route>
     </rt:routes>
    </rt:routing-table>
   </rt:routing-tables>
  </rt:routing>
 </data>
</rpc-reply>
]]></artwork>

    </figure>
    
  </section>

  <section anchor="change-log" title="Change Log">

    <t>RFC Editor: remove this section upon publication as an RFC.</t>

    <section title="Changes Between Versions -05 and -06">
      <t>
        <list style="symbols">
          <t>Document title changed: "Configuration" was replaced by
          "Management".</t>
          <t>New typedefs "routing-table-ref" and "route-filter-ref".</t>
          <t>Double slashes "//" were removed from XPath expressions
          and replaced with the single "/".</t>
	  <t>Removed uniqueness requirement for "router-id".</t>
	  <t>Complete data tree is now in <xref target="app.data-tree"/>.</t>
	  <t>Changed type of "source-protocol" from "leafref" to "string".</t>
	  <t>Clarified the relationship between routing protocol
	  instances and connected routing tables.</t>
	  <t>Added a must constraint saying that a routing table
	  connected to the direct pseudo-protocol must not be a main
	  routing table.</t>
        </list>
      </t>
    </section>

    <section title="Changes Between Versions -04 and -05">
      <t>
        <list style="symbols">
          <t>Routing tables are now global, i.e., "routing-tables" is
          a child of "routing" rather than "router".</t>
          <t>"must" statement for "static-routes" changed to "when".</t>
          <t>Added "main-routing-tables" containing references to main
          routing tables for each address family.</t>
          <t>Removed the defaults for "address-family" and "safi" and
          made them mandatory.</t>
          <t>Removed the default for route-filter/type and made this
          leaf mandatory.</t>
          <t>If there is no active route for a given destination, the
          "active-route" RPC returns no output.</t>
          <t>Added "enabled" switch under "routing-protocol".</t>
          <t>Added "router-type" identity and "type" leaf under
          "router".</t>
          <t>Route attribute "age" changed to "last-updated", its type
          is "yang:date-and-time".</t>
          <t>The "direct" pseudo-protocol is always connected to main
          routing tables.</t>
          <t>Entries in the list of connected routing tables renamed
          from "routing-table" to "connected-routing-table".</t>
          <t>Added "must" constraint saying that a routing table must
          not be its own recipient.</t>
        </list>
      </t>
    </section>
    <section title="Changes Between Versions -03 and -04">
      <t>
        <list style="symbols">
          <t>Changed "error-tag" for both RPC methods from "missing
          element" to "data-missing".</t>
          <t>Removed the decrementing behavior for advertised IPv6
          prefix parameters "valid-lifetime" and
          "preferred-lifetime".</t>
          <t>Changed the key of the static route lists from "seqno" to
          "id" because the routes needn't be sorted.</t>
          <t>Added 'must' constraint saying that "preferred-lifetime"
          must not be greater than "valid-lifetime".</t>
        </list>
      </t>
    </section>
    <section title="Changes Between Versions -02 and -03">
      <t>
        <list style="symbols">
          <t>Module "iana-afn-safi" moved to I-D "iana-if-type".</t>
          <t>Removed forwarding table.</t>
          <t>RPC "get-route" changed to "active-route". Its output is
          a list of routes (for multi-path routing).</t>
          <t>New RPC "route-count".</t>
          <t>For both RPCs, specification of negative responses was
          added.</t>
          <t>Relaxed separation of router instances.</t>
          <t>Assignment of interfaces to router instances needn't be
          disjoint.</t>
          <t>Route filters are now global.</t>
          <t>Added "allow-all-route-filter" for symmetry.</t>
          <t>Added <xref target="sec.interactions"/> about
          interactions with "ietf-interfaces" and "ietf-ip".</t>
          <t>Added "router-id" leaf.</t>
          <t>Specified the names for IPv4/IPv6 unicast main routing
          tables.</t>
          <t>Route parameter "last-modified" changed to "age".</t>
          <t>Added container "recipient-routing-tables".</t>
        </list>
      </t>
    </section>
    <section title="Changes Between Versions -01 and -02">
      <t><list style="symbols">
        <t>Added module "ietf-ipv6-unicast-routing".</t>
        <t>The example in <xref target="app.get-reply"/> now uses
        IP addresses from blocks reserved for documentation.</t>
        <t>Direct routes appear by default in the forwarding
        table.</t>
        <t>Network layer interfaces must be assigned to a router
        instance. Additional interface configuration may be present.</t>
        <t>The "when" statement is only used with "augment", "must" is
        used elsewhere.</t>
        <t>Additional "must" statements were added.</t>
        <t>The "route-content" grouping for IPv4 and IPv6 unicast now
        includes the material from the "ietf-routing" version via
        "uses rt:route-content".</t>
        <t>Explanation of symbols in the tree representation of data
        model hierarchy.</t>
      </list></t>
    </section>

    <section title="Changes Between Versions -00 and -01">
      <t><list style="symbols">
        <t>AFN/SAFI-independent stuff was moved to the "ietf-routing"
        module.</t>
        <t>Typedefs for AFN and SAFI were placed in a separate
        "iana-afn-safi" module.</t>
        <t>Names of some data nodes were changed, in particular
        "routing-process" is now "router".</t>
        <t>The restriction of a single AFN/SAFI per router was
        lifted.</t>
        <t>RPC operation "delete-route" was removed.</t>
        <t>Illegal XPath references from "get-route" to the datastore
        were fixed.</t>
        <t>Section "Security Considerations" was written.</t>
      </list></t>
    </section>

  </section>

</back>

</rfc>
